<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC] 前言输入子系统，用于管理各种输入设备，采用软件分层的思想，把一些通用的操作和经常需要更改的操作分开。通用的部分就是纯软件逻辑，不涉及硬件操作，而经常需要更改的部分就是配置硬件。因此通过输入子系统，让各种输入设备开发比较简单，不需重复编写通用的代码，只需要专注硬件的配置就可以了。那么，什么是输入设备？从IO角度看，与cpu的输入IO引脚连接的设备就是输入设备，比如按键；从广义角度，人机交">
<meta property="og:type" content="article">
<meta property="og:title" content="linux input子系统设计">
<meta property="og:url" content="http://yoursite.com/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="[TOC] 前言输入子系统，用于管理各种输入设备，采用软件分层的思想，把一些通用的操作和经常需要更改的操作分开。通用的部分就是纯软件逻辑，不涉及硬件操作，而经常需要更改的部分就是配置硬件。因此通过输入子系统，让各种输入设备开发比较简单，不需重复编写通用的代码，只需要专注硬件的配置就可以了。那么，什么是输入设备？从IO角度看，与cpu的输入IO引脚连接的设备就是输入设备，比如按键；从广义角度，人机交">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jiali.clouddn.com/20210104_002.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210104_001.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210104_003.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210107_001.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210104_004.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210105_001.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210106_001.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210107_002.png">
<meta property="article:published_time" content="2021-01-04T07:35:27.000Z">
<meta property="article:modified_time" content="2021-01-07T06:01:17.206Z">
<meta property="article:author" content="David Meng">
<meta property="article:tag" content="Input">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiali.clouddn.com/20210104_002.png">

<link rel="canonical" href="http://yoursite.com/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>linux input子系统设计 | Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux input子系统设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-04 15:35:27" itemprop="dateCreated datePublished" datetime="2021-01-04T15:35:27+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-07 14:01:17" itemprop="dateModified" datetime="2021-01-07T14:01:17+08:00">2021-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>输入子系统，用于管理各种输入设备，采用软件分层的思想，把一些通用的操作和经常需要更改的操作分开。通用的部分就是纯软件逻辑，不涉及硬件操作，而经常需要更改的部分就是配置硬件。因此通过输入子系统，让各种输入设备开发比较简单，不需重复编写通用的代码，只需要专注硬件的配置就可以了。那么，什么是输入设备？从IO角度看，与cpu的输入IO引脚连接的设备就是输入设备，比如按键；从广义角度，人机交互的设备就是输入设备，比如鼠标，键盘，触摸屏。关于Input Subsystem定义：</p>
<p>The input subsystem is the part of the Linux kernel that manages the various input devices (such as keyboards, mice, joysticks, tablets and a wide range of other devices) that a user uses to interact with the kernel, command line and graphical user interface. This subsystem is included in the kernel because these devices usually are accessed through special hardware interfaces (such as serial ports, PS/2 ports, Apple Desktop Bus and the Universal Serial Bus), which are protected and managed by the kernel. The kernel then exposes the user input in a consistent, device-independent way to user space through a range of defined APIs</p>
<p>Linux 输入子系统全景图如下：</p>
<p><img src="http://jiali.clouddn.com/20210104_002.png" alt=""></p>
<p>​                                                                                                                       Linux 输入子系统全景图</p>
<p>input core 为event handlers和drivers层提供实现的接口；event handlers 为用户空间与内核空间交互提供接口；drivers,实现各种输入设备的操作。</p>
<h2 id="Input-Subsystem软件层次分析"><a href="#Input-Subsystem软件层次分析" class="headerlink" title="Input Subsystem软件层次分析"></a>Input Subsystem软件层次分析</h2><p> input subsystem 软件层次分为 input core层、drivers层 和 event handlers层。它们之间的关系如下图。</p>
<p><img src="http://jiali.clouddn.com/20210104_001.png" alt=""></p>
<p>​                                                                                                   input subsystem 软件层次图</p>
<ul>
<li>input core：提供input subsystem所有的核心操作，由drivers/input/input.c文件定义。</li>
<li>drivers:操作各种输入设备，与设备交互，把设备数据传给event handlers。</li>
<li>event handlers:定义应用层与内核交互的接口，并把收到的设备数据传给应用层。</li>
</ul>
<h2 id="Input-Subsystem设计"><a href="#Input-Subsystem设计" class="headerlink" title="Input Subsystem设计"></a>Input Subsystem设计</h2><p>1、主要数据结构</p>
<p><img src="http://jiali.clouddn.com/20210104_003.png" alt=""></p>
<p>​                                                                                                             表 输入子系统主要数据结构</p>
<p>数据链表如下：</p>
<p><img src="http://jiali.clouddn.com/20210107_001.png" alt=""></p>
<p>​                                                                                                      图 数据链表关系</p>
<p>2、软件设计</p>
<p>软件方案设计如下图</p>
<p><img src="http://jiali.clouddn.com/20210104_004.png" alt=""></p>
<p>​                                                                                                         图 软件方案设计</p>
<p>3、intput 子系统实现</p>
<p>input子系统实现如下图</p>
<p><img src="http://jiali.clouddn.com/20210105_001.png" alt=""></p>
<p>​                                                                                                              图 input 子系统实现</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>主要分析input.c 、evdev.c、触摸屏驱动atmel_mxt_ts.c这三个代表文件，理解input子系统如何工作。</p>
<h3 id="1、Linux-input-子系统目录层次"><a href="#1、Linux-input-子系统目录层次" class="headerlink" title="1、Linux input 子系统目录层次"></a>1、Linux input 子系统目录层次</h3><p>Linux input 子系统目录如下：</p>
<p><img src="http://jiali.clouddn.com/20210106_001.png" alt=""></p>
<p>input顶层目录包含各种event handlers(比如mousedev.c \evdev.c\joydev.c)和input core（input.c）,子目录就是输入设备驱动文件。</p>
<h3 id="2、主要数据结构关系"><a href="#2、主要数据结构关系" class="headerlink" title="2、主要数据结构关系"></a>2、主要数据结构关系</h3><p>（1）表示输入设备的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *phys;</span><br><span class="line">	const char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line"></span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned int hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">	unsigned int keycodemax;</span><br><span class="line">	unsigned int keycodesize;</span><br><span class="line">	void *keycode;</span><br><span class="line"></span><br><span class="line">	int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  const struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned int *old_keycode);</span><br><span class="line">	int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line"></span><br><span class="line">	struct ff_device *ff;</span><br><span class="line"></span><br><span class="line">	unsigned int repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line"></span><br><span class="line">	int rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">	struct input_mt_slot *mt;</span><br><span class="line">	int mtsize;</span><br><span class="line">	int slot;</span><br><span class="line">	int trkid;</span><br><span class="line"></span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line"></span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	int (*open)(struct input_dev *dev);</span><br><span class="line">	void (*close)(struct input_dev *dev);</span><br><span class="line">	int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br><span class="line"></span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line"></span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	unsigned int users;</span><br><span class="line">	bool going_away;</span><br><span class="line"></span><br><span class="line">	bool sync;</span><br><span class="line"></span><br><span class="line">	struct device dev;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）、表示evdev事件处理的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handler - implements one of interfaces for input devices</span><br><span class="line"> * @private: driver-specific data</span><br><span class="line"> * @event: event handler. This method is being called by input core with</span><br><span class="line"> *	interrupts disabled and dev-&gt;event_lock spinlock held and so</span><br><span class="line"> *	it may not sleep</span><br><span class="line"> * @filter: similar to @event; separates normal event handlers from</span><br><span class="line"> *	&quot;filters&quot;.</span><br><span class="line"> * @match: called after comparing device&#39;s id with handler&#39;s id_table</span><br><span class="line"> *	to perform fine-grained matching between device and handler</span><br><span class="line"> * @connect: called when attaching a handler to an input device</span><br><span class="line"> * @disconnect: disconnects a handler from input device</span><br><span class="line"> * @start: starts handler for given handle. This function is called by</span><br><span class="line"> *	input core right after connect() method and also when a process</span><br><span class="line"> *	that &quot;grabbed&quot; a device releases it</span><br><span class="line"> * @fops: file operations this driver implements</span><br><span class="line"> * @minor: beginning of range of 32 minors for devices this driver</span><br><span class="line"> *	can provide</span><br><span class="line"> * @name: name of the handler, to be shown in &#x2F;proc&#x2F;bus&#x2F;input&#x2F;handlers</span><br><span class="line"> * @id_table: pointer to a table of input_device_ids this driver can</span><br><span class="line"> *	handle</span><br><span class="line"> * @h_list: list of input handles associated with the handler</span><br><span class="line"> * @node: for placing the driver onto input_handler_list</span><br><span class="line"> *</span><br><span class="line"> * Input handlers attach to input devices and create input handles. There</span><br><span class="line"> * are likely several handlers attached to any given input device at the</span><br><span class="line"> * same time. All of them will get their copy of input event generated by</span><br><span class="line"> * the device.</span><br><span class="line"> *</span><br><span class="line"> * The very same structure is used to implement input filters. Input core</span><br><span class="line"> * allows filters to run first and will not pass event to regular handlers</span><br><span class="line"> * if any of the filters indicate that the event should be filtered (by</span><br><span class="line"> * returning %true from their filter() method).</span><br><span class="line"> *</span><br><span class="line"> * Note that input core serializes calls to connect() and disconnect()</span><br><span class="line"> * methods.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">	int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">	void (*disconnect)(struct input_handle *handle);</span><br><span class="line">	void (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">	const struct file_operations *fops;</span><br><span class="line">	int minor;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	const struct input_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）连接输入设备和event handler对象的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handle - links input device with an input handler</span><br><span class="line"> * @private: handler-specific data</span><br><span class="line"> * @open: counter showing whether the handle is &#39;open&#39;, i.e. should deliver</span><br><span class="line"> *	events from its device</span><br><span class="line"> * @name: name given to the handle by handler that created it</span><br><span class="line"> * @dev: input device the handle is attached to</span><br><span class="line"> * @handler: handler that works with the device through this handle</span><br><span class="line"> * @d_node: used to put the handle on device&#39;s list of attached handles</span><br><span class="line"> * @h_node: used to put the handle on handler&#39;s list of handles from which</span><br><span class="line"> *	it gets events</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	int open;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	struct input_dev *dev;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line"></span><br><span class="line">	struct list_head	d_node;</span><br><span class="line">	struct list_head	h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、input子系统的类"><a href="#3、input子系统的类" class="headerlink" title="3、input子系统的类"></a>3、input子系统的类</h3><p>根据数据结构的关系，总结出input子系统的类，如下</p>
<p><img src="http://jiali.clouddn.com/20210107_002.png" alt=""></p>
<p>​                                                                                                                   图 input子系统的类</p>
<h3 id="4、主要函数分析"><a href="#4、主要函数分析" class="headerlink" title="4、主要函数分析"></a>4、主要函数分析</h3><p>结合触摸屏、evdev  handler和input core 分析input 代码流程</p>
<p>首先初始化input 子系统,文件为drivers/input/input.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	err &#x3D; class_register(&amp;input_class);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register input_dev class\n&quot;);</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err &#x3D; input_proc_init();</span><br><span class="line">	if (err)</span><br><span class="line">		goto fail1;</span><br><span class="line"></span><br><span class="line">	err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">		goto fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit input_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_proc_exit();</span><br><span class="line">	unregister_chrdev(INPUT_MAJOR, &quot;input&quot;);</span><br><span class="line">	class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);</span><br><span class="line">module_exit(input_exit);</span><br></pre></td></tr></table></figure>

<p>其次，注册evdev handler</p>
<p>文件在drivers/input/evdev.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit evdev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，注册dev 驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_device - register device with input core</span><br><span class="line"> * @dev: device to be registered</span><br><span class="line"> *</span><br><span class="line"> * This function registers device with input core. The device must be</span><br><span class="line"> * allocated with input_allocate_device() and all it&#39;s capabilities</span><br><span class="line"> * set up before registering.</span><br><span class="line"> * If function fails the device must be freed with input_free_device().</span><br><span class="line"> * Once device has been successfully registered it can be unregistered</span><br><span class="line"> * with input_unregister_device(); input_free_device() should not be</span><br><span class="line"> * called in this case.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	static atomic_t input_no &#x3D; ATOMIC_INIT(0);</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	const char *path;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Every input device generates EV_SYN&#x2F;SYN_REPORT events. *&#x2F;</span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* KEY_RESERVED is not supposed to be transmitted to userspace. *&#x2F;</span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. *&#x2F;</span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;hint_events_per_packet)</span><br><span class="line">		dev-&gt;hint_events_per_packet &#x3D;</span><br><span class="line">				input_estimate_events_per_packet(dev);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If delay and period are pre-set by the driver, then autorepeating</span><br><span class="line">	 * is handled by the driver itself and we don&#39;t do it in input.c.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	init_timer(&amp;dev-&gt;timer);</span><br><span class="line">	if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">		dev-&gt;timer.data &#x3D; (long) dev;</span><br><span class="line">		dev-&gt;timer.function &#x3D; input_repeat_key;</span><br><span class="line">		dev-&gt;rep[REP_DELAY] &#x3D; 250;</span><br><span class="line">		dev-&gt;rep[REP_PERIOD] &#x3D; 33;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode &#x3D; input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode &#x3D; input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,</span><br><span class="line">		     (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;dev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(&quot;%s as %s\n&quot;,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;,</span><br><span class="line">		path ? path : &quot;N&#x2F;A&quot;);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		device_del(&amp;dev-&gt;dev);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>evdev handler 和dev注册都会判断evdev handler和dev 匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">	const struct input_device_id *id;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	id &#x3D; input_match_device(handler, dev);</span><br><span class="line">	if (!id)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	error &#x3D; handler-&gt;connect(handler, dev, id);</span><br><span class="line">	if (error &amp;&amp; error !&#x3D; -ENODEV)</span><br><span class="line">		pr_err(&quot;failed to attach handler %s to device %s, error: %d\n&quot;,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配成功后，调用 evdev handler 的connect函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Create new evdev device. Note that input core serializes calls</span><br><span class="line"> * to connect and disconnect so we don&#39;t need to lock evdev_table here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line">			 const struct input_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev *evdev;</span><br><span class="line">	int minor;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)</span><br><span class="line">		if (!evdev_table[minor])</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">	if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;</span><br><span class="line">		pr_err(&quot;no more free evdev devices\n&quot;);</span><br><span class="line">		return -ENFILE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);</span><br><span class="line">	if (!evdev)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">	spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">	mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">	init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);</span><br><span class="line">	evdev-&gt;exist &#x3D; true;</span><br><span class="line">	evdev-&gt;minor &#x3D; minor;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">	evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">	evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">	evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);</span><br><span class="line">	evdev-&gt;dev.class &#x3D; &amp;input_class;</span><br><span class="line">	evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;</span><br><span class="line">	evdev-&gt;dev.release &#x3D; evdev_free;</span><br><span class="line">	device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_evdev;</span><br><span class="line"></span><br><span class="line">	error &#x3D; evdev_install_chrdev(evdev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_unregister_handle;</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;evdev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">	evdev_cleanup(evdev);</span><br><span class="line"> err_unregister_handle:</span><br><span class="line">	input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line"> err_free_evdev:</span><br><span class="line">	put_device(&amp;evdev-&gt;dev);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在connect函数调用input_register_handle函数注册handle。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_handle - register a new input handle</span><br><span class="line"> * @handle: handle to register</span><br><span class="line"> *</span><br><span class="line"> * This function puts a new input handle onto device&#39;s</span><br><span class="line"> * and handler&#39;s lists so that events can flow through</span><br><span class="line"> * it once it is opened using input_open_device().</span><br><span class="line"> *</span><br><span class="line"> * This function is supposed to be called from handler&#39;s</span><br><span class="line"> * connect() method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_handle(struct input_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_handler *handler &#x3D; handle-&gt;handler;</span><br><span class="line">	struct input_dev *dev &#x3D; handle-&gt;dev;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * We take dev-&gt;mutex here to prevent race with</span><br><span class="line">	 * input_release_device().</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Filters go to the head of the list, normal handlers</span><br><span class="line">	 * to the tail.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (handler-&gt;filter)</span><br><span class="line">		list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">	else</span><br><span class="line">		list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Since we are supposed to be called from -&gt;connect()</span><br><span class="line">	 * which is mutually exclusive with -&gt;disconnect()</span><br><span class="line">	 * we can&#39;t be racing with input_unregister_handle()</span><br><span class="line">	 * and so separate lock is not needed here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	if (handler-&gt;start)</span><br><span class="line">		handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码分析完毕，后面看看应用层如何与input 子系统交互。</p>
<h2 id="应用层与内核input子系统交互"><a href="#应用层与内核input子系统交互" class="headerlink" title="应用层与内核input子系统交互"></a>应用层与内核input子系统交互</h2><p>应用层与设备交互，通过 Linux一套接口实现，就是open 、read 、write函数。这些函数最终会调用input 子系统的evdev handler 的fops的open、read和write。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>evdev_fops定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations evdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.read		&#x3D; evdev_read,</span><br><span class="line">	.write		&#x3D; evdev_write,</span><br><span class="line">	.poll		&#x3D; evdev_poll,</span><br><span class="line">	.open		&#x3D; evdev_open,</span><br><span class="line">	.release	&#x3D; evdev_release,</span><br><span class="line">	.unlocked_ioctl	&#x3D; evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl	&#x3D; evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">	.fasync		&#x3D; evdev_fasync,</span><br><span class="line">	.flush		&#x3D; evdev_flush,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看一下evdev_read</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *buffer,</span><br><span class="line">			  size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev_client *client &#x3D; file-&gt;private_data;</span><br><span class="line">	struct evdev *evdev &#x3D; client-&gt;evdev;</span><br><span class="line">	struct input_event event;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	if (count &lt; input_event_size())</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (client-&gt;packet_head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp;</span><br><span class="line">	    (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">		client-&gt;packet_head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line"></span><br><span class="line">	if (!evdev-&gt;exist)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	while (retval + input_event_size() &lt;&#x3D; count &amp;&amp;</span><br><span class="line">	       evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">		if (input_event_to_user(buffer + retval, &amp;event))</span><br><span class="line">			return -EFAULT;</span><br><span class="line"></span><br><span class="line">		retval +&#x3D; input_event_size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，可以看出input 子系统简化了输入设备的驱动程序开发。这边设备驱动专注设备的配置和交互，不用重新编写与应用层交互的代码。设备驱动遵循下面的流程：</p>
<blockquote>
<p>1、input_allocate_device() 给input_dev分配空间</p>
<p>2、设置input_dev对象，设置事件类型、code</p>
<p>3、硬件初始化，中断初始化，定义中断处理程序</p>
<p>4、通过 input_register_device() 注册 </p>
<p>5、定义中断处理程序，上报事件并同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、上报事件</span><br><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_switch(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">2、同步</span><br><span class="line">void input_sync(struct input_dev *dev)</span><br></pre></td></tr></table></figure>


</blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/lcw/p/3293302.html" target="_blank" rel="noopener">input子系统全面分析</a></p>
<p><a href="https://www.linuxjournal.com/article/6396" target="_blank" rel="noopener">The Linux USB Input Subsystem, Part I</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Input/" rel="tag"># Input</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android-emmc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" rel="prev" title="【转载】Android-emmc性能测试">
      <i class="fa fa-chevron-left"></i> 【转载】Android-emmc性能测试
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/05/Linux/Driver/Input/Atmel%E7%9A%84mXT2952T2%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" rel="next" title="Atmel的mXT2952T2触摸屏驱动开发">
      Atmel的mXT2952T2触摸屏驱动开发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Input-Subsystem软件层次分析"><span class="nav-number">2.</span> <span class="nav-text">Input Subsystem软件层次分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Input-Subsystem设计"><span class="nav-number">3.</span> <span class="nav-text">Input Subsystem设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码分析"><span class="nav-number">4.</span> <span class="nav-text">代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Linux-input-子系统目录层次"><span class="nav-number">4.1.</span> <span class="nav-text">1、Linux input 子系统目录层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、主要数据结构关系"><span class="nav-number">4.2.</span> <span class="nav-text">2、主要数据结构关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、input子系统的类"><span class="nav-number">4.3.</span> <span class="nav-text">3、input子系统的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、主要函数分析"><span class="nav-number">4.4.</span> <span class="nav-text">4、主要函数分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用层与内核input子系统交互"><span class="nav-number">5.</span> <span class="nav-text">应用层与内核input子系统交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
