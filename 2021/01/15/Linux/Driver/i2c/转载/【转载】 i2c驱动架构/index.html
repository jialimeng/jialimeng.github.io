<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC] 本文转自：【https:&#x2F;&#x2F;blog.csdn.net&#x2F;ghostyu&#x2F;article&#x2F;details&#x2F;8094049】 预备知识在阅读本文最好先熟悉一种i2c设备的驱动程序，并且浏览一下i2c-core.c以及芯片提供商的提供的i2c总线驱动（i2c-davinci.c）。标题党请见谅！ 其实i2c接口非常的简单，即使用51单片的gpio来模拟i2c，编写一个e2prom或者其他i2">
<meta property="og:type" content="article">
<meta property="og:title" content="【转载】 i2c驱动架构">
<meta property="og:url" content="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="[TOC] 本文转自：【https:&#x2F;&#x2F;blog.csdn.net&#x2F;ghostyu&#x2F;article&#x2F;details&#x2F;8094049】 预备知识在阅读本文最好先熟悉一种i2c设备的驱动程序，并且浏览一下i2c-core.c以及芯片提供商的提供的i2c总线驱动（i2c-davinci.c）。标题党请见谅！ 其实i2c接口非常的简单，即使用51单片的gpio来模拟i2c，编写一个e2prom或者其他i2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jiali.clouddn.com/20210115_001.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210115_002.png">
<meta property="og:image" content="http://jiali.clouddn.com/20210115_003.png">
<meta property="article:published_time" content="2021-01-15T03:34:14.000Z">
<meta property="article:modified_time" content="2021-01-15T08:22:06.712Z">
<meta property="article:author" content="David Meng">
<meta property="article:tag" content="i2c">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiali.clouddn.com/20210115_001.png">

<link rel="canonical" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>【转载】 i2c驱动架构 | Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【转载】 i2c驱动架构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 11:34:14 / Modified: 16:22:06" itemprop="dateCreated datePublished" datetime="2021-01-15T11:34:14+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<p>本文转自：【<a href="https://blog.csdn.net/ghostyu/article/details/8094049】" target="_blank" rel="noopener">https://blog.csdn.net/ghostyu/article/details/8094049】</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h1><p><strong>在阅读本文最好先熟悉一种i2c设备的驱动程序，并且浏览一下i2c-core.c以及芯片提供商的提供的i2c总线驱动（i2c-davinci.c）。标题党请见谅！</strong></p>
<p>其实i2c接口非常的简单，即使用51单片的gpio来模拟i2c，编写一个e2prom或者其他i2c接口的驱动程序，也不是什么难事，几百行代码就能搞定。</p>
<p>但是Linux的i2c驱动体系结构却有相当的复杂度，不管是叫linux i2c驱动还是单片机i2c驱动，其根本还是操作soc芯片内部的i2c模块（也叫i2c adapter）（读写i2c相关的寄存器）来产生start、stop还有ack信号而已。</p>
<h1 id="linux设备驱动到底复杂在什么地方？"><a href="#linux设备驱动到底复杂在什么地方？" class="headerlink" title="linux设备驱动到底复杂在什么地方？"></a><strong>linux设备驱动到底复杂在什么地方？</strong></h1><p>假设soc芯片dm368有两个i2c adapter（368内部真正只有一个i2c模块）：i2c_adapter1，i2c_adapter1；然后外部有三个i2c接口的设备i2c_device1，i2c_device2，i2c_device3。</p>
<p>现在要求在裸机下写出他们的驱动函数。那么肯定要写出6个不同的驱动函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i2c_adapter1_ReadWrite_i2c_device1();</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device3()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device1()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device3()</span><br></pre></td></tr></table></figure>

<p>设想一共有m个i2c adapter和n个外设i2c device，那么将需要m<em>n个驱动。并且这m</em>n个驱动程序必要会有很大部分重复的代码，而且不利于驱动程序的移植。</p>
<p>如果采用adapter和device分离的思想来写这样的驱动会是怎样呢？</p>
<p><img src="http://jiali.clouddn.com/20210115_001.png" alt=""></p>
<p>​                                                                                                                                   图1</p>
<p>这样分离之后，只需要m+n个驱动，而且Adapter和Device的几乎没有耦合性，增加一个Adapter或者device并不会影响其余的驱动。</p>
<p><strong>这就是分离思想带来的好处。除此之外，linux虽然是C写的，但是大量使用了面向对象的变成方法（可以理解为分层的思想），仅仅分离细想和分层思想的引入，就大大增加了linux设备驱动的复杂度。</strong></p>
<h1 id="linux驱动中-i2c驱动架构"><a href="#linux驱动中-i2c驱动架构" class="headerlink" title="linux驱动中 i2c驱动架构"></a><strong>linux驱动中 i2c驱动架构</strong></h1><p><img src="http://jiali.clouddn.com/20210115_002.png" alt=""></p>
<p>​                                                                                                                 图2</p>
<p><strong><em>\</em>上图完整的描述了linux i2c驱动架构，虽然I2C硬件体系结构比较简单，但是i2c体系结构在linux中的实现却相当复杂。那么我们如何编写特定i2c接口器件（比如，ov2715，需要i2c来配置寄存器）的驱动程序？就是说上述架构中的那些部分需要我们完成，而哪些是linux内核已经完善的或者是芯片提供商（TI davinci平台已经做好的）已经提供的？**</strong></p>
<h1 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h1><p><strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。<strong>覆盖图中的硬件实现层</strong></p>
<p><strong>第二层</strong>：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。<strong>覆盖图中的访问抽象层、i2c核心层</strong></p>
<p><strong>第三层</strong>：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第四层</strong>：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c</strong></p>
<p><strong>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</strong></p>
<p><strong>明确了方向后，**</strong>再来具体分析。**</p>
<h1 id="具体分析"><a href="#具体分析" class="headerlink" title="\具体分析**"></a><strong><em>\</em>具体分析**</strong></h1><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>
<p>现在，我们就来看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>
<h2 id="1、i2c-driver"><a href="#1、i2c-driver" class="headerlink" title="1、i2c_driver"></a><strong>1、i2c_driver</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_client)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*command)(struct i2c_client *client,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、i2c-client"><a href="#2、i2c-client" class="headerlink" title="2、i2c_client"></a><strong>2、i2c_client</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> short addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit 	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* and our access routines	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> usage_count;		<span class="comment">/* How many accesses currently  */</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* to the client		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">released</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、i2c-adapter"><a href="#3、i2c-adapter" class="headerlink" title="3、i2c_adapter"></a><strong>3、i2c_adapter</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span><span class="comment">/* the algorithm to access the bus	*/</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line">	<span class="comment">/* --- administration stuff. */</span></span><br><span class="line">	<span class="keyword">int</span> (*client_register)(struct i2c_client *);</span><br><span class="line">	<span class="keyword">int</span> (*client_unregister)(struct i2c_client *);</span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">clist_lock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> timeout;</span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">class_dev</span>;</span>	<span class="comment">/* the class device */</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">class_dev_released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4、i2c-algorithm"><a href="#4、i2c-algorithm" class="headerlink" title="4、i2c_algorithm"></a><strong>4、i2c_algorithm</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, </span><br><span class="line">	                   <span class="keyword">int</span> num);</span><br><span class="line">	<span class="keyword">int</span> (*slave_send)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*slave_recv)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>【i2c_adapter与i2c_algorithm】</strong></p>
<p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I2C Message - used for pure i2c transaction, also from /dev interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line"> 	__u16 flags;		</span><br><span class="line"> 	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line"> 	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【i2c_driver和i2c_client】</strong></p>
<p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<p><strong>【i2c_adapter和i2c_client】</strong></p>
<p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class="line">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>



<p>如果看过i2c设备驱动程序的人一定对上面几个函数比较熟悉。</p>
<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(struct i2c_adapter * adap, struct i2c_msg *msgs, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class="comment">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_attach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	device_register(&amp;client-&gt;dev);</span><br><span class="line">	device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_detach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line"></span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用，稍后分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class="line"><span class="comment"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class="line"><span class="comment"> * available for clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_register(&amp;adap-&gt;dev);</span><br><span class="line">	device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* inform drivers of new adapters */</span></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;attach_adapter)</span><br><span class="line">			<span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">			driver-&gt;attach_adapter(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_del_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;detach_adapter)</span><br><span class="line">			<span class="keyword">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class="line">		client = list_entry(item, struct i2c_client, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">davinci_i2c_driver</span> = &#123;</span></span><br><span class="line">	.probe		= davinci_i2c_probe,</span><br><span class="line">	.remove		= davinci_i2c_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">"i2c_davinci"</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* I2C may be needed to bring up other drivers */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">davinci_i2c_init_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">subsys_initcall(davinci_i2c_init_driver);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">davinci_i2c_exit_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	platform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_davinci_algo</span> = &#123;</span></span><br><span class="line">	.master_xfer	= i2c_davinci_xfer,</span><br><span class="line">	.functionality	= i2c_davinci_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>

<h1 id="梳理图"><a href="#梳理图" class="headerlink" title="梳理图"></a>梳理图</h1><p><strong><em>\</em>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容，请看图3。**</strong></p>
<p> <img src="http://jiali.clouddn.com/20210115_003.png" alt=""></p>
<p>​                                                                  图3</p>
<p>好了，上面这些代码的展示是告诉我们，linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/i2c/" rel="tag"># i2c</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%89%96%E6%9E%90/" rel="prev" title="【转载】Linux驱动之I2C子系统剖析">
      <i class="fa fa-chevron-left"></i> 【转载】Linux驱动之I2C子系统剖析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%9A0-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" rel="next" title="【转载】Linux I2C子系统分析：0-整体框架介绍">
      【转载】Linux I2C子系统分析：0-整体框架介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#预备知识"><span class="nav-number">1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux设备驱动到底复杂在什么地方？"><span class="nav-number">2.</span> <span class="nav-text">linux设备驱动到底复杂在什么地方？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux驱动中-i2c驱动架构"><span class="nav-number">3.</span> <span class="nav-text">linux驱动中 i2c驱动架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#架构层次分类"><span class="nav-number">4.</span> <span class="nav-text">架构层次分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#具体分析"><span class="nav-number">5.</span> <span class="nav-text">\具体分析**</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、i2c-driver"><span class="nav-number">5.1.</span> <span class="nav-text">1、i2c_driver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、i2c-client"><span class="nav-number">5.2.</span> <span class="nav-text">2、i2c_client</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、i2c-adapter"><span class="nav-number">5.3.</span> <span class="nav-text">3、i2c_adapter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、i2c-algorithm"><span class="nav-number">5.4.</span> <span class="nav-text">4、i2c_algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#梳理图"><span class="nav-number">6.</span> <span class="nav-text">梳理图</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
