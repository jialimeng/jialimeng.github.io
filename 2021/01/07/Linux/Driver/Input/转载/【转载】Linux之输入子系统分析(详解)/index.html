<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文转自：博客园–诺谦 【https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lifexy&#x2F;p&#x2F;7542989.html】 12.Linux之输入子系统分析(详解)在此节之前，我们学的都是简单的字符驱动，涉及的内容有字符驱动的框架、自动创建设备节点、linux中断、poll机制、异步通知、同步互斥&#x2F;非阻塞、定时器去抖动。 其中驱动框架如下: 1)写file_operations结构体的成员函数: .o">
<meta property="og:type" content="article">
<meta property="og:title" content="【转载】Linux之输入子系统分析(详解)">
<meta property="og:url" content="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="本文转自：博客园–诺谦 【https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lifexy&#x2F;p&#x2F;7542989.html】 12.Linux之输入子系统分析(详解)在此节之前，我们学的都是简单的字符驱动，涉及的内容有字符驱动的框架、自动创建设备节点、linux中断、poll机制、异步通知、同步互斥&#x2F;非阻塞、定时器去抖动。 其中驱动框架如下: 1)写file_operations结构体的成员函数: .o">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125656056-1309527087.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190208915-1448414250.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125709915-1132827718.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125734228-444718177.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125751978-2110731647.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125805775-128197571.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125828931-1140237004.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125845790-1398162479.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190616478-260239851.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125909525-684596795.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125924681-419081807.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125942290-1009610213.png">
<meta property="article:published_time" content="2021-01-07T11:11:00.000Z">
<meta property="article:modified_time" content="2021-01-07T11:16:05.888Z">
<meta property="article:author" content="David Meng">
<meta property="article:tag" content="Input">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://common.cnblogs.com/images/copycode.gif">

<link rel="canonical" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>【转载】Linux之输入子系统分析(详解) | Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【转载】Linux之输入子系统分析(详解)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:11:00 / Modified: 19:16:05" itemprop="dateCreated datePublished" datetime="2021-01-07T19:11:00+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文转自：博客园–<a href="https://www.cnblogs.com/lifexy/" target="_blank" rel="noopener">诺谦</a> 【<a href="https://www.cnblogs.com/lifexy/p/7542989.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7542989.html】</a></p>
<h1 id="12-Linux之输入子系统分析-详解"><a href="#12-Linux之输入子系统分析-详解" class="headerlink" title="12.Linux之输入子系统分析(详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">12.Linux之输入子系统分析(详解)</a></h1><p>在此节之前，我们学的都是简单的字符驱动，涉及的内容有<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>字符驱动的框架</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>自动创建设备节点</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506718.html" target="_blank" rel="noopener"><strong>linux中断</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508633.html" target="_blank" rel="noopener"><strong>poll机制</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508791.html" target="_blank" rel="noopener"><strong>异步通知</strong></a>、<strong><a href="http://www.cnblogs.com/lifexy/p/7515488.html" target="_blank" rel="noopener">同步互斥/非阻塞</a></strong>、<a href="http://www.cnblogs.com/lifexy/p/7522122.html" target="_blank" rel="noopener"><strong>定时器去抖动</strong></a>。</p>
<p>其中<strong>驱动框架</strong>如下:</p>
<p>1)写file_operations结构体的成员函数: .open()、.read()、.write()</p>
<p>2)在入口函数里通过register_chrdev()创建驱动名,生成主设备号,赋入file_operations结构体</p>
<p>3)在出口函数里通过unregister_chrdev() 卸载驱动</p>
<p>若有多个不同的驱动程序时,应用程序就要打开多个不同的驱动设备，由于是自己写肯定会很清楚,如果给别人来使用时是不是很麻烦？</p>
<p>所以需要使用<strong>输入子系统</strong>, 使应用程序无需打开多个不同的驱动设备便能实现</p>
<hr>
<p><strong>1.输入子系统简介</strong></p>
<p>同样的输入子系统也需要输入驱动的框架,好来辨认应用程序要打开的是哪个输入驱动</p>
<p>比如: 鼠标、键盘、游戏手柄等等这些都属于输入设备；这些输入设备的驱动都是通过输入子系统来实现的（当然，这些设备也依赖于usb子系统）</p>
<p>这些输入设备都各有不同，那么输入子系统也就只能实现他们的共性，差异性则由设备驱动来实现。差异性又体现在哪里？</p>
<p>最直观的就表现在这些设备功能上的不同了。对于我们写驱动的人来说在设备驱动中就只要使用输入子系统提供的工具（也就是函数）来完成这些“差异”就行了，其他的则是输入子系统的工作。这个思想不仅存在于输入子系统，其他子系统也是一样(比如:usb子系统、video子系统等)</p>
<p>所以我们先来分析下输入子系统<strong>input.c</strong>的代码,然后怎么来使用输入子系统(在内核中以input来形容输入子系统)</p>
<p><strong>2.打开input.c,位于内核deivers/input</strong></p>
<p>有以下这么两段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subsys_initcall(input_init);   &#x2F;&#x2F;修饰入口函数</span><br><span class="line"></span><br><span class="line">module_exit(input_exit);     &#x2F;&#x2F;修饰出口函数</span><br></pre></td></tr></table></figure>



<p><strong>显然输入子系统是作为一个模块存在,我们先来分析下input_int()入口函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __init input_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3        int err;</span><br><span class="line"> 4        err &#x3D; class_register(&amp;input_class);   &#x2F;&#x2F;(1)注册类,放在&#x2F;sys&#x2F;class</span><br><span class="line"> 5        if (err) &#123;</span><br><span class="line"> 6               printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);</span><br><span class="line"> 7               return err;</span><br><span class="line"> 8        &#125;</span><br><span class="line"> 9  </span><br><span class="line">10        err &#x3D; input_proc_init();    &#x2F;&#x2F;在&#x2F;proc下面建立相关的文件</span><br><span class="line">11        if (err)</span><br><span class="line">12               goto fail1;</span><br><span class="line">13 </span><br><span class="line">14        err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops); &#x2F;&#x2F;(2)注册驱动</span><br><span class="line">15        if (err) &#123;</span><br><span class="line">16               printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">17               goto fail2;</span><br><span class="line">18        &#125;</span><br><span class="line">19 </span><br><span class="line">20  </span><br><span class="line">21 </span><br><span class="line">22        return 0;</span><br><span class="line">23 </span><br><span class="line">24  </span><br><span class="line">25 </span><br><span class="line">26  fail2:     input_proc_exit();</span><br><span class="line">27 </span><br><span class="line">28  fail1:     class_unregister(&amp;input_class);</span><br><span class="line">29 </span><br><span class="line">30        return err;</span><br><span class="line">31 </span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1)<strong>上面第4行”err = class_register(&amp;input_class);”</strong>是在/sys/class 里创建一个 input类, input_class变量如下图:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125656056-1309527087.png" alt="img"></p>
<p>如下图,我们启动内核,再启动一个input子系统的驱动后，也可以看到创建了个”input”类 :</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190208915-1448414250.png" alt="img"></p>
<p>为什么这里代码只创建类，没有使用class_device_create()函数在类下面创建驱动设备？</p>
<p>在下面第8小结会详细讲到,这里简单描述:当注册input子系统的驱动后，才会有驱动设备，此时这里的代码是没有驱动的</p>
<p>(2)<strong>上面第14行</strong>通过register_chrdev创建驱动设备,其中变量INPUT_MAJOR =13,所以创建了一个主设备为13的”input”设备。</p>
<p>然后我们来看看它的操作结构体input_fops,如下图:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125709915-1132827718.png" alt="img"></p>
<p>只有一个.open函数,比如当我们挂载一个新的input驱动,则内核便会调用该.open函数,接下来分析该.open函数</p>
<p><strong>3 然后进入input_open_file函数(drivers/input/input.c)</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line"> 2  &#123;</span><br><span class="line"> 3      struct input_handler *handler &#x3D; input_table[iminor(inode) &gt;&gt; 5]; &#x2F;&#x2F; (1)</span><br><span class="line"> 4      const struct file_operations *old_fops, *new_fops &#x3D; NULL;</span><br><span class="line"> 5      int err;</span><br><span class="line"> 6 </span><br><span class="line"> 7      if (!handler || !(new_fops &#x3D; fops_get(handler-&gt;fops)))  &#x2F;&#x2F;(2)</span><br><span class="line"> 8           return -ENODEV; </span><br><span class="line"> 9 </span><br><span class="line">10     if (!new_fops-&gt;open) &#123;</span><br><span class="line">11            fops_put(new_fops);</span><br><span class="line">12            return -ENODEV;</span><br><span class="line">13     &#125;</span><br><span class="line">14 </span><br><span class="line">15     old_fops &#x3D; file-&gt;f_op;</span><br><span class="line">16     file-&gt;f_op &#x3D; new_fops;     &#x2F;&#x2F;(3)</span><br><span class="line">17 </span><br><span class="line">18     err &#x3D; new_fops-&gt;open(inode, file);   &#x2F;&#x2F;(4)</span><br><span class="line">19     if (err) &#123;</span><br><span class="line">20           fops_put(file-&gt;f_op);</span><br><span class="line">21            file-&gt;f_op &#x3D; fops_get(old_fops);</span><br><span class="line">22    &#125;</span><br><span class="line">23 </span><br><span class="line">24    fops_put(old_fops);</span><br><span class="line">25 </span><br><span class="line">26     return err;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第3行中</strong>,其中iminor (inode)函数调用了MINOR(inode-&gt;i_rdev);读取子设备号,然后将子设备除以32,找到新挂载的input驱动的数组号,然后放在input_handler 驱动处理函数handler中 </p>
<p><strong>(2)第7行中</strong>,若handler有值,说明挂载有这个驱动,就将handler结构体里的成员file_operations * fops赋到新的file_operations *new_fops里面</p>
<p><strong>(3)第16行中</strong>, 再将新的file_operations *new_fops赋到file-&gt; file_operations  *f_op里, 此时input子系统的file_operations就等于新挂载的input驱动的file_operations结构体,实现一个偷天换日的效果.</p>
<p><strong>(4)第18行中</strong>,然后调用新挂载的input驱动的*new_fops里面的成员.open函数</p>
<p><strong>4.上面代码的input_table[]数组在初始时是没有值的,</strong></p>
<p><strong>所以我们来看看input_table数组里面的数据又是在哪个函数里被赋值</strong></p>
<p>在input.c函数(drivers/input/input.c)中搜索input_table,找到它在input_register_handler()函数中被赋值,代码如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 int input_register_handler(struct input_handler *handler)</span><br><span class="line">2 &#123;</span><br><span class="line">3 ... ...</span><br><span class="line">4 input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;   &#x2F;&#x2F;input_table[]被赋值</span><br><span class="line">5 ... ...</span><br><span class="line">6 list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); &#x2F;&#x2F;然后将这个input_handler放到input_handler_list链表中  </span><br><span class="line">7 ... ...</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是将驱动处理程序input_handler注册到input_table[]中，然后放在input_handler_list链表中,后面会讲这个链表</p>
<p><strong>5继续来搜索input_register_handler,看看这个函数被谁来调用</strong></p>
<p>如下图所示,有evdev.c(事件设备)，tsdev.c(触摸屏设备)，joydev.c(joystick操作杆设备)，keyboard.c(键盘设备)，mousedev.c(鼠标设备) 这5个内核自带的设备处理函数注册到input子系统中</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125734228-444718177.png" alt="img"></p>
<p>我们以evdev.c为例,它在evdev_ini()函数中注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">       return input_register_handler(&amp;evdev_handler);  &#x2F;&#x2F;注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>6我们来看看这个evdev_handler变量是什么结构体,:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">2        .event &#x3D;  evdev_event,    </span><br><span class="line">3        .connect &#x3D;      evdev_connect,  &#x2F;&#x2F;(4)</span><br><span class="line">4        .disconnect &#x3D; evdev_disconnect,</span><br><span class="line">5        .fops &#x3D;           &amp;evdev_fops,    &#x2F;&#x2F;(1)</span><br><span class="line">6        .minor &#x3D;  EVDEV_MINOR_BASE, &#x2F;&#x2F;(2)</span><br><span class="line">7        .name &#x3D;         &quot;evdev&quot;,</span><br><span class="line">8        .id_table &#x3D;      evdev_ids, &#x2F;&#x2F;(3)</span><br><span class="line">9 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是我们之前看的input_handler驱动处理结构体</p>
<p>(1) <strong>第5行中.fops:</strong>文件操作结构体,其中evdev_fops函数就是自己的写的操作函数,然后赋到.fops中</p>
<p>(2)<strong>第6行中 .minor:</strong>用来存放次设备号</p>
<p>其中EVDEV_MINOR_BASE=64, 然后调用input_register_handler(&amp;evdev_handler)后,由于EVDEV_MINOR_BASE/32=2,所以存到input_table[2]中</p>
<p> 所以当open打开这个input设备,就会进入 input_open_file()函数,执行evdev_handler-&gt; evdev_fops -&gt; .open函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125751978-2110731647.png" alt="img"></p>
<p>(3)<strong>第8行中.id_table :</strong> 表示能支持哪些输入设备，比如某个驱动设备的input_dev-&gt;的id和某个input_handler的id_table相匹配，就会调用.connect连接函数,如下图</p>
<p>(4)<strong>第3行中.connect:</strong>连接函数，将设备input_dev和某个input_handler建立连接,如下图</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125805775-128197571.png" alt="img"></p>
<p><strong>7我们先来看看上图的input_register_device()函数,如何创建驱动设备的</strong></p>
<p>搜索input_register_device,发现内核自己就已经注册了很多驱动设备</p>
<p><strong>7.1然后进入input_register_device()函数,代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备</span><br><span class="line">2 &#123;</span><br><span class="line">3  ... ...</span><br><span class="line">4        list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中</span><br><span class="line">5  ... ...</span><br><span class="line">6        list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)</span><br><span class="line">7        input_attach_handler(dev, handler); </span><br><span class="line">8  ... ...</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第4行中,</strong>将要注册的input_dev驱动设备放在input_dev_list链表中</p>
<p><strong>(2)第6行中,</strong>其中input_handler_list在前面讲过,就是存放每个input_handle驱动处理结构体,</p>
<p>然后list_for_each_entry()函数会将每个input_handle从链表中取出,放到handler中</p>
<p>最后会调用input_attach_handler()函数,将每个input_handle的id_table进行判断,若两者支持便进行连接。</p>
<p><strong>7.2然后我们在回过头来看注册input_handler的input_register_handler()函数,如下图所示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125828931-1140237004.png" alt="img"></p>
<p>所以,不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支持, 若两者支持便进行连接。</p>
<p><strong>7.3我们来看看input_attach_handler()如何实现匹配两者id的:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line">id &#x3D; input_match_device(handler-&gt;id_table, dev);  &#x2F;&#x2F;匹配两者</span><br><span class="line"></span><br><span class="line">if (!id)                                     &#x2F;&#x2F;若不匹配,return退出</span><br><span class="line">return -ENODEV; </span><br><span class="line"></span><br><span class="line">error &#x3D; handler-&gt;connect(handler, dev, id);  &#x2F;&#x2F;调用input_handler -&gt;connect函数建立连接</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若两者匹配成功，就会自动进入input_handler 的connect函数建立连接</p>
<p><strong>8我们还是以evdev.c(事件驱动) 的evdev_handler-&gt;connect函数</strong></p>
<p><strong>来分析**</strong>是怎样建立连接的,如下图:**</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125845790-1398162479.png" alt="img"></p>
<p><strong>8.1 evdev_handler的.connect函数是evdev_connect(),代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)     </span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3 ... ... </span><br><span class="line"> 4 for (minor &#x3D; 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++); &#x2F;&#x2F;查找驱动设备的子设备号</span><br><span class="line"> 5     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  &#x2F;&#x2F; EVDEV_MINORS&#x3D;32,所以该事件下的驱动设备最多存32个,</span><br><span class="line"> 6         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);</span><br><span class="line"> 7         return -ENFILE;                &#x2F;&#x2F;没找到驱动设备</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9  ... ...</span><br><span class="line">10  evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);   &#x2F;&#x2F;分配一个input_handle全局结构体(没有r)</span><br><span class="line">11  ... ...</span><br><span class="line">12  evdev-&gt;handle.dev &#x3D; dev;              &#x2F;&#x2F;指向参数input_dev驱动设备</span><br><span class="line">13 evdev-&gt;handle.name &#x3D; evdev-&gt;name;</span><br><span class="line">14 evdev-&gt;handle.handler &#x3D; handler;    &#x2F;&#x2F;指向参数 input_handler驱动处理结构体</span><br><span class="line">15 evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line">16 sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);    &#x2F;&#x2F;(1)保存驱动设备名字, event%d</span><br><span class="line">17 ... ...</span><br><span class="line">18 devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  &#x2F;&#x2F;(2) 将主设备号和次设备号转换成dev_t类型</span><br><span class="line">19 cdev &#x3D; class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name);                                                            &#x2F;&#x2F; (3)在input类下创建驱动设备</span><br><span class="line">20 </span><br><span class="line">21 ... ...</span><br><span class="line">22 error &#x3D; input_register_handle(&amp;evdev-&gt;handle); &#x2F;&#x2F;(4)注册这个input_handle结构体</span><br><span class="line">23 </span><br><span class="line">24 ... ...</span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1) 第16行中,是在保存驱动设备名字,名为event%d, 比如下图(键盘驱动)event1: 因为没有设置子设备号，默认从小到大排列,其中event0是表示这个input子系统,所以这个键盘驱动名字就是event1</p>
<p>(2)第18行中,是在保存驱动设备的主次设备号,其中主设备号INPUT_MAJOR=13,因为EVDEV_MINOR_BASE=64,所以此设备号=64+驱动程序本事子设备号, 比如下图(键盘驱动)event1:  主次设备号就是13,65</p>
<p>(3)在之前在2小结里就分析了input_class类结构，所以第19行中,会在/sys/class/input类下创建驱动设备event%d，比如下图(键盘驱动)event1:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190616478-260239851.png" alt="img"></p>
<p>(4)最终会进入input_register_handle()函数来注册,代码在下面</p>
<p>8.2 <strong>input_register_handle()函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_handle(struct input_handle *handle)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3       struct input_handler *handler &#x3D; handle-&gt;handler; &#x2F;&#x2F;handler&#x3D; input_handler驱动处理结构体 </span><br><span class="line"> 4 </span><br><span class="line"> 5       list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;(1)</span><br><span class="line"> 6       list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; (2)</span><br><span class="line"> 7  </span><br><span class="line"> 8       if (handler-&gt;start)</span><br><span class="line"> 9              handler-&gt;start(handle);</span><br><span class="line">10       return 0;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)在第5行中,</strong> 因为handle-&gt;dev指向input_dev驱动设备,所以就是将handle-&gt;d_node放入到input_dev驱动设备的h_list链表中,</p>
<p>即input_dev驱动设备的h_list链表就指向handle-&gt;d_node</p>
<p><strong>(2) 在第6行中,</strong> 同样, input_handler驱动处理结构体的h_list也指向了handle-&gt;h_node</p>
<p>最终如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125909525-684596795.png" alt="img"></p>
<p>两者的.h_list都指向了同一个handle结构体，然后通过.h_list 来找到handle的成员.dev和handler,便能找到对方,便建立了连接</p>
<p><strong>9建立了连接后，又如何读取evdev.c(事件驱动) 的evdev_handler-&gt;.fops-&gt;.read函数？</strong></p>
<p>事件驱动的.read函数是evdev_read()函数,我们来分析下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *      buffer, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line"> ... ...</span><br><span class="line">&#x2F;*判断应用层要读取的数据是否正确*&#x2F;</span><br><span class="line">if (count &lt; evdev_event_size())</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">&#x2F;*在非阻塞操作情况下,若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),则return返回*&#x2F;</span><br><span class="line"> if (client-&gt;head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">return -EAGAIN;</span><br><span class="line"> </span><br><span class="line">&#x2F;*若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),等待中断进入睡眠状态  *&#x2F;</span><br><span class="line">  retval &#x3D; wait_event_interruptible(evdev-&gt;wait,client-&gt;head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">  ... ...           &#x2F;&#x2F;上传数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>10若read函数进入了休眠状态，又是谁来唤醒？</strong></p>
<p>我们搜索这个evdev-&gt;wait这个等待队列变量,找到evdev_event函数里唤醒:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line"> wake_up_interruptible(&amp;evdev-&gt;wait);   &#x2F;&#x2F;有事件触发，便唤醒等待中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中evdev_event()是evdev.c(事件驱动) 的evdev_handler-&gt;.event成员,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125924681-419081807.png" alt="img"></p>
<p>当有事件发生了,比如对于按键驱动,当有按键按下时,就会进入.event函数中处理事件</p>
<p><strong>11分析下,是谁调用evdev_event()这个.event事件驱动函数</strong></p>
<p>应该就是之前分析的input_dev那层调用的</p>
<p>我们来看看内核 gpio_keys_isr()函数代码例子就知道了 (driver/input/keyboard/gpio_key.c)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t gpio_keys_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*获取按键值,赋到state里*&#x2F;</span><br><span class="line"> ... ...</span><br><span class="line"></span><br><span class="line">&#x2F;*上报事件*&#x2F;</span><br><span class="line">input_event(input, type, button-&gt;code, !!state);  </span><br><span class="line">input_sync(input);                        &#x2F;&#x2F;同步信号通知,表示事件发送完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>显然就是通过input_event()来调用.event事件函数,我们来看看:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">struct input_handle *handle;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#x2F;* 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体*&#x2F;</span><br><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)    </span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若之前驱动input_dev和处理input_handler已经通过input_handler 的.connect函数建立起了连接,那么就调用evdev_event()的.event事件函数，如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125942290-1009610213.png" alt="img"></p>
<p><strong>12本节总结分析:</strong></p>
<p><strong>1.**</strong>注册输入子系统<strong><strong>,</strong></strong>进入<strong>**put_init():</strong></p>
<p>1)创建主设备号为13的”input”字符设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br></pre></td></tr></table></figure>



<p><strong>2.open打开**</strong>驱动<strong><strong>,</strong></strong>进入<strong>**input_open_file():</strong></p>
<p>1)更新设备的file_oprations</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;f_op&#x3D;fops_get(handler-&gt;fops);</span><br></pre></td></tr></table></figure>



<p>2)执行file_oprations-&gt;open函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; new_fops-&gt;open(inode, file);</span><br></pre></td></tr></table></figure>



<p><strong>3.**</strong>注册<strong><strong>input_handler,</strong></strong>进入<strong>**input_register_handler():</strong></p>
<p>1)添加到input_table[]处理数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;</span><br></pre></td></tr></table></figure>



<p>2）添加到input_handler_list链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br></pre></td></tr></table></figure>



<p>3)判断input_dev的id,是否有支持这个驱动的设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(dev, &amp;input_dev_list, node)   &#x2F;&#x2F;遍历查找input_dev_list链表里所有input_dev</span><br><span class="line"></span><br><span class="line">input_attach_handler(dev, handler);             &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>

<p><strong>4.**</strong>注册<strong><strong>input_dev</strong></strong>，进入<strong>**input_register_device():</strong></p>
<p>1)放在input_dev_list链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br></pre></td></tr></table></figure>



<p>2)判断input_handler的id，是否有支持这个设备的驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;遍历查找input_handler_list链表里所有input_handler</span><br><span class="line">input_attach_handler(dev, handler);                      &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>



<p><strong>5.**</strong>判断<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的<strong><strong>id,</strong></strong>进入<strong>**input_attach_handler():</strong></p>
<p>1）匹配两者id,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_match_device(handler-&gt;id_table, dev);        &#x2F;&#x2F;匹配input_handler和dev的id,不成功退出函数</span><br></pre></td></tr></table></figure>



<p>2)匹配成功调用input_handler -&gt;connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler-&gt;connect(handler, dev, id);              &#x2F;&#x2F;建立连接</span><br></pre></td></tr></table></figure>

<p><strong>6.**</strong>建立<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的连接，进入<strong>**input_handler-&gt;connect():</strong></p>
<p>1)创建全局结构体,通过input_handle结构体连接双方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);    &#x2F;&#x2F;创建两者连接的input_handle全局结构体</span><br><span class="line">list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;连接input_dev-&gt;h_list</span><br><span class="line">list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; 连接input_handle-&gt;h_list</span><br></pre></td></tr></table></figure>

<p><strong>7.**</strong>有事件发生时<strong><strong>,</strong></strong>比如按键中断<strong><strong>,</strong></strong>在中断函数中需要进入<strong><strong>input_event()</strong></strong>上报事件<strong>**:</strong></p>
<p>1)找到驱动处理结构体，然后执行input_handler-&gt;event()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)     &#x2F;&#x2F; 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体</span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体(有可能一个驱动设备在不同情况下有不同的驱动处理方式)</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数</span><br></pre></td></tr></table></figure>





<p><strong>然后在<a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener">下一节便开始</a></strong><a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener"><strong>实现**</strong>输入子系统的键盘按键驱动**</a></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Input/" rel="tag"># Input</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/" rel="prev" title="【转载】input子系统全面分析">
      <i class="fa fa-chevron-left"></i> 【转载】input子系统全面分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%20(%E8%AF%A6%E8%A7%A3)/" rel="next" title="【转载】Linux键盘按键驱动 (详解)">
      【转载】Linux键盘按键驱动 (详解) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#12-Linux之输入子系统分析-详解"><span class="nav-number">1.</span> <span class="nav-text">12.Linux之输入子系统分析(详解)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
