<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文转自：博客园–涛少&amp;【https:&#x2F;&#x2F;www.cnblogs.com&#x2F;deng-tao&#x2F;p&#x2F;6094049.html】 INPUT输入子系统一、什么是input输入子系统？ 1、Linux系统支持的输入设备繁多，例如键盘、鼠标、触摸屏、手柄或者是一些输入设备像体感输入等等，Linux系统是如何管理如此之多的不同类型、不同原理、不同的输入信息的 输入设备的呢？其实就是通过input输入子">
<meta property="og:type" content="article">
<meta property="og:title" content="【转载】INPUT输入子系统">
<meta property="og:url" content="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91INPUT%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="本文转自：博客园–涛少&amp;【https:&#x2F;&#x2F;www.cnblogs.com&#x2F;deng-tao&#x2F;p&#x2F;6094049.html】 INPUT输入子系统一、什么是input输入子系统？ 1、Linux系统支持的输入设备繁多，例如键盘、鼠标、触摸屏、手柄或者是一些输入设备像体感输入等等，Linux系统是如何管理如此之多的不同类型、不同原理、不同的输入信息的 输入设备的呢？其实就是通过input输入子">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161123160655378-1206222144.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124094104690-937210902.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124145255815-1134348827.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125165556721-1160519994.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125175018409-1907320882.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125204019940-91391068.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="article:published_time" content="2021-01-07T11:41:25.000Z">
<meta property="article:modified_time" content="2021-01-07T11:45:42.498Z">
<meta property="article:author" content="David Meng">
<meta property="article:tag" content="Input">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/944893/201611/944893-20161123160655378-1206222144.png">

<link rel="canonical" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91INPUT%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>【转载】INPUT输入子系统 | Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91INPUT%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【转载】INPUT输入子系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:41:25 / Modified: 19:45:42" itemprop="dateCreated datePublished" datetime="2021-01-07T19:41:25+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文转自：博客园–<a href="https://home.cnblogs.com/u/deng-tao/" target="_blank" rel="noopener">涛少&amp;</a>【<a href="https://www.cnblogs.com/deng-tao/p/6094049.html】" target="_blank" rel="noopener">https://www.cnblogs.com/deng-tao/p/6094049.html】</a></p>
<h1 id="INPUT输入子系统"><a href="#INPUT输入子系统" class="headerlink" title="INPUT输入子系统"></a><a href="https://www.cnblogs.com/deng-tao/p/6094049.html" target="_blank" rel="noopener">INPUT输入子系统</a></h1><p>一、什么是input输入子系统？</p>
<p>1、Linux系统支持的输入设备繁多，例如键盘、鼠标、触摸屏、手柄或者是一些输入设备像体感输入等等，Linux系统是如何管理如此之多的不同类型、不同原理、不同的输入信息的</p>
<p>输入设备的呢？其实就是通过input输入子系统这套软件体系来完成的。从整体上来说，input输入子系统分为3层：上层（输入事件驱动层）、中层（输入核心层）、</p>
<p>下层（输入设备驱动层），如下图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161123160655378-1206222144.png" alt="img"></p>
<p>联系之前学过的驱动框架做对比，input输入子系统其实就是input输入设备的驱动框架，与之前的学过的驱动框架不同的是，input输入子系统分为3层：上、中、下，所以他的复杂度</p>
<p>要高于之前讲的lcd、misc、fb等的驱动框架。</p>
<p>2、图中Drivers对应的就是下层设备驱动层，对应各种各样不同的输入设备，Input Core对应的就是中层核心层，Handlers对应的就是上层输入事件驱动层，最右边的代表的是用户空间。</p>
<p>(1)从图中可以看出，系统中可以注册多个输入设备，每个输入设备的可以是不同的，例如一台电脑上可以带有鼠标，键盘….。</p>
<p>(2)上层中的各个handler（Keyboard/Mouse/Joystick/Event）是属于平行关系，他们都是属于上层。不同的handler下对应的输入设备在应用层中的接口命名方式不一样，例如</p>
<p>Mouse下的输入设备在应用层的接口是 /dev/input/mousen （n代表0、1、2…），Joystick下的输入设备在应用层的接口是 /dev/input/jsn（n代表0、1、2…），</p>
<p>Event下的输入设备在应用层的接口是 /dev/input/eventn（n代表0、1、2…），这个是在input输入子系统中实现的，下面会分析其中的原由。</p>
<p>(3)输入核心层其实是负责协调上层和下层，使得上层和下层之间能够完成数据传递。当下层发生输入事件的时候，整个系统就被激活了，事件就会通过核心层传递到上层对应的一个/多个</p>
<p>handler中，最终会传递到应用空间。</p>
<p>3、输入子系统解决了什么问题？</p>
<p>(1)在GUI界面中，用户的自由度太大了，可以做的事情太多了，可以响应不同的输入类设备，而且还能够对不同的输入类设备的输入做出不同的动作。例如window中的一个软</p>
<p>件既可以响应鼠标输入事件，也可以相应键盘输入事件，而且这些事件都是预先不知道的。</p>
<p>(2)input子系统解决了不同的输入类设备的输入事件与应用层之间的数据传输，使得应用层能够获取到各种不同的输入设备的输入事件，input输入子系统能够囊括所有的不同种</p>
<p>类的输入设备，在应用层都能够感知到所有发生的输入事件。</p>
<p>4、input输入子系统如何工作？</p>
<p>例如以一次鼠标按下事件为例子来说明我们的input输入子系统的工作过程：</p>
<p>当我们按下鼠标左键的时候就会触发中断（中断是早就注册好的），就会去执行中断所绑定的处理函数，在函数中就会去读取硬件寄存器来判断按下的是哪个按键和状态 —-&gt;</p>
<p>将按键信息上报给input core层  —&gt; input core层处理好了之后就会上报给input event层，在这里会将我们的输入事件封装成一个input_event结构体放入一个缓冲区中 —&gt;  </p>
<p>应用层read就会将缓冲区中的数据读取出去。</p>
<p>5、相关的数据结构</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_dev &#123;</span><br><span class="line"> 2     const char *name;             &#x2F;&#x2F;  input设备的名字</span><br><span class="line"> 3     const char *phys;              &#x2F;&#x2F;  </span><br><span class="line"> 4     const char *uniq;              &#x2F;&#x2F;</span><br><span class="line"> 5     struct input_id id;             &#x2F;&#x2F;  </span><br><span class="line"> 6 </span><br><span class="line"> 7 &#x2F;&#x2F;  这些是用来表示该input设备能够上报的事件类型有哪些   是用位的方式来表示的</span><br><span class="line"> 8     unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line"> 9     unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">10     unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">11     unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">12     unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">13     unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">14     unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">15     unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">16     unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">17 </span><br><span class="line">18     unsigned int keycodemax;</span><br><span class="line">19     unsigned int keycodesize;</span><br><span class="line">20     void *keycode;</span><br><span class="line">21     int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">22               unsigned int scancode, unsigned int keycode);</span><br><span class="line">23     int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">24               unsigned int scancode, unsigned int *keycode);</span><br><span class="line">25 </span><br><span class="line">26     struct ff_device *ff;</span><br><span class="line">27 </span><br><span class="line">28     unsigned int repeat_key;</span><br><span class="line">29     struct timer_list timer;</span><br><span class="line">30 </span><br><span class="line">31     int sync;</span><br><span class="line">32 </span><br><span class="line">33     int abs[ABS_CNT];</span><br><span class="line">34     int rep[REP_MAX + 1];</span><br><span class="line">35 </span><br><span class="line">36     unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">37     unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">38     unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">39     unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">40 </span><br><span class="line">41     int absmax[ABS_CNT];</span><br><span class="line">42     int absmin[ABS_CNT];</span><br><span class="line">43     int absfuzz[ABS_CNT];</span><br><span class="line">44     int absflat[ABS_CNT];</span><br><span class="line">45     int absres[ABS_CNT];</span><br><span class="line">46 </span><br><span class="line">47     int (*open)(struct input_dev *dev);              &#x2F;&#x2F;    设备的open函数</span><br><span class="line">48     void (*close)(struct input_dev *dev);          </span><br><span class="line">49     int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">50     int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);     &#x2F;&#x2F;  上报事件</span><br><span class="line">51 </span><br><span class="line">52     struct input_handle *grab;</span><br><span class="line">53 </span><br><span class="line">54     spinlock_t event_lock;</span><br><span class="line">55     struct mutex mutex;</span><br><span class="line">56 </span><br><span class="line">57     unsigned int users;</span><br><span class="line">58     bool going_away;</span><br><span class="line">59 </span><br><span class="line">60     struct device dev;                 &#x2F;&#x2F;  内置的device结构体变量</span><br><span class="line">61 </span><br><span class="line">62     struct list_head    h_list;    &#x2F;&#x2F;  用来挂接input_dev 设备连接的所有handle 的一个链表头</span><br><span class="line">63     struct list_head    node;    &#x2F;&#x2F;  作为链表节点挂接到  input_dev_list 链表上  (input_dev_list链表是input核心层维护的一个用来挂接所有input设备的一个链表头)</span><br><span class="line">64 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_handler &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     void *private;            &#x2F;&#x2F;  私有数据</span><br><span class="line"> 4 </span><br><span class="line"> 5     void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);   &#x2F;&#x2F;  handler用于向上层上报输入事件的函数</span><br><span class="line"> 6     bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line"> 7     bool (*match)(struct input_handler *handler, struct input_dev *dev);            &#x2F;&#x2F;   match 函数用来匹配handler 与 input_dev 设备</span><br><span class="line"> 8     int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);   &#x2F;&#x2F;  当handler 与 input_dev 匹配成功之后用来连接</span><br><span class="line"> 9     void (*disconnect)(struct input_handle *handle);          &#x2F;&#x2F;  断开handler 与 input_dev 之间的连接</span><br><span class="line">10     void (*start)(struct input_handle *handle);                    </span><br><span class="line">11 </span><br><span class="line">12     const struct file_operations *fops;             &#x2F;&#x2F;  一个file_operations 指针</span><br><span class="line">13     int minor;                                      &#x2F;&#x2F;  该handler 的编号 (在input_table 数组中用来计算数组下标) input_table数组就是input子系统用来管理注册的handler的一个数据结构</span><br><span class="line">14     const char *name;                               &#x2F;&#x2F;  handler的名字</span><br><span class="line">15 </span><br><span class="line">16     const struct input_device_id *id_table;      &#x2F;&#x2F;  指向一个 input_device_id  类型的数组，用来进行与input设备匹配时用到的信息</span><br><span class="line">17  </span><br><span class="line">18     struct list_head    h_list;       &#x2F;&#x2F;  用来挂接handler 上连接的所有handle 的一个链表头</span><br><span class="line">19     struct list_head    node;        &#x2F;&#x2F;  作为一个链表节点挂接到 input_handler_list 链表上(input_handler_list 链表是一个由上层handler参维护的一个用来挂接所有注册的handler的链表头)</span><br><span class="line">20 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_handle &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     void *private;               &#x2F;&#x2F;   handle  的私有数据</span><br><span class="line"> 4 </span><br><span class="line"> 5     int open;                     &#x2F;&#x2F;  这个也是用来做打开计数的</span><br><span class="line"> 6     const char *name;       &#x2F;&#x2F;   该handle 的名字</span><br><span class="line"> 7 </span><br><span class="line"> 8     struct input_dev *dev;                &#x2F;&#x2F;  用来指向该handle 绑定的input_dev 结构体</span><br><span class="line"> 9     struct input_handler *handler;    &#x2F;&#x2F;  用来指向该handle 绑定的 handler 结构体</span><br><span class="line">10 </span><br><span class="line">11     struct list_head    d_node;      &#x2F;&#x2F;  作为一个链表节点挂接到与他绑定的input_dev -&gt;hlist 链表上</span><br><span class="line">12     struct list_head    h_node;      &#x2F;&#x2F;  作为一个链表节点挂接到与他绑定的handler-&gt;hlist 链表上</span><br><span class="line">13 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_device_id &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     kernel_ulong_t flags;    &#x2F;&#x2F;  这个flag 表示我们的这个 input_device_id 是用来匹配下面的4个情况的哪一项</span><br><span class="line"> 4                                     &#x2F;&#x2F;  flag &#x3D;&#x3D; 1表示匹配总线  2表示匹配供应商   4表示匹配产品  8表示匹配版本</span><br><span class="line"> 5     __u16 bustype;</span><br><span class="line"> 6     __u16 vendor;</span><br><span class="line"> 7     __u16 product;</span><br><span class="line"> 8     __u16 version;</span><br><span class="line"> 9 </span><br><span class="line">10     kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">11     kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">12     kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">13     kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">14     kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">15     kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">16     kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">17     kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">18     kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">19 </span><br><span class="line">20     kernel_ulong_t driver_info;</span><br><span class="line">21 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>二、输入核心层源码分析（内核版本：2.6.35.7）</p>
<p>input输入子系统中的所有源码都放在 drivers\input 这个目录中，input.c文件就是核心层的源代码文件。在input目录中还可以看到一些文件夹，例如gameport、joystick</p>
<p>keyboard、misc、mouse….，这些文件夹里面存放的就是属于这类的input输入设备的设备驱动源代码，可以理解为input输入子系统的下层。</p>
<p>input目录下的evdev.c、joydev.c、mousedev.c..分别对应上层的各个不同的handler的源代码。</p>
<p>1、输入核心层模块注册函数input_init</p>
<p>在Linux中实现为一个模块的方法，所以可以在内核配置的进行动态的加载和卸载，这样做的原由是，存在有些系统中不需要任何</p>
<p>的输入类设备，这样就可以将input输入子系统这个模块去掉（上层也是实现为模块的），使得内核尽量变得更小。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __init input_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int err;</span><br><span class="line"> 4 </span><br><span class="line"> 5     input_init_abs_bypass();</span><br><span class="line"> 6 </span><br><span class="line"> 7     err &#x3D; class_register(&amp;input_class);                &#x2F;&#x2F;  创建设备类    &#x2F;sys&#x2F;class&#x2F;input</span><br><span class="line"> 8     if (err) &#123;</span><br><span class="line"> 9         printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);</span><br><span class="line">10         return err;</span><br><span class="line">11     &#125;</span><br><span class="line">12 </span><br><span class="line">13     err &#x3D; input_proc_init();           &#x2F;&#x2F;    proc文件系统相关的初始化</span><br><span class="line">14     if (err)</span><br><span class="line">15         goto fail1;</span><br><span class="line">16 </span><br><span class="line">17     err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);       &#x2F;&#x2F;   注册字符设备驱动   主设备号13   input_fops 中只实现了open函数，所以他的原理其实和misc其实是一样的</span><br><span class="line">18     if (err) &#123;</span><br><span class="line">19         printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">20         goto fail2;</span><br><span class="line">21     &#125;</span><br><span class="line">22 </span><br><span class="line">23     return 0;</span><br><span class="line">24 </span><br><span class="line">25  fail2:    input_proc_exit();</span><br><span class="line">26  fail1:    class_unregister(&amp;input_class);</span><br><span class="line">27     return err;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1)input_proc_init函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __init input_proc_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct proc_dir_entry *entry;</span><br><span class="line"> 4 </span><br><span class="line"> 5     proc_bus_input_dir &#x3D; proc_mkdir(&quot;bus&#x2F;input&quot;, NULL);    &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;目录下创建input目录 *&#x2F;</span><br><span class="line"> 6     if (!proc_bus_input_dir)</span><br><span class="line"> 7         return -ENOMEM;</span><br><span class="line"> 8 </span><br><span class="line"> 9     entry &#x3D; proc_create(&quot;devices&quot;, 0, proc_bus_input_dir,  &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;input&#x2F;目录下创建devices文件 *&#x2F;</span><br><span class="line">10                 &amp;input_devices_fileops);</span><br><span class="line">11     if (!entry)</span><br><span class="line">12         goto fail1;</span><br><span class="line">13 </span><br><span class="line">14     entry &#x3D; proc_create(&quot;handlers&quot;, 0, proc_bus_input_dir, &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;input&#x2F;目录下创建handlers文件 *&#x2F;</span><br><span class="line">15                 &amp;input_handlers_fileops);</span><br><span class="line">16     if (!entry)</span><br><span class="line">17         goto fail2;</span><br><span class="line">18 </span><br><span class="line">19     return 0;</span><br><span class="line">20 </span><br><span class="line">21  fail2:    remove_proc_entry(&quot;devices&quot;, proc_bus_input_dir);</span><br><span class="line">22  fail1: remove_proc_entry(&quot;bus&#x2F;input&quot;, NULL);</span><br><span class="line">23     return -ENOMEM;</span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当我们启动系统之后进入到proc文件系统中，确实可以看到在/proc/bus/input/目录下有两个文件devices和handlers，这两个文件就是在这里被创建的。我们cat devices 和 cat handlers</p>
<p>时对应的操作方法(show)就被封装在input_devices_fileops和input_handlers_fileops结构体中。</p>
<p>(2)input_fops变量</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124094104690-937210902.png" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_handler *handler;                                                &#x2F;&#x2F;  定义一个input_handler指针</span><br><span class="line"> 4     const struct file_operations *old_fops, *new_fops &#x3D; NULL;   &#x2F;&#x2F;  定义两个file_operations指针</span><br><span class="line"> 5     int err;</span><br><span class="line"> 6 </span><br><span class="line"> 7     err &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"> 8     if (err)</span><br><span class="line"> 9         return err;</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* No load-on-demand here? *&#x2F;</span><br><span class="line">12     handler &#x3D; input_table[iminor(inode) &gt;&gt; 5];         &#x2F;&#x2F;  通过次设备号在 input_table  数组中找到对应的 handler </span><br><span class="line">13     if (handler)</span><br><span class="line">14         new_fops &#x3D; fops_get(handler-&gt;fops);           &#x2F;&#x2F;  将handler 中的fops 指针赋值给 new_fops</span><br><span class="line">15 </span><br><span class="line">16     mutex_unlock(&amp;input_mutex);</span><br><span class="line">17 </span><br><span class="line">18     &#x2F;*</span><br><span class="line">19      * That&#39;s _really_ odd. Usually NULL -&gt;open means &quot;nothing special&quot;,</span><br><span class="line">20      * not &quot;no device&quot;. Oh, well...</span><br><span class="line">21      *&#x2F;</span><br><span class="line">22     if (!new_fops || !new_fops-&gt;open) &#123;</span><br><span class="line">23         fops_put(new_fops);</span><br><span class="line">24         err &#x3D; -ENODEV;</span><br><span class="line">25         goto out;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     old_fops &#x3D; file-&gt;f_op;           &#x2F;&#x2F;   将 file-&gt;fops 先保存到 old_fops 中，以便出错时能够恢复</span><br><span class="line">29     file-&gt;f_op &#x3D; new_fops;          &#x2F;&#x2F;   用new_fops 替换 file 中 fops </span><br><span class="line">30 </span><br><span class="line">31     err &#x3D; new_fops-&gt;open(inode, file);       &#x2F;&#x2F;  执行 file-&gt;open  函数</span><br><span class="line">32     if (err) &#123;</span><br><span class="line">33         fops_put(file-&gt;f_op);</span><br><span class="line">34         file-&gt;f_op &#x3D; fops_get(old_fops);</span><br><span class="line">35     &#125;</span><br><span class="line">36     fops_put(old_fops);</span><br><span class="line">37 out:</span><br><span class="line">38     return err;</span><br><span class="line">39 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>2、核心层提供给设备驱动层的接口函数</p>
<p>input设备驱动框架留给设备驱动层的接口函数主要有3个：</p>
<p>   input_allocate_device。分配一块input_dev结构体类型大小的内存</p>
<p>   input_set_capability。设置输入设备可以上报哪些输入事件</p>
<p>   input_register_device。向input核心层注册设备</p>
<p>(1)input_allocate_device函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_dev *input_allocate_device(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_dev *dev;                 &#x2F;&#x2F;   定义一个 input_dev  指针</span><br><span class="line"> 4 </span><br><span class="line"> 5     dev &#x3D; kzalloc(sizeof(struct input_dev), GFP_KERNEL);   &#x2F;&#x2F;  申请分配内存</span><br><span class="line"> 6     if (dev) &#123;</span><br><span class="line"> 7         dev-&gt;dev.type &#x3D; &amp;input_dev_type;          &#x2F;&#x2F;  确定input设备的 设备类型     input_dev_type</span><br><span class="line"> 8         dev-&gt;dev.class &#x3D; &amp;input_class;                &#x2F;&#x2F;  确定input设备所属的设备类   class</span><br><span class="line"> 9         device_initialize(&amp;dev-&gt;dev);                   &#x2F;&#x2F;  input设备的初始化</span><br><span class="line">10         mutex_init(&amp;dev-&gt;mutex);                        &#x2F;&#x2F;  互斥锁初始化</span><br><span class="line">11         spin_lock_init(&amp;dev-&gt;event_lock);            &#x2F;&#x2F;  自旋锁初始化</span><br><span class="line">12         INIT_LIST_HEAD(&amp;dev-&gt;h_list);                 &#x2F;&#x2F;  input_dev -&gt; h_list 链表初始化</span><br><span class="line">13         INIT_LIST_HEAD(&amp;dev-&gt;node);                 &#x2F;&#x2F;  input_dev -&gt; node 链表初始化</span><br><span class="line">14 </span><br><span class="line">15         __module_get(THIS_MODULE);</span><br><span class="line">16     &#125;</span><br><span class="line">17 </span><br><span class="line">18     return dev;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(2)input_set_capability函数：</p>
<p>函数原型：input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)</p>
<p>参数：dev就是设备的input_dev结构体变量</p>
<p>​    type表示设备可以上报的事件类型</p>
<p>​    code表示上报这类事件中的那个事件</p>
<p>注意：input_set_capability函数一次只能设置一个具体事件，如果设备可以上报多个事件，则需要重复调用这个函数来进行设置，例如：</p>
<p>input_set_capability(dev, EV_KEY, KEY_Q);     // 至于函数内部是怎么设置的，将会在后面进行分析。</p>
<p>input_set_capability(dev, EV_KEY, KEY_W);</p>
<p>input_set_capability(dev, EV_KEY, KEY_E);</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124145255815-1134348827.png" alt="img"></p>
<p>具体的这些类下面有哪些具体的输入事件，请看 drivers\input\input.h 这个文件。</p>
<p>(3)input_register_device函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)      &#x2F;&#x2F;  注册input输入设备</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     static atomic_t input_no &#x3D; ATOMIC_INIT(0);</span><br><span class="line"> 4     struct input_handler *handler;                          &#x2F;&#x2F;  定义一个  input_handler 结构体指针</span><br><span class="line"> 5     const char *path;</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     &#x2F;* Every input device generates EV_SYN&#x2F;SYN_REPORT events. *&#x2F;</span><br><span class="line"> 9     __set_bit(EV_SYN, dev-&gt;evbit);                  &#x2F;&#x2F;   每一个input输入设备都会发生这个事件</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* KEY_RESERVED is not supposed to be transmitted to userspace. *&#x2F;</span><br><span class="line">12     __clear_bit(KEY_RESERVED, dev-&gt;keybit);  &#x2F;&#x2F;  清除KEY_RESERVED 事件对应的bit位，也就是不传输这种类型的事件</span><br><span class="line">13 </span><br><span class="line">14     &#x2F;* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. *&#x2F;</span><br><span class="line">15     input_cleanse_bitmasks(dev);           &#x2F;&#x2F;   确保input_dev中的用来记录事件的变量中没有提到的位掩码是干净的。</span><br><span class="line">16 </span><br><span class="line">17     &#x2F;*</span><br><span class="line">18      * If delay and period are pre-set by the driver, then autorepeating</span><br><span class="line">19      * is handled by the driver itself and we don&#39;t do it in input.c.</span><br><span class="line">20      *&#x2F;</span><br><span class="line">21     init_timer(&amp;dev-&gt;timer);</span><br><span class="line">22     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">23         dev-&gt;timer.data &#x3D; (long) dev;</span><br><span class="line">24         dev-&gt;timer.function &#x3D; input_repeat_key;</span><br><span class="line">25         dev-&gt;rep[REP_DELAY] &#x3D; 250;</span><br><span class="line">26         dev-&gt;rep[REP_PERIOD] &#x3D; 33;</span><br><span class="line">27     &#125;</span><br><span class="line">28 </span><br><span class="line">29     if (!dev-&gt;getkeycode)</span><br><span class="line">30         dev-&gt;getkeycode &#x3D; input_default_getkeycode;</span><br><span class="line">31 </span><br><span class="line">32     if (!dev-&gt;setkeycode)</span><br><span class="line">33         dev-&gt;setkeycode &#x3D; input_default_setkeycode;</span><br><span class="line">34 </span><br><span class="line">35     dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,                                  &#x2F;&#x2F;   设置input设备对象的名字    input+数字</span><br><span class="line">36              (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line">37 </span><br><span class="line">38     error &#x3D; device_add(&amp;dev-&gt;dev);         &#x2F;&#x2F;   添加设备       例如:          &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0     </span><br><span class="line">39     if (error)</span><br><span class="line">40         return error;</span><br><span class="line">41 </span><br><span class="line">42     path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);  &#x2F;&#x2F;  获取input设备对象所在的路径      &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input_xxx   </span><br><span class="line">43     printk(KERN_INFO &quot;input: %s as %s\n&quot;,</span><br><span class="line">44         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);</span><br><span class="line">45     kfree(path);</span><br><span class="line">46 </span><br><span class="line">47     error &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">48     if (error) &#123;</span><br><span class="line">49         device_del(&amp;dev-&gt;dev);</span><br><span class="line">50         return error;</span><br><span class="line">51     &#125;</span><br><span class="line">52 </span><br><span class="line">53     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);             &#x2F;&#x2F;   链表挂接:    将 input_dev-&gt;node 作为节点挂接到 input_dev_list  链表上</span><br><span class="line">54 </span><br><span class="line">55     list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;  遍历input_handler_list 链表上的所有handler</span><br><span class="line">56         input_attach_handler(dev, handler);                        &#x2F;&#x2F;  将handler与input设备进行匹配</span><br><span class="line">57 </span><br><span class="line">58     input_wakeup_procfs_readers();                &#x2F;&#x2F;  更新proc 文件系统</span><br><span class="line">59 </span><br><span class="line">60     mutex_unlock(&amp;input_mutex);</span><br><span class="line">61 </span><br><span class="line">62     return 0;</span><br><span class="line">63 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(4)input_attach_handler函数：</p>
<p>input_attach_handler就是input_register_device函数中用来对下层的设备驱动和上层的handler进行匹配的一个函数，只有匹配成功之后就会调用上层handler中的connect函数</p>
<p>进行连接绑定。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     const struct input_device_id *id;                &#x2F;&#x2F;   定义一个input_device_id 的指针</span><br><span class="line"> 4     int error;</span><br><span class="line"> 5 </span><br><span class="line"> 6     id &#x3D; input_match_device(handler, dev);   &#x2F;&#x2F;  通过这个函数进行handler与input设备的匹配工作</span><br><span class="line"> 7     if (!id)</span><br><span class="line"> 8         return -ENODEV;</span><br><span class="line"> 9 </span><br><span class="line">10     error &#x3D; handler-&gt;connect(handler, dev, id);  &#x2F;&#x2F;  匹配成功则调用 handler 中的 connect 函数进行连接</span><br><span class="line">11     if (error &amp;&amp; error !&#x3D; -ENODEV)</span><br><span class="line">12         printk(KERN_ERR</span><br><span class="line">13             &quot;input: failed to attach handler %s to device %s, &quot;</span><br><span class="line">14             &quot;error: %d\n&quot;,</span><br><span class="line">15             handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line">16 </span><br><span class="line">17     return error;</span><br><span class="line">18 &#125;</span><br><span class="line">19 </span><br><span class="line">20 </span><br><span class="line">21 </span><br><span class="line">22 static const struct input_device_id *input_match_device(struct input_handler *handler,</span><br><span class="line">23                             struct input_dev *dev)</span><br><span class="line">24 &#123;</span><br><span class="line">25     const struct input_device_id *id;            &#x2F;&#x2F;   定义一个 input_device_id  指针</span><br><span class="line">26     int i;</span><br><span class="line">27 </span><br><span class="line">28     for (id &#x3D; handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;  &#x2F;&#x2F;  依次遍历handler-&gt;id_table 所指向的input_device_id 数组中的各个元素</span><br><span class="line">29                                                                                                                     &#x2F;&#x2F;  依次进行下面的匹配过程</span><br><span class="line">30         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)         &#x2F;&#x2F;    匹配总线</span><br><span class="line">31             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)</span><br><span class="line">32                 continue;</span><br><span class="line">33 </span><br><span class="line">34         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)  &#x2F;&#x2F;  匹配供应商</span><br><span class="line">35             if (id-&gt;vendor !&#x3D; dev-&gt;id.vendor)</span><br><span class="line">36                 continue;</span><br><span class="line">37 </span><br><span class="line">38         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)  &#x2F;&#x2F;  匹配产品</span><br><span class="line">39             if (id-&gt;product !&#x3D; dev-&gt;id.product)</span><br><span class="line">40                 continue;</span><br><span class="line">41 </span><br><span class="line">42         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)  &#x2F;&#x2F;  匹配版本</span><br><span class="line">43             if (id-&gt;version !&#x3D; dev-&gt;id.version)</span><br><span class="line">44                 continue;</span><br><span class="line">45 </span><br><span class="line">46     &#x2F;&#x2F;    下面的这些是匹配我们上传的事件是否属实</span><br><span class="line">47         MATCH_BIT(evbit,  EV_MAX);</span><br><span class="line">48         MATCH_BIT(keybit, KEY_MAX);</span><br><span class="line">49         MATCH_BIT(relbit, REL_MAX);</span><br><span class="line">50         MATCH_BIT(absbit, ABS_MAX);</span><br><span class="line">51         MATCH_BIT(mscbit, MSC_MAX);</span><br><span class="line">52         MATCH_BIT(ledbit, LED_MAX);</span><br><span class="line">53         MATCH_BIT(sndbit, SND_MAX);</span><br><span class="line">54         MATCH_BIT(ffbit,  FF_MAX);</span><br><span class="line">55         MATCH_BIT(swbit,  SW_MAX);</span><br><span class="line">56 </span><br><span class="line">57         if (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">58             return id;        &#x2F;&#x2F;    如果数组中的某个匹配成功了就返回他的地址</span><br><span class="line">59     &#125;</span><br><span class="line">60 </span><br><span class="line">61     return NULL;</span><br><span class="line">62 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_attach_handler函数做的事情有两件：调用input_match_device函数进行设备与handler的匹配、匹配成功调用handler的连接函数进行连接（至于如何连接将会在后面说到）。</p>
<p>3、核心层提供给事件驱动层的接口函数</p>
<p>在input输入核心层向事件驱动层提供的接口主要有两个：</p>
<p>  input_register_handler。事件驱动层向核心层注册handler</p>
<p>  input_register_handle。事件驱动层向核心层注册handle。  注意上面的是handler，这里是handle，不一样，后面会说到。</p>
<p>(1)input_register_handler函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_handler(struct input_handler *handler)    &#x2F;&#x2F;  向核心层注册handler</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_dev *dev;          &#x2F;&#x2F;  定义一个input_dev 指针</span><br><span class="line"> 4     int retval; </span><br><span class="line"> 5 </span><br><span class="line"> 6     retval &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"> 7     if (retval)</span><br><span class="line"> 8         return retval;</span><br><span class="line"> 9 </span><br><span class="line">10     INIT_LIST_HEAD(&amp;handler-&gt;h_list);      &#x2F;&#x2F;  初始化 handler-&gt;h_list 链表</span><br><span class="line">11 </span><br><span class="line">12     if (handler-&gt;fops !&#x3D; NULL) &#123;          &#x2F;&#x2F;  如果 handler -&gt; fops 存在</span><br><span class="line">13         if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;  &#x2F;&#x2F;  如果input_table 数组中没有该handler  的位置了 则返回</span><br><span class="line">14             retval &#x3D; -EBUSY;</span><br><span class="line">15             goto out;</span><br><span class="line">16         &#125;</span><br><span class="line">17         input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;  &#x2F;&#x2F;  将 handler 指针存放在input_table 数组中去</span><br><span class="line">18     &#125;</span><br><span class="line">19 </span><br><span class="line">20     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);   &#x2F;&#x2F;  将 handler 通过 handler -&gt; node 节点 挂接到 input_handler_list 链表上</span><br><span class="line">21 </span><br><span class="line">22     list_for_each_entry(dev, &amp;input_dev_list, node)     &#x2F;&#x2F;  遍历 input_dev_list 链表下挂接的所有的 input_dev 设备</span><br><span class="line">23         input_attach_handler(dev, handler);          &#x2F;&#x2F;  然后进行匹配</span><br><span class="line">24 </span><br><span class="line">25     input_wakeup_procfs_readers();             &#x2F;&#x2F;  更新proc 文件系统</span><br><span class="line">26 </span><br><span class="line">27  out:</span><br><span class="line">28     mutex_unlock(&amp;input_mutex);</span><br><span class="line">29     return retval;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过分析了上面的input_register_device和这里的input_register_handler函数可以知道：注册设备的时候，不一定是先注册了handler才能够注册设备。当注册设备时，会先将</p>
<p>设备挂接到设备管理链表(input_dev_list)上，然后再去遍历input_handler_list链表匹配hander。同样对于handler注册的时候，也会先将handler挂接到handler管理链表</p>
<p>(input_handler_list)上，然后再去遍历input_dev_list链表匹配设备。所以从这里可以看出来，这种机制好像之前说过的platform总线下设备和驱动的匹配过程。</p>
<p>而且一个input_dev可以与多个handler匹配成功，从而可以在sysfs中创建多个设备文件，也可以在/dev/目录下创建多个设备节点，并且他们的次设备号是不一样的，这个很好理解。</p>
<p>所以就是导致一个设备对应多个次设备号，那这样有没有错呢？当然是没有错的。例如在我们的Ubuntu中，/dev/input/event3 和 </p>
<p>/dev/input/mouse1 都是对应鼠标这个设备。</p>
<p>(2)input_register_handle函数</p>
<p>这个函数的作用就是注册一个handle，也就是实现上图中的将各个handle连接起来构成一个环形的结构，再调用这个函数之前已经将handle中的dev和handler已经是填充好了的，</p>
<p>具体的这个函数代码就不去分析了。</p>
<p>其实handler、input_dev、handle3这之间的关系，在之前就已经接触过了，讲Linux设备驱动模型底层架构的时候遇到过，下面用一副关系图来描述他们之间的一个关系：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125165556721-1160519994.png" alt="img"></p>
<p>从本质上讲，input_dev与handler是多对多的关系，从上图可以看出来，一个input_dev可以对应多个handler，一个handler也可以对应多个input_dev。因为在匹配的时候，</p>
<p>一个input_dev会与所有的handler都进行匹配的，并不是匹配成功一次就退出。</p>
<p>从图中可以看出来，一个handle就是用来记录系统中一对匹配成功的handler和device，我们可以从这个handle出发得到handler的信息，还可以得到device的信息。所以正因为有这样的</p>
<p>功能，所以可以由handler经过handle最终获取到device的信息，同理也可以从device从发经过handle最终获取到handler的信息。这种运用方法将会在后面的分析中看到。</p>
<p>4、总结：</p>
<p>核心层（其实就是驱动框架）提供的服务有哪些：</p>
<p>(1)创建设备类、注册字符设备</p>
<p>(2)向设备驱动层提供注册接口</p>
<p>(3)提供上层handler和下层device之间的匹配函数</p>
<p>(4)向上层提供注册handler的接口</p>
<p>二、输入事件驱动层源码分析</p>
<p>input输入子系统的输入事件驱动层（上层）其实是由各个handler构成的，各个handler之间是属于平行关系，不存在相互调用的现象。目前用的最多是event，今天就以这个handler</p>
<p>为例分析他的源代码，以便对handler的实现有一定的了解，前面说到过，input输入子系统的源代码都在 drivers\input\这个目录下，其中 drivers\input\evdev.c就是event</p>
<p>的源代码文件。</p>
<p>从evdev.c文件的末尾可以看到使用了module_init、module_exit这些宏，说明内核中将这部分实现为模块的方式，这其实很好理解，因为input核心层都是实现为模块的方式，而</p>
<p>上层是要依赖于核心层才能够注册、才能够工作的，而核心层都已经实现为模块了，那么上层不更得需要这样做吗。好了，废话不多说开始分析代码。</p>
<p>1、模块注册函数：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125175018409-1907320882.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125204019940-91391068.png" alt="img"></p>
<p>evdev_handler变量就是本次分析的handler对应的结构体变量，变量中填充最重要的有3个：</p>
<p>evdev_event函数：</p>
<p>evdev_connect函数：</p>
<p>evdev_fops变量：</p>
<p>2、相关的数据结构</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct evdev &#123;     </span><br><span class="line"> 2     int exist;</span><br><span class="line"> 3     int open;                                &#x2F;&#x2F;  这个是用来作为设备被打开的计数</span><br><span class="line"> 4     int minor;                               &#x2F;&#x2F;   handler 与 input设备匹配成功之后创建的设备对应的device的次设备号相对于基准次设备号的偏移量</span><br><span class="line"> 5     struct input_handle handle;   &#x2F;&#x2F;   内置的一个  handle ，里面记录了匹配成功的input_dev 和 handler            </span><br><span class="line"> 6     wait_queue_head_t wait;</span><br><span class="line"> 7     struct evdev_client *grab;</span><br><span class="line"> 8     struct list_head client_list;       &#x2F;&#x2F;   用来挂接与 evdev 匹配成功的evdev_client 的一个链表头 </span><br><span class="line"> 9     spinlock_t client_lock; &#x2F;* protects client_list *&#x2F;</span><br><span class="line">10     struct mutex mutex;             &#x2F;&#x2F;  互斥锁</span><br><span class="line">11     struct device dev;                 &#x2F;&#x2F;  这个是handler 与 input设备匹配成功之后创建的设备对应的device</span><br><span class="line">12 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct evdev_client &#123;</span><br><span class="line"> 2     struct input_event buffer[EVDEV_BUFFER_SIZE];    &#x2F;&#x2F;  用来存放input_dev 事件的缓冲区</span><br><span class="line"> 3     int head;</span><br><span class="line"> 4     int tail;</span><br><span class="line"> 5     spinlock_t buffer_lock; &#x2F;* protects access to buffer, head and tail *&#x2F;</span><br><span class="line"> 6     struct fasync_struct *fasync;</span><br><span class="line"> 7     struct evdev *evdev;              &#x2F;&#x2F;   evdev 指针</span><br><span class="line"> 8     struct list_head node;            &#x2F;&#x2F;  作为一个链表节点挂接到相应的 evdev-&gt;client_list 链表上</span><br><span class="line"> 9     struct wake_lock wake_lock;</span><br><span class="line">10     char name[28];            &#x2F;&#x2F;  名字</span><br><span class="line">11 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 struct input_event &#123;</span><br><span class="line">2     struct timeval time;        &#x2F;&#x2F;  事件发生的事件</span><br><span class="line">3     __u16 type;                    &#x2F;&#x2F;  事件的类型</span><br><span class="line">4     __u16 code;                   &#x2F;&#x2F;   事件的码值</span><br><span class="line">5     __s32 value;                   &#x2F;&#x2F;  事件的状态</span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>



<p>3、函数详解</p>
<p>(1)evdev_connect函数分析：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line"> 2              const struct input_device_id *id)</span><br><span class="line"> 3 &#123;</span><br><span class="line"> 4     struct evdev *evdev;                 &#x2F;&#x2F;  定义一个 evdev 指针</span><br><span class="line"> 5     int minor;</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)  &#x2F;&#x2F;  从evdev_table 数组中找到一个没有被使用的最小的数组项  最大值32</span><br><span class="line"> 9         if (!evdev_table[minor])</span><br><span class="line">10             break;</span><br><span class="line">11 </span><br><span class="line">12     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;</span><br><span class="line">13         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);</span><br><span class="line">14         return -ENFILE;</span><br><span class="line">15     &#125;</span><br><span class="line">16 </span><br><span class="line">17     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);   &#x2F;&#x2F;  给evdev 申请分配内存</span><br><span class="line">18     if (!evdev)</span><br><span class="line">19         return -ENOMEM;</span><br><span class="line">20 </span><br><span class="line">21     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);            &#x2F;&#x2F;  初始化 evdev-&gt;client_list 链表</span><br><span class="line">22     spin_lock_init(&amp;evdev-&gt;client_lock);              &#x2F;&#x2F;  初始化自旋锁 evdev-&gt;client_lock</span><br><span class="line">23     mutex_init(&amp;evdev-&gt;mutex);                          &#x2F;&#x2F;  初始化互斥锁 evdev-&gt;mutex</span><br><span class="line">24     init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">25 </span><br><span class="line">26     dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);  &#x2F;&#x2F; 设置input设备的名字</span><br><span class="line">27     evdev-&gt;exist &#x3D; 1;</span><br><span class="line">28     evdev-&gt;minor &#x3D; minor;                                     &#x2F;&#x2F;  input设备的次设备号的偏移量 </span><br><span class="line">29 </span><br><span class="line">30     evdev-&gt;handle.dev &#x3D; input_get_device(dev);              &#x2F;&#x2F;  将我们传进来的 input_dev 指针存放在 evdev-&gt;handle.dev 中</span><br><span class="line">31     evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);     &#x2F;&#x2F;  设置 evdev -&gt; dev 对象的名字，并且把名字赋值给 evdev-&gt;handle.name</span><br><span class="line">32     evdev-&gt;handle.handler &#x3D; handler;          &#x2F;&#x2F;  将我们传进来的 handler 指针存放在 handle.handler 中</span><br><span class="line">33     evdev-&gt;handle.private &#x3D; evdev;             &#x2F;&#x2F;  把evdev 作为handle 的私有数据</span><br><span class="line">34 </span><br><span class="line">35     evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);        &#x2F;&#x2F;  设置 evdev-&gt;device 设备的设备号</span><br><span class="line">36     evdev-&gt;dev.class &#x3D; &amp;input_class;                                                  &#x2F;&#x2F;  将 input_class 作为 evdev-&gt;device 的设备类</span><br><span class="line">37     evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;                                                &#x2F;&#x2F; 将input_dev  -&gt; device 作为evdev-&gt;device 的父设备</span><br><span class="line">38     evdev-&gt;dev.release &#x3D; evdev_free;                   &#x2F;&#x2F;  evdev -&gt; device 设备的卸载函数</span><br><span class="line">39     device_initialize(&amp;evdev-&gt;dev);                      &#x2F;&#x2F;  设备初始化</span><br><span class="line">40 </span><br><span class="line">41     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);       &#x2F;&#x2F;  注册handle </span><br><span class="line">42     if (error)</span><br><span class="line">43         goto err_free_evdev;</span><br><span class="line">44 </span><br><span class="line">45     error &#x3D; evdev_install_chrdev(evdev);       &#x2F;&#x2F; 安装evdev   其实就是将evdev 结构体指针存放在evdev_table数组当中  下标就是evdev-&gt;minor</span><br><span class="line">46     if (error)</span><br><span class="line">47         goto err_unregister_handle;</span><br><span class="line">48 </span><br><span class="line">49     error &#x3D; device_add(&amp;evdev-&gt;dev);     &#x2F;&#x2F;  添加设备到系统          &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0&#x2F;event0        event0就是表示建立的设备文件</span><br><span class="line">50     if (error)</span><br><span class="line">51         goto err_cleanup_evdev;</span><br><span class="line">52 </span><br><span class="line">53     return 0;</span><br><span class="line">54 </span><br><span class="line">55  err_cleanup_evdev:</span><br><span class="line">56     evdev_cleanup(evdev);</span><br><span class="line">57  err_unregister_handle:</span><br><span class="line">58     input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line">59  err_free_evdev:</span><br><span class="line">60     put_device(&amp;evdev-&gt;dev);</span><br><span class="line">61     return error;</span><br><span class="line">62 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>这里搞清楚:  /sys/devices/virtual/input/input0  这个设备是在注册input_dev时创建的，而input0/event0就是在handler和input_dev匹配成功之后创建的，也会在/dev/目录</p>
<p>下创建设备节点。 </p>
<p>(2)evdev_open分析</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int evdev_open(struct inode *inode, struct file *file)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct evdev *evdev;                       &#x2F;&#x2F;  定义一个 evdev 结构体指针</span><br><span class="line"> 4     struct evdev_client *client;             &#x2F;&#x2F;   定义一个evdev_client 指针</span><br><span class="line"> 5     int i &#x3D; iminor(inode) - EVDEV_MINOR_BASE;   &#x2F;&#x2F;  通过inode 获取 需要打开的设备对应的evdev_table 数组中的下标变量</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     if (i &gt;&#x3D; EVDEV_MINORS)</span><br><span class="line"> 9         return -ENODEV;</span><br><span class="line">10 </span><br><span class="line">11     error &#x3D; mutex_lock_interruptible(&amp;evdev_table_mutex);</span><br><span class="line">12     if (error)</span><br><span class="line">13         return error;</span><br><span class="line">14     evdev &#x3D; evdev_table[i];             &#x2F;&#x2F;  从evdev_table  数组中找到evdev </span><br><span class="line">15     if (evdev)</span><br><span class="line">16         get_device(&amp;evdev-&gt;dev);</span><br><span class="line">17     mutex_unlock(&amp;evdev_table_mutex);</span><br><span class="line">18 </span><br><span class="line">19     if (!evdev)</span><br><span class="line">20         return -ENODEV;</span><br><span class="line">21 </span><br><span class="line">22     client &#x3D; kzalloc(sizeof(struct evdev_client), GFP_KERNEL);      &#x2F;&#x2F;  给 client 申请分配内存</span><br><span class="line">23     if (!client) &#123;</span><br><span class="line">24         error &#x3D; -ENOMEM;</span><br><span class="line">25         goto err_put_evdev;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">29     snprintf(client-&gt;name, sizeof(client-&gt;name), &quot;%s-%d&quot;,</span><br><span class="line">30             dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">31     wake_lock_init(&amp;client-&gt;wake_lock, WAKE_LOCK_SUSPEND, client-&gt;name);</span><br><span class="line">32     client-&gt;evdev &#x3D; evdev;                          &#x2F;&#x2F;  通过client-&gt;evdev 指针指向 evdev</span><br><span class="line">33     evdev_attach_client(evdev, client);   &#x2F;&#x2F;  其实这个函数就是做了一个链表挂接:  client-&gt;node  挂接到 evdev-&gt;client_list</span><br><span class="line">34 </span><br><span class="line">35     error &#x3D; evdev_open_device(evdev); &#x2F;&#x2F;  打开 evdev 设备   最终就会打开 input_dev -&gt; open 函数</span><br><span class="line">36     if (error)</span><br><span class="line">37         goto err_free_client;</span><br><span class="line">38 </span><br><span class="line">39     file-&gt;private_data &#x3D; client;              &#x2F;&#x2F;   将evdev_client 作为file 的私有数据存在</span><br><span class="line">40     nonseekable_open(inode, file);</span><br><span class="line">41 </span><br><span class="line">42     return 0;</span><br><span class="line">43 </span><br><span class="line">44  err_free_client:</span><br><span class="line">45     evdev_detach_client(evdev, client);</span><br><span class="line">46     kfree(client);</span><br><span class="line">47  err_put_evdev:</span><br><span class="line">48     put_device(&amp;evdev-&gt;dev);</span><br><span class="line">49     return error;</span><br><span class="line">50 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>4、总结：</p>
<p>(1)其实下层可以上报的事件都在我们的内核中是定义好的，我们都可以上报这些事，但是input子系统的上层输入事件驱动层的各个handler只能够处理某一些事件（event除外），</p>
<p>例如joy handler只能处理摇杆类型的事件，key handler只能处理键盘，内部实现的原理就是会在核心层做handler和device匹配的过程。如果我们的上报的事件与多个handler都</p>
<p>能够匹配成功，那么绑定之后核心层会向这多个handler都上报事件，再由handler上报给应用层。</p>
<p>(2)input设备注册的流程:</p>
<p>下层通过调用核心层的函数来向子系统注册input输入设备</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_device</p>
<p>  device_add:  /sys/devices/virtual/input/input0</p>
<p>  链表挂接: input_dev-&gt;node   ——-&gt;  input_dev_list</p>
<p>  input_attach_handler              //  进行input_dev和handler之间的匹配</p>
<p>​    调用handler-&gt;connect进行连接</p>
<p>​      构建evdev结构体，加入evdev_table数组</p>
<p>​      input_register_handle</p>
<p>​      device_add:  /sys/devices/virtual/input/input0/event0</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(3)handler注册流程</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_handler</p>
<p>  input_table[handler-&gt;minor &gt;&gt; 5] = handler</p>
<p>  链表挂接:  handler-&gt;node  —–&gt;  input_handler_list</p>
<p>  input_attach_handler</p>
<p>​    handler-&gt;connect          // 调用handler的connect函数进行连接</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(4)事件如何传递到应用层</p>
<p>input子系统下层通过调用input_event函数项核心层上报数据</p>
<p>input_event</p>
<p>  input_handle_event</p>
<p>​    input_pass_event</p>
<p>​      handler-&gt;event()       //  最终会调用到handler 中的event函数</p>
<p>​        evdev_pass_event</p>
<p>​          client-&gt;buffer[client-&gt;head++] = *event;   //  会将input输入事件数据存放在evdev_client结构体中的缓冲去中</p>
<p>当我们的应用层通过open打开event0这个设备节点时最终会调用到input_init函数中注册的字符设备input时注册的file_operations-&gt;open() 函数</p>
<p>input_open_file</p>
<p>  handler = input_table[iminor(inode) &gt;&gt; 5]</p>
<p>  handler-&gt;fops-&gt;open()      </p>
<p>​    evdev = evdev_table[i];</p>
<p>​    evdev_open_device</p>
<p>​      input_open_device</p>
<p>​        input_dev-&gt;open()     //  最终就是执行input设备中的open函数</p>
<p>​    file-&gt;private_data = evdev_client; </p>
<p>所以当我们在应用层调用read函数时，最终会调用到handler-&gt;fops-&gt;read函数</p>
<p>evdev_read</p>
<p>  evdev_fetch_next_event</p>
<p>​    *event = client-&gt;buffer[client-&gt;tail++]    //  将evdev_client-&gt;buffer中的数据取走</p>
<p>  input_event_to_user</p>
<p>​    copy_to_user          //  拷贝到用户空间</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>到此为止，input输入子系统中还有设备驱动层没有说到，将会在下一篇博文中补充。。。。。。。。。。。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Input/" rel="tag"># Input</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android(Linux)%20%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" rel="prev" title="【转载】Android(Linux) 输入子系统解析">
      <i class="fa fa-chevron-left"></i> 【转载】Android(Linux) 输入子系统解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/07/Linux/Driver/i2c/Linux%20I2C%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" rel="next" title="Linux I2C驱动设计">
      Linux I2C驱动设计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#INPUT输入子系统"><span class="nav-number">1.</span> <span class="nav-text">INPUT输入子系统</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
