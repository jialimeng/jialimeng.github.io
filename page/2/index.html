<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="冒险，创新，永不放弃">
<meta property="og:type" content="website">
<meta property="og:title" content="Tech Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="冒险，创新，永不放弃">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="David Meng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux-IIC%E9%A9%B1%E5%8A%A8(%E8%AF%A6%E8%A7%A3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux-IIC%E9%A9%B1%E5%8A%A8(%E8%AF%A6%E8%A7%A3)/" class="post-title-link" itemprop="url">【转载】Linux-IIC驱动(详解)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 17:03:39 / Modified: 17:05:51" itemprop="dateCreated datePublished" datetime="2021-01-15T17:03:39+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://www.cnblogs.com/lifexy/p/7816324.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7816324.html】</a></p>
<p>上一节 我们学习了:  </p>
<p>IIC接口下的24C02 驱动分析: <a href="http://www.cnblogs.com/lifexy/p/7793686.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7793686.html</a></p>
<p>接下来本节, 学习Linux下如何利用linux下I2C驱动体系结构来操作24C02</p>
<hr>
<p><strong>1. I2C体系结构分析</strong></p>
<p><strong>1.1首先进入linux内核的driver/i2c目录下,如下图所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194402075-2024973640.png" alt="img"></p>
<p>其中重要的文件介绍如下:</p>
<p><strong>1)</strong>algos文件夹(algorithms)</p>
<p>里面保存I2C的通信方面的算法</p>
<p><strong>2)</strong>busses文件夹</p>
<p>里面保存I2C总线驱动相关的文件,比如i2c-omap.c、 i2c-versatile.c、 i2c-s3c2410.c等。</p>
<p><strong>3)</strong> chips文件夹</p>
<p>里面保存I2C设备驱动相关的文件,如下图所示,比如m41t00,就是RTC实时钟</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194416216-654621318.png" alt="img"></p>
<p><strong>4)</strong> i2c-core.c<br>这个文件实现了I2C核心的功能(I2C总线的初始化、注册和适配器添加和注销等相关工作)以及/proc/bus/i2c<em>接口。<br>*</em>5)** i2c-dev.c<br>提供了通用的read（ ） 、 write（ ） 和ioctl（ ） 等接口，实现了I2C适配器设备文件的功能，其中I2C设备的主设备号都为89， 次设备号为0~255。<br>应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器， 并控制I2C设备的工作方式</p>
<p>显然,它和前几次驱动类似， I2C也分为总线驱动和设备驱动,总线就是协议相关的，它知道如何收发数据，但不知道数据含义，设备驱动却知道数据含义</p>
<p><strong>1.2 I2C驱动架构,如下图所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194431294-567878229.png" alt="img"></p>
<p>如上图所示,每一条I2C对应一个adapter适配器,在kernel中, adapter适配器是通过struct adapter结构体定义,主要是通过i2c core层将i2c设备与i2c adapter关联起来.</p>
<p>在kernel中提供了两个adapter注册接口,分别为i2c_add_adapter()和i2c_add_numbered_adapter().由于在系统中可能存在多个adapter,因为将每一条I2C总线对应一个编号,下文中称为I2C总线号.这个总线号的PCI中的总线号不同.它和硬件无关,只是软件上便于区分而已.</p>
<p>对于i2c_add_adapter()而言,它使用的是动态总线号,即由系统给其分析一个总线号,而i2c_add_numbered_adapter()则是自己指定总线号,如果这个总线号非法或者是被占用,就会注册失败.</p>
<p><strong>2.接下来便来分析I2C总线驱动</strong></p>
<p>参考 drivers/i2c/busses/i2c-s3c2410.c</p>
<p>先进入init入口函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194447059-1799759547.png" alt="img"></p>
<p>在init函数中,注册了一个 “s3c2440-i2c”的platform_driver平台驱动,我们来看看probe函数做了些什么</p>
<p><strong>3.进入s3c24xx_i2c_probe函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter  adap;</span><br><span class="line"></span><br><span class="line">static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">　　　　struct s3c24xx_i2c *i2c &#x3D; &amp;s3c24xx_i2c;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       &#x2F;*获取,使能I2C时钟*&#x2F;</span><br><span class="line">       i2c-&gt;clk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);               &#x2F;&#x2F;获取i2c时钟</span><br><span class="line">       clk_enable(i2c-&gt;clk);                                         &#x2F;&#x2F;使能i2c时钟</span><br><span class="line"></span><br><span class="line">       ... ....</span><br><span class="line">       &#x2F;*获取资源*&#x2F;</span><br><span class="line">       res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">       i2c-&gt;regs &#x3D; ioremap(res-&gt;start, (res-&gt;end-res-&gt;start)+1);</span><br><span class="line"></span><br><span class="line">       ... ....</span><br><span class="line"></span><br><span class="line">       &#x2F;*设置i2c_adapter适配器结构体, 将i2c结构体设为adap的私有数据成员*&#x2F;</span><br><span class="line">　　　　i2c-&gt;adap.algo_data &#x3D; i2c;          &#x2F;&#x2F;i2c_adapter适配器指向s3c24xx_i2c;</span><br><span class="line">       i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">　　　　&#x2F;* initialise the i2c controller *&#x2F;</span><br><span class="line">       &#x2F;*初始化2440的I2C相关的寄存器*&#x2F;</span><br><span class="line">       ret &#x3D; s3c24xx_i2c_init(i2c);</span><br><span class="line">       if (ret !&#x3D; 0)</span><br><span class="line">              goto err_iomap;</span><br><span class="line"></span><br><span class="line">       ... ...</span><br><span class="line">       &#x2F;*注册中断服务函数*&#x2F;</span><br><span class="line">       ret &#x3D; request_irq(res-&gt;start, s3c24xx_i2c_irq, IRQF_DISABLED,pdev-&gt;name, i2c);</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       &#x2F;*注册i2c_adapter适配器结构体*&#x2F;</span><br><span class="line">       ret &#x3D; i2c_add_adapter(&amp;i2c-&gt;adap);</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_adapter结构体是放在s3c24xx_i2c-&gt;adap下,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194502481-835272550.png" alt="img"></p>
<p><strong>4.接下来我们进入i2c_add_adapter()函数看看,到底如何注册的</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">       int   id, res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">       if (idr_pre_get(&amp;i2c_adapter_idr, GFP_KERNEL) &#x3D;&#x3D; 0) &#x2F;&#x2F;调用idr_pre_get()为i2c_adapter预留内存空间</span><br><span class="line">              return -ENOMEM;</span><br><span class="line"></span><br><span class="line">       mutex_lock(&amp;core_lists);</span><br><span class="line"></span><br><span class="line">       &#x2F;* &quot;above&quot; here means &quot;above or equal to&quot;, sigh *&#x2F;</span><br><span class="line">       res &#x3D; idr_get_new_above(&amp;i2c_adapter_idr, adapter,__i2c_first_dynamic_bus_num, &amp;id);</span><br><span class="line">       &#x2F;&#x2F;调用idr_get_new_above()将结构插入i2c_adapter_idr中,并将插入的位置赋给id,以后可以通过id在i2c_adapter_idr中找到相应的i2c_adapter结构体</span><br><span class="line"></span><br><span class="line">       mutex_unlock(&amp;core_lists);</span><br><span class="line"></span><br><span class="line">       if (res &lt; 0) &#123;</span><br><span class="line">              if (res &#x3D;&#x3D; -EAGAIN)</span><br><span class="line">                    goto retry;</span><br><span class="line">              return res;</span><br><span class="line">       &#125;</span><br><span class="line">       adapter-&gt;nr &#x3D; id;</span><br><span class="line">       return i2c_register_adapter(adapter);  &#x2F;&#x2F;调用i2c_register_adapter()函数进一步来注册.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_register_adapter()函数代码如下所示:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">       struct list_head  *item;               &#x2F;&#x2F;链表头,用来存放i2c_driver结构体的表头</span><br><span class="line">       struct i2c_driver *driver;                     &#x2F;&#x2F;i2c_driver,用来描述一个IIC设备驱动</span><br><span class="line">        list_add_tail(&amp;adap-&gt;list, &amp;adapters);       &#x2F;&#x2F;添加到内核的adapter链表中</span><br><span class="line">        ... ...</span><br><span class="line">       list_for_each(item,&amp;drivers) &#123;        &#x2F;&#x2F;for循环,从drivers链表里找到i2c_driver结构体的表头</span><br><span class="line">              driver &#x3D; list_entry(item, struct i2c_driver, list); &#x2F;&#x2F;通过list_head表头,找到i2c_driver结构体</span><br><span class="line">              if (driver-&gt;attach_adapter)  </span><br><span class="line">                     &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;</span><br><span class="line">                     driver-&gt;attach_adapter(adap);    　　　　　　　　　　　　　　　　&#x2F;&#x2F;调用i2c_driver的attach_adapter函数来看看,这个新注册的设配器是否支持i2c_driver &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在i2c_register_adapter()函数里主要执行以下几步:</p>
<p><strong>①</strong>将adapter放入i2c_bus_type的adapter链表<br><strong>②</strong>将所有的i2c设备调出来,执行i2c_driver设备的attach_adapter函数来匹配</p>
<p>其中, i2c_driver结构体会在后面讲述到</p>
<p><strong>而i2c_adapter适配器结构体的成员结构,如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter &#123;  </span><br><span class="line"></span><br><span class="line"> struct module *owner;　　　　　　　　　　　　　　&#x2F;&#x2F;所属模块  </span><br><span class="line"> unsigned int id;　　　　　　　　　　　　　　　　&#x2F;&#x2F;algorithm的类型，定义于i2c-id.h,  </span><br><span class="line"> unsigned int class;      </span><br><span class="line"> const struct i2c_algorithm *algo; 　　　　&#x2F;&#x2F;总线通信方法结构体指针  </span><br><span class="line"> void *algo_data;   　　　　　　　　　　　　&#x2F;&#x2F;algorithm数据  </span><br><span class="line"> struct rt_mutex bus_lock;　　　　　　　　&#x2F;&#x2F;控制并发访问的自旋锁  </span><br><span class="line"> int timeout;     </span><br><span class="line"> int retries;　　　　　　　　　　　　　　　　&#x2F;&#x2F;重试次数  </span><br><span class="line"> struct device dev; 　　　　　　　　　　　　&#x2F;&#x2F;适配器设备   </span><br><span class="line"> int nr;                  　　　　　　　　&#x2F;&#x2F;存放在i2c_adapter_idr里的位置号</span><br><span class="line"> char name[48];　　　　　　　　　　　　　　&#x2F;&#x2F;适配器名称  </span><br><span class="line"> struct completion dev_released;　　　　&#x2F;&#x2F;用于同步  </span><br><span class="line"> struct list_head userspace_clients;   &#x2F;&#x2F;client链表头  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>i2c_adapter表示物理上的一个i2C设备(适配器), 在i2c-s3c2410.c中,是存放在s3c24xx_i2c结构体下的(struct  i2c_adapter  adap)成员中</p>
<p><strong>5.其中s3c24xx_i2c的结构体成员如下所示</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const struct i2c_algorithm s3c24xx_i2c_algorithm &#x3D; &#123;            </span><br><span class="line">       .master_xfer          &#x3D; s3c24xx_i2c_xfer,  &#x2F;&#x2F;主机传输</span><br><span class="line">       .functionality          &#x3D; s3c24xx_i2c_func,                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct s3c24xx_i2c s3c24xx_i2c &#x3D; &#123;</span><br><span class="line">       .lock              &#x3D; __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),</span><br><span class="line">       .wait              &#x3D; __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),</span><br><span class="line">       .tx_setup &#x3D; 50,                        &#x2F;&#x2F;用来延时,等待SCL被释放</span><br><span class="line">       .adap             &#x3D; &#123;                                             &#x2F;&#x2F; i2c_adapter适配器结构体</span><br><span class="line">              .name                   &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">              .owner                  &#x3D; THIS_MODULE,</span><br><span class="line">              .algo                     &#x3D; &amp;s3c24xx_i2c_algorithm,           &#x2F;&#x2F;存放i2c_algorithm算法结构体</span><br><span class="line">              .retries           &#x3D; 2,                                       &#x2F;&#x2F;重试次数</span><br><span class="line">              .class                    &#x3D; I2C_CLASS_HWMON,</span><br><span class="line">       &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>显然这里是直接设置了i2c_adapter结构体,所以在s3c24xx_i2c_probe ()函数中没有分配i2c_adapter适配器结构体,</p>
<p>其中, i2c_adapter结构体的名称等于”s3c2410-i2c”,它的通信方式等于s3c24xx_i2c_algorithm,重试次数等于2</p>
<p><strong>PS:如果缺少i2c_algorithm的i2c_adapter什么也做不了，就只是个I2C设备,而没有通信方式</strong></p>
<p>s3c24xx_i2c_algorithm中的关键函数master_xfer()就是用于产生i2c访问周期需要的start stop ack等信号</p>
<p>比如,在s3c24xx_i2c_algorithm中的关键函数master_xfer()里,调用了:</p>
<p>s3c24xx_i2c_xfer -&gt; s3c24xx_i2c_doxfer()-&gt;s3c24xx_i2c_message_start()</p>
<p>来启动传输message信息, 其中s3c24xx_i2c_message_start()函数代码如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c, struct i2c_msg *msg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> unsigned int addr &#x3D; (msg-&gt;addr &amp; 0x7f) &lt;&lt; 1;              &#x2F;&#x2F;IIC从设备地址的最低位为读写标志位</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       stat &#x3D; 0;</span><br><span class="line">       stat |&#x3D;  S3C2410_IICSTAT_TXRXEN;     &#x2F;&#x2F;设置标志位启动IIC收发使能</span><br><span class="line"></span><br><span class="line">       if (msg-&gt;flags &amp; I2C_M_RD) &#123;                     &#x2F;&#x2F;判断是读,还是写</span><br><span class="line">              stat |&#x3D; S3C2410_IICSTAT_MASTER_RX;       </span><br><span class="line">              addr |&#x3D; 1;                                          &#x2F;&#x2F;设置从IIC设备地址为读标志</span><br><span class="line">       &#125; else</span><br><span class="line">              stat |&#x3D; S3C2410_IICSTAT_MASTER_TX;</span><br><span class="line"></span><br><span class="line">       s3c24xx_i2c_enable_ack(i2c);                &#x2F;&#x2F;使能ACK信号</span><br><span class="line"></span><br><span class="line">　　　　iiccon &#x3D; readl(i2c-&gt;regs + S3C2410_IICCON);    &#x2F;&#x2F;读出IICCON寄存器</span><br><span class="line"></span><br><span class="line">       writel(stat, i2c-&gt;regs + S3C2410_IICSTAT);   &#x2F;&#x2F;写入IICSTAT寄存器,使能IIC的读或写标志</span><br><span class="line"></span><br><span class="line">       dev_dbg(i2c-&gt;dev, &quot;START: %08lx to IICSTAT, %02x to DS\n&quot;, stat, addr);</span><br><span class="line"></span><br><span class="line">       writeb(addr, i2c-&gt;regs + S3C2410_IICDS);  &#x2F;&#x2F;将IIC从设备地址写入IICDS寄存器</span><br><span class="line"></span><br><span class="line">       &#x2F;* delay here to ensure the data byte has gotten onto the bus</span><br><span class="line">        * before the transaction is started *&#x2F;</span><br><span class="line"></span><br><span class="line">       ndelay(i2c-&gt;tx_setup);         &#x2F;&#x2F;延时,等待SCL被释放,下面便可以发送起始信号+IIC设备地址值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       dev_dbg(i2c-&gt;dev, &quot;iiccon, %08lx\n&quot;, iiccon);</span><br><span class="line">       writel(iiccon, i2c-&gt;regs + S3C2410_IICCON);            </span><br><span class="line"></span><br><span class="line">       stat |&#x3D;  S3C2410_IICSTAT_START;              </span><br><span class="line">       writel(stat, i2c-&gt;regs + S3C2410_IICSTAT); </span><br><span class="line">　　　　　　　　　　　　&#x2F;&#x2F;设置IICSTAT寄存器的bit5&#x3D;1,开始发送起始信号+IIC从设备地址值,并回应ACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过上面的代码和注释,发现主要是写入IIC从设备地址,然后发送起始信号+IIC从设备地址值,并回应ACK</p>
<p>显然IIC总线驱动i2c-s3c2410.c,主要设置适配器adapter,里面帮我们做好了IIC通信的架构,就是不知道发什么内容</p>
<p><strong>我们进入driver/i2c/chips中,看看eeprom设备驱动是如何写的</strong></p>
<p>参考: driver/i2c/chips/eeprom.c</p>
<p><strong>6.还是首先来看它的init入口函数:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194519716-1730511691.png" alt="img"></p>
<p>其中struct  i2c_driver eeprom_driver的成员如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_driver eeprom_driver &#x3D; &#123;</span><br><span class="line">       .driver &#x3D; &#123;</span><br><span class="line">              .name     &#x3D; &quot;eeprom&quot;,                        &#x2F;&#x2F;名称</span><br><span class="line">        &#125;,</span><br><span class="line">       .id           &#x3D; I2C_DRIVERID_EEPROM,           &#x2F;&#x2F;IIC设备标识ID</span><br><span class="line">       .attach_adapter     &#x3D; eeprom_attach_adapter,  &#x2F;&#x2F;用来与总线驱动的适配器匹配,匹配成功添加到适配器adapter中</span><br><span class="line">       .detach_client &#x3D; eeprom_detach_client,      &#x2F;&#x2F;与总线驱动的适配器解绑,分离这个IIC从设备</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>如下图所示, eeprom_driver结构体的ID成员在i2c-id.h中,里面还定义了大部分常用I2C设备驱动的设备ID</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194533466-969534257.png" alt="img"></p>
<p>显然,在init函数中通过i2c_add_driver()注册i2c_driver结构体,然后通过i2c_driver -&gt;attach_adapter来匹配内核中的各个总线驱动的适配器, 发送这个设备地址,若有ACK响应,表示匹配成功</p>
<p><strong>7.接下来,我们进入i2c_add_driver()来看看是不是这样的</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int i2c_add_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">       driver-&gt;driver.owner &#x3D; owner;</span><br><span class="line">       driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;    &#x2F;&#x2F;将i2c_driver放在i2c_bus_type链表中   </span><br><span class="line"></span><br><span class="line">       res &#x3D; driver_register(&amp;driver-&gt;driver); &#x2F;&#x2F;注册一个i2c_driver</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       if (driver-&gt;attach_adapter) &#123;</span><br><span class="line">              struct i2c_adapter *adapter;                     &#x2F;&#x2F;定义一个i2c_adapter适配器</span><br><span class="line">          list_for_each_entry(adapter, &amp;adapters, list)  &#x2F;&#x2F;for循环提取出adapters链表中所有的i2c_adapter适配器,放入到adapter结构体中</span><br><span class="line"> 　　　　　&#123;</span><br><span class="line">          driver-&gt;attach_adapter(adapter); &#x2F;&#x2F;来匹配取出来的i2c_adapter适配器</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      ... ...</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在i2c_add_driver ()函数里主要执行以下几步:</p>
<p><strong>①</strong>放入到i2c_bus_type链表</p>
<p><strong>②</strong>取出adapters链表中所有的i2c_adapter,然后执行i2c_driver-&gt;attach_adapter()</p>
<p><strong>所以i2c_adapter适配器和i2c_driver设备驱动注册框架如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194549372-635602878.png" alt="img"></p>
<p> 这里调用了i2c_driver -&gt;attach_adapter(adapter),我们看看里面是不是通过发送IIC设备地址，等待ACK响应来匹配的</p>
<p><strong>8.以struct i2c_driver eeprom_driver 为例,进入i2c_driver -&gt;eeprom_attach_adapter()函数</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194557138-2076450775.png" alt="img"></p>
<p>如下图所示,里面调用了i2c_probe(adapter, &amp;addr_data, eeprom_detect)函数</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194605794-2061351036.png" alt="img"></p>
<p>上图的第1个参数就是i2c_adapter适配器,第2个参数addr_data变量,里面存放了IIC设备地址的信息,第3个参数eeprom_detect就是具体的设备探测回调函数i2c_probe()函数,会通过adapter适配器发送IIC设备地址addr_data,如果收到ACK信号,就调用eeprom_detect()回调函数来注册i2c_client结构体,该结构体对应真实的物理从设备,而i2c_driver对应的是设备驱动,也就是说,只有当适配器支持这个设备驱动,才会注册i2c_client从设备,后面会讲这个回调函数如何注册i2c_client</p>
<p>而在i2c_driver -&gt;detach_client()中,则注销i2c_client结构体</p>
<p>其中addr_data变量是struct i2c_client_address_data<strong>结构体</strong>,它的成员如下所示:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client_address_data &#123;</span><br><span class="line">       unsigned short *normal_i2c;     &#x2F;&#x2F;存放正常的设备高7位地址数据</span><br><span class="line">       unsigned short *probe;          &#x2F;&#x2F;存放不受*ignore影响的高7位设备地址数据</span><br><span class="line">       unsigned short *ignore;         &#x2F;&#x2F;存放*ignore的高7位设备地址数据</span><br><span class="line">       unsigned short **forces;        &#x2F;&#x2F;forces表示适配器匹配不了该设备,也要将其放入适配器中</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当上面结构体的数组成员以I2C_CLIENT_END结尾,则表示地址已结束,比如at24c02设备为例,看这个结构体如何定义的:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define  AT24C02_ADDR           (0xA0&gt;&gt;1)           &#x2F;&#x2F;AT24C02地址</span><br><span class="line"></span><br><span class="line">static unsigned short  ignore[] &#x3D; &#123; I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short  normal_addr[] &#x3D; &#123; AT24C02_ADDR, I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short   force_addr[] &#x3D; &#123;ANY_I2C_BUS, AT24C02_ADDR ,2C_CLIENT_END&#125;;</span><br><span class="line">static unsigned short   * forces[] &#x3D; &#123;force_addr, NULL&#125;;　　　　　　　　　　　　&#x2F;&#x2F;ANY_I2C_BUS:表示支持所有适配器总线,若填指定的适配器总线ID,则表示该设备只支持指定的那个适配器</span><br><span class="line"></span><br><span class="line">static struct i2c_client_address_data  addr_data &#x3D; &#123;</span><br><span class="line">       .normal_i2c     &#x3D; normal_addr,    &#x2F;&#x2F;存放at24c02地址</span><br><span class="line">       .probe           &#x3D; ignore,        &#x2F;&#x2F;表示无地址</span><br><span class="line">       .ignore           &#x3D; ignore,        &#x2F;&#x2F;表示无地址</span><br><span class="line">       . forces          &#x3D; forces,        &#x2F;&#x2F;存放强制的at24c02地址,表示强制支持</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>一般而言,都不会设置.forces成员,这里只是打个比方</p>
<p><strong>8.1接下来继续进入i2c_probe()函数继续分析,如下所示:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i2c_probe(struct i2c_adapter *adapter,struct i2c_client_address_data *address_data,int (*found_proc) (struct i2c_adapter *, int, int))</span><br><span class="line">&#123;</span><br><span class="line">       ... ...</span><br><span class="line">       err &#x3D; i2c_probe_address(adapter,forces[kind][i + 1],kind, found_proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了i2c_probe_address()函数,从名称上来看,显然它就是用来发送起始信号+设备地址,来探测IIC设备地址用的</p>
<p><strong>8.2进入i2c_probe_address()函数:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_probe_address(struct i2c_adapter *adapter, int addr, int kind,int (*found_proc) (struct i2c_adapter *, int, int))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;*判断设备地址是否有效,addr里存放的是设备地址前7位,比如AT24C02&#x3D;0xA0,那么addr&#x3D;0x50*&#x2F;</span><br><span class="line">       if (addr &lt; 0x03 || addr &gt; 0x77) &#123;</span><br><span class="line">              dev_warn(&amp;adapter-&gt;dev, &quot;Invalid probe address 0x%02x\n&quot;,addr);    &#x2F;&#x2F;打印地址无效,并退出</span><br><span class="line">              return -EINVAL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;*查找链表中其它IIC设备的设备地址,若这个设备地址已经被使用,则return*&#x2F;</span><br><span class="line">       if (i2c_check_addr(adapter, addr))</span><br><span class="line">              return 0; </span><br><span class="line"></span><br><span class="line">       if (kind &lt; 0) &#123;</span><br><span class="line">              if (i2c_smbus_xfer(adapter, addr, 0, 0, 0,I2C_SMBUS_QUICK, NULL) &lt; 0)      &#x2F;&#x2F;进入I2C传输函数</span><br><span class="line">　　　　　　　　 return 0;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>8.3 其中i2c_smbus_xfer()传输函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s32 i2c_smbus_xfer(struct i2c_adapter * adapter, u16 addr, unsigned short flags,char read_write, u8 command, int size,union i2c_smbus_data * data)</span><br><span class="line">&#123;</span><br><span class="line">       s32 res;</span><br><span class="line"></span><br><span class="line">       flags &amp;&#x3D; I2C_M_TEN | I2C_CLIENT_PEC;</span><br><span class="line"></span><br><span class="line">       if (adapter-&gt;algo-&gt;smbus_xfer) &#123;   &#x2F;&#x2F;如果adapter适配器有smbus_xfer这个函数</span><br><span class="line">              mutex_lock(&amp;adapter-&gt;bus_lock);                            &#x2F;&#x2F;加互斥锁</span><br><span class="line">              res &#x3D; adapter-&gt;algo-&gt;smbus_xfer(adapter,addr,flags,read_write,command,size,data);  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&#x2F;&#x2F;调用adapter适配器里的传输函数</span><br><span class="line">              mutex_unlock(&amp;adapter-&gt;bus_lock);                  &#x2F;&#x2F;解互斥锁</span><br><span class="line">       &#125; else                          &#x2F;&#x2F;否则使用默认函数传输设备地址</span><br><span class="line">              res &#x3D; i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,command,size,data);</span><br><span class="line">       return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>看了上面代码后,显然我们的s3c2410-i2c适配器没有algo-&gt;smbus_xfer函数,而是使用i2c_smbus_xfer_emulated()函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194624247-1622232895.png" alt="img"></p>
<p><strong>PS:通常适配器都是不支持的,使用默认的i2c_smbus_xfer_emulated()函数</strong></p>
<p><strong>8.4 接下来看i2c_smbus_xfer_emulated()函数如何传输的:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,unsigned short flags,char read_write, u8 command, int size, union i2c_smbus_data * data)</span><br><span class="line">&#123;</span><br><span class="line">       unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];              &#x2F;&#x2F;属于 msg[0]的buf成员</span><br><span class="line">       unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];              &#x2F;&#x2F;属于 msg[1]的buf成员</span><br><span class="line">       int num &#x3D; read_write &#x3D;&#x3D; I2C_SMBUS_READ?2:1;              &#x2F;&#x2F;如果为读命令,就等于2,表示要执行两次数据传输</span><br><span class="line">       struct i2c_msg msg[2] &#x3D; &#123; &#123; addr, flags, 1, msgbuf0 &#125;,</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　&#123; addr, flags | I2C_M_RD, 0, msgbuf1 &#125;&#125;;           &#x2F;&#x2F;定义两个i2c_msg结构体,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       msgbuf0[0] &#x3D; command;             &#x2F;&#x2F;IIC设备地址最低位为读写命令</span><br><span class="line">       ... ...</span><br><span class="line">if (i2c_transfer(adapter, msg, num) &lt; 0)</span><br><span class="line">              return -1;</span><br><span class="line"></span><br><span class="line">              &#x2F;*设置i2c_msg结构体成员*&#x2F;</span><br><span class="line">              if (read_write &#x3D;&#x3D; I2C_SMBUS_READ)</span><br><span class="line">              switch(size) &#123;</span><br><span class="line">              ... ...</span><br><span class="line">              case I2C_SMBUS_BYTE_DATA:              &#x2F;&#x2F;如果是读字节</span><br><span class="line">              if (read_write &#x3D;&#x3D; I2C_SMBUS_READ)</span><br><span class="line">                     msg[1].len &#x3D; 1;</span><br><span class="line">              else &#123;</span><br><span class="line">                     msg[0].len &#x3D; 2;</span><br><span class="line">                     msgbuf0[1] &#x3D; data-&gt;byte;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">              ... ...</span><br><span class="line">              &#125;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       if (i2c_transfer(adapter, msg, num) &lt; 0)             &#x2F;&#x2F;将 i2c_msg结构体的内容发送给I2C设备</span><br><span class="line">              return -1;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_msg结构体的结构,如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">       __u16 addr;    　　　　　　&#x2F;&#x2F;I2C从机的设备地址</span><br><span class="line">       __u16 flags;     　　    &#x2F;&#x2F;当flags&#x3D;0表示写, flags&#x3D; I2C_M_RD表示读</span><br><span class="line">       __u16 len;              &#x2F;&#x2F;传输的数据长度,等于buf数组里的字节数</span><br><span class="line">       __u8 *buf;              &#x2F;&#x2F;存放数据的数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中之所以读操作需要两个i2c_msg,写操作需要一个i2c_msg,是因为读IIC设备是两个流程</p>
<p>在上一节IIC接口下的24C02 驱动分析:<a href="http://www.cnblogs.com/lifexy/p/7793686.html" target="_blank" rel="noopener"> http://www.cnblogs.com/lifexy/p/7793686.html</a>里就已经分析到了,</p>
<p>只要发送一个S起始信号则就是一个i2c_msg,如下两个读写操作图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194638622-994179422.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194645528-2046926273.png" alt="img"></p>
<p>而在i2c_transfer()函数中,最终又是调用了之前分析的i2c_adapter-&gt;algo-&gt;master_xfer()发送函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194708669-885477807.png" alt="img"></p>
<p>其中i2c_transfer()的参数*adap表示通过哪个适配器传输出去,msgs表示I2C消息,num表示msgs的数目</p>
<p>内核每发送一个Msg都会先发出S开始信号和设备地址.直到所有Msg传输完毕，最后发出P停止信号。</p>
<p>当i2c_transfer()返回值为正数,表示已经传输正数个数据,当返回负数,说明I2C传输出错</p>
<p><strong>8.5 所以在i2c_driver -&gt;attach_adapter(adapter)函数里主要执行以下几步:</strong></p>
<p><strong>1)</strong> 调用 i2c_probe(adap, i2c_client_address_data<strong>设备地址结构体</strong>, 回调函数);</p>
<p><strong>2)</strong> 将要发的设备地址结构体打包成i2c_msg,</p>
<p><strong>3)</strong> 然后执行i2c_transfer()来调用i2c_adapter-&gt;algo-&gt;master_xfer()将i2c_msg发出去</p>
<p><strong>4)</strong>若收到ACK回应,便进入回调函数,注册i2c_client从设备,使该设备与适配器联系在一起</p>
<p><strong>所以适配器和iic设备驱动最终注册框架图如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194722247-1723647250.png" alt="img"></p>
<p><strong>9.接下来便来分析回调函数如何注册i2c_client从设备的</strong></p>
<p>先来看看i2c_client结构体:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client &#123;  </span><br><span class="line"></span><br><span class="line"> unsigned short flags；&#x2F;&#x2F;标志    </span><br><span class="line"></span><br><span class="line"> unsigned short addr; &#x2F;&#x2F;该i2c从设备的设备地址,存放地址高7位  </span><br><span class="line"></span><br><span class="line"> char name[I2C_NAME_SIZE];   &#x2F;&#x2F;设备名字</span><br><span class="line"></span><br><span class="line"> struct i2c_adapter *adapter;&#x2F;&#x2F;依附的i2c_adapter,表示该IIC设备支持哪个适配器  </span><br><span class="line"></span><br><span class="line"> struct i2c_driver *driver;&#x2F;&#x2F;依附的i2c_driver ,表示该IIC从设备的驱动是哪个</span><br><span class="line"></span><br><span class="line"> struct device dev;&#x2F;&#x2F;设备结构体    </span><br><span class="line"></span><br><span class="line"> int irq;&#x2F;&#x2F;设备所使用的结构体    </span><br><span class="line"></span><br><span class="line"> struct list_head detected;&#x2F;&#x2F;链表头  </span><br><span class="line"></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>还是以driver/i2c/chips/eeprom.c为例,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194741044-298465589.png" alt="img"></p>
<p><strong>9.1这里的回调函数是eeprom_detect()函数,代码如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int eeprom_detect(struct i2c_adapter *adapter, int address, int kind)</span><br><span class="line">&#123;</span><br><span class="line">struct i2c_client *new_client;        &#x2F;&#x2F;定义一个i2c_client结构体局部变量</span><br><span class="line"></span><br><span class="line">new_client &#x3D;kzalloc(sizeof(struct i2c_client), GFP_KERNEL);      &#x2F;&#x2F;分配i2c_client结构体为全局变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*设置i2c_client结构体*&#x2F;</span><br><span class="line">new_client-&gt;addr &#x3D; address;               &#x2F;&#x2F;设置设备地址</span><br><span class="line">new_client-&gt;adapter &#x3D; adapter;          &#x2F;&#x2F;设置依附的i2c_adapter</span><br><span class="line">new_client-&gt;driver &#x3D; &amp;eeprom_driver;  &#x2F;&#x2F;设置依附的i2c_driver</span><br><span class="line">new_client-&gt;flags &#x3D; 0;                         &#x2F;&#x2F;设置标志位为初始值</span><br><span class="line">strlcpy(new_client-&gt;name, &quot;eeprom&quot;, I2C_NAME_SIZE);     &#x2F;&#x2F;设置名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*注册i2c_client*&#x2F;</span><br><span class="line"> if ((err &#x3D; i2c_attach_client(new_client)))</span><br><span class="line">        goto exit_kfree;    &#x2F;&#x2F;注册失败,便释放i2c_client这个全局变量</span><br><span class="line"> ... ...</span><br><span class="line">exit_kfree:</span><br><span class="line">       kfree(new_client);</span><br><span class="line">exit:</span><br><span class="line">       return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当注册了i2c_client从设备后,便可以使用i2c_transfer()来实现与设备传输数据了</p>
<p><strong>10.接下来,我们便参考driver/i2c/chips/eeprom.c驱动,来写出24C02驱动以及测试程序</strong></p>
<p><strong>驱动代码步骤如下:</strong></p>
<p><strong>1.</strong>定义file_operations结构体 ,设置字符设备的读写函数(实现对24C02的读写操作)<br>//构造i2c_msg结构体, 使用i2c_transfer()来实现与设备传输数据</p>
<p><strong>2.</strong>定义i2c_client_address_data结构体,里面保存24C02的设备地址<br><strong>3.</strong> 定义一个i2c_driver驱动结构体<br>    <strong>3.1</strong> 设置i2c_driver-&gt; attach_adapter<br>　　　　 // 里面直接调用 i2c_probe(adap, i2c_client_address_data结构体, 回调函数);</p>
<p>　  <strong>3.2</strong> 设置i2c_driver-&gt; detach_client<br>　      //里面卸载i2c_client, 字符设备</p>
<p><strong>4.</strong>写回调函数,里面注册i2c_client,字符设备( 字符设备用来实现读写24C02里的数据)<br>   <strong>4.1</strong> 分配并设置i2c_client</p>
<p>   <strong>4.2</strong> 使用i2c_attach_client()将i2c_client与适配器进行连接</p>
<p>  <strong>4.3</strong> 注册字符设备</p>
<p><strong>5.</strong> 写init入口函数,exit出口函数<br>init: 使用i2c_add_driver()注册i2c_driver<br>exit: 使用i2c_del_driver ()卸载i2c_driver</p>
<p><strong>具体驱动代码如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *  I2C-24C02</span><br><span class="line"> *&#x2F;</span><br><span class="line">#include &lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;jiffies.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;mutex.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"></span><br><span class="line">static struct i2c_client *at24c02_client;         &#x2F;&#x2F;从设备结构体</span><br><span class="line">static struct class *at24c02_class;                &#x2F;&#x2F;类结构体</span><br><span class="line">static unsigned int at24c02_major;                 </span><br><span class="line"></span><br><span class="line"> &#x2F;*1.定义file_operations结构体 ,</span><br><span class="line">  *  设置字符设备的读写函数(实现对24C02的读写操作)</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t at24c02_read(struct file *file, char __user *buf, size_t size, loff_t * offset)</span><br><span class="line">&#123;</span><br><span class="line">       struct i2c_msg msg[2];</span><br><span class="line">       u8 addr;</span><br><span class="line">       u8 data;</span><br><span class="line">       int ret;</span><br><span class="line">       </span><br><span class="line">        if(size!&#x3D;1)</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">       copy_from_user(&amp;addr,buf,1);                       &#x2F;&#x2F;获取读地址</span><br><span class="line"></span><br><span class="line">        msg[0].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[0].flags&#x3D;0;                                            &#x2F;&#x2F;写标志</span><br><span class="line">        msg[0].len  &#x3D;1;</span><br><span class="line">        msg[0].buf  &#x3D;&amp;addr;                                     &#x2F;&#x2F;写入要读的地址</span><br><span class="line"></span><br><span class="line">        msg[1].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[1].flags&#x3D;I2C_M_RD;                               &#x2F;&#x2F;读标志</span><br><span class="line">        msg[1].len  &#x3D;1;</span><br><span class="line">        msg[1].buf  &#x3D;&amp;data;                                     &#x2F;&#x2F;读出数据 </span><br><span class="line"></span><br><span class="line">        ret&#x3D;i2c_transfer(at24c02_client-&gt;adapter, msg, 2);     </span><br><span class="line">        if(ret&#x3D;&#x3D;2)      &#x2F;&#x2F;表示2个msg传输成功</span><br><span class="line">        &#123;</span><br><span class="line">             copy_to_user(buf,&amp;data,1);                       &#x2F;&#x2F;上传数据       </span><br><span class="line">             return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t at24c02_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">       struct i2c_msg msg[1];</span><br><span class="line">       u8 val[2];      </span><br><span class="line">       int ret;</span><br><span class="line">       </span><br><span class="line">        if(size!&#x3D;2)         &#x2F;&#x2F;地址   数据</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">        copy_from_user(val,buf,2);                       &#x2F;&#x2F;获取 地址   数据</span><br><span class="line">        msg[0].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[0].flags&#x3D;0;                                       &#x2F;&#x2F;写标志</span><br><span class="line">        msg[0].len  &#x3D;2;</span><br><span class="line">        msg[0].buf  &#x3D;val;                                     &#x2F;&#x2F;写入要写的地址   数据</span><br><span class="line"></span><br><span class="line">        ret&#x3D;i2c_transfer(at24c02_client-&gt;adapter, msg, 1);     </span><br><span class="line">        if(ret&#x3D;&#x3D;1)      &#x2F;&#x2F;表示1个msg传输成功</span><br><span class="line">        &#123;           </span><br><span class="line">             return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct  file_operations at24c02_fops&#x3D;&#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .read  &#x3D; at24c02_read,</span><br><span class="line">    .write &#x3D; at24c02_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*2.定义i2c_client_address_data结构体,保存24C02的设备地址*&#x2F;</span><br><span class="line">static unsigned short ignore[] &#x3D; &#123; I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short normal_addr[] &#x3D; &#123;0X50,  I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short   force_addr[] &#x3D; &#123;ANY_I2C_BUS, 0x60, I2C_CLIENT_END&#125;;</span><br><span class="line">static unsigned short   * forces[] &#x3D;     &#123;force_addr, NULL&#125;;    </span><br><span class="line">static struct i2c_client_address_data   at24c02_addr&#x3D;&#123;</span><br><span class="line">            .normal_i2c&#x3D;normal_addr,</span><br><span class="line">            .probe&#x3D;ignore,</span><br><span class="line">            .ignore&#x3D;ignore,</span><br><span class="line">           &#x2F;&#x2F;  .forces&#x3D;forces,                  &#x2F;&#x2F; 强制地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*3. 定义一个i2c_driver驱动结构体*&#x2F;</span><br><span class="line">static int   at24c02_attach_adapter(struct i2c_adapter *adapter);</span><br><span class="line">static int   at24c02_detach_client(struct i2c_client *client);</span><br><span class="line">static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind);</span><br><span class="line"></span><br><span class="line">&#x2F;* This is the driver that will be inserted *&#x2F;</span><br><span class="line">static struct i2c_driver at24c02_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name    &#x3D; &quot;at24c02&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    .attach_adapter    &#x3D; at24c02_attach_adapter,       &#x2F;&#x2F;绑定回调函数</span><br><span class="line">    .detach_client    &#x3D; at24c02_detach_client,                &#x2F;&#x2F;解绑回调函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*3.1 设置i2c_driver-&gt; attach_adapter*&#x2F;</span><br><span class="line">static int   at24c02_attach_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">        return i2c_probe(adapter,&amp;at24c02_addr, at24c02_detect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*3.2 设置i2c_driver-&gt; detach_client*&#x2F;</span><br><span class="line">static int   at24c02_detach_client(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;at24c02_detach_client\n&quot;);</span><br><span class="line"></span><br><span class="line">    i2c_detach_client(at24c02_client) ;   </span><br><span class="line">    kfree(at24c02_client);   </span><br><span class="line">    class_device_destroy(at24c02_class,MKDEV(at24c02_major, 0));</span><br><span class="line">    class_destroy(at24c02_class);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*4.写回调函数,里面注册i2c_client,字符设备*&#x2F; </span><br><span class="line">static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind)</span><br><span class="line">&#123;</span><br><span class="line">   printk(&quot;at24c02_detect\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 4.1 分配并设置i2c_client *&#x2F;</span><br><span class="line">    at24c02_client&#x3D; kzalloc(sizeof(struct i2c_client), GFP_KERNEL);</span><br><span class="line">   </span><br><span class="line">    at24c02_client-&gt;addr &#x3D; addr;</span><br><span class="line">    at24c02_client-&gt;adapter &#x3D; adap;</span><br><span class="line">    at24c02_client-&gt;driver &#x3D; &amp;at24c02_driver;</span><br><span class="line">    at24c02_client-&gt;flags &#x3D; 0;</span><br><span class="line">    strlcpy(at24c02_client-&gt;name, &quot;at24c02&quot;, I2C_NAME_SIZE);</span><br><span class="line"></span><br><span class="line">   &#x2F;*4.2 使用i2c_attach_client()将i2c_client与适配器进行连接*&#x2F;</span><br><span class="line">    i2c_attach_client(at24c02_client) ;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*4.3 注册字符设备*&#x2F;</span><br><span class="line">    at24c02_major&#x3D; register_chrdev(0, &quot;at24c02&quot;, &amp;at24c02_fops);  </span><br><span class="line">    at24c02_class&#x3D;class_create(THIS_MODULE, &quot;at24c02&quot;);   </span><br><span class="line">    class_device_create(at24c02_class,0, MKDEV(at24c02_major, 0),0,&quot;at24c02&quot;);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*5. 写init入口函数,exit出口函数*&#x2F;</span><br><span class="line">static int at24c02_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_add_driver(&amp;at24c02_driver);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void at24c02_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;at24c02_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(at24c02_init);</span><br><span class="line">module_exit(at24c02_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>11.测试运行</strong></p>
<p>如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194801809-125890547.png" alt="img"></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IIC%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%8424C02%20%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IIC%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%8424C02%20%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】IIC接口下的24C02 驱动分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 16:59:44 / Modified: 17:06:01" itemprop="dateCreated datePublished" datetime="2021-01-15T16:59:44+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://www.cnblogs.com/lifexy/p/7793686.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7793686.html】</a></p>
<p>本节来学习IIC接口下的24C02 驱动分析,本节学完后,再来学习Linux下如何使用IIC操作24C02</p>
<hr>
<p><strong>1.I2C通信介绍</strong></p>
<p>它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据,是一个多主机的半双工通信方式</p>
<p>每个挂接在总线上的器件都有个唯一的地址</p>
<p>位速在标准模式下可达 100kbit/s,在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。</p>
<p><strong>2. I2C总线系统结构,如下所示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160056575-1544374794.png" alt="img"></p>
<p>其中SCL时钟线的频率由主机提供,且从机不能主动来引起数据传输,必须等待主机先发信号才行</p>
<p>两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</p>
<p><strong>3.I2C时序介绍</strong></p>
<p><strong>1)空闲状态</strong></p>
<p>当总线上的SDA和SCL两条信号线同时处于高电平,便是空闲状态,如上面的硬件图所示,当我们不传输数据时, SDA和SCL被上拉电阻拉高,即进入空闲状态</p>
<p><strong>2)**</strong>起始信号**</p>
<p>当SCL为高期间，SDA由高到低的跳变；便是总线的启动信号,只能由主机发起,且在空闲状态下才能启动该信号,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160104794-1546406489.png" alt="img"></p>
<p><strong>3)**</strong>停止信号**</p>
<p>当SCL为高期间，SDA由低到高的跳变；便是总线的停止信号,表示数据已传输完成,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160108247-2041083640.png" alt="img"></p>
<p><strong>4)**</strong>传输数据格式**</p>
<p>当发了起始信号后,就开始传输数据,传输的数据格式如下图所示:</p>
<p>当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的(若SDA不稳定就会变成起始/停止信号)</p>
<p>当SCL为低电平时,便是SDA的电平变化状态</p>
<p>若主从机在传输数据期间,需要完成其它功能(例如一个中断),可以主动拉低SCL,使I2C进入等待状态,直到处理结束再释放SCL,数据传输会继续</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160112700-1908810180.png" alt="img"></p>
<p><strong>5)**</strong>应答信号ACK**</p>
<p>I2C总线上的数据都是以8位数据(字节)进行的,当发送了8个数据后,发送方会在第9个时钟脉冲期间释放SDA数据,当接收方接收该字节成功,便会输出一个ACK应答信号,当SDA为高电平,表示为非应答信号NACK,当SDA为低电平,表示为有效应答信号ACK</p>
<p><strong>PS:</strong>当<strong>主机为接收方</strong>时,收到最后一个字节后,主机可以不发送ACK,直接发送停止信号来结束传输。</p>
<p>当<strong>从机为接收方</strong>时,没有发送ACK,则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送,主机可以发送停止信号再次发送起始信号启动新的传输</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160125278-134312409.png" alt="img"></p>
<p><strong>6)**</strong>完整的数据传输**</p>
<p>如下图所示, 发送起始信号后,便发送一个8位的设备地址,其中第8位是对设备的读写标志,后面紧跟着的就是数据了,直到发送停止信号终止</p>
<p><strong>PS:</strong>当我们第一次是读操作,然后想换成写操作时,可以再次发送一个起始信号,然后发送读的设备地址,不需要停止信号便能实现不同的地址转换</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160141888-898822484.png" alt="img"></p>
<p><strong>4. AT24C02**</strong>介绍**</p>
<p>AT24C02是通过I2C实现通讯的,是一个存储芯片,能够存储2Kb(256KB)数据</p>
<p><strong>4.1**</strong>它的的硬件图如下:**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160159731-872248298.png" alt="img"></p>
<p>其中A2~A0,是这个24C02设备的硬件地址,接GND表示硬件地址都为0</p>
<p><strong>4.2**</strong>其中AT24C02<strong>**的数据格式如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160208825-938746051.png" alt="img"></p>
<p><strong>4.3**</strong>打开AT24C02<strong><strong>数据手册,</strong></strong>它的设备地址如下图所示:**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160235434-519181103.png" alt="img"></p>
<p>其中A2<del>A1表示硬件地址,P2</del>P0表示page页地址</p>
<p>bit[0]地址:表示读/写状态,1:读,0:写 (所有I2C器件都是这样,最低位表示方向位)</p>
<p><strong>4.3.1 为什么需要page**</strong>页地址？**</p>
<p>因为I2C的数据位是8位,而AT24CXX的读写地址值最大可以为2048(2^11),超过了I2C的数据位</p>
<p>而page页地址就是用来解决这个问题的</p>
<p><strong>比如AT24C16:</strong></p>
<p>当发送:0XA2(设备地址P[2:0]=0x01) ,0x00(读地址)时:</p>
<p>表示要读的真正地址=0x01(页地址)*256+0(读地址)=0x100,转化为二进制= 1 0000 0000</p>
<p>当发送:0XA0(设备地址), 0x00(读地址)时:</p>
<p>表示要读的真正地址=0x00*256+0xFF=0xFF，转化为二进制= 0 1111 1111</p>
<p><strong>4.3.2 如上图所示,对于AT240C02来讲:</strong></p>
<ul>
<li>芯片的容量小于等于2^8(256)字节,那么读写地址就用8bit来表示,所以设备地址里没有P2~P0</li>
<li>读操作时,发送的设备地址等于0XA1</li>
<li>写操作时,发送的设备地址等于0XA0</li>
</ul>
<p><strong>5. AT24C02**</strong>时序图介绍**</p>
<p><strong>5.1**</strong>写时序介绍**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160251747-176931382.png" alt="img"></p>
<p>当随机写一个字节时,只需要先发送一个起始信号,然后跟上0XA0设备地址,以及要写的起始地址值,后面便是要写入地址的data,如果需要连续写数据,只需要连续写入data,地址会自动加1,直到发送停止信号结束</p>
<p><strong>5.2**</strong>读时序介绍**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160301450-1538334264.png" alt="img"></p>
<p>当随机读一个字节时,先发送第一个起始信号,然后写入0XA0设备地址和要读的地址值,</p>
<p>接着发送第二个起始信号,然后写入0XA1设备地址,接着就是要读的data,如果需要连续读数据,只需要连续读出data,地址会自动加1,直到发送停止信号结束</p>
<p><strong>接下来,下节开始学习:</strong></p>
<p>Linux下如何利用linux下I2C驱动体系结构来操作24C02  <a href="http://www.cnblogs.com/lifexy/p/7816324.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7816324.html</a></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】I2C驱动框架分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 16:49:57 / Modified: 16:53:38" itemprop="dateCreated datePublished" datetime="2021-01-15T16:49:57+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3802629.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3802629.html】</a></p>
<h1 id="【Linux高级驱动】I2C驱动框架分析"><a href="#【Linux高级驱动】I2C驱动框架分析" class="headerlink" title="【Linux高级驱动】I2C驱动框架分析"></a><a href="https://www.cnblogs.com/lcw/p/3802629.html" target="_blank" rel="noopener">【Linux高级驱动】I2C驱动框架分析</a></h1><h2 id="1-i2c-dev-c-i2c设备驱动组件层"><a href="#1-i2c-dev-c-i2c设备驱动组件层" class="headerlink" title="1.i2c-dev.c(i2c设备驱动组件层)"></a>1.i2c-dev.c(i2c设备驱动组件层)</h2><p>  <strong>功能</strong>:1)给用户提供接口</p>
<p>i2c_dev_init //入口函数<br> /<em>申请主设备号</em>/</p>
<p>register_chrdev(I2C_MAJOR(89), “i2c”, &amp;i2cdev_fops);<br> /<em>创建一个设备类</em>/<br> i2c_dev_class = class_create(THIS_MODULE, “i2c-dev”);<br> /<em>注册一个i2c驱动</em>/<br> i2c_add_driver(&amp;i2cdev_driver);<br> i2c_register_driver(THIS_MODULE, driver);<br>  /<em>指定总线类型</em>/<br>  driver-&gt;driver.bus = &i2c_bus_type;<br>  /<em>驱动注册<br>  *1.将i2c驱动加入i2c总线的驱动链表<br>  *2.搜索设备链表,实现匹配,根据i2c总线的匹配原理:必须要求i2c驱动结构体中实现id_table<br>  \</em> 但是,i2c驱动结构体中并没有实现id_table,所以永远都匹配失败<br>  */<br>  driver_register(&amp;driver-&gt;driver);</p>
<p>  /<em>搜索适配器链表,每搜索一个适配器,都会调用__process_new_driver函数<br>  <em>在此函数中,又会调用i2c驱动中的,attach_adapter函数<br>  */<br>  bus_for_each_dev(&amp;i2c_bus_type, NULL, driver, __process_new_driver);<br>  __process_new_driver //此函数可能会被调用多次<br>  i2c_do_add_adapter(data, to_i2c_adapter(dev));<br>   *</em>if** (driver-&gt;attach_adapter) {<br>   /</em> We ignore the return code; if it fails, too bad */<br>   driver-&gt;attach_adapter(adap);  //i2cdev_attach_adapter<br>   }</p>
<p><strong>static</strong> <strong>const</strong> <strong>struct</strong> file_operations i2cdev_fops = {<br> .owner = THIS_MODULE,<br> .llseek = no_llseek,<br> .read = i2cdev_read,<br> .write = i2cdev_write,<br> .unlocked_ioctl = i2cdev_ioctl,<br> .open = i2cdev_open,<br> .release = i2cdev_release,<br>};<br><strong>static</strong> <strong>struct</strong> i2c_driver i2cdev_driver = {<br> .driver = {<br> .name = “dev_driver”,<br> },<br> .attach_adapter = i2cdev_attach_adapter,<br> .detach_adapter = i2cdev_detach_adapter,<br>};</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-i2c-core-c-i2c核心层组件"><a href="#2-i2c-core-c-i2c核心层组件" class="headerlink" title="2.i2c-core.c(i2c核心层组件)"></a>2.i2c-core.c(i2c核心层组件)</h2><p>  <strong>功能</strong>:1)注册一条i2c总线<br>     2)提供基本的接口函数,用来建立上层与下层的连接</p>
<p>i2c_init //入口函数<br> /<em>注册I2C总线</em>/<br> bus_register(&amp;i2c_bus_type);</p>
<p><strong>struct</strong> bus_type i2c_bus_type = { //实际的物理总线,I2C总线<br> .name = “i2c”,<br> .match = i2c_device_match, //匹配函数<br> .probe = i2c_device_probe,<br> .remove = i2c_device_remove,<br> .shutdown = i2c_device_shutdown,<br> .pm = &amp;i2c_device_pm_ops,<br>};<br><strong>static</strong> <strong>int</strong> i2c_device_match(<strong>struct</strong> device <em>dev, <strong>struct</strong> device_driver <em>drv)<br>{<br> *</em>struct** i2c_client <em>client = i2c_verify_client(dev);<br> *</em>struct** i2c_driver <em>driver;<br> *</em>if** (!client)<br> <strong>return</strong> 0;<br> driver = to_i2c_driver(drv);<br> /</em> match on an id table if there is one <em>/<br> *</em>if** (driver-&gt;id_table)<br> <strong>return</strong> i2c_match_id(driver-&gt;id_table, client) != NULL;<br>  <strong>while</strong> (id-&gt;name[0]) {<br>   <strong>if</strong> (strcmp(client-&gt;name, id-&gt;name) == 0)<br>   <strong>return</strong> id;<br>   id++;<br>  }<br> <strong>return</strong> 0;<br>}</p>
<h3 id="涉及的重要结构体"><a href="#涉及的重要结构体" class="headerlink" title="涉及的重要结构体:"></a>涉及的重要结构体:</h3><p><strong>struct</strong> i2c_client {   //表示一个i2c设备<br> <strong>unsigned</strong> <strong>short</strong> flags;  /* div., see below <em>/<br> <strong>unsigned</strong> <strong>short</strong> addr;  /*器件地址</em>/<br> <strong>char</strong> name[I2C_NAME_SIZE]; /<em>名字</em>/<br> <strong>struct</strong> i2c_adapter <em>adapter; /*所属适配器,所属控制器</em>/<br> <strong>struct</strong> i2c_driver <em>driver; /*设备驱动</em>/<br> <strong>struct</strong> device dev;  /* the device structure <em>/<br> <strong>int</strong> irq;   /</em> irq issued by device <em>/<br> <strong>struct</strong> list_head detected;<br>};<br><strong>struct</strong> i2c_driver {   //用来表示i2c驱动<br> <strong>unsigned</strong> <strong>int</strong> <strong>class</strong>;<br> /</em> Notifies the driver that a new bus has appeared or is about to be<br> * removed. You should avoid using this if you can, it will probably<br> * be removed in a near future.<br> <em>/<br> <strong>int</strong> (<em>attach_adapter)(*</em>struct** i2c_adapter <em>);<br> *</em>int** (<em>detach_adapter)(*</em>struct** i2c_adapter <em>);<br> /</em>probe函数:初始化工作,设备检测,</em>/<br> <strong>int</strong> (<em>probe)(<strong>struct</strong> i2c_client <em>, *</em>const** <strong>struct</strong> i2c_device_id <em>);<br> *</em>int** (<em>remove)(*</em>struct** i2c_client <em>);<br> *</em>struct** device_driver driver;  //设备驱动<br> <strong>const</strong> <strong>struct</strong> i2c_device_id <em>id_table; //指定此驱动能为哪些设备服务<br> …<br> …<br>};<br>*</em>struct** i2c_adapter {  //表示一个i2c适配器/i2c控制器<br> <strong>const</strong> <strong>struct</strong> i2c_algorithm *algo; /</em> the algorithm to access the bus <em>/<br> /*操作方法</em>/<br> <strong>int</strong> (<em>master_xfer)(<strong>struct</strong> i2c_adapter <em>adap, *</em>struct** i2c_msg <em>msgs,*</em>int** num);<br> <strong>int</strong> nr;   /*适配器的号码</em>/<br> …<br> …<br>};<br><strong>struct</strong> i2c_msg {   //表示一个i2c数据包<br> __u16 addr;   /<em>设备地址</em>/<br> __u16 flags;   /<em>表示:1-表示读包 0-表示写包</em>/<br> __u16 len;   /<em>数据包的长度</em>/<br> __u8 <em>buf;   /*真正的数据</em>/<br> …<br> …<br>};</p>
<h3 id="涉及的重要函数接口"><a href="#涉及的重要函数接口" class="headerlink" title="涉及的重要函数接口:"></a>涉及的重要函数接口:</h3><p>/<em>注册一个i2c控制器</em>/<br><strong>int</strong> i2c_add_adapter(<strong>struct</strong> i2c_adapter <em>adapter)<br><strong>int</strong> i2c_del_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>/</em>注册i2c驱动</em>/<br><strong>int</strong> i2c_add_driver(<strong>struct</strong> i2c_driver <em>driver)<br><strong>int</strong> i2c_add_numbered_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>*</em>int** i2c_del_numbered_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>*</em>extern** <strong>int</strong> i2c_del_driver(<strong>struct</strong> i2c_driver <em>driver);<br>/</em>接收i2c数据包</em>/<br><strong>int</strong> i2c_master_recv(<strong>struct</strong> i2c_client <em>client, <strong>char</strong> <em>buf, *</em>int** count)<br>/*发送i2c数据包</em>/<br><strong>int</strong> i2c_master_send(<strong>struct</strong> i2c_client <em>client, <strong>const</strong> <strong>char</strong> <em>buf, *</em>int** count)<br>/*提交i2c数据包到总线驱动层</em>/<br><strong>int</strong> i2c_transfer(<strong>struct</strong> i2c_adapter <em>adap, *</em>struct** i2c_msg <em>msgs, *</em>int** num)</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-busses目录-i2c总线驱动-i2c控制器驱动-i2c适配器驱动"><a href="#3-busses目录-i2c总线驱动-i2c控制器驱动-i2c适配器驱动" class="headerlink" title="3.busses目录:i2c总线驱动/i2c控制器驱动/i2c适配器驱动"></a>3.busses目录:i2c总线驱动/i2c控制器驱动/i2c适配器驱动</h2><p>  i2c-s3c2410.c</p>
<p>  <strong>功能</strong>:1)实现对i2c控制器的初始化<br>     2)实现操作方法(实现i2c协议,完成数据的发送)</p>
<h2 id="如何用通用接口驱动来操作i2c设备"><a href="#如何用通用接口驱动来操作i2c设备" class="headerlink" title="如何用通用接口驱动来操作i2c设备"></a>如何用通用接口驱动来操作i2c设备</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h1 id="app-open-“-dev-i2c-0”-O-RDWR"><a href="#app-open-“-dev-i2c-0”-O-RDWR" class="headerlink" title="app: open(“/dev/i2c-0”, O_RDWR);"></a>app: open(“/dev/i2c-0”, O_RDWR);</h1><p>sys: sys_open<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .open = i2cdev_open,<br>   /<em>构建一个i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client;<br>   <strong>struct</strong> i2c_adapter <em>adap;<br>   /</em>获取适配器</em>/<br>   adap = i2c_get_adapter(i2c_dev-&gt;adap-&gt;nr);<br>   client = kzalloc(<strong>sizeof</strong>(*client), GFP_KERNEL);<br>   client-&gt;driver = &i2cdev_driver; //指定i2c设备驱动<br>   client-&gt;adapter = adap;   //指定适配器<br>   file-&gt;private_data = client;</p>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><h1 id="app-ioctl-fd-I2C-SLAVE-0x48"><a href="#app-ioctl-fd-I2C-SLAVE-0x48" class="headerlink" title="app: ioctl(fd, I2C_SLAVE, 0x48)"></a>app: ioctl(fd, I2C_SLAVE, 0x48)</h1><p>sys: sys_ioctl<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .unlocked_ioctl = i2cdev_ioctl,<br>   /<em>获取i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client = file-&gt;private_data;<br>   *</em>switch** (cmd) {<br>   <strong>case</strong> I2C_SLAVE:  I2C_M_TEN:是否为10位寻址的设备<br>    <strong>if</strong> ((arg &gt; 0x3ff) ||(((client-&gt;flags &amp; I2C_M_TEN) == 0) &amp;&amp; arg &gt; 0x7f))<br>    <strong>return</strong> -EINVAL;<br>    client-&gt;addr = arg; //0x48<br>   }</p>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h1 id="app-write-fd-wbuf-1"><a href="#app-write-fd-wbuf-1" class="headerlink" title="app: write(fd, wbuf, 1)"></a>app: write(fd, wbuf, 1)</h1><p>sys: sys_write<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .write = i2cdev_write,<br>   /<em>获取i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client = file-&gt;private_data;<br>   *</em>char** *tmp;<br>   tmp = kmalloc(count, GFP_KERNEL);<br>   copy_from_user(tmp, buf, count)</p>
<p>   /<em>发送数据到核心层</em>/<br>i2c-core.c  i2c_master_send(client, tmp, count);<br>   <strong>struct</strong> i2c_msg msg;  //表示i2c数据包<br>   /<em>填充数据包</em>/<br>   msg.addr = client-&gt;addr;  //0x48<br>   msg.flags = client-&gt;flags &amp; I2C_M_TEN; //写<br>   msg.len = count;   //1<br>   msg.buf = (<strong>char</strong> <em>)buf;   //wbuf 0x0<br>   /*提交数据给总线驱动层</em>/<br>   i2c_transfer(adap, &amp;msg, 1);<br>    <strong>if</strong> (adap-&gt;algo-&gt;master_xfer)<br>i2c_s3c2410.c   adap-&gt;algo-&gt;master_xfer(adap, msgs, num);  //s3c24xx_i2c_xfer<br>     s3c24xx_i2c_xfer</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E4%B8%8BI2C%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E4%B8%8BI2C%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】linux下I2C驱动架构全面分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 16:41:02 / Modified: 16:49:39" itemprop="dateCreated datePublished" datetime="2021-01-15T16:41:02+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3297889.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3297889.html】</a></p>
<h1 id="【驱动】linux下I2C驱动架构全面分析"><a href="#【驱动】linux下I2C驱动架构全面分析" class="headerlink" title="【驱动】linux下I2C驱动架构全面分析"></a><a href="https://www.cnblogs.com/lcw/p/3297889.html" target="_blank" rel="noopener">【驱动】linux下I2C驱动架构全面分析</a></h1><h2 id="I2C-概述"><a href="#I2C-概述" class="headerlink" title="I2C 概述"></a>I2C 概述</h2><p>　　I2C是philips提出的外设总线.</p>
<p>　　I2C只有两条线,一条串行数据线:SDA,一条是时钟线SCL ，使用SCL，SDA这两根信号线就实现了设备之间的数据交互，它方便了工程师的布线。</p>
<p>　　因此，I2C总线被非常广泛地应用在EEPROM，实时钟，小型LCD等设备与CPU的接口中。</p>
<hr>
<h2 id="linux下的驱动思路"><a href="#linux下的驱动思路" class="headerlink" title="linux下的驱动思路"></a>linux下的驱动思路</h2><p>　　在linux系统下编写I2C驱动，目前主要有两种方法，一种是把I2C设备当作一个普通的字符设备来处理，另一种是利用linux下I2C驱动体系结构来完成。下面比较下这两种方法：<br>　　第一种方法：<br>　　　　优点：思路比较直接，不需要花很多时间去了解linux中复杂的I2C子系统的操作方法。<br>　　　　<strong>缺点</strong>：<br>  　　  要求工程师不仅要对I2C设备的操作熟悉，而且要熟悉I2C的适配器(I2C控制器)操作。<br>  　　  要求工程师对I2C的设备器及I2C的设备操作方法都比较熟悉，最重要的是写出的程序可以移植性差。<br>  　　  对内核的资源无法直接使用，因为内核提供的所有I2C设备器以及设备驱动都是基于I2C子系统的格式。</p>
<p>　　第一种方法的优点就是第二种方法的缺点，<br>　　第一种方法的缺点就是第二种方法的优点。</p>
<h2 id="I2C架构概述"><a href="#I2C架构概述" class="headerlink" title="I2C架构概述"></a>I2C架构概述</h2><p>　　Linux的I2C体系结构分为3个组成部分：</p>
<p>　　<strong>I2C核心</strong>：I2C核心提供了I2C总线驱动和设备驱动的注册，注销方法，I2C通信方法(”algorithm”)上层的，与具体适配器无关的代码以及探测设备，检测设备地址的上层代码等。</p>
<p>　　<strong>I2C总线驱动</strong>：I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。</p>
<p>　　<strong>I2C设备驱动</strong>：I2C设备驱动(也称为客户驱动)是对I2C硬件体系结构中设备端的实现，设备一般挂接在受CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。</p>
<h2 id="linux驱动中i2c驱动架构"><a href="#linux驱动中i2c驱动架构" class="headerlink" title="linux驱动中i2c驱动架构"></a><strong>linux驱动中i2c驱动架构</strong></h2><p>　　<strong><img src="https://images0.cnblogs.com/blog/536940/201309/02225054-2c2abb8ed8da431390a03bcbfd6563df.png" alt="img"></strong></p>
<p>　　上图完整的描述了linux i2c驱动架构，虽然I2C硬件体系结构比较简单，但是i2c体系结构在linux中的实现却相当复杂。</p>
<p>　　那么我们<strong>如何编写特定i2c接口器件的驱动程序？就是说上述架构中的那些部分需要我们完成，而哪些是linux内核已经完善的或者是芯片提供商已经提供的？</strong></p>
<hr>
<h2 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h2><p>　　<strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。<strong>覆盖图中的硬件实现层</strong></p>
<p>　　<strong>第二层</strong>：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。<strong>覆盖图中的访问抽象层、i2c核心层</strong></p>
<p>　　<strong>第三层</strong>：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。<strong>覆盖图中的driver驱动层</strong></p>
<p>　　<strong>第四层</strong>：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。<strong>覆盖图中的driver驱动层</strong></p>
<p>　　第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。</p>
<p>　　在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的(与特定硬件相关的代码)已由芯片提供商编写完成，例如三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c</p>
<p>　　第三第四层与特定device相干的就需要驱动工程师来实现了。</p>
<hr>
<h2 id="Linux下I2C体系文件构架"><a href="#Linux下I2C体系文件构架" class="headerlink" title="Linux下I2C体系文件构架"></a>Linux下I2C体系文件构架</h2><p>　　在Linux内核源代码中的driver目录下包含一个i2c目录</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/02230534-eb154ee59ea04c8ca73efd7248b366ac.jpg" alt="img"></p>
<p>　　<strong>i2c-core.c</strong>这个文件实现了I2C核心的功能以及/proc/bus/i2c<em>接口。<br>　  *</em>i2c-dev.c<strong>实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备。通过适配器访设备时的主设备号都为89，次设备号为0-255。I2c-dev.c并没有针对特定的设备而设计，只是提供了通用的read(),write(),和ioctl()等接口，应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器，并控制I2C设备的工作方式。<br>　　**busses</strong>文件夹这个文件中包含了一些I2C总线的驱动，如针对S3C2410，S3C2440，S3C6410等处理器的I2C控制器驱动为i2c-s3c2410.c.<br>　　<strong>algos</strong>文件夹实现了一些I2C总线适配器的algorithm.</p>
<hr>
<h2 id="重要的结构体"><a href="#重要的结构体" class="headerlink" title="重要的结构体"></a><strong>重要的结构体</strong></h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a><strong>i2c_driver</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct i2c_driver &#123;</span><br><span class="line"> 2 unsigned int class;</span><br><span class="line"> 3 int (*attach_adapter)(struct i2c_adapter *);&#x2F;&#x2F;依附i2c_adapter函数指针</span><br><span class="line"> 4 int (*detach_adapter)(struct i2c_adapter *);&#x2F;&#x2F;脱离i2c_adapter函数指针</span><br><span class="line"> 5 int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line"> 6 int (*remove)(struct i2c_client *);</span><br><span class="line"> 7 void (*shutdown)(struct i2c_client *);</span><br><span class="line"> 8 int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br><span class="line"> 9 int (*resume)(struct i2c_client *);</span><br><span class="line">10 void (*alert)(struct i2c_client *, unsigned int data);</span><br><span class="line">11 int (*command)(struct i2c_client *client, unsigned int cmd, void*arg);&#x2F;&#x2F;命令列表</span><br><span class="line">12 struct device_driver driver;</span><br><span class="line">13 const struct i2c_device_id *id_table;&#x2F;&#x2F;该驱动所支持的设备ID表</span><br><span class="line">14 int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">15 const unsigned short *address_list;</span><br><span class="line">16 struct list_head clients;</span><br><span class="line">17 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a><strong>i2c_client</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct i2c_client &#123;</span><br><span class="line"> 2  unsigned short flags；&#x2F;&#x2F;标志  </span><br><span class="line"> 3  unsigned short addr; &#x2F;&#x2F;低7位为芯片地址  </span><br><span class="line"> 4  char name[I2C_NAME_SIZE];&#x2F;&#x2F;设备名称</span><br><span class="line"> 5  struct i2c_adapter *adapter;&#x2F;&#x2F;依附的i2c_adapter</span><br><span class="line"> 6  struct i2c_driver *driver;&#x2F;&#x2F;依附的i2c_driver </span><br><span class="line"> 7  struct device dev;&#x2F;&#x2F;设备结构体  </span><br><span class="line"> 8  int irq;&#x2F;&#x2F;设备所使用的结构体  </span><br><span class="line"> 9  struct list_head detected;&#x2F;&#x2F;链表头</span><br><span class="line">10  &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a><strong>i2c_adapter</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct i2c_adapter &#123;</span><br><span class="line"> 2  struct module *owner;&#x2F;&#x2F;所属模块</span><br><span class="line"> 3  unsigned int id;&#x2F;&#x2F;algorithm的类型，定义于i2c-id.h,</span><br><span class="line"> 4  unsigned int class;    </span><br><span class="line"> 5  const struct i2c_algorithm *algo; &#x2F;&#x2F;总线通信方法结构体指针</span><br><span class="line"> 6  void *algo_data;&#x2F;&#x2F;algorithm数据</span><br><span class="line"> 7  struct rt_mutex bus_lock;&#x2F;&#x2F;控制并发访问的自旋锁</span><br><span class="line"> 8  int timeout;   </span><br><span class="line"> 9  int retries;&#x2F;&#x2F;重试次数</span><br><span class="line">10  struct device dev; &#x2F;&#x2F;适配器设备 </span><br><span class="line">11  int nr;</span><br><span class="line">12  char name[48];&#x2F;&#x2F;适配器名称</span><br><span class="line">13  struct completion dev_released;&#x2F;&#x2F;用于同步</span><br><span class="line">14  struct list_head userspace_clients;&#x2F;&#x2F;client链表头</span><br><span class="line">15 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a><strong>i2c_algorithm</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 struct i2c_algorithm &#123;</span><br><span class="line">2 int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);&#x2F;&#x2F;I2C传输函数指针</span><br><span class="line">3 int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write,u8 command, int size, union </span><br><span class="line">4 i2c_smbus_data *data);&#x2F;&#x2F;smbus传输函数指针</span><br><span class="line">5 u32 (*functionality) (struct i2c_adapter *);&#x2F;&#x2F;返回适配器支持的功能</span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<hr>
<h2 id="各结构体的作用与它们之间的关系"><a href="#各结构体的作用与它们之间的关系" class="headerlink" title="各结构体的作用与它们之间的关系"></a>各结构体的作用与它们之间的关系</h2><h3 id="i2c-adapter与i2c-algorithm"><a href="#i2c-adapter与i2c-algorithm" class="headerlink" title="i2c_adapter与i2c_algorithm"></a><strong>i2c_adapter与i2c_algorithm</strong></h3><p>　　i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>　　i2c_algorithm中的关键函数<strong>master_xfer()</strong>用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。</p>
<p>　　i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 struct i2c_msg &#123;  </span><br><span class="line">2     __u16 addr; &#x2F;* slave address            *&#x2F;  </span><br><span class="line">3     __u16 flags;          </span><br><span class="line">4     __u16 len;      &#x2F;* msg length               *&#x2F;  </span><br><span class="line">5     __u8 *buf;      &#x2F;* pointer to msg data          *&#x2F;  </span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-driver和i2c-client"><a href="#i2c-driver和i2c-client" class="headerlink" title="i2c_driver和i2c_client"></a><strong>i2c_driver和i2c_client</strong></h3><p>　　i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()</p>
<p>　　i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述</p>
<p>　　i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<h3 id="i2c-adapter和i2c-client"><a href="#i2c-adapter和i2c-client" class="headerlink" title="i2c_adapter和i2c_client"></a><strong>i2c_adapter和i2c_client</strong></h3><p>　　i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>　　</p>
<p>　　从i2c驱动架构图中可以看出，linux内核对i2c架构抽象了一个叫<strong>核心层core</strong>的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件事件提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<hr>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>　　先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为<strong>i2c-core.c</strong>，位于内核目录/driver/i2c/i2c-core.c</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 EXPORT_SYMBOL(i2c_add_adapter);  </span><br><span class="line">2 EXPORT_SYMBOL(i2c_del_adapter);  </span><br><span class="line">3 EXPORT_SYMBOL(i2c_del_driver);  </span><br><span class="line">4 EXPORT_SYMBOL(i2c_attach_client);  </span><br><span class="line">5 EXPORT_SYMBOL(i2c_detach_client);  </span><br><span class="line">6   </span><br><span class="line">7 EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　<strong>i2c_transfer()</strong>函数：i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     int ret;  </span><br><span class="line"> 4     if (adap-&gt;algo-&gt;master_xfer) &#123;&#x2F;&#x2F;如果master_xfer函数存在，则调用，否则返回错误  </span><br><span class="line"> 5         ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap,msgs,num);&#x2F;&#x2F;这个函数在硬件相关的代码中给algorithm赋值  </span><br><span class="line"> 6         return ret;  </span><br><span class="line"> 7     &#125; else &#123;  </span><br><span class="line"> 8         return -ENOSYS;  </span><br><span class="line"> 9     &#125;  </span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。</p>
<p>　　相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员在开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 int i2c_attach_client(struct i2c_client *client)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     ...  </span><br><span class="line"> 4     device_register(&amp;client-&gt;dev);  </span><br><span class="line"> 5     device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);  </span><br><span class="line"> 6     ...  </span><br><span class="line"> 7     return 0;  </span><br><span class="line"> 8 &#125;  </span><br><span class="line"> 9 </span><br><span class="line">10 </span><br><span class="line">11 [cpp] view plaincopy</span><br><span class="line">12 int i2c_detach_client(struct i2c_client *client)  </span><br><span class="line">13 &#123;  </span><br><span class="line">14     ...  </span><br><span class="line">15     device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);  </span><br><span class="line">16     device_unregister(&amp;client-&gt;dev);  </span><br><span class="line">17     ...  </span><br><span class="line">18     return res;  </span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　<strong>i2c_add_adapter</strong>()函数和i2c_del_adapter()在i2c-davinci.c中有调用，稍后分析</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> 1 int i2c_add_adapter(struct i2c_adapter *adap)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     ...  </span><br><span class="line"> 4     device_register(&amp;adap-&gt;dev);  </span><br><span class="line"> 5     device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);  </span><br><span class="line"> 6     ...  </span><br><span class="line"> 7     &#x2F;* inform drivers of new adapters *&#x2F;  </span><br><span class="line"> 8     list_for_each(item,&amp;drivers) &#123;  </span><br><span class="line"> 9         driver &#x3D; list_entry(item, struct i2c_driver, list);  </span><br><span class="line">10         if (driver-&gt;attach_adapter)  </span><br><span class="line">11             &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;  </span><br><span class="line">12             driver-&gt;attach_adapter(adap);  </span><br><span class="line">13     &#125;  </span><br><span class="line">14     ...  </span><br><span class="line">15 &#125;  </span><br><span class="line">16 </span><br><span class="line">17 </span><br><span class="line">18 </span><br><span class="line">19 int i2c_del_adapter(struct i2c_adapter *adap)  </span><br><span class="line">20 &#123;  </span><br><span class="line">21     ...  </span><br><span class="line">22     list_for_each(item,&amp;drivers) &#123;  </span><br><span class="line">23         driver &#x3D; list_entry(item, struct i2c_driver, list);  </span><br><span class="line">24         if (driver-&gt;detach_adapter)  </span><br><span class="line">25             if ((res &#x3D; driver-&gt;detach_adapter(adap))) &#123;  </span><br><span class="line">26             &#125;  </span><br><span class="line">27     &#125;  </span><br><span class="line">28     ...  </span><br><span class="line">29     list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;  </span><br><span class="line">30         client &#x3D; list_entry(item, struct i2c_client, list);  </span><br><span class="line">31   </span><br><span class="line">32         if ((res&#x3D;client-&gt;driver-&gt;detach_client(client))) &#123;  </span><br><span class="line">33   </span><br><span class="line">34         &#125;  </span><br><span class="line">35     &#125;  </span><br><span class="line">36     ...  </span><br><span class="line">37     device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);  </span><br><span class="line">38     device_unregister(&amp;adap-&gt;dev);  </span><br><span class="line">39   </span><br><span class="line">40 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 static struct platform_driver davinci_i2c_driver &#x3D; &#123;  </span><br><span class="line"> 2     .probe      &#x3D; davinci_i2c_probe,  </span><br><span class="line"> 3     .remove     &#x3D; davinci_i2c_remove,  </span><br><span class="line"> 4     .driver     &#x3D; &#123;  </span><br><span class="line"> 5         .name   &#x3D; &quot;i2c_davinci&quot;,  </span><br><span class="line"> 6         .owner  &#x3D; THIS_MODULE,  </span><br><span class="line"> 7     &#125;,  </span><br><span class="line"> 8 &#125;;  </span><br><span class="line"> 9   </span><br><span class="line">10 &#x2F;* I2C may be needed to bring up other drivers *&#x2F;  </span><br><span class="line">11 static int __init davinci_i2c_init_driver(void)  </span><br><span class="line">12 &#123;  </span><br><span class="line">13     return platform_driver_register(&amp;davinci_i2c_driver);  </span><br><span class="line">14 &#125;  </span><br><span class="line">15 subsys_initcall(davinci_i2c_init_driver);  </span><br><span class="line">16   </span><br><span class="line">17 static void __exit davinci_i2c_exit_driver(void)  </span><br><span class="line">18 &#123;  </span><br><span class="line">19     platform_driver_unregister(&amp;davinci_i2c_driver);  </span><br><span class="line">20 &#125;  </span><br><span class="line">21 module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static struct i2c_algorithm i2c_davinci_algo &#x3D; &#123;  </span><br><span class="line">2     .master_xfer    &#x3D; i2c_davinci_xfer,  </span><br><span class="line">3     .functionality  &#x3D; i2c_davinci_func,  </span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 adap-&gt;algo &#x3D; &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="适配器驱动程序分析"><a href="#适配器驱动程序分析" class="headerlink" title="适配器驱动程序分析"></a>适配器驱动程序分析</h2><p>　　在linux系统中，适配器驱动位于linux目录下的\drivers\i2c\busses下，不同的处理器的适配器驱动程序设计有差异，但是总体思路不变。</p>
<p>　　在适配器的驱动中，实现两个结构体非常关键，也是整个适配器驱动的灵魂。</p>
<p>　　下面以某个适配器的驱动程序为例进行说明：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 static struct platform_driver tcc_i2c_driver &#x3D; &#123;</span><br><span class="line"> 2  .probe   &#x3D; tcc_i2c_probe,</span><br><span class="line"> 3  .remove   &#x3D; tcc_i2c_remove,</span><br><span class="line"> 4  .suspend  &#x3D; tcc_i2c_suspend_late,</span><br><span class="line"> 5  .resume   &#x3D; tcc_i2c_resume_early,</span><br><span class="line"> 6  .driver   &#x3D; &#123;</span><br><span class="line"> 7   .owner  &#x3D; THIS_MODULE,</span><br><span class="line"> 8   .name  &#x3D; &quot;tcc-i2c&quot;,</span><br><span class="line"> 9  &#125;,</span><br><span class="line">10 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p> 　以上说明这个驱动是基于平台总线的，这样实现的目的是与CPU紧紧联系起来。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static const struct i2c_algorithm tcc_i2c_algorithm &#x3D; &#123;</span><br><span class="line">2  .master_xfer &#x3D; tcc_i2c_xfer,</span><br><span class="line">3  .functionality &#x3D; tcc_i2c_func,</span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　这个结构体也是非常的关键，这个结构体里面的函数<strong>tcc_i2c_xfer</strong>是适配器算法的实现，这个函数实现了适配器与I2C CORE的连接。</p>
<p>　　<strong>tcc_i2c_func</strong>是指该适配器所支持的功能。</p>
<p>　　tcc_i2c_xfer这个函数实质是实现I2C数据的发送与接收的处理过程。不同的处理器实现的方法不同，主要表现在寄存器的设置与中断的处理方法上。</p>
<p>　　把握上面的两点去分析适配器程序就简单多了。</p>
<hr>
<h2 id="I2C-core驱动程序分析"><a href="#I2C-core驱动程序分析" class="headerlink" title="I2C-core驱动程序分析"></a>I2C-core驱动程序分析</h2><p>　　在I2C-core.c这个函数中，把握下面的几个关键函数就可以了。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 &#x2F;&#x2F;增加&#x2F;删除i2c_adapter</span><br><span class="line"> 2 int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line"> 3 int i2c_del_adapter(struct i2c_adapter *adap)</span><br><span class="line"> 4 </span><br><span class="line"> 5 &#x2F;&#x2F;增加&#x2F;删除i2c_driver</span><br><span class="line"> 6 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line"> 7 void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line"> 8 </span><br><span class="line"> 9 &#x2F;&#x2F;i2c_client依附&#x2F;脱离</span><br><span class="line">10 int i2c_attach_client(struct i2c_client *client)</span><br><span class="line">11 </span><br><span class="line">12 &#x2F;&#x2F;增加&#x2F;删除i2c_driver</span><br><span class="line">13 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">14 void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">15 </span><br><span class="line">16 &#x2F;&#x2F;i2c_client依附&#x2F;脱离</span><br><span class="line">17 int i2c_attach_client(struct i2c_client *client)</span><br><span class="line">18 int i2c_detach_client(struct i2c_client *client)</span><br><span class="line">19 </span><br><span class="line">20 &#x2F;&#x2F;I2C传输,发送和接收</span><br><span class="line">21 int i2c_master_send(struct i2c_client *client,const char *buf ,int count)</span><br><span class="line">22 int i2c_master_recv(struct i2c_client *client, char *buf ,int count)</span><br><span class="line">23 int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　I2c_transfer这个函数实现了core与adapter的联系。</p>
<hr>
<h2 id="代码调用层次图"><a href="#代码调用层次图" class="headerlink" title="代码调用层次图"></a>代码调用层次图</h2><p>　　有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/02234128-18be3750dd3a4494bd9d173d40284179.png" alt="img"></p>
<p>　　上面这些代码的展示是告诉我们：linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。</p>
<p>　　剩下的就是针对挂载在i2c两线上的i2c设备了device，而编写的即具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）</p>
<hr>
<h2 id="编写驱动需要完成的工作"><a href="#编写驱动需要完成的工作" class="headerlink" title="编写驱动需要完成的工作"></a>编写驱动需要完成的工作</h2><p>　　编写具体的I2C驱动时，工程师需要处理的主要工作如下：</p>
<p>　　1).提供I2C适配器的硬件驱动，探测，初始化I2C适配器(如申请I2C的I/O地址和中断号)，驱动CPU控制的I2C适配器从硬件上产生。</p>
<p>　　2).提供I2C控制的algorithm, 用具体适配器的xxx_xfer()函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋给i2c_adapter的algo指针。</p>
<p>　　3).实现I2C设备驱动中的i2c_driver接口，用具体yyy的yyy_probe()，yyy_remove()，yyy_suspend(),yyy_resume()函数指针和i2c_device_id设备ID表赋给i2c_driver的probe,remove,suspend,resume和id_table指针。</p>
<p>　　4).实现I2C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接。</p>
<p>　　</p>
<p>　　上面的工作中前两个属于I2C总线驱动，后面两个属于I2C设备驱动。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> <a href="http://blog.csdn.net/ghostyu" target="_blank" rel="noopener">http://blog.csdn.net/ghostyu</a></p>
<p><a href="http://blog.chinaunix.net/uid-25906157-id-3376728.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-25906157-id-3376728.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%9A0-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%9A0-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">【转载】Linux I2C子系统分析：0-整体框架介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 16:25:41 / Modified: 16:37:29" itemprop="dateCreated datePublished" datetime="2021-01-15T16:25:41+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：【<a href="https://www.cnblogs.com/schips/p/linux-subsystem-i2c-0-about.html】" target="_blank" rel="noopener">https://www.cnblogs.com/schips/p/linux-subsystem-i2c-0-about.html】</a></p>
<p>内核版本：v4.14</p>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>在Linux的I2C架构如图：</p>
<p><a href="https://img2020.cnblogs.com/blog/2120938/202010/2120938-20201013152732525-1054325417.png" target="_blank" rel="noopener"><img src="https://img2020.cnblogs.com/blog/2120938/202010/2120938-20201013152732525-1054325417.png" alt="Linux-i2c子系统框图"></a></p>
<p>Linux-i2c子系统框图</p>
<p>内核空间部分可以分为：i2c设备驱动、i2c核心以及i2c总线驱动。</p>
<ul>
<li><strong>i2c核心</strong>：框架的实现；提供i2c总线驱动和设备驱动的注册、注销方法；i2c通信方法（algorithm）上层的，与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等。这一部分的工作由内核开发者完成。</li>
<li><strong>i2c总线驱动</strong>：具体控制器的实现；i2c总线驱动是对i2c硬件体系结构中适配器端的实现，说白了，就是怎么操作i2c模块工作。适配器可由CPU控制，甚至直接集成到cpu里面（ algorithm driver<br>adapter driver）</li>
<li><strong>i2c设备</strong>：对i2c硬件体系结构中设备端的实现，比如说板上的EEPROM设备等。设备一般挂接在cpu控制的i2c适配器上，通过i2c适配器与cpu交换数据。（ chip drivers, 包括多种类型，如RTC, EEPROM, I/O expander, hardware monitoring, sound, video等）</li>
</ul>
<p>名词解释：</p>
<ul>
<li>i2c-adapter（适配器）：指的是CPU实际的I2C控制器（例如I2C0，I2C1）；</li>
<li>i2c-device（设备）：指的是I2C总线上的从设备（例如某片EEPROM，某个触摸屏）；</li>
<li>i2c algorithm（算法、实现方法）：这里指的是对i2c设备一套对应的通信方法。</li>
</ul>
<p>分层的好处：</p>
<ul>
<li>让工程师们各司其职，只关心自己应该实现的部分</li>
<li>不需要为每一个i2c控制器编写所有从设备的控制代码，只需要分别完成n个控制器的控制接口，m个从设备的访问实现，即可实现任意的控制器访问任意的从设备（假设硬件连接支持）</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>以下原型均定义在<code>include/linux/i2c.h</code>中，随着内核版本的不同有差异，但差异不大。</p>
<h3 id="i2c-设备驱动"><a href="#i2c-设备驱动" class="headerlink" title="i2c 设备驱动"></a>i2c 设备驱动</h3><p><strong>i2c_driver：</strong>代表一个i2c设备驱动；</p>
<p>i2c 设备驱动要使用i2c_driver 和i2c_client数据结构并填充i2c_driver中的成员函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_driver - represent an I2C device driver</span></span><br><span class="line"><span class="comment"> * @class: What kind of i2c device we instantiate (for detect)</span></span><br><span class="line"><span class="comment"> * @attach_adapter: Callback for bus addition (deprecated)</span></span><br><span class="line"><span class="comment"> * @probe: Callback for device binding - soon to be deprecated</span></span><br><span class="line"><span class="comment"> * @probe_new: New callback for device binding</span></span><br><span class="line"><span class="comment"> * @remove: Callback for device unbinding</span></span><br><span class="line"><span class="comment"> * @shutdown: Callback for device shutdown</span></span><br><span class="line"><span class="comment"> * @alert: Alert callback, for example for the SMBus alert protocol</span></span><br><span class="line"><span class="comment"> * @command: Callback for bus-wide signaling (optional)</span></span><br><span class="line"><span class="comment"> * @driver: Device driver model driver</span></span><br><span class="line"><span class="comment"> * @id_table: List of I2C devices supported by this driver</span></span><br><span class="line"><span class="comment"> * @detect: Callback for device detection</span></span><br><span class="line"><span class="comment"> * @address_list: The I2C addresses to probe (for detect)</span></span><br><span class="line"><span class="comment"> * @clients: List of detected clients we created (for i2c-core use only)</span></span><br><span class="line"><span class="comment"> * @disable_i2c_core_irq_mapping: Tell the i2c-core to not do irq-mapping</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver.owner field should be set to the module owner of this driver.</span></span><br><span class="line"><span class="comment"> * The driver.name field should be set to the name of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For automatic device detection, both @detect and @address_list must</span></span><br><span class="line"><span class="comment"> * be defined. @class should also be set, otherwise only devices forced</span></span><br><span class="line"><span class="comment"> * with module parameters will be created. The detect function must</span></span><br><span class="line"><span class="comment"> * fill at least the name field of the i2c_board_info structure it is</span></span><br><span class="line"><span class="comment"> * handed upon successful detection, and possibly also the flags field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @detect is missing, the driver will still work fine for enumerated</span></span><br><span class="line"><span class="comment"> * devices. Detected devices simply won't be supported. This is expected</span></span><br><span class="line"><span class="comment"> * for the many I2C/SMBus devices which can't be detected reliably, and</span></span><br><span class="line"><span class="comment"> * the ones which can always be enumerated in practice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The i2c_client structure which is handed to the @detect callback is</span></span><br><span class="line"><span class="comment"> * not a real i2c_client. It is initialized just enough so that you can</span></span><br><span class="line"><span class="comment"> * call i2c_smbus_read_byte_data and friends on it. Don't do anything</span></span><br><span class="line"><span class="comment"> * else with it. In particular, calling dev_dbg and friends on it is</span></span><br><span class="line"><span class="comment"> * not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">// 表示我们将注册的是那种设备（探测时用）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *) __deprecated; <span class="comment">// 添加总线时，告诉驱动的回调函数（以后可能要弃用）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct i2c_client *, <span class="keyword">const</span> struct i2c_device_id *); <span class="comment">// 绑定设备时的回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">remove</span>)(struct i2c_client *); <span class="comment">// 解除绑定时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()'s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe_new)(struct i2c_client *); <span class="comment">// 新的设备绑定回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don't relate to enumeration  */</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct i2c_client *); <span class="comment">// 设备关闭时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response's low bit ("event flag").</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> (*alert)(struct i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="keyword">unsigned</span> <span class="keyword">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*command)(struct i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg); <span class="comment">// 类似于ioctl 的命令控制函数</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span> <span class="comment">// 设备驱动模型中的驱动</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="keyword">int</span> (*detect)(struct i2c_client *, struct i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> short *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> <span class="comment">// 我们创建的检测到的clients（仅供i2c核心使用）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如：RTC设备的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">"rtc-ds1307"</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-客户端"><a href="#i2c-客户端" class="headerlink" title="i2c 客户端"></a>i2c 客户端</h3><p><strong>i2c_client</strong>：代表一个连接到i2c_bus总线上的从设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_client - represent an I2C slave device</span></span><br><span class="line"><span class="comment"> * @flags: </span></span><br><span class="line"><span class="comment"> 	- I2C_CLIENT_TEN ： the device uses a ten bit chip address; 表示i2c从设备使用的芯片地址为10bit</span></span><br><span class="line"><span class="comment">	- I2C_CLIENT_PEC ： it uses SMBus Packet Error Checking；   表示设备使用SMBus错误检查</span></span><br><span class="line"><span class="comment"> * @addr: Address used on the I2C bus connected to the parent adapter.</span></span><br><span class="line"><span class="comment"> * @name: Indicates the type of the device, usually a chip name that's</span></span><br><span class="line"><span class="comment"> *	generic enough to hide second-sourcing and compatible revisions.</span></span><br><span class="line"><span class="comment"> * @adapter: manages the bus segment hosting this I2C device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model device node for the slave.</span></span><br><span class="line"><span class="comment"> * @irq: indicates the IRQ generated by this device (if any)</span></span><br><span class="line"><span class="comment"> * @detected: member of an i2c_driver.clients list or i2c-core's</span></span><br><span class="line"><span class="comment"> *	userspace_devices list</span></span><br><span class="line"><span class="comment"> * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter</span></span><br><span class="line"><span class="comment"> *	calls it to pass on slave events to the slave driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_client identifies a single device (i.e. chip) connected to an</span></span><br><span class="line"><span class="comment"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span></span><br><span class="line"><span class="comment"> * managing the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short flags;	 <span class="comment">// 一个标示，丰富这个设备的特殊细节</span></span><br><span class="line">	<span class="keyword">unsigned</span> short addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit；addresses are stored in the _LOWER_ 7 bits	 */</span> <span class="comment">// 从设备在连接到相应适配器总线上使用的地址；默认使用低七位。</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span> <span class="comment">// 挂接设备的适配器；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span> <span class="comment">// 访问设备的驱动；</span></span><br><span class="line">	<span class="keyword">int</span> irq;			<span class="comment">/* irq issued by device		*/</span> <span class="comment">// 表明由设备产生的中断；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span> <span class="comment">// 一个i2c_driver支持的client的数量或i2c-core的用户空间设备的链表。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="keyword">i2c_slave_cb_t</span> slave_cb;	<span class="comment">/* callback for slave mode	*/</span> <span class="comment">// 从模式下的回调函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_client的信息通常在BSP的板文件中通过i2c_board_info填充， 如下面的代码就定义了一个I2C设备的ID为“wm8580”、 地址为0x1b、 的i2c_client：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">i2c_devs0</span>[] __<span class="title">initdata</span> = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">"wm8580"</span>, <span class="number">0x1b</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		type[I2C_NAME_SIZE];</span><br><span class="line">	<span class="keyword">unsigned</span> short	flags;</span><br><span class="line">	<span class="keyword">unsigned</span> short	addr;</span><br><span class="line">	<span class="keyword">void</span>		*platform_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>	*<span class="title">archdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>		irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c适配器"><a href="#i2c适配器" class="headerlink" title="i2c适配器"></a>i2c适配器</h3><p>i2c_adapter：一个用于标识物理总线（也就是i2c总线）连同访问它必要的算法的一个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">host_notify_domain</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_algorithm中的关键函数master_xfer() 用于产生I2C访问周期需要的信号， 以i2c_msg（即I2C消息） 为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_msg - an I2C transaction segment beginning with START</span></span><br><span class="line"><span class="comment"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span></span><br><span class="line"><span class="comment"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span></span><br><span class="line"><span class="comment"> *	must support I2C_FUNC_10BIT_ADDR.</span></span><br><span class="line"><span class="comment"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span></span><br><span class="line"><span class="comment"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span></span><br><span class="line"><span class="comment"> *	flags through i2c_check_functionality().</span></span><br><span class="line"><span class="comment"> * @len: Number of data bytes in @buf being read from or written to the</span></span><br><span class="line"><span class="comment"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span></span><br><span class="line"><span class="comment"> *	is set, the caller guarantees that this buffer can hold up to</span></span><br><span class="line"><span class="comment"> *	32 bytes in addition to the initial length byte sent by the</span></span><br><span class="line"><span class="comment"> *	slave (plus, if used, the SMBus PEC); and this value will be</span></span><br><span class="line"><span class="comment"> *	incremented by the number of block data bytes received.</span></span><br><span class="line"><span class="comment"> * @buf: The buffer into which data is read, or from which it's written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_msg is the low level representation of one segment of an I2C</span></span><br><span class="line"><span class="comment"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span></span><br><span class="line"><span class="comment"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span></span><br><span class="line"><span class="comment"> * @i2c_adapter.@master_xfer() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when I2C "protocol mangling" is used, all I2C adapters implement</span></span><br><span class="line"><span class="comment"> * the standard rules for I2C transactions.  Each transaction begins with a</span></span><br><span class="line"><span class="comment"> * START.  That is followed by the slave address, and a bit encoding read</span></span><br><span class="line"><span class="comment"> * versus write.  Then follow all the data bytes, possibly including a byte</span></span><br><span class="line"><span class="comment"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span></span><br><span class="line"><span class="comment"> * bytes have been transferred and ACKed.  If this is the last message in a</span></span><br><span class="line"><span class="comment"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span></span><br><span class="line"><span class="comment"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span></span><br><span class="line"><span class="comment"> * passing certain @flags may have changed those standard protocol behaviors.</span></span><br><span class="line"><span class="comment"> * Those flags are only for use with broken/nonconforming slaves, and with</span></span><br><span class="line"><span class="comment"> * adapters which are known to support the specific mangling options they</span></span><br><span class="line"><span class="comment"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line">	__u16 flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c通信方法"><a href="#i2c通信方法" class="headerlink" title="i2c通信方法"></a>i2c通信方法</h3><p>i2c_algorithm是为一类使用相同总线算法寻址的一个接口。</p>
<ul>
<li>当适配器不能使用i2c访问设备时，把master_xfer设置为NULL</li>
<li>如果一个适配器可以做SMBus访问时，设置smbus_xfer；如果把smbus_xfer设置成NULL，SMBus协议使用通用I2C模拟的消息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: </span></span><br><span class="line"><span class="comment">     Issue a set of i2c transactions to the given I2C adapter defined by the </span></span><br><span class="line"><span class="comment">     msgs array, with num messages available to transfer via the adapter </span></span><br><span class="line"><span class="comment">     specified by adap.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: </span></span><br><span class="line"><span class="comment">  	 Issue smbus transactions to the given I2C adapter. If this is not present,</span></span><br><span class="line"><span class="comment">     then the bus layer will try and convert the SMBus calls into I2C transfers</span></span><br><span class="line"><span class="comment">     instead.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the I2C_FUNC_* flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the @master_xfer field should indicate the type of</span></span><br><span class="line"><span class="comment"> * error code that occurred during the transfer, as documented in the kernel</span></span><br><span class="line"><span class="comment"> * Documentation file Documentation/i2c/fault-codes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/* If an adapter algorithm can't do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	   to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	   using common I2C messages */</span></span><br><span class="line">	<span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	   processed, or a negative value on error */</span></span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">			   <span class="keyword">int</span> num); </span><br><span class="line">    <span class="comment">// 向msgs数组定义的给定i2c适配器发出一组i2c事务，其中num条消息可通过adap指定的适配器传输。</span></span><br><span class="line">	<span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">			   <span class="keyword">unsigned</span> short flags, <span class="keyword">char</span> read_write,</span><br><span class="line">			   u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">    <span class="comment">//  向给定的I2C适配器发出smbus事务。如果这不存在，那么总线层将尝试将SMBus调用转换为I2C传输。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line">	<span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><h3 id="i2c-adapter和i2c-algorithm"><a href="#i2c-adapter和i2c-algorithm" class="headerlink" title="i2c_adapter和i2c_algorithm"></a>i2c_adapter和i2c_algorithm</h3><p>由于i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法。</p>
<p>一个i2c适配器需要i2c_algorithm中提供的通信函数来控制适配器上产生特定的访问周期。</p>
<blockquote>
<p>缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
</blockquote>
<h3 id="i2c-driver和i2c-client"><a href="#i2c-driver和i2c-client" class="headerlink" title="i2c_driver和i2c_client"></a>i2c_driver和i2c_client</h3><p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等；</p>
<p>另外， <code>struct i2c_device_id</code>形式的<code>id_table</code>是该驱动所支持的I2C设备的ID表。 i2c_client对应于真实的物理设备， 每个I2C设备都需要一个<code>i2c_client</code>来描述。 <code>i2c_driver</code>与<code>i2c_client</code>的关系是一对多， 一个i2c_driver可以支持多个同类型的<code>i2c_client</code>。</p>
<p>每个探测到的设备通过在client数据结构中得到自己的数据</p>
<p>在I2C总线驱动i2c_bus_type的<code>match()</code>函数<code>i2c_device_match()</code> 中， 会调用<code>i2c_match_id()</code> 函数匹配在板文件中定义的ID和i2c_driver所支持的ID表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> = <span class="title">i2c_verify_client</span>(<span class="title">dev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    driver = to_i2c_driver(drv);</span><br><span class="line">    <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct i2c_device_id *<span class="title">i2c_match_id</span><span class="params">(<span class="keyword">const</span> struct i2c_device_id *id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-adpater与i2c-client"><a href="#i2c-adpater与i2c-client" class="headerlink" title="i2c_adpater与i2c_client"></a>i2c_adpater与i2c_client</h3><p>i2c_adpater与i2c_client的关系与I2C硬件体系中适配器和设备的关系一致， 即i2c_client依附于i2c_adpater。 由于一个适配器可以连接多个I2C设备， 所以一个i2c_adpater也可以被多个i2c_client依附，i2c_adpater中包括依附于它的i2c_client的链表。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://i2c.wiki.kernel.org/index.php/Driver_Architecture" target="_blank" rel="noopener">https://i2c.wiki.kernel.org/index.php/Driver_Architecture</a><br><a href="https://blog.csdn.net/xie0812/article/details/22942375" target="_blank" rel="noopener">https://blog.csdn.net/xie0812/article/details/22942375</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">【转载】 i2c驱动架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 11:34:14 / Modified: 16:22:06" itemprop="dateCreated datePublished" datetime="2021-01-15T11:34:14+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：【<a href="https://blog.csdn.net/ghostyu/article/details/8094049】" target="_blank" rel="noopener">https://blog.csdn.net/ghostyu/article/details/8094049】</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h1><p><strong>在阅读本文最好先熟悉一种i2c设备的驱动程序，并且浏览一下i2c-core.c以及芯片提供商的提供的i2c总线驱动（i2c-davinci.c）。标题党请见谅！</strong></p>
<p>其实i2c接口非常的简单，即使用51单片的gpio来模拟i2c，编写一个e2prom或者其他i2c接口的驱动程序，也不是什么难事，几百行代码就能搞定。</p>
<p>但是Linux的i2c驱动体系结构却有相当的复杂度，不管是叫linux i2c驱动还是单片机i2c驱动，其根本还是操作soc芯片内部的i2c模块（也叫i2c adapter）（读写i2c相关的寄存器）来产生start、stop还有ack信号而已。</p>
<h1 id="linux设备驱动到底复杂在什么地方？"><a href="#linux设备驱动到底复杂在什么地方？" class="headerlink" title="linux设备驱动到底复杂在什么地方？"></a><strong>linux设备驱动到底复杂在什么地方？</strong></h1><p>假设soc芯片dm368有两个i2c adapter（368内部真正只有一个i2c模块）：i2c_adapter1，i2c_adapter1；然后外部有三个i2c接口的设备i2c_device1，i2c_device2，i2c_device3。</p>
<p>现在要求在裸机下写出他们的驱动函数。那么肯定要写出6个不同的驱动函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i2c_adapter1_ReadWrite_i2c_device1();</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device3()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device1()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device3()</span><br></pre></td></tr></table></figure>

<p>设想一共有m个i2c adapter和n个外设i2c device，那么将需要m<em>n个驱动。并且这m</em>n个驱动程序必要会有很大部分重复的代码，而且不利于驱动程序的移植。</p>
<p>如果采用adapter和device分离的思想来写这样的驱动会是怎样呢？</p>
<p><img src="http://jiali.clouddn.com/20210115_001.png" alt=""></p>
<p>​                                                                                                                                   图1</p>
<p>这样分离之后，只需要m+n个驱动，而且Adapter和Device的几乎没有耦合性，增加一个Adapter或者device并不会影响其余的驱动。</p>
<p><strong>这就是分离思想带来的好处。除此之外，linux虽然是C写的，但是大量使用了面向对象的变成方法（可以理解为分层的思想），仅仅分离细想和分层思想的引入，就大大增加了linux设备驱动的复杂度。</strong></p>
<h1 id="linux驱动中-i2c驱动架构"><a href="#linux驱动中-i2c驱动架构" class="headerlink" title="linux驱动中 i2c驱动架构"></a><strong>linux驱动中 i2c驱动架构</strong></h1><p><img src="http://jiali.clouddn.com/20210115_002.png" alt=""></p>
<p>​                                                                                                                 图2</p>
<p><strong><em>\</em>上图完整的描述了linux i2c驱动架构，虽然I2C硬件体系结构比较简单，但是i2c体系结构在linux中的实现却相当复杂。那么我们如何编写特定i2c接口器件（比如，ov2715，需要i2c来配置寄存器）的驱动程序？就是说上述架构中的那些部分需要我们完成，而哪些是linux内核已经完善的或者是芯片提供商（TI davinci平台已经做好的）已经提供的？**</strong></p>
<h1 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h1><p><strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。<strong>覆盖图中的硬件实现层</strong></p>
<p><strong>第二层</strong>：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。<strong>覆盖图中的访问抽象层、i2c核心层</strong></p>
<p><strong>第三层</strong>：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第四层</strong>：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c</strong></p>
<p><strong>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</strong></p>
<p><strong>明确了方向后，**</strong>再来具体分析。**</p>
<h1 id="具体分析"><a href="#具体分析" class="headerlink" title="\具体分析**"></a><strong><em>\</em>具体分析**</strong></h1><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>
<p>现在，我们就来看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>
<h2 id="1、i2c-driver"><a href="#1、i2c-driver" class="headerlink" title="1、i2c_driver"></a><strong>1、i2c_driver</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_client)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*command)(struct i2c_client *client,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、i2c-client"><a href="#2、i2c-client" class="headerlink" title="2、i2c_client"></a><strong>2、i2c_client</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> short addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit 	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* and our access routines	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> usage_count;		<span class="comment">/* How many accesses currently  */</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* to the client		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">released</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、i2c-adapter"><a href="#3、i2c-adapter" class="headerlink" title="3、i2c_adapter"></a><strong>3、i2c_adapter</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span><span class="comment">/* the algorithm to access the bus	*/</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line">	<span class="comment">/* --- administration stuff. */</span></span><br><span class="line">	<span class="keyword">int</span> (*client_register)(struct i2c_client *);</span><br><span class="line">	<span class="keyword">int</span> (*client_unregister)(struct i2c_client *);</span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">clist_lock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> timeout;</span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">class_dev</span>;</span>	<span class="comment">/* the class device */</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">class_dev_released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4、i2c-algorithm"><a href="#4、i2c-algorithm" class="headerlink" title="4、i2c_algorithm"></a><strong>4、i2c_algorithm</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, </span><br><span class="line">	                   <span class="keyword">int</span> num);</span><br><span class="line">	<span class="keyword">int</span> (*slave_send)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*slave_recv)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>【i2c_adapter与i2c_algorithm】</strong></p>
<p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I2C Message - used for pure i2c transaction, also from /dev interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line"> 	__u16 flags;		</span><br><span class="line"> 	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line"> 	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【i2c_driver和i2c_client】</strong></p>
<p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<p><strong>【i2c_adapter和i2c_client】</strong></p>
<p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class="line">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>



<p>如果看过i2c设备驱动程序的人一定对上面几个函数比较熟悉。</p>
<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(struct i2c_adapter * adap, struct i2c_msg *msgs, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class="comment">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_attach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	device_register(&amp;client-&gt;dev);</span><br><span class="line">	device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_detach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line"></span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用，稍后分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class="line"><span class="comment"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class="line"><span class="comment"> * available for clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_register(&amp;adap-&gt;dev);</span><br><span class="line">	device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* inform drivers of new adapters */</span></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;attach_adapter)</span><br><span class="line">			<span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">			driver-&gt;attach_adapter(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_del_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;detach_adapter)</span><br><span class="line">			<span class="keyword">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class="line">		client = list_entry(item, struct i2c_client, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">davinci_i2c_driver</span> = &#123;</span></span><br><span class="line">	.probe		= davinci_i2c_probe,</span><br><span class="line">	.remove		= davinci_i2c_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">"i2c_davinci"</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* I2C may be needed to bring up other drivers */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">davinci_i2c_init_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">subsys_initcall(davinci_i2c_init_driver);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">davinci_i2c_exit_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	platform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_davinci_algo</span> = &#123;</span></span><br><span class="line">	.master_xfer	= i2c_davinci_xfer,</span><br><span class="line">	.functionality	= i2c_davinci_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>

<h1 id="梳理图"><a href="#梳理图" class="headerlink" title="梳理图"></a>梳理图</h1><p><strong><em>\</em>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容，请看图3。**</strong></p>
<p> <img src="http://jiali.clouddn.com/20210115_003.png" alt=""></p>
<p>​                                                                  图3</p>
<p>好了，上面这些代码的展示是告诉我们，linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">【转载】Linux驱动之I2C子系统剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-15 11:19:38 / Modified: 11:25:39" itemprop="dateCreated datePublished" datetime="2021-01-15T11:19:38+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：【 <a href="https://www.caiyifan.cn/p/8d9c6db2.html】" target="_blank" rel="noopener">https://www.caiyifan.cn/p/8d9c6db2.html】</a></p>
<p>前言</p>
<p>I2C是广泛应用于计算机中的串行总线，用于处理器和其外设之间的通信。</p>
<h2 id="I2C硬件基本概念"><a href="#I2C硬件基本概念" class="headerlink" title="I2C硬件基本概念"></a>I2C硬件基本概念</h2><ul>
<li><p>I2C总线由两根传递数据的双向信号线与一根地线组成，半双工、主从方式通信。</p>
<ul>
<li>Serial Clock Line (SCL)</li>
<li>Serial Data Address (SDA)</li>
</ul>
</li>
<li><p>每个设备都有一个唯一设备地址，一次传输8bit，高位在前，低位在后。</p>
</li>
<li><p>一次完整的I2C通信需要经历一个完整的时序，I2C总线通信完整时序如下图。一般在驱动中无需关心具体时序，只需操作SoC中的I2C控制器即可，只有在裸机下需要用GPIO模拟I2C通信时才需用到，所以笔者在本文不阐述I2C时序（其实就是懒 O__O “…）。</p>
</li>
</ul>
<p>  <img src="https://img.caiyifan.cn/I2C%E6%97%B6%E5%BA%8F.png" alt="img"></p>
<ul>
<li><p>总线速度有三种模式</p>
<ul>
<li>标准模式 100kbps</li>
<li>快速模式 400kbps</li>
<li>高速模式 3.4Mbps</li>
</ul>
</li>
</ul>
<h2 id="I2C子系统框架"><a href="#I2C子系统框架" class="headerlink" title="I2C子系统框架"></a>I2C子系统框架</h2><ul>
<li>I2C设备驱动层：drivers/i2c/i2c-dev.c (通用型) 或者为特定设备定制的设备驱动（比如E2PROM驱动）</li>
<li>I2C核心层： drivers/i2c/i2c-coere.c</li>
<li>I2C总线驱动层(主机控制器驱动层)：drivers/i2c/busses/i2c-s3c2410.c</li>
</ul>
<h3 id="I2C设备驱动层"><a href="#I2C设备驱动层" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><ul>
<li>是I2C从机的驱动程序</li>
<li>给用户提供调用接口</li>
<li>内核提供两种方式来实现设备驱动：<ul>
<li>第一种是内核默认实现的<strong>通用型的I2C设备驱动</strong>，位于<code>drivers/i2c/i2c-dev.c</code>中。 这种方式<strong>仅仅只是封装了I2C的基本操作</strong>，相当于<strong>只是封装了I2C的基本时序</strong>，向应用层只提供了I2C基本操作的接口，该接口通用于所有的I2C设备。具体设备相关的操作，需要开发者在应用层根据硬件特性来完成对设备的操作。<strong>该方式的优点就是通用，而缺点也很明显，封装的不够彻底，需要应用开发人员对硬件有一定程度的了解</strong>。</li>
<li>第二种是根据特定设备来编写的<strong>特定的I2C设备驱动</strong>, 该方式<strong>彻底封装了硬件的操作</strong>，提供给应用层的接口<strong>彻底屏蔽I2C的通信细节</strong>。该方式的<strong>优点就是应用开发人员无需关心硬件</strong>。</li>
</ul>
</li>
</ul>
<h3 id="I2C核心层"><a href="#I2C核心层" class="headerlink" title="I2C核心层"></a>I2C核心层</h3><ul>
<li>注册I2C总线</li>
<li>由内核开发人员编写的，不涉及具体硬件</li>
<li>给驱动编程人员提供编程接口</li>
</ul>
<h3 id="I2C总线驱动层"><a href="#I2C总线驱动层" class="headerlink" title="I2C总线驱动层"></a>I2C总线驱动层</h3><ul>
<li>是I2C主机适配器的驱动程序</li>
<li>初始化I2C适配器(控制器)</li>
<li>实现操作方法：根据I2C操作时序进行操作I2C控制器实现收发数据</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码中会涉及到一部分SMBus相关内容，SMBus是Intel在I2C的基础上开发的类似I2C的总线，本文不探讨SMBus相关内容（其实说白了，还是懒QAQ）。笔者会大体上对I2C子系统的源码进行分析，如若分析的有出入，还望指出。</p>
<h3 id="I2C核心层-1"><a href="#I2C核心层-1" class="headerlink" title="I2C核心层"></a>I2C核心层</h3><p>I2C核心层的实现位于<code>drivers/i2c/i2c-core.c</code>中，笔者从<code>i2c_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; bus_register(&amp;i2c_bus_type);     &#x2F;&#x2F; 注册I2C总线 </span><br><span class="line">    if (retval)</span><br><span class="line">        return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">    if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">        retval &#x3D; -ENOMEM;</span><br><span class="line">        goto bus_err;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    retval &#x3D; i2c_add_driver(&amp;dummy_driver);    &#x2F;&#x2F; 注册了一个虚假的I2C驱动</span><br><span class="line">    if (retval)</span><br><span class="line">        goto class_err;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line">#endif</span><br><span class="line">    bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数先是调用了<code>bus_register</code>函数注册了I2C总线，随后调用<code>i2c_add_driver</code>函数来注册了一个虚假的I2C驱动。</p>
<p>先对注册的I2C总线<code>i2c_bus_type</code>进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class="line">    .match      &#x3D; i2c_device_match,</span><br><span class="line">    .probe      &#x3D; i2c_device_probe,</span><br><span class="line">    .remove     &#x3D; i2c_device_remove,</span><br><span class="line">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class="line">    .pm     &#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据Linux设备驱动模型的原理，I2C总线下会挂载两条链表，分别为设备链和驱动链，只要其中一个链表有结点插入，即会通过<code>i2c_device_match</code>函数来遍历另一条链表去匹配设备与驱动，一旦匹配上则会调用<code>i2c_device_probe</code>函数，而<code>i2c_device_probe</code>函数又会调用i2c_driver的<code>probe</code>函数。进到<code>i2c_device_match</code>和<code>i2c_device_probe</code>进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    if (!client)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; to_i2c_driver(drv);</span><br><span class="line">    &#x2F;* match on an id table if there is one *&#x2F;</span><br><span class="line">    if (driver-&gt;id_table)</span><br><span class="line">        return i2c_match_id(driver-&gt;id_table, client) !&#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, <code>i2c_device_match</code>函数调用的是<code>i2c_match_id</code>函数来进行匹配。从源码中可见，<strong>需要注意的是I2C总线匹配方式不同于Platform总线，I2C总线只匹配<code>id_table</code>中的name，并不会去匹配driver中的name</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_device_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client  *client &#x3D; i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver  *driver;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    if (!client)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; to_i2c_driver(dev-&gt;driver);</span><br><span class="line">    if (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line">    client-&gt;driver &#x3D; driver;</span><br><span class="line">    if (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">        device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">                    client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">    dev_dbg(dev, &quot;probe\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 调用driver中的probe函数 *&#x2F;</span><br><span class="line">    status &#x3D; driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">    if (status) &#123;</span><br><span class="line">        client-&gt;driver &#x3D; NULL;</span><br><span class="line">        i2c_set_clientdata(client, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，的确是调用<code>driver-&gt;probe</code>来进行真正的probe。<strong>需要注意的是<code>if (!driver-&gt;probe || !driver-&gt;id_table) return -ENODEV;</code>中对<code>id_table</code>进行了非空判断，所以如果采用设备树方式进行匹配也需要对<code>.id_table</code>进行有效赋值，否则会出现match上了但probe函数不会调用的奇怪现象</strong>，个人感觉这应该是个bug，毕竟这个核心层在设备树出现之前就已经存在了。</p>
<p>回到<code>i2c_init</code>函数，然后注册了一个空的名为<code>dummy</code>的i2c_driver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int dummy_probe(struct i2c_client *client,</span><br><span class="line">               const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int dummy_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct i2c_driver dummy_driver &#x3D; &#123;</span><br><span class="line">    .driver.name    &#x3D; &quot;dummy&quot;,</span><br><span class="line">    .probe      &#x3D; dummy_probe,</span><br><span class="line">    .remove     &#x3D; dummy_remove,</span><br><span class="line">    .id_table   &#x3D; dummy_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个完全空的虚假驱动，而I2C核心层为何要注册一个假的驱动不得而知，笔者查阅了网上资料也没法得知，但是<code>/sys/bus/i2c/drivers/dummy</code>确实存在，所以笔者猜测应该纯粹是开发该层次调试用的。</p>
<p>核心层还提供了一系列函数接口供驱动开发者注册和注销驱动：</p>
<ul>
<li>i2c_add_adapter 注册I2C主机适配器驱动 (动态分配总线号)</li>
<li>i2c_add_numbered_adapter 注册I2C主机适配器驱动 (静态指定总线号)</li>
<li>i2c_del_adapter 注销I2C主机适配器驱动</li>
<li>i2c_add_driver 注册I2C从机设备驱动</li>
<li>i2c_del_driver 注销I2C从机设备驱动</li>
</ul>
<p>其他函数暂不分析，在分析其他层的时候调用时再进行分析。</p>
<h3 id="I2C设备驱动层-1"><a href="#I2C设备驱动层-1" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><p>笔者先从内核提供的通用驱动开始分析，最后在文末给出特定驱动的分析。内核提供了一个通用于所有设备的I2C设备驱动，用户可以在应用层实现对I2C的驱动，其实现位于<code>drivers/i2c/i2c-dev.c</code>中。同样从init函数开始，笔者从<code>i2c_dev_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static int __init i2c_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;i2c &#x2F;dev entries driver\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 将通用驱动注册为字符设备驱动，并提供file_operations 操作方法 *&#x2F;</span><br><span class="line">    res &#x3D; register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops);</span><br><span class="line">    if (res)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建类 *&#x2F;</span><br><span class="line">    i2c_dev_class &#x3D; class_create(THIS_MODULE, &quot;i2c-dev&quot;);</span><br><span class="line">    if (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">        res &#x3D; PTR_ERR(i2c_dev_class);</span><br><span class="line">        goto out_unreg_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册I2C从机设备驱动 *&#x2F;</span><br><span class="line">    res &#x3D; i2c_add_driver(&amp;i2cdev_driver);</span><br><span class="line">    if (res)</span><br><span class="line">        goto out_unreg_class;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">    class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">    unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">out:</span><br><span class="line">    printk(KERN_ERR &quot;%s: Driver Initialisation failed\n&quot;, __FILE__);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i2c_dev_init</code>函数先是调用了<code>register_chrdev</code>函数注册了一个字符设备驱动，并提供了一个file_operations。由此可见，是将通用驱动实现为字符设备驱动，并由其file_operations结构体的方法为应用层提供通用接口。然后调用<code>class_create</code>创建了一个类，但是可以看到并没有调用<code>device_create</code>在该类下创建设备，所以注意在这里并没有生成设备节点。最后调用<code>i2c_add_driver</code>注册了一个I2C从机设备驱动<code>i2cdev_driver</code>。<code>i2cdev_driver</code>定义如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_driver i2cdev_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name   &#x3D; &quot;dev_driver&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    .attach_adapter &#x3D; i2cdev_attach_adapter,</span><br><span class="line">    .detach_adapter &#x3D; i2cdev_detach_adapter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上可以看到并没有对<code>id_table</code>进行赋值，从上文在I2C核心层分析可知，I2C总线是根据<code>id_table</code>进行匹配，所以这里并不会按照常规的Linux驱动模型进行match后probe，况且这个驱动里也没有probe方法。所以这到底是什么情况？别慌，虽然没有id_table和probe，但是它单独提供了两个方法<code>attach_adapter</code>和<code>detach_adapter</code>。这里先埋个伏笔，不做分析，到I2C总线驱动层分析后自然会柳暗花明。</p>
<h3 id="I2C总线驱动层-1"><a href="#I2C总线驱动层-1" class="headerlink" title="I2C总线驱动层"></a>I2C总线驱动层</h3><p>笔者使用的SoC是S5PV210，其控制器跟S3C2410基本一致，所以三星的驱动开发者并没有再去写一份S5PV210的主机适配器驱动，而是使用了S3C2410的主机适配器驱动，其位于<code>drivers/i2c/busses/i2c-s3c2410.c</code>中。</p>
<p>从<code>i2c_adap_s3c_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int __init i2c_adap_s3c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    return platform_driver_register(&amp;s3c24xx_i2c_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其作为平台设备驱动而实现，注册了<code>s3c24xx_i2c_driver</code>驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static struct platform_device_id s3c24xx_driver_ids[] &#x3D; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name       &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">        .driver_data    &#x3D; TYPE_S3C2410,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .name       &#x3D; &quot;s3c2440-i2c&quot;,</span><br><span class="line">        .driver_data    &#x3D; TYPE_S3C2440,</span><br><span class="line">    &#125;, &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(platform, s3c24xx_driver_ids);</span><br><span class="line"></span><br><span class="line">static struct platform_driver s3c24xx_i2c_driver &#x3D; &#123;</span><br><span class="line">    .probe      &#x3D; s3c24xx_i2c_probe,</span><br><span class="line">    .remove     &#x3D; s3c24xx_i2c_remove,</span><br><span class="line">    .id_table   &#x3D; s3c24xx_driver_ids,</span><br><span class="line">    .driver     &#x3D; &#123;</span><br><span class="line">        .owner  &#x3D; THIS_MODULE,</span><br><span class="line">        .name   &#x3D; &quot;s3c-i2c&quot;,</span><br><span class="line">        .pm &#x3D; S3C24XX_DEV_PM_OPS,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据平台总线的原理，很容易得知在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中对其驱动对应的设备进行了注册，其注册的设备定义位于<code>dev-i2c0.c</code>，这是I2C的资源文件。其定义的资源如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static struct resource s3c_i2c_resource[] &#x3D; &#123;</span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; S3C_PA_IIC,</span><br><span class="line">        .end   &#x3D; S3C_PA_IIC + SZ_4K - 1,</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; IRQ_IIC,</span><br><span class="line">        .end   &#x3D; IRQ_IIC,</span><br><span class="line">        .flags &#x3D; IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct platform_device s3c_device_i2c0 &#x3D; &#123;</span><br><span class="line">    .name         &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">    .id       &#x3D; 0,</span><br><span class="line">    .num_resources    &#x3D; ARRAY_SIZE(s3c_i2c_resource),</span><br><span class="line">    .resource     &#x3D; s3c_i2c_resource,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由name可知，与<code>s3c24xx_i2c_driver</code>是匹配的。除此之外，还定义了平台数据<code>default_i2c_data0</code>和<code>default_i2c_data0</code>函数。其相关的调用还是在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中进行的，在<code>mach-x210.c</code>中的<code>smdkc110_machine_init</code>函数中进行了如下调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* i2c *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设置I2C平台数据       NULL表示设置默认的平台数据</span><br><span class="line">s3c_i2c0_set_platdata(NULL);</span><br><span class="line">s3c_i2c1_set_platdata(NULL);</span><br><span class="line">s3c_i2c2_set_platdata(NULL);</span><br></pre></td></tr></table></figure>

<p>现在进到<code>s3c_i2c0_set_platdata</code>函数进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static struct s3c2410_platform_i2c default_i2c_data0 __initdata &#x3D; &#123;</span><br><span class="line">    .flags      &#x3D; 0,</span><br><span class="line">    .slave_addr &#x3D; 0x10,          &#x2F;&#x2F; I2C控制器作为从设备时使用的地址</span><br><span class="line">    .frequency  &#x3D; 400*1000,      &#x2F;&#x2F; 400kbps</span><br><span class="line">    .sda_delay  &#x3D; S3C2410_IICLC_SDA_DELAY15 | S3C2410_IICLC_FILTER_ON,   &#x2F;&#x2F; 间隔时间</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void __init s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *pd)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c2410_platform_i2c *npd;</span><br><span class="line"></span><br><span class="line">    if (!pd)   &#x2F;&#x2F; 参数为NULL则使用该函数上面定义的默认的平台数据</span><br><span class="line">        pd &#x3D; &amp;default_i2c_data0;</span><br><span class="line"></span><br><span class="line">    npd &#x3D; kmemdup(pd, sizeof(struct s3c2410_platform_i2c), GFP_KERNEL);</span><br><span class="line">    if (!npd)</span><br><span class="line">        printk(KERN_ERR &quot;%s: no memory for platform data\n&quot;, __func__);</span><br><span class="line">    else if (!npd-&gt;cfg_gpio)</span><br><span class="line">        npd-&gt;cfg_gpio &#x3D; s3c_i2c0_cfg_gpio;  &#x2F;&#x2F; GPIO初始化方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置为平台数据</span><br><span class="line">    s3c_device_i2c0.dev.platform_data &#x3D; npd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到传递NULL则使用了默认的平台数据, 将<code>s3c_i2c0_cfg_gpio</code>函数设置到了平台数据<code>cfg_gpio</code>方法中，最后将平台数据挂接到<code>s3c_device_i2c0</code>这个设备上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void s3c_i2c0_cfg_gpio(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    s3c_gpio_cfgpin(S5PV210_GPD1(0), S3C_GPIO_SFN(2));      &#x2F;&#x2F; 设置控制寄存器为I2C0_SDA模式</span><br><span class="line">    s3c_gpio_setpull(S5PV210_GPD1(0), S3C_GPIO_PULL_NONE);     </span><br><span class="line">    s3c_gpio_cfgpin(S5PV210_GPD1(1), S3C_GPIO_SFN(2));      &#x2F;&#x2F; 设置控制寄存器为I2C0_SCL模式</span><br><span class="line">    s3c_gpio_setpull(S5PV210_GPD1(1), S3C_GPIO_PULL_NONE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>s3c_i2c0_cfg_gpio</code>函数只是对I2C控制器两根通信线的GPIO初始化。</p>
<p>接下去回到I2C总线驱动层<code>i2c-s3c2410.c</code>中, 进入到<code>s3c24xx_i2c_probe</code>函数进行分析。 probe函数的代码比较多，分段进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct s3c24xx_i2c *i2c;</span><br><span class="line">struct s3c2410_platform_i2c *pdata;</span><br><span class="line">struct resource *res;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取I2C平台数据</span><br><span class="line">pdata &#x3D; pdev-&gt;dev.platform_data;</span><br><span class="line">if (!pdata) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;no platform data\n&quot;);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c &#x3D; kzalloc(sizeof(struct s3c24xx_i2c), GFP_KERNEL);</span><br><span class="line">if (!i2c) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\n&quot;);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strlcpy(i2c-&gt;adap.name, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;adap.name));</span><br><span class="line">i2c-&gt;adap.owner   &#x3D; THIS_MODULE;</span><br><span class="line">i2c-&gt;adap.algo    &#x3D; &amp;s3c24xx_i2c_algorithm;      &#x2F;&#x2F; I2C主机控制器的操作方法</span><br><span class="line">i2c-&gt;adap.retries &#x3D; 2;</span><br><span class="line">i2c-&gt;adap.class   &#x3D; I2C_CLASS_HWMON | I2C_CLASS_SPD;</span><br><span class="line">i2c-&gt;tx_setup     &#x3D; 50;</span><br></pre></td></tr></table></figure>

<p>三星采用<code>struct s3c24xx_i2c</code>结构体来对SoC的控制器进行抽象，该结构体继承于<code>struct i2c_adapter</code>。该段代码先是从device中获取了平台数据，该平台数据即是上文调用<code>s3c_i2c0_set_platdata</code>函数时设置的。然后对<code>i2c-&gt;adap</code>进行了相关赋值，关键部分是<code>i2c-&gt;adap.algo = &amp;s3c24xx_i2c_algorithm;</code>，<code>adap.algo</code>表示I2C主机控制器的操作方法，将该SoC的操作方法挂接到了适配器上。<code>s3c24xx_i2c_algorithm</code>定义了两个操作方法，主要是<code>master_xfer</code>方法，用来发送消息。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static const struct i2c_algorithm s3c24xx_i2c_algorithm &#x3D; &#123;</span><br><span class="line">    .master_xfer        &#x3D; s3c24xx_i2c_xfer,</span><br><span class="line">    .functionality      &#x3D; s3c24xx_i2c_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>s3c24xx_i2c_xfer</code>涉及到对具体控制器的操作，不进行展开，但是注意的是其内部调用的是<code>s3c24xx_i2c_doxfer</code>，在<code>s3c24xx_i2c_doxfer</code>函数内部发送完数据后，调用<code>wait_event_timeout</code>函数来进行睡眠等待从机响应。因此可知内核中I2C的等待从机的ACK信号是通过中断实现的，即主机发送完数据后进入睡眠等待从机，从机响应后通过中断通知主机后唤醒。</p>
<p>probe函数接着做了获取时钟和使能时钟，相关代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取时钟</span><br><span class="line">    i2c-&gt;clk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);</span><br><span class="line"></span><br><span class="line">    if (IS_ERR(i2c-&gt;clk)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, &quot;cannot get clock\n&quot;);</span><br><span class="line">        ret &#x3D; -ENOENT;</span><br><span class="line">        goto err_noclk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;pdev-&gt;dev, &quot;clock source %p\n&quot;, i2c-&gt;clk);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使能时钟</span><br><span class="line">    clk_enable(i2c-&gt;clk);</span><br></pre></td></tr></table></figure>

<p>紧接着对具体IO和IRQ进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取I2C平台资源（IO内存地址、IRQ）</span><br><span class="line">res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">if (res &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot find IO resource\n&quot;);</span><br><span class="line">    ret &#x3D; -ENOENT;</span><br><span class="line">    goto err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c-&gt;ioarea &#x3D; request_mem_region(res-&gt;start, resource_size(res),</span><br><span class="line">                 pdev-&gt;name);</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;ioarea &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot request IO\n&quot;);</span><br><span class="line">    ret &#x3D; -ENXIO;</span><br><span class="line">    goto err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将物理地址映射为虚拟地址</span><br><span class="line">i2c-&gt;regs &#x3D; ioremap(res-&gt;start, resource_size(res));</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;regs &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot map IO\n&quot;);</span><br><span class="line">    ret &#x3D; -ENXIO;</span><br><span class="line">    goto err_ioarea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;pdev-&gt;dev, &quot;registers %p (%p, %p)\n&quot;,</span><br><span class="line">    i2c-&gt;regs, i2c-&gt;ioarea, res);</span><br><span class="line"></span><br><span class="line">&#x2F;* setup info block for the i2c core *&#x2F;</span><br><span class="line"></span><br><span class="line">i2c-&gt;adap.algo_data &#x3D; i2c;</span><br><span class="line">i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">&#x2F;* initialise the i2c controller *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化I2C控制器</span><br><span class="line">ret &#x3D; s3c24xx_i2c_init(i2c);    </span><br><span class="line">if (ret !&#x3D; 0)</span><br><span class="line">    goto err_iomap;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取IRQ资源</span><br><span class="line">i2c-&gt;irq &#x3D; ret &#x3D; platform_get_irq(pdev, 0);   </span><br><span class="line">if (ret &lt;&#x3D; 0) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot find IRQ\n&quot;);</span><br><span class="line">    goto err_iomap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 申请IRQ (裸机一般使用查询法来判断从机的响应，而内核一般采用中断方式等待从机响应)</span><br><span class="line">ret &#x3D; request_irq(i2c-&gt;irq, s3c24xx_i2c_irq, IRQF_DISABLED,</span><br><span class="line">          dev_name(&amp;pdev-&gt;dev), i2c);</span><br></pre></td></tr></table></figure>

<p>把关注点放在初始化I2C控制器的<code>s3c24xx_i2c_init</code>函数和申请IRQ上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int s3c24xx_i2c_init(struct s3c24xx_i2c *i2c)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long iicon &#x3D; S3C2410_IICCON_IRQEN | S3C2410_IICCON_ACKEN;</span><br><span class="line">    struct s3c2410_platform_i2c *pdata;</span><br><span class="line">    unsigned int freq;</span><br><span class="line"></span><br><span class="line">    &#x2F;* get the plafrom data *&#x2F;</span><br><span class="line"></span><br><span class="line">    pdata &#x3D; i2c-&gt;dev-&gt;platform_data;</span><br><span class="line"></span><br><span class="line">    &#x2F;* inititalise the gpio *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (pdata-&gt;cfg_gpio)</span><br><span class="line">        pdata-&gt;cfg_gpio(to_platform_device(i2c-&gt;dev));      &#x2F;&#x2F; 设置I2C对应的管脚</span><br><span class="line"></span><br><span class="line">    &#x2F;* write slave address *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 设置I2C控制器作为从设备时的地址</span><br><span class="line">    writeb(pdata-&gt;slave_addr, i2c-&gt;regs + S3C2410_IICADD);  </span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;slave address 0x%02x\n&quot;, pdata-&gt;slave_addr);</span><br><span class="line"></span><br><span class="line">    writel(iicon, i2c-&gt;regs + S3C2410_IICCON);        &#x2F;&#x2F; 使能 Tx&#x2F;Rx Interrupt 和 ACK信号</span><br><span class="line"></span><br><span class="line">    &#x2F;* we need to work out the divisors for the clock... *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 配置I2C的时钟频率</span><br><span class="line">    if (s3c24xx_i2c_clockrate(i2c, &amp;freq) !&#x3D; 0) &#123;</span><br><span class="line">        writel(0, i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line">        dev_err(i2c-&gt;dev, &quot;cannot meet bus frequency required\n&quot;);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* todo - check that the i2c lines aren&#39;t being dragged anywhere *&#x2F;</span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;bus frequency set to %d KHz\n&quot;, freq);</span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;S3C2410_IICCON&#x3D;0x%02lx\n&quot;, iicon);</span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;S3C2440_IICLC&#x3D;%08x\n&quot;, pdata-&gt;sda_delay);</span><br><span class="line">    writel(pdata-&gt;sda_delay, i2c-&gt;regs + S3C2440_IICLC);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到设置I2C对应的管脚是调用平台数据中的<code>cfg_gpio</code>，其实看到这里如果还有印象的话就能反应出来这是在调用<code>s3c_i2c0_set_platdata</code>中设置的。该函数还设置了I2C控制器的从地址，该地址用来在控制器作为从地址时使用，但是这种情况的出现微乎其微。除此之外使能Tx/Rx Interrupt和ACK信号，配置了I2C的时钟频率。</p>
<p>注意从前一段分析中得知，内核中I2C采用中断方式等待从机响应，所以probe函数这一段代码中申请了IRQ并绑定了中断处理函数<code>s3c24xx_i2c_irq</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c24xx_i2c *i2c &#x3D; dev_id;</span><br><span class="line">    unsigned long status;</span><br><span class="line">    unsigned long tmp;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取I2CSTAT寄存器的值</span><br><span class="line">    status &#x3D; readl(i2c-&gt;regs + S3C2410_IICSTAT);</span><br><span class="line"></span><br><span class="line">    if (status &amp; S3C2410_IICSTAT_ARBITR) &#123;   &#x2F;&#x2F; I2C总线仲裁失败</span><br><span class="line">        &#x2F;* deal with arbitration loss *&#x2F;</span><br><span class="line">        dev_err(i2c-&gt;dev, &quot;deal with arbitration loss\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (i2c-&gt;state &#x3D;&#x3D; STATE_IDLE) &#123;</span><br><span class="line">        dev_dbg(i2c-&gt;dev, &quot;IRQ: error i2c-&gt;state &#x3D;&#x3D; IDLE\n&quot;);</span><br><span class="line"></span><br><span class="line">        tmp &#x3D; readl(i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line">        tmp &amp;&#x3D; ~S3C2410_IICCON_IRQPEND;</span><br><span class="line">        writel(tmp, i2c-&gt;regs +  S3C2410_IICCON);</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* pretty much this leaves us with the fact that we&#39;ve</span><br><span class="line">     * transmitted or received whatever byte we last sent *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理I2C的收发数据</span><br><span class="line">    i2c_s3c_irq_nextbyte(i2c, status);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体也不展开分析了，但是要注意的是有这么一条线：该中断处理函数调用了<code>i2c_s3c_irq_nextbyte</code>，然后内部调用了<code>s3c24xx_i2c_stop</code>，再内部调用了<code>s3c24xx_i2c_master_complete</code>，最后再内部执行了一个关键代码<code>wake_up(&amp;i2c-&gt;wait);</code>，这就是通过中断方式唤醒之前在发送数据时进行的睡眠等待。</p>
<p>回到probe函数，最后分析重头戏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; i2c_add_numbered_adapter(&amp;i2c-&gt;adap);</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;failed to add bus to i2c core\n&quot;);</span><br><span class="line">    goto err_cpufreq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码将I2C适配器注册到了内核中。<code>i2c_add_numbered_adapter</code>函数由核心层提供，其定义位于I2C核心层<code>drivers/i2c/i2c-core.c</code>中，用来注册I2C适配器。其实在内核中提供了两个adapter注册接口,分别为<code>i2c_add_adapter</code>和<code>i2c_add_numbered_adapter</code>由于在系统中可能存在多个adapter, 所以将每一条I2C总线(控制器)对应一个编号，这个总线号（可以称这个编号为总线号码）与PCI中的总线号不同。它和硬件无关, 只是软件上便于区分而已。对于<code>i2c_add_adapter</code>而言, 它使用的是动态总线号, 即由系统给其分配一个总线号, 而<code>i2c_add_numbered_adapter</code>则是自己指定总线号, 如果这个总线号非法或者是被占用, 就会注册失败。不管哪个注册接口，其核心都是调用<code>i2c_register_adapter</code>函数来进行真正的注册。取出<code>i2c_register_adapter</code>函数的关键部分进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res &#x3D; device_register(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">    i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">dummy &#x3D; bus_for_each_drv(&amp;i2c_bus_type, NULL, adap,</span><br><span class="line">             __process_new_adapter);</span><br></pre></td></tr></table></figure>

<p><code>device_register(&amp;adap-&gt;dev);</code>表示主机适配器adapter的注册。</p>
<p><code>i2c_scan_static_board_info(adap);</code>内部先遍历<code>__i2c_board_list</code>取出板卡信息（描述的是板子上的I2C外设的信息，即I2C从机的信息），该链表的生成是在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中进行的，在<code>mach-x210.c</code>中的<code>smdkc110_machine_init</code>函数中进行了除之前分析的调用<code>s3c_i2c0_set_platdata</code>外，还调用了<code>i2c_register_board_info</code>对板卡信息进行了注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int __init</span><br><span class="line">i2c_register_board_info(int busnum,</span><br><span class="line">    struct i2c_board_info const *info, unsigned len)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    down_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    &#x2F;* dynamic bus numbers will be assigned after the last static one *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; __i2c_first_dynamic_bus_num为全局未显式初始化变量，所以第一次进到这个函数，值为0</span><br><span class="line">    if (busnum &gt;&#x3D; __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num &#x3D; busnum + 1;</span><br><span class="line"></span><br><span class="line">    for (status &#x3D; 0; len; len--, info++) &#123;</span><br><span class="line">        struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo &#x3D; kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">        if (!devinfo) &#123;</span><br><span class="line">            pr_debug(&quot;i2c-core: can&#39;t register boardinfo!\n&quot;);</span><br><span class="line">            status &#x3D; -ENOMEM;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum &#x3D; busnum;</span><br><span class="line">        devinfo-&gt;board_info &#x3D; *info;</span><br><span class="line">        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);    &#x2F;&#x2F; 将board_info用链表管理起来 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>板卡信息的描述，主要对其设备名和从地址进行赋值，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define I2C_BOARD_INFO(dev_type, dev_addr) \</span><br><span class="line">    .type &#x3D; dev_type, .addr &#x3D; (dev_addr)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TOUCHSCREEN_GSLX680</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;gslX680&quot;, 0x40),  &#x2F;&#x2F; 主要对其设备名和从地址进行赋值</span><br><span class="line">    &#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>然后在<code>i2c_scan_static_board_info</code>内部利用板卡信息作为原料调用<code>i2c_new_device</code>来创建了client，表示从机设备，并将adapter挂接到了client结构体内部的指针上。<code>i2c_scan_static_board_info</code>代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;__i2c_board_lock);</span><br><span class="line">    &#x2F;&#x2F; __i2c_board_list在调用i2c_register_board_info时链接起来的</span><br><span class="line">    list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class="line">        if (devinfo-&gt;busnum &#x3D;&#x3D; adapter-&gt;nr</span><br><span class="line">                &amp;&amp; !i2c_new_device(adapter,</span><br><span class="line">                        &amp;devinfo-&gt;board_info))</span><br><span class="line">            dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">                &quot;Can&#39;t create device at 0x%02x\n&quot;,</span><br><span class="line">                devinfo-&gt;board_info.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    up_read(&amp;__i2c_board_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完client后，回到<code>i2c_register_adapter</code>函数，最后执行了<code>dummy = bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</code>，<strong>该函数是遍历在I2C总线上已经注册的driver，通过回调<code>__process_new_adapter</code>函数的方式，遍历到i2c-dev这个通用驱动后就会用其<code>i2cdev_attach_adapter</code>方法来挂接到在i2c-dev中注册的字符设备驱动，并使用这个字符设备驱动的主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点，应用层访问这个设备节点后即可调用在i2c-dev中注册的file_operations中的操作方法，从操作方法源码知，最终读写调用的是adapter中的读写方法（即在本平台中为i2c-s3c2410.c中定义的方法）</strong>。下面对其进行验证。</p>
<p><code>__process_new_adapter</code>展开如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_do_add_adapter(struct i2c_driver *driver,</span><br><span class="line">                  struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* Detect supported devices on that bus, and instantiate them *&#x2F;</span><br><span class="line">    i2c_detect(adap, driver);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Let legacy drivers scan this bus for matching devices *&#x2F;</span><br><span class="line">    if (driver-&gt;attach_adapter) &#123;</span><br><span class="line">        &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;</span><br><span class="line">        driver-&gt;attach_adapter(adap);   &#x2F;&#x2F; 调用i2c-dev中的i2cdev_attach_adapter方法</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __process_new_adapter(struct device_driver *d, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    return i2c_do_add_adapter(to_i2c_driver(d), data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>driver-&gt;attach_adapter(adap);</code>，的确是调用I2C总线下的驱动中的<code>attach_adapter</code>方法，到了这里在I2C设备驱动层埋下的悬念终于要水落石出了（不容易啊啊啊啊啊啊），穿越回到I2C设备驱动层进行分析，进入<code>drivers/i2c/i2c-dev.c</code>分析<code>i2cdev_attach_adapter</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static int i2cdev_attach_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_dev *i2c_dev;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    i2c_dev &#x3D; get_free_i2c_dev(adap);</span><br><span class="line">    if (IS_ERR(i2c_dev))</span><br><span class="line">        return PTR_ERR(i2c_dev);</span><br><span class="line"></span><br><span class="line">    &#x2F;* register this i2c device with the driver core *&#x2F;</span><br><span class="line">    &#x2F;* 使用主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点 *&#x2F;</span><br><span class="line">    i2c_dev-&gt;dev &#x3D; device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">                     MKDEV(I2C_MAJOR, adap-&gt;nr), NULL,</span><br><span class="line">                     &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">    if (IS_ERR(i2c_dev-&gt;dev)) &#123;</span><br><span class="line">        res &#x3D; PTR_ERR(i2c_dev-&gt;dev);</span><br><span class="line">        goto error;</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">    if (res)</span><br><span class="line">        goto error_destroy;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;,</span><br><span class="line">         adap-&gt;name, adap-&gt;nr);</span><br><span class="line">    return 0;</span><br><span class="line">error_destroy:</span><br><span class="line">    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line">error:</span><br><span class="line">    return_i2c_dev(i2c_dev);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev, MKDEV(I2C_MAJOR, adap-&gt;nr), NULL, &quot;i2c-%d&quot;, adap-&gt;nr);</code>使用主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t i2cdev_write(struct file *file, const char __user *buf,</span><br><span class="line">        size_t count, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    char *tmp;</span><br><span class="line">    &#x2F;&#x2F; 取出i2c_client</span><br><span class="line">    struct i2c_client *client &#x3D; file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    if (count &gt; 8192)</span><br><span class="line">        count &#x3D; 8192;</span><br><span class="line"></span><br><span class="line">    tmp &#x3D; kmalloc(count, GFP_KERNEL);</span><br><span class="line">    if (tmp &#x3D;&#x3D; NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#x2F;&#x2F; 拷贝用户数据到内核空间</span><br><span class="line">    if (copy_from_user(tmp, buf, count)) &#123;</span><br><span class="line">        kfree(tmp);</span><br><span class="line">        return -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;,</span><br><span class="line">        iminor(file-&gt;f_path.dentry-&gt;d_inode), count);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送I2C数据</span><br><span class="line">    ret &#x3D; i2c_master_send(client, tmp, count);</span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以write函数为例，可以看到写数据通过<code>ret = i2c_master_send(client, tmp, count);</code>完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i2c_master_send(struct i2c_client *client, const char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    &#x2F;&#x2F; 获取I2C适配器</span><br><span class="line">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 封装I2C数据包</span><br><span class="line">    msg.addr &#x3D; client-&gt;addr;</span><br><span class="line">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;   &#x2F;&#x2F; 发送标志位</span><br><span class="line">    msg.len &#x3D; count;</span><br><span class="line">    msg.buf &#x3D; (char *)buf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送I2C数据包</span><br><span class="line">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;* If everything went ok (i.e. 1 msg transmitted), return #bytes</span><br><span class="line">       transmitted, else error code. *&#x2F;</span><br><span class="line">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，经过I2C数据包的封装后，真正的最终写数据通过<code>ret = i2c_transfer(adap, &amp;msg, 1);</code>完成的。进入到<code>i2c_transfer</code>函数，截取关键部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (ret &#x3D; 0, try &#x3D; 0; try &lt;&#x3D; adap-&gt;retries; try++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用具体的SoC的I2C总线驱动的发送方法</span><br><span class="line">    ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line">    if (ret !&#x3D; -EAGAIN)</span><br><span class="line">        break;</span><br><span class="line">    if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</code>终于回到了原点见到了I2C总线驱动层中定义的操作方法。</p>
<p>可以看到过程的确如上文所说，表现为<strong>从I2C总线驱动层自底向上后又由自顶向下的调用流程</strong>，简直一跃千里后又倾泻而下。</p>
<h2 id="I2C特定设备驱动分析"><a href="#I2C特定设备驱动分析" class="headerlink" title="I2C特定设备驱动分析"></a>I2C特定设备驱动分析</h2><p>笔者以S5PV210的E2PROM驱动为例讲解, 源码见<a href="https://github.com/IfanTsai/LinuxDriver/blob/master/i2c/at24c02.c" target="_blank" rel="noopener">github链接</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct e2prom_device &#123;</span><br><span class="line">    struct i2c_client *at24c02_client;   &#x2F;* I2C client(从设备) *&#x2F;</span><br><span class="line">    &#x2F;* class和device用来自动创建设备节点 *&#x2F;</span><br><span class="line">    struct class      *at24c02_class;</span><br><span class="line">    struct device     *at24c02_device;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct e2prom_device *e2prom_dev;</span><br></pre></td></tr></table></figure>

<p>封装一个<code>e2prom_device</code>结构体表示对E2PROM的抽象，其中包含I2C client（用来表示I2C从设备）以及class和device（这两者单纯是用来自动创建设备节点的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_device_id e2prom_table[] &#x3D; &#123;</span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">        .name         &#x3D; &quot;24c02&quot;,</span><br><span class="line">        .driver_data  &#x3D; 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .name         &#x3D; &quot;24c08&quot;,</span><br><span class="line">        .driver_data  &#x3D; 0,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* I2C设备驱动 *&#x2F;</span><br><span class="line">struct i2c_driver e2prom_driver &#x3D; &#123;</span><br><span class="line">    .probe     &#x3D;  e2prom_probe,</span><br><span class="line">    .remove    &#x3D;  e2prom_remove,</span><br><span class="line">    .id_table  &#x3D;  e2prom_table,</span><br><span class="line">    .driver    &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;e2prom&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init e2prom_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    return i2c_add_driver(&amp;e2prom_driver);   &#x2F;* 注册I2C设备驱动 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是调用<code>i2c_add_driver</code>注册I2C设备驱动。根据上文在I2C核心层的源码分析可知，会通过在核心层中注册的<code>i2c_bus_type</code>下的<code>i2c_device_match</code>函数来匹配设备与驱动，一旦匹配上则会调用其<code>i2c_device_probe</code>函数，而<code>i2c_device_probe</code>函数又会调用i2c_driver的probe函数。注意如上文分析所知，client生成的原料为board_info，所以要使这个驱动成功匹配，需要在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中使用<code>i2c_register_board_info</code>来注册board_info。接下去直奔prob函数进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations e2prom_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open  &#x3D; e2prom_open,</span><br><span class="line">    .write &#x3D; e2prom_write,</span><br><span class="line">    .read &#x3D;  e2prom_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int e2prom_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;e2prom probe!\n&quot;);</span><br><span class="line">    e2prom_dev &#x3D; kmalloc(sizeof(struct e2prom_device), GFP_KERNEL);</span><br><span class="line">    if (!e2prom_dev) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;malloc failed!\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e2prom_dev-&gt;at24c02_client &#x3D; client;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册为字符设备驱动 *&#x2F;</span><br><span class="line">    ret &#x3D; register_chrdev(E2PROM_MAJOR, &quot;e2prom_module&quot;, &amp;e2prom_fops);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;malloc failed\n&quot;);</span><br><span class="line">        ret &#x3D; -ENOMEM;</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建类  *&#x2F;</span><br><span class="line">    e2prom_dev-&gt;at24c02_class &#x3D; class_create(THIS_MODULE, &quot;e2prom_class&quot;);</span><br><span class="line">    if (IS_ERR(e2prom_dev-&gt;at24c02_class)) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;class create failed!\n&quot;);</span><br><span class="line">        ret &#x3D; PTR_ERR(e2prom_dev-&gt;at24c02_class);</span><br><span class="line">        goto err1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 在类下创建设备 *&#x2F;</span><br><span class="line">    e2prom_dev-&gt;at24c02_device &#x3D; device_create(e2prom_dev-&gt;at24c02_class, NULL, MKDEV(E2PROM_MAJOR, 0), NULL, &quot;at24c08&quot;);</span><br><span class="line">    if (IS_ERR(e2prom_dev-&gt;at24c02_device)) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;class create failed!\n&quot;);</span><br><span class="line">        ret &#x3D; PTR_ERR(e2prom_dev-&gt;at24c02_device);</span><br><span class="line">        goto err1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">err1:</span><br><span class="line">    unregister_chrdev(E2PROM_MAJOR, &quot;e2prom_module&quot;);</span><br><span class="line">err0:</span><br><span class="line">    kfree(e2prom_dev);</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>在probe函数中调用<code>register_chrdev</code>函数来将E2PROM驱动注册为了字符设备驱动，并绑定了fops。然后调用<code>class_create</code>和<code>device_create</code>自动生成设备节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int e2prom_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open方法为空，以write方法为例讲解具体的操作，read方法类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t e2prom_write(struct file *file, const char __user *buf,</span><br><span class="line">        size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    char *tmp;</span><br><span class="line">    tmp &#x3D; kmalloc(size, GFP_KERNEL);</span><br><span class="line">    if (tmp &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;mallo failed!\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 将用户空间数据拷贝到内核空间 *&#x2F;</span><br><span class="line">    ret &#x3D; copy_from_user(tmp, buf, size);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(&quot;copy data faile!\n&quot;);</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* I2C write *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_write_byte(tmp, size);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;wrtie byte failed!\n&quot;);</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return size;</span><br><span class="line"></span><br><span class="line">err0:</span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到真正的操作I2C在<code>i2c_write_byte</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_write_byte(char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 封装I2C数据包 *&#x2F;</span><br><span class="line">    msg.addr   &#x3D; e2prom_dev-&gt;at24c02_client-&gt;addr; &#x2F;* I2C从设备地址 *&#x2F;</span><br><span class="line">    msg.flags  &#x3D; 0;                                &#x2F;* write flag *&#x2F;</span><br><span class="line">    msg.len    &#x3D; count;                            &#x2F;* 数据长度 *&#x2F;</span><br><span class="line">    msg.buf    &#x3D; buf;                              &#x2F;* 写入的数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 调用I2C核心层提供的传输函数，其本质还是调用的I2C总线驱动(主机控制器驱动)层下实现的algo-&gt;master_xfe方法 *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_transfer(e2prom_dev-&gt;at24c02_client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;i2c transfer failed!\n&quot;);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是调用在I2C核心层提供的传输函数，其本质还是在传输函数内部调用了跟具体SoC相关的I2C主机控制器操作方法中的传输方法。该函数接口需要提供一个<code>i2c_msg</code>，所以对其进行了创建并填充，注意<code>msg.flags = 0;</code>中0表示写，1表示读。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/13/Linux/Driver/Input/maXTouch%20Object%20Protocol%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/Linux/Driver/Input/maXTouch%20Object%20Protocol%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">Microchip maXTouch Object Protocol理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-13 19:08:31" itemprop="dateCreated datePublished" datetime="2021-01-13T19:08:31+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 16:34:38" itemprop="dateModified" datetime="2021-01-15T16:34:38+08:00">2021-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microchip 为maXTouch controllers编写一份 不依赖芯片平台的Object Protocol，Object Protocol可以在每个芯片中进行移植，兼容主机驱动。那么如何理解Object Protocol？</p>
<p>本文讲解mXT2952TD芯片的Object Protocol  ，版本为version 1.0。</p>
<h2 id="Memory-Map-Structure-of-Object"><a href="#Memory-Map-Structure-of-Object" class="headerlink" title="Memory Map Structure of Object"></a>Memory Map Structure of Object</h2><p>设计协议的目的就是实现模块化管理。将芯片的整体功能，划分一个个小功能模块，一个模块代表某些特征，比如触摸屏功能。object可以理解为一个模块，代表触摸屏芯片的某一个功能。根据功能需要，object可以使能或者不使能。</p>
<p>每个object都有自己的配置空间，object 配置空间的内存映射如下：</p>
<p><img src="http://jiali.clouddn.com/20210113_001.png" alt=""></p>
<p>​                                                                                                             图 object 内存映射</p>
<p>ID Information ：芯片的基本信息</p>
<p>Objects：各种类型的object在内存的具体位置</p>
<p>Object Table:每一种object都有自己的object table,用来描述object的基本信息。</p>
<h3 id="如何理解Object-Table"><a href="#如何理解Object-Table" class="headerlink" title="如何理解Object Table"></a>如何理解Object Table</h3><p>Object Table的格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210113_002.png" alt=""></p>
<p>​                                                                                                                图 object table字段说明 </p>
<p><strong>Type:</strong>每种object都有唯一的类型识别码（1、2、3、4、5…）.比如Command Processor T6的识别码就是6，Command Processor T代表处理器的名字前缀，完整的名字就是Command Processor T6.</p>
<p><strong>start position:</strong>Object在内存映射的开始位置。用两个字节表示一个内存地址LSByte代表低字节,MSByte代表高字节。因此驱动程序读写object,需要知道object在内存映射中的地址，并且使用该地址与object交流数据</p>
<p><strong>size:</strong>object占多大的内存</p>
<p><strong>instance:</strong>表示相同类型的object的数量，也就是相同类型的object有多少个。 多个object instance在内存中的位置是按顺序分配。</p>
<p><strong>Report ID:</strong>object 传递消息给host，消息自带有Report ID,host通过Report ID来识别消息来自哪个object.每一个object instance，可以拥有一组 Report ID,也可以为一个Report ID.</p>
<p> 如何计算object的Report ID数量呢？</p>
<ul>
<li>读取 object table byte 4的值+1</li>
<li>读取object table byte 5的值</li>
<li>最后，将它们相乘的结果减1，就是一个object instance 最大的report id。</li>
</ul>
<p>注意：</p>
<p>所有object 的report id是按照顺序排列的，芯片规定从1开始排列report id。report id 分配如下图</p>
<p><img src="http://jiali.clouddn.com/20210114_001.png" alt=""></p>
<p>​                     </p>
<p>​                                                                                                 图 object report id 划分</p>
<p>report id 排列算法：</p>
<p>report_id=1</p>
<p><strong>object 1 report id 划分：</strong></p>
<p>min_id=report_id</p>
<p>report_id+=1*1，结果为2</p>
<p>max_id=report_id-1,结果为1</p>
<p><strong>object 2 report id 划分：</strong></p>
<p>min_id=object 1计算出来的report id 也就是2</p>
<p>report_id+=2*10，结果为22</p>
<p>max_id=report_id-1,结果为21</p>
<p><strong>object 3 report id 划分：</strong></p>
<p>min_id=object 2计算出来的report id 也就是22</p>
<p>report_id+=2*1，结果为24</p>
<p>max_id=report_id-1,结果为23</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	int i;</span><br><span class="line">	u8 reportid;</span><br><span class="line">	</span><br><span class="line">	reportid &#x3D; 1;</span><br><span class="line">	data-&gt;mem_size &#x3D; 0;</span><br><span class="line">	for (i &#x3D; 0; i &lt; data-&gt;info-&gt;object_num; i++) &#123;</span><br><span class="line">		struct mxt_object *object &#x3D; object_table + i;</span><br><span class="line">		u8 min_id, max_id;</span><br><span class="line"></span><br><span class="line">		le16_to_cpus(&amp;object-&gt;start_address);</span><br><span class="line"></span><br><span class="line">		if (object-&gt;num_report_ids) &#123;</span><br><span class="line">			min_id &#x3D; reportid;</span><br><span class="line">			reportid +&#x3D; object-&gt;num_report_ids *</span><br><span class="line">					mxt_obj_instances(object);</span><br><span class="line">			max_id &#x3D; reportid - 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			min_id &#x3D; 0;</span><br><span class="line">			max_id &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>host 驱动遍历mXT2952T2的Object ID 列表如下：</p>
<p><img src="http://jiali.clouddn.com/mxt_oject_list.png" alt=""> </p>
<p>​                                                           图 mXT2952T2的Object ID 列表</p>
<p>从上图可以理解instance：</p>
<p>比如T61 一个object instance的配置项如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_002.png" alt=""></p>
<p>​                                                                                                                                   图 T61 object 配置空间</p>
<p>所以，T61有几个instance，就有几个上面的配置空间。因此，T61占用内存空间大小为instance的数量乘以object配置空间的大小。                  </p>
<h3 id="object-分类"><a href="#object-分类" class="headerlink" title="object 分类"></a>object 分类</h3><p>The mXT2952TD contains the following classes of objects:<br>• Debug objects – provide a raw data output method for development and testing.<br>See Section 2.0 “Debug Objects”.<br>• General objects – required for global configuration, transmitting messages and receiving commands. See<br>Section 3.0 “General Objects”.<br>• Touch objects – operate on measured signals from the touch sensor and report touch data. See Section 4.0<br>“Touch Objects”.<br>• Signal processing objects – process data from other objects (typically signal filtering operations). See<br>Section 5.0 “Signal Processing Objects”.<br>• Support objects – provide additional functionality on the device. See Section 6.0 “Support Objects”.</p>
<h2 id="重要的object分析"><a href="#重要的object分析" class="headerlink" title="重要的object分析"></a>重要的object分析</h2><p>挑几个用到的object来讲解一下使用方法。</p>
<h3 id="Message-Processor-T5-Object"><a href="#Message-Processor-T5-Object" class="headerlink" title="Message Processor T5 Object"></a>Message Processor T5 Object</h3><p>Message Processor T5 object 的作用就是用来传递最新的消息给Host.所有产生消息的object 都通过Message Processor T5 object 传递给host.因此，maXTouch controllers 使用Message Processor T5 object与外界Host进行交流数据。</p>
<p>当maXTouch controllers有消息发送时候，通过CHG Line的电平拉低来告诉host消息已经生成，请Host去读消息，并且使用report id识别消息来自哪个object。因此，host 驱动检测CHG Line的电平，通过中断的方式来读取maXTouch controllers的消息。</p>
<p>Message Processor T5 Object 的配置空间如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_003.png" alt=""></p>
<p>​                                                                                                    图 Message Processor T5 Object 的配置空间</p>
<p><strong>REPORTID:</strong> 表示产生消息的object</p>
<p><strong>MESSAGE:</strong> object产生的消息内容</p>
<p>maXTouch controllers支持DMA读取Message Processor T5 Object的消息，具体配置如下：</p>
<ul>
<li>先读取Message Count T44 Object 的消息个数</li>
<li>然后根据消息个数，全部读取Message Processor T5 Object的消息</li>
</ul>
<p>程序处理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Read T44 and T5 together *&#x2F;</span><br><span class="line">	ret &#x3D; __mxt_read_reg(data-&gt;client, data-&gt;T44_address,</span><br><span class="line">		data-&gt;T5_msg_size + 1, data-&gt;msg_buf);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_err(dev, &quot;Failed to read T44 and T5 (%d)\n&quot;, ret);</span><br><span class="line">		return IRQ_NONE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count &#x3D; data-&gt;msg_buf[0];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int mxt_read_and_process_messages(struct mxt_data *data, u8 count)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	int ret;</span><br><span class="line">	int i;</span><br><span class="line">	u8 num_valid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Safety check for msg_buf *&#x2F;</span><br><span class="line">	if (count &gt; data-&gt;max_reportid)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process remaining messages if necessary *&#x2F;</span><br><span class="line">	ret &#x3D; __mxt_read_reg(data-&gt;client, data-&gt;T5_address,</span><br><span class="line">				data-&gt;T5_msg_size * count, data-&gt;msg_buf);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_err(dev, &quot;Failed to read %u messages (%d)\n&quot;, count, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return num_valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Message-Processor-T44-Object"><a href="#Message-Processor-T44-Object" class="headerlink" title="Message Processor T44 Object"></a>Message Processor T44 Object</h3><p>统计存储在缓存中的消息个数，用于DMA读取数据。配置空间如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_004.png" alt=""></p>
<p>​                                                                                                                   图 T44 Object 配置空间</p>
<h3 id="Multiple-Touch-Touchscreen-T100-Object"><a href="#Multiple-Touch-Touchscreen-T100-Object" class="headerlink" title="Multiple Touch Touchscreen T100 Object"></a>Multiple Touch Touchscreen T100 Object</h3><p>1、T100 Object 配置空间</p>
<p>略</p>
<p>2、T100 Object产生消息的格式</p>
<p>The Multiple Touch Touchscreen T100 object reports the following screen and touch status information:<br>• Screen status information, such as the number of nodes affected and the number of reported touches<br>• Finger touches detected by the Multiple Touch Touchscreen T100 object<br>• Passive stylus touches detected by the Passive Stylus T47 object<br>• Glove touches detected by the Glove Detection T78 object<br>• Grip suppression by the Grip Suppression T40 object<br>• Screen suppression by the Touch Suppression T42 object</p>
<p>当手指触摸屏幕时候，T100 Object 产生消息，report id 分别为46-63。</p>
<p>（1）第一个report id产生的消息</p>
<p>该消息用来报告触摸屏的状态，消息格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_005.png" alt=""></p>
<p>​                                                                                                               图 T100 reportid=46消息格式</p>
<p>（2）第二个report id产生的消息</p>
<p>该消息用作预留功能。</p>
<p><img src="http://jiali.clouddn.com/20210114_006.png" alt=""></p>
<p>​                                                                                                             图 T100 reportid=46消息格式 </p>
<p>（2）剩余report id产生的消息</p>
<p>剩余的16个report id用于报告触摸点的信息。maXTouch controllers支持同时操作16个触摸点，因此在剩余的16个report id中，每一个report id产生的消息代表一个触摸点。消息格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_007.png" alt=""></p>
<p>​                                                                                                        图 其中一个触摸点的消息格式</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>1、单个手指触摸，读取message</p>
<p><img src="http://jiali.clouddn.com/20210115_004.png" alt=""></p>
<p>2、两个手指同时触摸，读取message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">~ # dmesg -c</span><br><span class="line">[ 2855.705442] in mxt_interrpt</span><br><span class="line">[ 2855.705457] in data-&gt;T44_address</span><br><span class="line">[ 2855.705920] report_id:46</span><br><span class="line">[ 2855.705926] msg_buf[0]:46 msg_buf[1]:128 msg_buf[2]:0 msg_buf[3]:0 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.705952] mxt_proc_t100_message</span><br><span class="line">[ 2855.706680] mxt_read_and_process_messages count 2, report_id 48,t5_msg_size:10</span><br><span class="line">[ 2855.706690] report_id:48</span><br><span class="line">[ 2855.706695] msg_buf[0]:48 msg_buf[1]:148 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.706747] mxt_proc_t100_message</span><br><span class="line">[ 2855.706754] mxt_read_and_process_messages count 2, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.706762] report_id:49</span><br><span class="line">[ 2855.706767] msg_buf[0]:49 msg_buf[1]:148 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.720988] in mxt_interrpt</span><br><span class="line">[ 2855.721004] in data-&gt;T44_address</span><br><span class="line">[ 2855.721480] report_id:48</span><br><span class="line">[ 2855.721486] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.721523] mxt_proc_t100_message</span><br><span class="line">[ 2855.721989] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.721999] report_id:49</span><br><span class="line">[ 2855.722004] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.736746] in mxt_interrpt</span><br><span class="line">[ 2855.736755] in data-&gt;T44_address</span><br><span class="line">[ 2855.737202] report_id:48</span><br><span class="line">[ 2855.737207] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.737238] mxt_proc_t100_message</span><br><span class="line">[ 2855.737684] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.737693] report_id:49</span><br><span class="line">[ 2855.737698] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.752528] in mxt_interrpt</span><br><span class="line">[ 2855.752535] in data-&gt;T44_address</span><br><span class="line">[ 2855.752974] report_id:48</span><br><span class="line">[ 2855.752980] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.753009] mxt_proc_t100_message</span><br><span class="line">[ 2855.753450] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.753458] report_id:49</span><br><span class="line">[ 2855.753463] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.768293] in mxt_interrpt</span><br><span class="line">[ 2855.768306] in data-&gt;T44_address</span><br><span class="line">[ 2855.768761] report_id:48</span><br><span class="line">[ 2855.768768] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.768804] mxt_proc_t100_message</span><br><span class="line">[ 2855.769246] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.769255] report_id:49</span><br><span class="line">[ 2855.769259] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.784113] in mxt_interrpt</span><br><span class="line">[ 2855.784122] in data-&gt;T44_address</span><br><span class="line">[ 2855.784578] report_id:48</span><br><span class="line">[ 2855.784584] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.784615] mxt_proc_t100_message</span><br><span class="line">[ 2855.785057] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.785065] report_id:49</span><br><span class="line">[ 2855.785070] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.799808] in mxt_interrpt</span><br><span class="line">[ 2855.799817] in data-&gt;T44_address</span><br><span class="line">[ 2855.800262] report_id:48</span><br><span class="line">[ 2855.800268] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.800300] mxt_proc_t100_message</span><br><span class="line">[ 2855.800748] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.800758] report_id:49</span><br><span class="line">[ 2855.800762] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.815623] in mxt_interrpt</span><br><span class="line">[ 2855.815630] in data-&gt;T44_address</span><br><span class="line">[ 2855.816069] report_id:48</span><br><span class="line">[ 2855.816075] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.816104] mxt_proc_t100_message</span><br><span class="line">[ 2855.816549] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.816559] report_id:49</span><br><span class="line">[ 2855.816563] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.831364] in mxt_interrpt</span><br><span class="line">[ 2855.831371] in data-&gt;T44_address</span><br><span class="line">[ 2855.831818] report_id:48</span><br><span class="line">[ 2855.831824] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.831854] mxt_proc_t100_message</span><br><span class="line">[ 2855.832293] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.832301] report_id:49</span><br><span class="line">[ 2855.832306] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.847125] in mxt_interrpt</span><br><span class="line">[ 2855.847133] in data-&gt;T44_address</span><br><span class="line">[ 2855.847578] report_id:48</span><br><span class="line">[ 2855.847585] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.847614] mxt_proc_t100_message</span><br><span class="line">[ 2855.848055] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.848063] report_id:49</span><br><span class="line">[ 2855.848068] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.862910] in mxt_interrpt</span><br><span class="line">[ 2855.862918] in data-&gt;T44_address</span><br><span class="line">[ 2855.863355] report_id:48</span><br><span class="line">[ 2855.863361] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.863389] mxt_proc_t100_message</span><br><span class="line">[ 2855.863836] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.863845] report_id:49</span><br><span class="line">[ 2855.863850] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.878673] in mxt_interrpt</span><br><span class="line">[ 2855.878681] in data-&gt;T44_address</span><br><span class="line">[ 2855.879120] report_id:48</span><br><span class="line">[ 2855.879125] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.879155] mxt_proc_t100_message</span><br><span class="line">[ 2855.879597] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.879606] report_id:49</span><br><span class="line">[ 2855.879612] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.894455] in mxt_interrpt</span><br><span class="line">[ 2855.894462] in data-&gt;T44_address</span><br><span class="line">[ 2855.894901] report_id:48</span><br><span class="line">[ 2855.894907] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.894936] mxt_proc_t100_message</span><br><span class="line">[ 2855.895375] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.895383] report_id:49</span><br><span class="line">[ 2855.895388] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.910220] in mxt_interrpt</span><br><span class="line">[ 2855.910226] in data-&gt;T44_address</span><br><span class="line">[ 2855.910668] report_id:48</span><br><span class="line">[ 2855.910675] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.910704] mxt_proc_t100_message</span><br><span class="line">[ 2855.911144] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.911152] report_id:49</span><br><span class="line">[ 2855.911157] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.925984] in mxt_interrpt</span><br><span class="line">[ 2855.925992] in data-&gt;T44_address</span><br><span class="line">[ 2855.926458] report_id:48</span><br><span class="line">[ 2855.926466] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.926499] mxt_proc_t100_message</span><br><span class="line">[ 2855.926954] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.926964] report_id:49</span><br><span class="line">[ 2855.926969] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.941775] in mxt_interrpt</span><br><span class="line">[ 2855.941784] in data-&gt;T44_address</span><br><span class="line">[ 2855.942228] report_id:48</span><br><span class="line">[ 2855.942233] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.942264] mxt_proc_t100_message</span><br><span class="line">[ 2855.942707] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.942716] report_id:49</span><br><span class="line">[ 2855.942721] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.957554] in mxt_interrpt</span><br><span class="line">[ 2855.957565] in data-&gt;T44_address</span><br><span class="line">[ 2855.958029] report_id:48</span><br><span class="line">[ 2855.958035] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.958068] mxt_proc_t100_message</span><br><span class="line">[ 2855.958515] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.958525] report_id:49</span><br><span class="line">[ 2855.958530] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.973332] in mxt_interrpt</span><br><span class="line">[ 2855.973340] in data-&gt;T44_address</span><br><span class="line">[ 2855.973793] report_id:48</span><br><span class="line">[ 2855.973799] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.973831] mxt_proc_t100_message</span><br><span class="line">[ 2855.974271] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.974279] report_id:49</span><br><span class="line">[ 2855.974284] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.989151] in mxt_interrpt</span><br><span class="line">[ 2855.989158] in data-&gt;T44_address</span><br><span class="line">[ 2855.989607] report_id:48</span><br><span class="line">[ 2855.989613] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.989643] mxt_proc_t100_message</span><br><span class="line">[ 2855.990084] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.990092] report_id:49</span><br><span class="line">[ 2855.990097] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.004852] in mxt_interrpt</span><br><span class="line">[ 2856.004860] in data-&gt;T44_address</span><br><span class="line">[ 2856.005301] report_id:48</span><br><span class="line">[ 2856.005307] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.005337] mxt_proc_t100_message</span><br><span class="line">[ 2856.005795] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.005806] report_id:49</span><br><span class="line">[ 2856.005811] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.020607] in mxt_interrpt</span><br><span class="line">[ 2856.020615] in data-&gt;T44_address</span><br><span class="line">[ 2856.021057] report_id:48</span><br><span class="line">[ 2856.021063] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.021097] mxt_proc_t100_message</span><br><span class="line">[ 2856.021540] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.021549] report_id:49</span><br><span class="line">[ 2856.021554] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.036403] in mxt_interrpt</span><br><span class="line">[ 2856.036423] in data-&gt;T44_address</span><br><span class="line">[ 2856.036876] report_id:48</span><br><span class="line">[ 2856.036882] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.036913] mxt_proc_t100_message</span><br><span class="line">[ 2856.037354] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.037362] report_id:49</span><br><span class="line">[ 2856.037367] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.052161] in mxt_interrpt</span><br><span class="line">[ 2856.052168] in data-&gt;T44_address</span><br><span class="line">[ 2856.052610] report_id:48</span><br><span class="line">[ 2856.052617] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.052646] mxt_proc_t100_message</span><br><span class="line">[ 2856.053085] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.053093] report_id:49</span><br><span class="line">[ 2856.053098] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.067933] in mxt_interrpt</span><br><span class="line">[ 2856.067939] in data-&gt;T44_address</span><br><span class="line">[ 2856.068377] report_id:48</span><br><span class="line">[ 2856.068383] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.068423] mxt_proc_t100_message</span><br><span class="line">[ 2856.068870] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.068879] report_id:49</span><br><span class="line">[ 2856.068884] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.083717] in mxt_interrpt</span><br><span class="line">[ 2856.083724] in data-&gt;T44_address</span><br><span class="line">[ 2856.084162] report_id:48</span><br><span class="line">[ 2856.084167] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.084197] mxt_proc_t100_message</span><br><span class="line">[ 2856.084644] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.084653] report_id:49</span><br><span class="line">[ 2856.084657] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.099483] in mxt_interrpt</span><br><span class="line">[ 2856.099490] in data-&gt;T44_address</span><br><span class="line">[ 2856.099928] report_id:48</span><br><span class="line">[ 2856.099934] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.099964] mxt_proc_t100_message</span><br><span class="line">[ 2856.100403] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.100424] report_id:49</span><br><span class="line">[ 2856.100429] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.114993] in mxt_interrpt</span><br><span class="line">[ 2856.115001] in data-&gt;T44_address</span><br><span class="line">[ 2856.115440] report_id:48</span><br><span class="line">[ 2856.115446] msg_buf[0]:48 msg_buf[1]:21 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.115483] mxt_proc_t100_message</span><br><span class="line">[ 2856.115940] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.115952] report_id:49</span><br><span class="line">[ 2856.115956] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.130327] in mxt_interrpt</span><br><span class="line">[ 2856.130339] in data-&gt;T44_address</span><br><span class="line">[ 2856.130802] report_id:46</span><br><span class="line">[ 2856.130808] msg_buf[0]:46 msg_buf[1]:0 msg_buf[2]:0 msg_buf[3]:0 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.130832] mxt_proc_t100_message</span><br><span class="line">[ 2856.131273] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.131281] report_id:49</span><br><span class="line">[ 2856.131286] msg_buf[0]:49 msg_buf[1]:21 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.393232] in mxt_interrpt</span><br><span class="line">[ 2856.393249] in data-&gt;T44_address</span><br><span class="line">[ 2856.393869] report_id:10</span><br><span class="line">[ 2856.393877] msg_buf[0]:10 msg_buf[1]:193 msg_buf[2]:207 msg_buf[3]:7 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.393905] report_id&#x3D;10,modify timer</span><br></pre></td></tr></table></figure>



<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>本文总结Microchip maXTouch controller的object的使用和配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/12/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】Linux 触摸屏驱动分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-12 15:10:01 / Modified: 15:13:50" itemprop="dateCreated datePublished" datetime="2021-01-12T15:10:01+08:00">2021-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载<a href="https://blog.csdn.net/bingxx11/article/details/7905364" target="_blank" rel="noopener">https://blog.csdn.net/bingxx11/article/details/7905364</a></p>
<p>一.、前提知识</p>
<p>1、Linux输入子系统(Input Subsystem)：</p>
<p>   在Linux中，输入子系统是由输入子系统设备驱动层、输入子系统核心层(Input Core)和输入子系统事件处理层(Event Handler)组成。其中设备驱动层提供对硬件各寄存器的读写访问和将底层硬件对用户输入访问的响应转换为标准的输入事件，再通过核心层提交给事件处理层；而核心层对下提供了设备驱动层的编程接口，对上又提供了事件处理层的编程接口；而事件处理层就为我们用户空间的应用程序提供了统一访问设备的接口和驱动层提交来的事件处理。所以这使得我们输入设备的驱动部分不在用关心对设备文件的操作，而是要关心对各硬件寄存器的操作和提交的输入事件。下面用图形来描述一下这三者的关系吧！<br>另外，又找了另一幅图来说明Linux输入子系统的结构，可能更加形象容易理解。如下：</p>
<p>2、输入子系统设备驱动层实现原理：</p>
<p>   在Linux中，Input设备用input_dev结构体描述，定义在input.h中。设备的驱动只需按照如下步骤就可实现了。<br>①、在驱动模块加载函数中设置Input设备支持input子系统的哪些事件；<br>②、将Input设备注册到input子系统中；<br>③、在Input设备发生输入操作时(如：键盘被按下/抬起、触摸屏被触摸/抬起/移动、鼠标被移动/单击/抬起时等)，提交所发生的事件及对应的键值/坐标等状态。</p>
<p>Linux中输入设备的事件类型有(这里只列出了常用的一些，更多请看linux/input.h中)：</p>
<p>EV_SYN     0x00     同步事件<br>       EV_KEY     0x01     按键事件<br>       EV_REL     0x02     相对坐标(如：鼠标移动，报告的是相对最后一次位置的偏移)<br>       EV_ABS     0x03     绝对坐标(如：触摸屏和操作杆，报告的是绝对的坐标位置)<br>       EV_MSC     0x04     其它<br>      EV_LED     0x11     LED<br>      EV_SND     0x12     声音<br>      EV_REP     0x14     Repeat<br>      EV_FF      0x15     力反馈</p>
<p>用于提交较常用的事件类型给输入子系统的函数有：</p>
<p>void input_report_key(struct input_dev *dev, unsigned int code, int value); //提交按键事件的函数<br>void input_report_rel(struct input_dev *dev, unsigned int code, int value); //提交相对坐标事件的函数<br>void input_report_abs(struct input_dev *dev, unsigned int code, int value); //提交绝对坐标事件的函数</p>
<p>注意，在提交输入设备的事件后必须用下列方法使事件同步，让它告知input系统，设备驱动已经发出了一个完整的报告：</p>
<p>void input_sync(struct input_dev *dev)</p>
<p>二、触摸屏驱动的实现步骤</p>
<p>1、硬件原理图分析：</p>
<p>   S3c2440芯片内部触摸屏接口与ADC接口是集成在一起的，硬件结构原理图请看：S3C2440上ADC驱动实例开发讲解中的图，其中通道7(XP或AIN7)作为触摸屏接口的X坐标输入，通道5(YP或AIN5)作为触摸屏接口的Y坐标输入。在”S3C2440上ADC驱动实例开发讲解”中，AD转换的模拟信号是由开发板上的一个电位器产生并通过通道1(AIN0)输入的，而这里的模拟信号则是由点触触摸屏所产生的X坐标和Y坐标两个模拟信号，并分别通过通道7和通道5输入。S3c2440提供的触摸屏接口有4种处理模式，分别是：正常转换模式、单独的X/Y位置转换模式、自动X/Y位置转换模式和等待中断模式，对于在每种模式下工作的要求，请详细查看数据手册的描述。本驱动实例将采用自动X/Y位置转换模式和等待中断模式。</p>
<p>注意：在每步中，为了让代码逻辑更加有条理和容易理解，就没有考虑代码的顺序，比如函数要先定义后调用。如果要编译此代码，请严格按照C语言的规范来调整代码的顺序。</p>
<p>2、建立触摸屏驱动程序my2440_ts.c，首先实现加载和卸载部分，在驱动加载部分，我们主要做的事情是：启用ADC所需要的时钟、映射IO口、初始化寄存器、申请中断、初始化输入设备、将输入设备注册到输入子系统。代码如下：</p>
<p>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/clk.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/input.h&gt;<br>#include &lt;linux/serio.h&gt;<br>#include &lt;plat/regs-adc.h&gt;<br>#include &lt;asm/irq.h&gt;<br>#include &lt;asm/io.h&gt;</p>
<p>/<em>用于保存从平台时钟列表中获取的ADC时钟</em>/<br>static struct clk <em>adc_clk;<br>/*定义了一个用来保存经过虚拟映射后的内存地址</em>/<br>static void __iomem <em>adc_base;<br>/*定义一个输入设备来表示我们的触摸屏设备</em>/<br>static struct input_dev <em>ts_dev;<br>/*设备名称</em>/<br>#define DEVICE_NAME    “my2440_TouchScreen”<br>/<em>定义一个WAIT4INT宏，该宏将对ADC触摸屏控制寄存器进行操作<br>S3C2410_ADCTSC_YM_SEN这些宏都定义在regs-adc.h中</em>/<br>#define WAIT4INT(x)    (((x)&lt;&lt;8) | S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | <br>                    S3C2410_ADCTSC_XP_SEN | S3C2410_ADCTSC_XY_PST(3))<br>static int __init ts_init(void)<br>{<br>    int ret;<br>    /<em>从平台时钟队列中获取ADC的时钟，这里为什么要取得这个时钟，因为ADC的转换频率跟时钟有关。<br>    系统的一些时钟定义在arch/arm/plat-s3c24xx/s3c2410-clock.c中</em>/<br>    adc_clk = clk_get(NULL, “adc”);<br>    if(!adc_clk)<br>    {<br>        /<em>错误处理</em>/<br>        printk(KERN_ERR “falied to find adc clock source\n”);<br>        return -ENOENT;<br>    }<br>    /<em>时钟获取后要使能后才可以使用，clk_enable定义在arch/arm/plat-s3c/clock.c中</em>/<br>    clk_enable(adc_clk);<br>    /<em>将ADC的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中。<br>     注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作,<br>     S3C2410_PA_ADC是ADC控制器的基地址，定义在mach-s3c2410/include/mach/map.h中，0x20是虚拟地址长度大小</em>/<br>    adc_base = ioremap(S3C2410_PA_ADC, 0x20);<br>    if(adc_base == NULL)<br>    {<br>        /<em>错误处理</em>/<br>        printk(KERN_ERR “failed to remap register block\n”);<br>        ret = -EINVAL;<br>        goto err_noclk;<br>    }<br>    /<em>初始化ADC控制寄存器和ADC触摸屏控制寄存器</em>/<br>    adc_initialize();<br>    /<em>申请ADC中断，AD转换完成后触发。这里使用共享中断IRQF_SHARED是因为该中断号在ADC驱动中也使用了，<br>    最后一个参数1是随便给的一个值，因为如果不给值设为NULL的话，中断就申请不成功</em>/<br>    ret = request_irq(IRQ_ADC, adc_irq, IRQF_SHARED | IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);<br>    if(ret)<br>    {<br>        printk(KERN_ERR “IRQ%d error %d\n”, IRQ_ADC, ret);<br>        ret = -EINVAL;<br>        goto err_nomap;<br>    }<br>    /<em>申请触摸屏中断，对触摸屏按下或提笔时触发</em>/<br>    ret = request_irq(IRQ_TC, tc_irq, IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);<br>    if(ret)<br>    {<br>        printk(KERN_ERR “IRQ%d error %d\n”, IRQ_TC, ret);<br>        ret = -EINVAL;<br>        goto err_noirq;<br>    }<br>    /<em>给输入设备申请空间，input_allocate_device定义在input.h中</em>/<br>    ts_dev = input_allocate_device();<br>    /<em>下面初始化输入设备，即给输入设备结构体input_dev的成员设置值。<br>    evbit字段用于描述支持的事件，这里支持同步事件、按键事件、绝对坐标事件，<br>    BIT宏实际就是对1进行位操作，定义在linux/bitops.h中</em>/<br>    ts_dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);</p>
<pre><code>/*keybit字段用于描述按键的类型，在input.h中定义了很多，这里用BTN_TOUCH类型来表示触摸屏的点击*/
ts_dev-&gt;keybit[BITS_TO_LONGS(BTN_TOUCH)] = BIT(BTN_TOUCH);
/*对于触摸屏来说，使用的是绝对坐标系统。这里设置该坐标系统中X和Y坐标的最小值和最大值(0-1023范围)
ABS_X和ABS_Y就表示X坐标和Y坐标，ABS_PRESSURE就表示触摸屏是按下还是抬起状态*/
input_set_abs_params(ts_dev, ABS_X, 0, 0x3FF, 0, 0);
input_set_abs_params(ts_dev, ABS_Y, 0, 0x3FF, 0, 0);
input_set_abs_params(ts_dev, ABS_PRESSURE, 0, 1, 0, 0);
/*以下是设置触摸屏输入设备的身份信息，直接在这里写死。
这些信息可以在驱动挂载后在/proc/bus/input/devices中查看到*/
ts_dev-&gt;name          = DEVICE_NAME;   /*设备名称*/
ts_dev-&gt;id.bustype    = BUS_RS232;     /*总线类型*/    
ts_dev-&gt;id.vendor     = 0xDEAD;        /*经销商ID号*/
ts_dev-&gt;id.product    = 0xBEEF;        /*产品ID号*/
ts_dev-&gt;id.version    = 0x0101;        /*版本ID号*/
/*好了，一些都准备就绪，现在就把ts_dev触摸屏设备注册到输入子系统中*/
input_register_device(ts_dev);
return 0;</code></pre><p>/<em>下面是错误跳转处理</em>/<br>err_noclk:<br>    clk_disable(adc_clk);<br>    clk_put(adc_clk);<br>err_nomap:<br>    iounmap(adc_base);<br>err_noirq:<br>    free_irq(IRQ_ADC, 1);<br>    return ret;<br>}<br>/<em>初始化ADC控制寄存器和ADC触摸屏控制寄存器</em>/<br>static void adc_initialize(void)<br>{<br>    /<em>计算结果为(二进制)：111111111000000，再根据数据手册得知<br>    此处是将AD转换预定标器值设为255、AD转换预定标器使能有效</em>/<br>    writel(S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(0xFF), adc_base + S3C2410_ADCCON);<br>    /<em>对ADC开始延时寄存器进行设置，延时值为0xffff</em>/<br>    writel(0xffff, adc_base + S3C2410_ADCDLY);<br>    /<em>WAIT4INT宏计算结果为(二进制)：11010011，再根据数据手册得知<br>    此处是将ADC触摸屏控制寄存器设置成等待中断模式</em>/<br>    writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);<br>}<br>static void __exit ts_exit(void)<br>{<br>    /<em>屏蔽和释放中断</em>/<br>    disable_irq(IRQ_ADC);<br>    disable_irq(IRQ_TC);<br>    free_irq(IRQ_ADC, 1);<br>    free_irq(IRQ_TC, 1);<br>    /<em>释放虚拟地址映射空间</em>/<br>    iounmap(adc_base);<br>    /<em>屏蔽和销毁时钟</em>/<br>    if(adc_clk)<br>    {<br>        clk_disable(adc_clk);<br>        clk_put(adc_clk);<br>        adc_clk = NULL;<br>    }<br>    /<em>将触摸屏设备从输入子系统中注销</em>/<br>    input_unregister_device(ts_dev);<br>}<br>module_init(ts_init);<br>module_exit(ts_exit);<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“Huang Gang”);<br>MODULE_DESCRIPTION(“My2440 Touch Screen Driver”);</p>
<p>3、接下来要做的是，在两个中断服务程序中实现触摸屏状态和坐标的转换。先看代码，如下：</p>
<p>/<em>定义一个外部的信号量ADC_LOCK，因为ADC_LOCK在ADC驱动程序中已申明<br>这样就能保证ADC资源在ADC驱动和触摸屏驱动中进行互斥访问</em>/<br>extern struct semaphore ADC_LOCK;<br>/<em>做为一个标签，只有对触摸屏操作后才对X和Y坐标进行转换</em>/<br>static int OwnADC = 0;<br>/<em>用于记录转换后的X坐标值和Y坐标值</em>/<br>static long xp;<br>static long yp;<br>/<em>用于计数对触摸屏压下或抬起时模拟输入转换的次数</em>/<br>static int count;<br>/<em>定义一个AUTOPST宏，将ADC触摸屏控制寄存器设置成自动转换模式</em>/<br>#define AUTOPST    (S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | <br>                S3C2410_ADCTSC_AUTO_PST | S3C2410_ADCTSC_XY_PST(0))<br>/<em>触摸屏中断服务程序，对触摸屏按下或提笔时触发执行</em>/<br>static irqreturn_t tc_irq(int irq, void <em>dev_id)<br>{<br>    /*用于记录这一次AD转换后的值</em>/<br>    unsigned long data0;<br>    unsigned long data1;<br>    /<em>用于记录触摸屏操作状态是按下还是抬起</em>/<br>    int updown;<br>    /<em>ADC资源可以获取，即上锁</em>/<br>    if (down_trylock(&amp;ADC_LOCK) == 0)<br>    {<br>        /<em>标识对触摸屏进行了操作</em>/<br>        OwnADC = 1;<br>        /<em>读取这一次AD转换后的值，注意这次主要读的是状态</em>/<br>        data0 = readl(adc_base + S3C2410_ADCDAT0);<br>        data1 = readl(adc_base + S3C2410_ADCDAT1);<br>        /<em>记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN</em>/<br>        updown = (!(data0 &amp; S3C2410_ADCDAT0_UPDOWN)) &amp;&amp; (!(data1 &amp; S3C2410_ADCDAT0_UPDOWN));<br>        /<em>判断触摸屏的操作状态</em>/<br>        if (updown)<br>        {<br>            /<em>如果是按下状态，则调用touch_timer_fire函数来启动ADC转换，该函数定义后面再讲</em>/<br>            touch_timer_fire(0);<br>        }<br>        else<br>        {<br>            /<em>如果是抬起状态，就结束了这一次的操作，所以就释放ADC资源的占有</em>/<br>            OwnADC = 0;<br>            up(&amp;ADC_LOCK);<br>        }<br>    }<br>    return IRQ_HANDLED;<br>}<br>static void touch_timer_fire(unsigned long data)<br>{<br>    /<em>用于记录这一次AD转换后的值</em>/<br>      unsigned long data0;<br>      unsigned long data1;<br>    /<em>用于记录触摸屏操作状态是按下还是抬起</em>/<br>    int updown;<br>    /<em>读取这一次AD转换后的值，注意这次主要读的是状态</em>/<br>      data0 = readl(adc_base + S3C2410_ADCDAT0);<br>    data1 = readl(adc_base + S3C2410_ADCDAT1);<br>    /<em>记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN</em>/<br>     updown = (!(data0 &amp; S3C2410_ADCDAT0_UPDOWN)) &amp;&amp; (!(data1 &amp; S3C2410_ADCDAT0_UPDOWN));<br>    /<em>判断触摸屏的操作状态</em>/<br>     if (updown)<br>    {<br>        /<em>如果状态是按下，并且ADC已经转换了就报告事件和数据</em>/<br>         if (count != 0)<br>        {<br>            long tmp;</p>
<pre><code>tmp = xp;
xp = yp;
yp = tmp;

xp &gt;&gt;= 2;
yp &gt;&gt;= 2;</code></pre><p>#ifdef CONFIG_TOUCHSCREEN_MY2440_DEBUG<br>            /<em>触摸屏调试信息，编译内核时选上此项后，点击触摸屏会在终端上打印出坐标信息</em>/<br>            struct timeval tv;<br>            do_gettimeofday(&amp;tv);<br>            printk(KERN_DEBUG “T: %06d, X: %03ld, Y: %03ld\n”, (int)tv.tv_usec, xp, yp);<br>#endif<br>            /<em>报告X、Y的绝对坐标值</em>/<br>             input_report_abs(ts_dev, ABS_X, xp);<br>             input_report_abs(ts_dev, ABS_Y, yp);<br>            /<em>报告触摸屏的状态，1表明触摸屏被按下</em>/<br>            input_report_abs(ts_dev, ABS_PRESSURE, 1);<br>            /<em>报告按键事件，键值为1(代表触摸屏对应的按键被按下)</em>/<br>             input_report_key(ts_dev, BTN_TOUCH, 1);<br>            /<em>等待接收方受到数据后回复确认，用于同步</em>/<br>             input_sync(ts_dev);<br>         }<br>        /<em>如果状态是按下，并且ADC还没有开始转换就启动ADC进行转换</em>/<br>         xp = 0;<br>         yp = 0;<br>         count = 0;<br>        /<em>设置触摸屏的模式为自动转换模式</em>/<br>         writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);<br>        /<em>启动ADC转换</em>/<br>         writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);<br>     }<br>    else<br>    {<br>        /<em>否则是抬起状态</em>/<br>         count = 0;<br>        /<em>报告按键事件，键值为0(代表触摸屏对应的按键被释放)</em>/<br>         input_report_key(ts_dev, BTN_TOUCH, 0);<br>        /<em>报告触摸屏的状态，0表明触摸屏没被按下</em>/<br>         input_report_abs(ts_dev, ABS_PRESSURE, 0);<br>        /<em>等待接收方受到数据后回复确认，用于同步</em>/<br>         input_sync(ts_dev);<br>        /<em>将触摸屏重新设置为等待中断状态</em>/<br>         writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);<br>        /<em>如果触摸屏抬起，就意味着这一次的操作结束，所以就释放ADC资源的占有</em>/<br>        if (OwnADC)<br>        {<br>            OwnADC = 0;<br>            up(&amp;ADC_LOCK);<br>        }<br>     }<br>}<br>/<em>定义并初始化了一个定时器touch_timer，定时器服务程序为touch_timer_fire</em>/<br>static struct timer_list touch_timer = TIMER_INITIALIZER(touch_timer_fire, 0, 0);<br>/<em>ADC中断服务程序，AD转换完成后触发执行</em>/<br>static irqreturn_t adc_irq(int irq, void <em>dev_id)<br>{<br>    /*用于记录这一次AD转换后的值</em>/<br>    unsigned long data0;<br>    unsigned long data1;<br>    if(OwnADC)<br>    {<br>        /<em>读取这一次AD转换后的值，注意这次主要读的是坐标</em>/<br>        data0 = readl(adc_base + S3C2410_ADCDAT0);<br>        data1 = readl(adc_base + S3C2410_ADCDAT1);<br>        /<em>记录这一次通过AD转换后的X坐标值和Y坐标值，根据数据手册可知，X和Y坐标转换数值<br>        分别保存在数据寄存器0和1的第0-9位，所以这里与上S3C2410_ADCDAT0_XPDATA_MASK就是取0-9位的值</em>/<br>        xp += data0 &amp; S3C2410_ADCDAT0_XPDATA_MASK;<br>        yp += data1 &amp; S3C2410_ADCDAT1_YPDATA_MASK;<br>        /<em>计数这一次AD转换的次数</em>/<br>        count++;<br>        if (count &lt; (1&lt;&lt;2))<br>        {<br>            /<em>如果转换的次数小于4，则重新启动ADC转换</em>/<br>            writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);<br>            writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);<br>        }<br>        else<br>        {<br>            /<em>否则，启动1个时间滴答的定时器，这是就会去执行定时器服务程序上报事件和数据</em>/<br>            mod_timer(&amp;touch_timer, jiffies + 1);<br>            writel(WAIT4INT(1), adc_base + S3C2410_ADCTSC);<br>        }<br>    }<br>    return IRQ_HANDLED;<br>}</p>
<p>我们从整体上描述转换这个的过程：<br>(1)如果触摸屏感觉到触摸，则触发触摸屏中断即进入tc_irq，获取ADC_LOCK后判断触摸屏状态为按下，则调用touch_timer_fire启动ADC转换；<br>(2)当ADC转换启动后，触发ADC中断即进入adc_irq，如果这一次转换的次数小于4，则重新启动ADC进行转换，如果4次完毕后，启动1个时间滴答的定时器，停止ADC转换，也就是说在这个时间滴答内，ADC转换是停止的；<br>(3)这里为什么要在1个时间滴答到来之前停止ADC的转换呢？这是为了防止屏幕抖动。<br>(4)如果1个时间滴答到来则进入定时器服务程序touch_timer_fire，判断触摸屏仍然处于按下状态则上报事件和转换的数据，并重启ADC转换，重复第(2)步；<br>(5)如果触摸抬起了，则上报释放事件，并将触摸屏重新设置为等待中断状态。</p>
<p>四、移植和测试触摸屏驱动程序</p>
<pre><code>移植和测试请看Linux-2.6.30.4在2440上的移植之触摸屏驱动</code></pre><p>移植和测试请看<a href="http://blog.chinaunix.net/u3/101649/showart_2085414.html" target="_blank" rel="noopener">Linux-2.6.30.4在2440上的移植之触摸屏驱动</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/i2c/Linux%20I2C%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/i2c/Linux%20I2C%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">Linux I2C驱动设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-07 19:46:19" itemprop="dateCreated datePublished" datetime="2021-01-07T19:46:19+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-22 10:12:20" itemprop="dateModified" datetime="2021-01-22T10:12:20+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">i2c总线驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了网上一些关于Linux i2c驱动的博客文章，都将i2c分为device 、i2c core和driver三层。对于linux  i2c的分层，我有不同的理解。因此，把我的理解，记录下来。i2c对单片机来说，实现比较简单，但是Linux的i2c子系统为什么写得比较复杂？Linux把i2c做成一个通用平台，划分层次，方便分工合作。划分层次，每个方向专注一个层次，更改一个层次，不影响其他层次。因此，做Linux i2c驱动，跟i2c设备接触的开发者，专心配置设备的寄存器，降低了i2c开发难度。</p>
<h2 id="i2c架构理解"><a href="#i2c架构理解" class="headerlink" title="i2c架构理解"></a>i2c架构理解</h2><p><img src="http://jiali.clouddn.com/20210111_001.png" alt=""></p>
<p>client操作层：提供注册字符设备，实现应用层read、write、open等功能</p>
<p>i2c-core层：提供i2c适配器和driver的注册和注销等核心功能接口</p>
<p>i2c driver层：实现设备的驱动程序，包括初始化、挂起和唤醒等</p>
<p>i2c_adapter: 初始化i2c控制器，注册适配器，并提供一种适合设备的通信时序algorithm</p>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>1、struct i2c_driver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_driver - represent an I2C device driver</span><br><span class="line"> * @class: What kind of i2c device we instantiate (for detect)</span><br><span class="line"> * @attach_adapter: Callback for bus addition (deprecated)</span><br><span class="line"> * @detach_adapter: Callback for bus removal (deprecated)</span><br><span class="line"> * @probe: Callback for device binding</span><br><span class="line"> * @remove: Callback for device unbinding</span><br><span class="line"> * @shutdown: Callback for device shutdown</span><br><span class="line"> * @suspend: Callback for device suspend</span><br><span class="line"> * @resume: Callback for device resume</span><br><span class="line"> * @alert: Alert callback, for example for the SMBus alert protocol</span><br><span class="line"> * @command: Callback for bus-wide signaling (optional)</span><br><span class="line"> * @driver: Device driver model driver</span><br><span class="line"> * @id_table: List of I2C devices supported by this driver</span><br><span class="line"> * @detect: Callback for device detection</span><br><span class="line"> * @address_list: The I2C addresses to probe (for detect)</span><br><span class="line"> * @clients: List of detected clients we created (for i2c-core use only)</span><br><span class="line"> *</span><br><span class="line"> * The driver.owner field should be set to the module owner of this driver.</span><br><span class="line"> * The driver.name field should be set to the name of this driver.</span><br><span class="line"> *</span><br><span class="line"> * For automatic device detection, both @detect and @address_data must</span><br><span class="line"> * be defined. @class should also be set, otherwise only devices forced</span><br><span class="line"> * with module parameters will be created. The detect function must</span><br><span class="line"> * fill at least the name field of the i2c_board_info structure it is</span><br><span class="line"> * handed upon successful detection, and possibly also the flags field.</span><br><span class="line"> *</span><br><span class="line"> * If @detect is missing, the driver will still work fine for enumerated</span><br><span class="line"> * devices. Detected devices simply won&#39;t be supported. This is expected</span><br><span class="line"> * for the many I2C&#x2F;SMBus devices which can&#39;t be detected reliably, and</span><br><span class="line"> * the ones which can always be enumerated in practice.</span><br><span class="line"> *</span><br><span class="line"> * The i2c_client structure which is handed to the @detect callback is</span><br><span class="line"> * not a real i2c_client. It is initialized just enough so that you can</span><br><span class="line"> * call i2c_smbus_read_byte_data and friends on it. Don&#39;t do anything</span><br><span class="line"> * else with it. In particular, calling dev_dbg and friends on it is</span><br><span class="line"> * not allowed.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_driver &#123;</span><br><span class="line">	unsigned int class;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Notifies the driver that a new bus has appeared or is about to be</span><br><span class="line">	 * removed. You should avoid using this, it will be removed in a</span><br><span class="line">	 * near future.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line">	int (*detach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class="line">	int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">	int (*remove)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line">	&#x2F;* driver model interfaces that don&#39;t relate to enumeration  *&#x2F;</span><br><span class="line">	void (*shutdown)(struct i2c_client *);</span><br><span class="line">	int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br><span class="line">	int (*resume)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Alert callback, for example for the SMBus alert protocol.</span><br><span class="line">	 * The format and meaning of the data value depends on the protocol.</span><br><span class="line">	 * For the SMBus alert protocol, there is a single bit of data passed</span><br><span class="line">	 * as the alert response&#39;s low bit (&quot;event flag&quot;).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void (*alert)(struct i2c_client *, unsigned int data);</span><br><span class="line"></span><br><span class="line">	&#x2F;* a ioctl like command that can be used to perform specific functions</span><br><span class="line">	 * with the device.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class="line"></span><br><span class="line">	struct device_driver driver;</span><br><span class="line">	const struct i2c_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Device detection callback for automatic device creation *&#x2F;</span><br><span class="line">	int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">	const unsigned short *address_list;</span><br><span class="line">	struct list_head clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、struct i2c_adapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	unsigned int class;		  &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">	const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class="line">	void *algo_data;</span><br><span class="line"></span><br><span class="line">	&#x2F;* data fields that are valid for all devices	*&#x2F;</span><br><span class="line">	struct rt_mutex bus_lock;</span><br><span class="line"></span><br><span class="line">	int timeout;			&#x2F;* in jiffies *&#x2F;</span><br><span class="line">	int retries;</span><br><span class="line">	struct device dev;		&#x2F;* the adapter device *&#x2F;</span><br><span class="line"></span><br><span class="line">	int nr;</span><br><span class="line">	char name[48];</span><br><span class="line">	struct completion dev_released;</span><br><span class="line"></span><br><span class="line">	struct mutex userspace_clients_lock;</span><br><span class="line">	struct list_head userspace_clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、struct i2c_algorithm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The following structs are for those who like to implement new bus drivers:</span><br><span class="line"> * i2c_algorithm is the interface to a class of hardware solutions which can</span><br><span class="line"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span><br><span class="line"> * to name two of the most common.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">	&#x2F;* If an adapter algorithm can&#39;t do I2C-level access, set master_xfer</span><br><span class="line">	   to NULL. If an adapter algorithm can do SMBus access, set</span><br><span class="line">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span><br><span class="line">	   using common I2C messages *&#x2F;</span><br><span class="line">	&#x2F;* master_xfer should return the number of messages successfully</span><br><span class="line">	   processed, or a negative value on error *&#x2F;</span><br><span class="line">	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">			   int num);</span><br><span class="line">	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">			   unsigned short flags, char read_write,</span><br><span class="line">			   u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	&#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、struct i2c_client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_client - represent an I2C slave device</span><br><span class="line"> * @flags: I2C_CLIENT_TEN indicates the device uses a ten bit chip address;</span><br><span class="line"> *	I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking</span><br><span class="line"> * @addr: Address used on the I2C bus connected to the parent adapter.</span><br><span class="line"> * @name: Indicates the type of the device, usually a chip name that&#39;s</span><br><span class="line"> *	generic enough to hide second-sourcing and compatible revisions.</span><br><span class="line"> * @adapter: manages the bus segment hosting this I2C device</span><br><span class="line"> * @driver: device&#39;s driver, hence pointer to access routines</span><br><span class="line"> * @dev: Driver model device node for the slave.</span><br><span class="line"> * @irq: indicates the IRQ generated by this device (if any)</span><br><span class="line"> * @detected: member of an i2c_driver.clients list or i2c-core&#39;s</span><br><span class="line"> *	userspace_devices list</span><br><span class="line"> *</span><br><span class="line"> * An i2c_client identifies a single device (i.e. chip) connected to an</span><br><span class="line"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span><br><span class="line"> * managing the device.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_client &#123;</span><br><span class="line">	unsigned short flags;		&#x2F;* div., see below		*&#x2F;</span><br><span class="line">	unsigned short addr;		&#x2F;* chip address - NOTE: 7bit	*&#x2F;</span><br><span class="line">					&#x2F;* addresses are stored in the	*&#x2F;</span><br><span class="line">					&#x2F;* _LOWER_ 7 bits		*&#x2F;</span><br><span class="line">	char name[I2C_NAME_SIZE];</span><br><span class="line">	struct i2c_adapter *adapter;	&#x2F;* the adapter we sit on	*&#x2F;</span><br><span class="line">	struct i2c_driver *driver;	&#x2F;* and our access routines	*&#x2F;</span><br><span class="line">	struct device dev;		&#x2F;* the device structure		*&#x2F;</span><br><span class="line">	int irq;			&#x2F;* irq issued by device		*&#x2F;</span><br><span class="line">	struct list_head detected;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5、struct i2c_msg描述传输数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_msg - an I2C transaction segment beginning with START</span><br><span class="line"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span><br><span class="line"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span><br><span class="line"> *	must support I2C_FUNC_10BIT_ADDR.</span><br><span class="line"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span><br><span class="line"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span><br><span class="line"> *	flags through i2c_check_functionality().</span><br><span class="line"> * @len: Number of data bytes in @buf being read from or written to the</span><br><span class="line"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span><br><span class="line"> *	is set, the caller guarantees that this buffer can hold up to</span><br><span class="line"> *	32 bytes in addition to the initial length byte sent by the</span><br><span class="line"> *	slave (plus, if used, the SMBus PEC); and this value will be</span><br><span class="line"> *	incremented by the number of block data bytes received.</span><br><span class="line"> * @buf: The buffer into which data is read, or from which it&#39;s written.</span><br><span class="line"> *</span><br><span class="line"> * An i2c_msg is the low level representation of one segment of an I2C</span><br><span class="line"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span><br><span class="line"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span><br><span class="line"> * @i2c_adapter.@master_xfer() method.</span><br><span class="line"> *</span><br><span class="line"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span><br><span class="line"> * the standard rules for I2C transactions.  Each transaction begins with a</span><br><span class="line"> * START.  That is followed by the slave address, and a bit encoding read</span><br><span class="line"> * versus write.  Then follow all the data bytes, possibly including a byte</span><br><span class="line"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span><br><span class="line"> * bytes have been transferred and ACKed.  If this is the last message in a</span><br><span class="line"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span><br><span class="line"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span><br><span class="line"> *</span><br><span class="line"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span><br><span class="line"> * passing certain @flags may have changed those standard protocol behaviors.</span><br><span class="line"> * Those flags are only for use with broken&#x2F;nonconforming slaves, and with</span><br><span class="line"> * adapters which are known to support the specific mangling options they</span><br><span class="line"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">	__u16 addr;	&#x2F;* slave address			*&#x2F;</span><br><span class="line">	__u16 flags;</span><br><span class="line">#define I2C_M_TEN		0x0010	&#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">#define I2C_M_RD		0x0001	&#x2F;* read data, from slave to master *&#x2F;</span><br><span class="line">#define I2C_M_NOSTART		0x4000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_REV_DIR_ADDR	0x2000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_IGNORE_NAK	0x1000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_NO_RD_ACK		0x0800	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_RECV_LEN		0x0400	&#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">	__u16 len;		&#x2F;* msg length				*&#x2F;</span><br><span class="line">	__u8 *buf;		&#x2F;* pointer to msg data			*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这几个数据结构之间的关系，如何理解？</p>
<p>i2c_client描述一个i2c设备， i2c_adapter描述cpu i2c控制器，i2c_algorithm描述i2c总线的通信时序，i2c_driver描述设备对应的一套操作方法。因此，i2c_adapter与i2c_client是一对多关系，i2c_driver与i2c_client也是一对多关系。一个i2c_driver上可以支持多个同等类型的i2c_client。</p>
<h2 id="目录层次"><a href="#目录层次" class="headerlink" title="目录层次"></a>目录层次</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drivers\i2c：</span><br><span class="line">i2c-core.c：i2c核心层，设备驱动和总线驱动的桥梁</span><br><span class="line">i2c-dev.c：通用 i2c 设备驱动</span><br><span class="line">busses：开源的 adapter ，比如i2c-omap.c用来初始化i2c控制器，创建adapter</span><br><span class="line">algos：i2c 通信算法</span><br><span class="line"></span><br><span class="line">include\linux\i2c.h：i2c-core.c的接口头文件</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="注册i2c-adapter"><a href="#注册i2c-adapter" class="headerlink" title="注册i2c_adapter"></a>注册i2c_adapter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">		res &#x3D; -EAGAIN;</span><br><span class="line">		goto out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Sanity checks *&#x2F;</span><br><span class="line">	if (unlikely(adap-&gt;name[0] &#x3D;&#x3D; &#39;\0&#39;)) &#123;</span><br><span class="line">		pr_err(&quot;i2c-core: Attempt to register an adapter with &quot;</span><br><span class="line">		       &quot;no name!\n&quot;);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	if (unlikely(!adap-&gt;algo)) &#123;</span><br><span class="line">		pr_err(&quot;i2c-core: Attempt to register adapter &#39;%s&#39; with &quot;</span><br><span class="line">		       &quot;no algo!\n&quot;, adap-&gt;name);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">	mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);&#x2F;&#x2F;初始化i2c_adapteruserspace_clients链表</span><br><span class="line"></span><br><span class="line">	&#x2F;* Set default timeout to 1 second if not already set *&#x2F;</span><br><span class="line">	if (adap-&gt;timeout &#x3D;&#x3D; 0)</span><br><span class="line">		adap-&gt;timeout &#x3D; HZ;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr); &#x2F;&#x2F;设置adapter名字</span><br><span class="line">	adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;      &#x2F;&#x2F;设置设备的总线类型</span><br><span class="line">	adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type; &#x2F;&#x2F;设置设备的设备类型</span><br><span class="line">	res &#x3D; device_register(&amp;adap-&gt;dev);  &#x2F;&#x2F; 注册设备&#x2F;sys&#x2F;devices&#x2F;i2c-%d</span><br><span class="line">	if (res)</span><br><span class="line">		goto out_list;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	res &#x3D; class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	if (res)</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">			 &quot;Failed to create compatibility class link\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;* create pre-declared device nodes *&#x2F;</span><br><span class="line">	if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		i2c_scan_static_board_info(adap); &#x2F;&#x2F;扫描并创建i2c设备</span><br><span class="line"></span><br><span class="line">	&#x2F;* Notify drivers *&#x2F;</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);&#x2F;&#x2F;遍历每个driver，选择匹配的driver</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="i2c-core初始化"><a href="#i2c-core初始化" class="headerlink" title="i2c-core初始化"></a>i2c-core初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;i2c&quot;,</span><br><span class="line">	.match		&#x3D; i2c_device_match,</span><br><span class="line">	.probe		&#x3D; i2c_device_probe,</span><br><span class="line">	.remove		&#x3D; i2c_device_remove,</span><br><span class="line">	.shutdown	&#x3D; i2c_device_shutdown,</span><br><span class="line">	.pm		&#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"></span><br><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; bus_register(&amp;i2c_bus_type); &#x2F;&#x2F;注册i2c总线</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">	if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval &#x3D; -ENOMEM;</span><br><span class="line">		goto bus_err;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	retval &#x3D; i2c_add_driver(&amp;dummy_driver); &#x2F;&#x2F;注册虚拟bus driver,对象为dummy_driver</span><br><span class="line">	if (retval)</span><br><span class="line">		goto class_err;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line">#endif</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit i2c_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">#endif</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* We must initialize early, because some subsystems register i2c drivers</span><br><span class="line"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span><br><span class="line"> *&#x2F;</span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>



<h3 id="添加driver"><a href="#添加driver" class="headerlink" title="添加driver"></a>添加driver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* use a define to avoid include chaining to get THIS_MODULE *&#x2F;</span><br><span class="line">#define i2c_add_driver(driver) \</span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span><br><span class="line"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	&#x2F;* add the driver to the list of i2c drivers in the driver core *&#x2F;</span><br><span class="line">	driver-&gt;driver.owner &#x3D; owner;</span><br><span class="line">	driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line"></span><br><span class="line">	&#x2F;* When registration returns, the driver core</span><br><span class="line">	 * will have called probe() for all matching-but-unbound devices.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	res &#x3D; driver_register(&amp;driver-&gt;driver);&#x2F;&#x2F;注册bus driver</span><br><span class="line">	if (res)</span><br><span class="line">		return res;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Drivers should switch to dev_pm_ops instead. *&#x2F;</span><br><span class="line">	if (driver-&gt;suspend)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy suspend method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line">	if (driver-&gt;resume)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy resume method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">	&#x2F;* Walk the adapters that are already present *&#x2F;</span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver); &#x2F;&#x2F;遍历adapter，选择匹配的dev adapter</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_register_driver);</span><br></pre></td></tr></table></figure>



<h3 id="i2c-dev创建"><a href="#i2c-dev创建" class="headerlink" title="i2c-dev创建"></a>i2c-dev创建</h3><p>通用i2c-dev平台的例子drivers\i2c\i2c-dev.c，当然，可以不使用i2c-dev.c，自己创建其他的设备，提供应用层read、write、open等字符设备的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations i2cdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">	.read		&#x3D; i2cdev_read,</span><br><span class="line">	.write		&#x3D; i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	&#x3D; i2cdev_ioctl,</span><br><span class="line">	.open		&#x3D; i2cdev_open,</span><br><span class="line">	.release	&#x3D; i2cdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* ------------------------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">static struct class *i2c_dev_class;</span><br><span class="line"></span><br><span class="line">static int i2cdev_attach_adapter(struct device *dev, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *adap;</span><br><span class="line">	struct i2c_dev *i2c_dev;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	if (dev-&gt;type !&#x3D; &amp;i2c_adapter_type)</span><br><span class="line">		return 0;</span><br><span class="line">	adap &#x3D; to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	i2c_dev &#x3D; get_free_i2c_dev(adap);</span><br><span class="line">	if (IS_ERR(i2c_dev))</span><br><span class="line">		return PTR_ERR(i2c_dev);</span><br><span class="line"></span><br><span class="line">	&#x2F;* register this i2c device with the driver core *&#x2F;</span><br><span class="line">	i2c_dev-&gt;dev &#x3D; device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">				     MKDEV(I2C_MAJOR, adap-&gt;nr), NULL,</span><br><span class="line">				     &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">	if (IS_ERR(i2c_dev-&gt;dev)) &#123;</span><br><span class="line">		res &#x3D; PTR_ERR(i2c_dev-&gt;dev);</span><br><span class="line">		goto error;</span><br><span class="line">	&#125;</span><br><span class="line">	res &#x3D; device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	if (res)</span><br><span class="line">		goto error_destroy;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	return 0;</span><br><span class="line">error_destroy:</span><br><span class="line">	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line">error:</span><br><span class="line">	return_i2c_dev(i2c_dev);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int i2cdev_detach_adapter(struct device *dev, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *adap;</span><br><span class="line">	struct i2c_dev *i2c_dev;</span><br><span class="line"></span><br><span class="line">	if (dev-&gt;type !&#x3D; &amp;i2c_adapter_type)</span><br><span class="line">		return 0;</span><br><span class="line">	adap &#x3D; to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	i2c_dev &#x3D; i2c_dev_get_by_minor(adap-&gt;nr);</span><br><span class="line">	if (!i2c_dev) &#x2F;* attach_adapter must have failed *&#x2F;</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	device_remove_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	return_i2c_dev(i2c_dev);</span><br><span class="line">	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-dev: adapter [%s] unregistered\n&quot;, adap-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,</span><br><span class="line">			 void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; data;</span><br><span class="line"></span><br><span class="line">	switch (action) &#123;</span><br><span class="line">	case BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		return i2cdev_attach_adapter(dev, NULL);</span><br><span class="line">	case BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		return i2cdev_detach_adapter(dev, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct notifier_block i2cdev_notifier &#x3D; &#123;</span><br><span class="line">	.notifier_call &#x3D; i2cdev_notifier_call,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* ------------------------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * module load&#x2F;unload record keeping</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int __init i2c_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO &quot;i2c &#x2F;dev entries driver\n&quot;);</span><br><span class="line"></span><br><span class="line">	res &#x3D; register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	i2c_dev_class &#x3D; class_create(THIS_MODULE, &quot;i2c-dev&quot;);</span><br><span class="line">	if (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">		res &#x3D; PTR_ERR(i2c_dev_class);</span><br><span class="line">		goto out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Keep track of adapters which will be added or removed later *&#x2F;</span><br><span class="line">	res &#x3D; bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out_unreg_class;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Bind to already existing adapters right away *&#x2F;</span><br><span class="line">	i2c_for_each_dev(NULL, i2cdev_attach_adapter);&#x2F;&#x2F;绑定存在的 i2c 控制器（adapter）</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">	unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">out:</span><br><span class="line">	printk(KERN_ERR &quot;%s: Driver Initialisation failed\n&quot;, __FILE__);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit i2c_dev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	bus_unregister_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	i2c_for_each_dev(NULL, i2cdev_detach_adapter);</span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">	unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(&quot;Frodo Looijaard &lt;frodol@dds.nl&gt; and &quot;</span><br><span class="line">		&quot;Simon G. Vogl &lt;simon@tk.uni-linz.ac.at&gt;&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;I2C &#x2F;dev entries driver&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line">module_init(i2c_dev_init);</span><br><span class="line">module_exit(i2c_dev_exit);</span><br></pre></td></tr></table></figure>



<h2 id="用户空间操作"><a href="#用户空间操作" class="headerlink" title="用户空间操作"></a>用户空间操作</h2><p>1、查看所有i2c设备，nr为adapter的编号，如，nr有0、1、2、3等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ # ls -la &#x2F;dev&#x2F;i2c*</span><br><span class="line">crw-rw----    1 root     root       89,   1 Jan  2 14:33 &#x2F;dev&#x2F;i2c-1</span><br></pre></td></tr></table></figure>

<p>2、查询i2c设备地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ # ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;</span><br><span class="line">1-001b  1-0029  1-0030  1-0032  1-0034  1-0036  1-0048  1-0057  i2c-1</span><br><span class="line">1-0022  1-002d  1-0031  1-0033  1-0035  1-0037  1-004a  1-0076</span><br></pre></td></tr></table></figure>

<p>3、查询i2c设备名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ # cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;i2c-1&#x2F;name</span><br><span class="line">OMAP I2C adapter</span><br><span class="line">查看触摸屏i2c设备名称</span><br><span class="line">~ # cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;1-004a&#x2F;name</span><br><span class="line">atmel_mxt_ts</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>应用层可以使用i2ctools工具调试i2c设备，参考下面连接</p>
<p>【<a href="https://i2c.wiki.kernel.org/index.php/I2C_Tools】" target="_blank" rel="noopener">https://i2c.wiki.kernel.org/index.php/I2C_Tools】</a></p>
<p>【<a href="https://elinux.org/Interfacing_with_I2C_Devices】" target="_blank" rel="noopener">https://elinux.org/Interfacing_with_I2C_Devices】</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
