<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="冒险，创新，永不放弃">
<meta property="og:type" content="website">
<meta property="og:title" content="Tech Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="冒险，创新，永不放弃">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="David Meng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android-emmc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android-emmc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">【转载】Android-emmc性能测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-29 15:14:07 / Modified: 15:18:06" itemprop="dateCreated datePublished" datetime="2020-12-29T15:14:07+08:00">2020-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="http://qiushao.net/2020/02/12/Android/emmc-performance-test/】" target="_blank" rel="noopener">http://qiushao.net/2020/02/12/Android/emmc-performance-test/】</a></p>
<h2 id="Android-emmc性能测试"><a href="#Android-emmc性能测试" class="headerlink" title="Android-emmc性能测试"></a>Android-emmc性能测试</h2><p>在 Android 可以用来测试 emmc io 性能的工具有很多，　比如 fio, iozone, dd 等。　看了大半天的　fio, iozone，　感觉用起来比较复杂，相对来说还是使用 dd 简单方便。接下来我们就以 dd 为主介绍一下如何测试 emmc 的 io　性能。</p>
<h2 id="1-页面缓存"><a href="#1-页面缓存" class="headerlink" title="1. 页面缓存"></a>1. 页面缓存</h2><p>在开始之前，我们先了解一下页面缓存的概念。简单的说就是系统会把读取过的部分文件缓存到内存中，以此加快热点文件的读取速度，提高磁盘的 IO 速度。<br>具体的原理见 <a href="http://www.ilinuxkernel.com/files/Linux.Kernel.Cache.pdf" target="_blank" rel="noopener">Linux内核文件Cache机制</a>。<br>为了测试 emmc 的真实读写性能，我们需要先把页面缓存给清理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br></pre></td></tr></table></figure>

<p>我们先看看页面缓存的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 5.023993 seconds, 203.8MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #                                                               </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 0.564027 seconds, 1.8GB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; # </span><br><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 5.103213 seconds, 200.7MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>连续执行两次同样参数的 dd 命令，　从 /dev/block/mmcblk0 (也就是我们的 emmc) 块设备中读取内容，　写到 /dev/null 。/dev/null 是一个虚拟设备，写入这个路径并不会保存，我们可以认为这个设备的写入速度无限大，　也就是写入速度不会成为这个命令的瓶颈，　我们这个命令主要是为了测试 emmc 的读取速度。可以看到第一次执行的结果是 203.8MB/s，　第二次执行的结果是 1.8GB/s。从这个数据来看，页面缓存极大的提高了热点文件的读取速度。然后我们用 <code>echo 1 &gt; /proc/sys/vm/drop_caches</code>　命令清除一下页面缓存，再执行同样的 dd　命令，发现速度跟第一次差不多了。</p>
<h2 id="2-写入性能测试"><a href="#2-写入性能测试" class="headerlink" title="2. 写入性能测试"></a>2. 写入性能测试</h2><p>我们分为两种情况来测试</p>
<h3 id="2-1-写入块设备"><a href="#2-1-写入块设备" class="headerlink" title="2.1 写入块设备"></a>2.1 写入块设备</h3><p>cache 分区一般是用来存放 OTA 升级包的，正常状态下挂载失败也不影响系统的正常运行，所以我们拿 cache 分区来作写入测试，先找到 cache 对应的块设备文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; #ls -l &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache                         &lt;</span><br><span class="line">lrwxrwxrwx 1 root root 21 1970-01-01 08:00 &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p18</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>cache 分区的块设备文件为 /dev/block/mmcblk0p18。<br>写入测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync     </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 24.122624 seconds, 42.4MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>输入文件为 /dev/zero，是一个虚拟设备，我们可以认为这个设备的读取速度无限大，也就是读取速度不会影响到写入的速度。<br>bs=1M : 一次写入 1M<br>count=1024 : 写入 1024 次，也就是写入的数据总量为 1G<br><strong>conv=fsync : dd 结束前，把数据同步到 emmc，如果没加这个参数的话，数据可能还在缓存之中。为了确保数据准确，一定要加这个参数。</strong></p>
<p>重复测试几次，速度基本在 42M/s　左右。</p>
<h3 id="2-2-写入文件"><a href="#2-2-写入文件" class="headerlink" title="2.2 写入文件"></a>2.2 写入文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;data&#x2F;ddtest.bin bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync                         &lt;</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 30.607905 seconds, 33.5MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>重复测试几次，速度基本在 33M/s　左右。相对直接写块设备文件慢了 10M/s 左右。这可能是文件系统带来的影响。</p>
<h2 id="3-读取测试"><a href="#3-读取测试" class="headerlink" title="3. 读取测试"></a>3. 读取测试</h2><h3 id="3-1-读取块设备"><a href="#3-1-读取块设备" class="headerlink" title="3.1 读取块设备"></a>3.1 读取块设备</h3><p>直接用我们上面介绍清除缓存的例子就行，这里就不再重复了。<br>从上面的例子得到的数据为 203M/s 左右。</p>
<h3 id="3-1-读取文件"><a href="#3-1-读取文件" class="headerlink" title="3.1 读取文件"></a>3.1 读取文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;data&#x2F;ddtest.bin of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 4.915286 seconds, 208.3MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>直接拿测试写入速度时生成的文件，重复测试几次，速度基本上在 208MB/s 左右。</p>
<h2 id="4-对比iozone"><a href="#4-对比iozone" class="headerlink" title="4. 对比iozone"></a>4. 对比iozone</h2><p>Android 系统源码中并没有 iozone，我们得自己人官网上下载编译，我下载时最新版本为　iozone3_489，　这个版本已经有 Android.mk 在代码里面了，　将源码放到 Android 系统源码里面 mm 即可。<br>随机读写测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">KKHi3751V810:&#x2F; # iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin                             </span><br><span class="line">        Iozone: Performance Test of File I&#x2F;O</span><br><span class="line">                Version $Revision: 3.489 $</span><br><span class="line">                Compiled for 64 bit mode.</span><br><span class="line">                Build: linux-arm </span><br><span class="line"></span><br><span class="line">        Contributors:William Norcott, Don Capps, Isom Crawford, Kirby Collins</span><br><span class="line">                     Al Slater, Scott Rhine, Mike Wisner, Ken Goss</span><br><span class="line">                     Steve Landherr, Brad Smith, Mark Kelly, Dr. Alain CYR,</span><br><span class="line">                     Randy Dunlap, Mark Montague, Dan Million, Gavin Brebner,</span><br><span class="line">                     Jean-Marc Zucconi, Jeff Blomberg, Benny Halevy, Dave Boone,</span><br><span class="line">                     Erik Habbinga, Kris Strecker, Walter Wong, Joshua Root,</span><br><span class="line">                     Fabrice Bacchella, Zhenghua Xue, Qin Li, Darren Sawyer,</span><br><span class="line">                     Vangel Bojaxhi, Ben England, Vikentsi Lapa,</span><br><span class="line">                     Alexey Skidanov, Sudhir Kumar.</span><br><span class="line"></span><br><span class="line">        Run began: Wed Feb 12 20:47:58 2020</span><br><span class="line"></span><br><span class="line">        Auto Mode</span><br><span class="line">        Cross over of record size disabled.</span><br><span class="line">        Include fsync in write timing</span><br><span class="line">        Include close in write timing</span><br><span class="line">        O_DIRECT feature enabled</span><br><span class="line">        No retest option selected</span><br><span class="line">        Record Size 1024 kB</span><br><span class="line">        File size set to 1048576 kB</span><br><span class="line">        Setting no_unlink</span><br><span class="line">        Command line used: iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin</span><br><span class="line">        Output is in kBytes&#x2F;sec</span><br><span class="line">        Time Resolution &#x3D; 0.000001 seconds.</span><br><span class="line">        Processor cache size set to 32 kBytes.</span><br><span class="line">        Processor cache line size set to 64 bytes.</span><br><span class="line">        File stride size set to 17 * record size.</span><br><span class="line">                                                              random    random     bkwd    record    stride                                    </span><br><span class="line">              kB  reclen    write  rewrite    read    reread    read     write     read   rewrite      read   fwrite frewrite    fread  freread</span><br><span class="line">         1048576    1024    74782        0                     199299    71520                                                                </span><br><span class="line"></span><br><span class="line">iozone test complete.</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>从结果来看，随机读速度为 199299 kB/s , 大概为 200M/s。　随机写速度为 71520 kB/s，　大概为 70M/s。<br>重复测试几次结果差不多，读的速度基本跟 dd 的一致。写入的比 dd 的快了将近一倍。</p>
<h2 id="5-对比fio"><a href="#5-对比fio" class="headerlink" title="5. 对比fio"></a>5. 对比fio</h2><h3 id="5-1-写入文件速度"><a href="#5-1-写入文件速度" class="headerlink" title="5.1 写入文件速度"></a>5.1 写入文件速度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randwrite -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_write_1m</span><br><span class="line">rand_write_1m: (g&#x3D;0): rw&#x3D;randwrite, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1</span><br><span class="line">...</span><br><span class="line">fio-2.2.6</span><br><span class="line">Starting 4 threads</span><br><span class="line">Jobs: 3 (f&#x3D;3): [w(3),_(1)] [98.1% done] [0KB&#x2F;80734KB&#x2F;0KB &#x2F;s] [0&#x2F;78&#x2F;0 iops] [eta 00m:01s]</span><br><span class="line">rand_write_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;8316: Wed Feb 12 21:03:34 2020</span><br><span class="line">  write: io&#x3D;4096.0MB, bw&#x3D;83067KB&#x2F;s, iops&#x3D;81, runt&#x3D; 50493msec</span><br><span class="line">    clat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.60, stdev&#x3D;44.45</span><br><span class="line">     lat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.86, stdev&#x3D;44.44</span><br><span class="line">    clat percentiles (msec):</span><br><span class="line">     |  1.00th&#x3D;[   18],  5.00th&#x3D;[   22], 10.00th&#x3D;[   23], 20.00th&#x3D;[   26],</span><br><span class="line">     | 30.00th&#x3D;[   34], 40.00th&#x3D;[   37], 50.00th&#x3D;[   46], 60.00th&#x3D;[   48],</span><br><span class="line">     | 70.00th&#x3D;[   58], 80.00th&#x3D;[   65], 90.00th&#x3D;[   76], 95.00th&#x3D;[   87],</span><br><span class="line">     | 99.00th&#x3D;[  104], 99.50th&#x3D;[  114], 99.90th&#x3D;[  758], 99.95th&#x3D;[ 1123],</span><br><span class="line">     | 99.99th&#x3D;[ 1369]</span><br><span class="line">    bw (KB  &#x2F;s): min&#x3D; 1343, max&#x3D;41353, per&#x3D;25.49%, avg&#x3D;21171.93, stdev&#x3D;4637.55</span><br><span class="line">    lat (msec) : 20&#x3D;1.51%, 50&#x3D;60.52%, 100&#x3D;36.40%, 250&#x3D;1.37%, 500&#x3D;0.02%</span><br><span class="line">    lat (msec) : 750&#x3D;0.05%, 1000&#x3D;0.05%, 2000&#x3D;0.07%</span><br><span class="line">  cpu          : usr&#x3D;0.43%, sys&#x3D;1.13%, ctx&#x3D;10620, majf&#x3D;0, minf&#x3D;6</span><br><span class="line">  IO depths    : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     submit    : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     complete  : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     issued    : total&#x3D;r&#x3D;0&#x2F;w&#x3D;4096&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0</span><br><span class="line">     latency   : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  WRITE: io&#x3D;4096.0MB, aggrb&#x3D;83067KB&#x2F;s, minb&#x3D;83067KB&#x2F;s, maxb&#x3D;83067KB&#x2F;s, mint&#x3D;50493msec, maxt&#x3D;50493msec</span><br><span class="line"></span><br><span class="line">Disk stats (read&#x2F;write):</span><br><span class="line">  mmcblk0: ios&#x3D;54&#x2F;8332, merge&#x3D;5&#x2F;888, ticks&#x3D;60872&#x2F;378355, in_queue&#x3D;439181, util&#x3D;100.00%</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>4个线程的平均写入速度为 bw=83067KB/s，大概是 80M/s，　比 dd 也快了一倍多。</p>
<h3 id="5-2-读取文件速度"><a href="#5-2-读取文件速度" class="headerlink" title="5.2 读取文件速度"></a>5.2 读取文件速度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randread -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_read_1m</span><br><span class="line">rand_read_1m: (g&#x3D;0): rw&#x3D;randread, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1</span><br><span class="line">...</span><br><span class="line">fio-2.2.6</span><br><span class="line">Starting 4 threads</span><br><span class="line">Jobs: 1 (f&#x3D;1): [_(3),r(1)] [96.2% done] [148.5MB&#x2F;0KB&#x2F;0KB &#x2F;s] [148&#x2F;0&#x2F;0 iops] [eta 00m:01s]     </span><br><span class="line">rand_read_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;7889: Wed Feb 12 20:56:21 2020</span><br><span class="line">  read : io&#x3D;4096.0MB, bw&#x3D;171813KB&#x2F;s, iops&#x3D;167, runt&#x3D; 24412msec</span><br><span class="line">    clat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06</span><br><span class="line">     lat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06</span><br><span class="line">    clat percentiles (msec):</span><br><span class="line">     |  1.00th&#x3D;[    7],  5.00th&#x3D;[    8], 10.00th&#x3D;[    8], 20.00th&#x3D;[   11],</span><br><span class="line">     | 30.00th&#x3D;[   11], 40.00th&#x3D;[   11], 50.00th&#x3D;[   11], 60.00th&#x3D;[   14],</span><br><span class="line">     | 70.00th&#x3D;[   14], 80.00th&#x3D;[   14], 90.00th&#x3D;[   14], 95.00th&#x3D;[   14],</span><br><span class="line">     | 99.00th&#x3D;[   16], 99.50th&#x3D;[   30], 99.90th&#x3D;[ 2638], 99.95th&#x3D;[ 4113],</span><br><span class="line">     | 99.99th&#x3D;[ 9372]</span><br><span class="line">    bw (KB  &#x2F;s): min&#x3D;  964, max&#x3D;145420, per&#x3D;46.41%, avg&#x3D;79740.53, stdev&#x3D;25495.41</span><br><span class="line">    lat (msec) : 10&#x3D;13.77%, 20&#x3D;85.55%, 50&#x3D;0.29%, 100&#x3D;0.12%, 500&#x3D;0.05%</span><br><span class="line">    lat (msec) : 750&#x3D;0.05%, 2000&#x3D;0.05%, &gt;&#x3D;2000&#x3D;0.12%</span><br><span class="line">  cpu          : usr&#x3D;0.22%, sys&#x3D;3.16%, ctx&#x3D;9195, majf&#x3D;0, minf&#x3D;1030</span><br><span class="line">  IO depths    : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     submit    : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     complete  : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     issued    : total&#x3D;r&#x3D;4096&#x2F;w&#x3D;0&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0</span><br><span class="line">     latency   : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: io&#x3D;4096.0MB, aggrb&#x3D;171813KB&#x2F;s, minb&#x3D;171813KB&#x2F;s, maxb&#x3D;171813KB&#x2F;s, mint&#x3D;24412msec, maxt&#x3D;24412msec</span><br><span class="line"></span><br><span class="line">Disk stats (read&#x2F;write):</span><br><span class="line">  mmcblk0: ios&#x3D;8365&#x2F;46, merge&#x3D;15&#x2F;47, ticks&#x3D;633927&#x2F;61332, in_queue&#x3D;695214, util&#x3D;99.20%</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>４个线程的平均读速度为 bw=171813KB/s，　大概为 170M/s。</p>
<p>综合对比 dd, iozone, fio　这几个工具发现，读的速度基本上差不多，但写速度差距比较大，可能跟设置的参数有关。<br>为了简单起见，我们只采用 dd 的结果作为参考数据即可。</p>
<p>参考文章:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/MMC%20tools%20introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/MMC%20tools%20introduction/" class="post-title-link" itemprop="url">MMC tools introduction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-29 15:07:53 / Modified: 15:17:54" itemprop="dateCreated datePublished" datetime="2020-12-29T15:07:53+08:00">2020-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MMC-tools-introduction"><a href="#MMC-tools-introduction" class="headerlink" title="MMC tools introduction"></a>MMC tools introduction</h2><p>There is one MMC test tools called mmc-utils, which is maintained by Chris Ball, you can find it at the below public git repository:</p>
<p><a href="http://git.kernel.org/cgit/linux/kernel/git/cjb/mmc-utils.git/" target="_blank" rel="noopener">http://git.kernel.org/cgit/linux/kernel/git/cjb/mmc-utils.git/</a></p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>The mmc-utils tools can do the following:</p>
<ul>
<li>Print and parse extcsd data.</li>
<li>Determine the eMMC writeprotect status.</li>
<li>Set the eMMC writeprotect status.</li>
<li>Set the eMMC data sector size to 4KB by disabling emulation.</li>
<li>Create general purpose partition.</li>
<li>Enable the enhanced user area.</li>
<li>Enable write reliability per partition.</li>
<li>Print the response to STATUS_SEND (CMD13).</li>
<li>Enable the boot partition.</li>
<li>Set Boot Bus Conditions.</li>
<li>Enable the eMMC BKOPS feature.</li>
<li>Permanently enable the eMMC H/W Reset feature.</li>
<li>Permanently disable the eMMC H/W Reset feature.</li>
<li>Send Sanitize command.</li>
<li>Program authentication key for the device.</li>
<li>Counter value for the rpmb device will be read to stdout.</li>
<li>Read from rpmb device to output.</li>
<li>Write to rpmb device from data file.</li>
<li>Enable the eMMC cache feature.</li>
<li>Disable the eMMC cache feature.</li>
<li>Print and parse CID data.</li>
<li>Print and parse CSD data.</li>
<li>Print and parse SCR data.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】eMMC驱动分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-28 11:51:17 / Modified: 11:56:23" itemprop="dateCreated datePublished" datetime="2020-12-28T11:51:17+08:00">2020-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://www.daimajiaoliu.com/daima/4794cd5a29003fc】" target="_blank" rel="noopener">https://www.daimajiaoliu.com/daima/4794cd5a29003fc】</a></p>
<h1 id="基于ATMEL-sama5d3芯片与Linux-3-6-9内核"><a href="#基于ATMEL-sama5d3芯片与Linux-3-6-9内核" class="headerlink" title="基于ATMEL-sama5d3芯片与Linux-3.6.9内核"></a>基于ATMEL-sama5d3芯片与Linux-3.6.9内核</h1><h2 id="SD卡系列简介"><a href="#SD卡系列简介" class="headerlink" title="SD卡系列简介"></a>SD卡系列简介</h2><p>这些都是网上找出来的，权当作为开场白了。</p>
<p>MMC卡全称Multi Media Card，由西门子公司和SanDisk公司1997年推出的多媒体记忆卡标准。MMC卡尺寸为32mm x24mm x 1.4mm，它将存贮单元和控制器一同做到了卡上，智能的控制器使得MMC保证兼容性和灵活性。MMC卡具有MMC和SPI两种工作模式，MMC模式是默认工作模式，具有MMC的全部特性。而SPI模式则是MMC协议的一个子集，主要用于低速系统。</p>
<p>SD卡全称Secure Digital Memory Card，由松下、东芝和SanDisk公司于1999年8月共同开发的新一代记忆卡标准，已完全兼容MMC标准。SD卡比MMC卡多了一个进行数据著作权保护的暗号认证功能，读写速度比MMC卡快4倍。尺寸为32mm x 24mm x2.1mm，长宽和MMC卡一样，只是比MMC卡厚了0.7mm，以容纳更大容量的存贮单元。SD卡与MMC卡保持向上兼容，也就是说，MMC卡可以被新的设有SD卡插槽的设备存取，但是SD卡却不可以被设有MMC插槽的设备存取。</p>
<p>SDIO全称Secure Digital Input and Output Card，SDIO是在SD标准上定义了一种外设接口，它使用SD的I/O接口来连接外围设备，并通过SD上的I/O数据接口与这些外围设备传输数据。现在已经有很多手持设备支持SDIO功能，而且许多SDIO外设也被开发出来，目前常见的SDIO外设有：WIFI Card、GPS Card、 Bluetooth Card等等。</p>
<p>eMMC全称Embedded Multi MediaCard，是MMC协会所制定的内嵌式存储器标准规格，主要应用于智能手机和移动嵌入式产品等。eMMC是一种嵌入式非易失性存储系统，由闪存和闪存控制器两部分组成，它的一个明显优势是在封装中集成了一个闪存控制器，它采用JEDEC标准BGA封装，并采用统一闪存接口管理闪存。eMMC结构由一个嵌入式存储解决方案组成，带有MMC接口、快闪存储设备及主控制器，所有这些由一个小型BGA封装。由于采用标准封装，eMMC也很容易升级，并不用改变硬件结构。</p>
<h2 id="MMC-SD通信协议"><a href="#MMC-SD通信协议" class="headerlink" title="MMC/SD通信协议"></a>MMC/SD通信协议</h2><p>卡的状态与模式：</p>
<p>工作条件检测：</p>
<p>发送CMD0(reset)；</p>
<p>发送CMD8，用于取得SD卡支持的工作电压。</p>
<p>在版本2.0中，发送ACMD41，必须先发送CMD8，有应答则是高容量SD卡。</p>
<p>ACMD41是给卡的控制器一个识别卡是否能在给定电压下工作的机制。</p>
<p>卡根据CMD8的参数检测控制器的电压，如果电压不可以，卡处于Idle状态；如果电压可以，发送回执(check voltage, check pattern)，控制器分析回传的CMD8参数校验是否可以在给定的电压下工作。</p>
<p>在ACMD41之后，控制器与卡之间的工作电压将确定。</p>
<p>初始化：</p>
<p>开始于收到ACMD41。</p>
<p>响应CMD8的卡为SDHC卡，ACMD41的HCS部分为1；不响应CMD8的则是普通SD卡；</p>
<p>作为ACMD41的回应，SDHC卡会带有CCS=1。</p>
<p>控制器发送CMD2，处于Ready状态的卡，发送自己的CID作为响应，然后卡进入Identification状态。</p>
<p>控制器发送CMD3，SD卡会发送一个相对地址（RCA）作为响应。卡进入等待状态。</p>
<p>数据传输模式：</p>
<p>CMD7：选择某个卡进入Transfer状态。</p>
<p>CMD9：获取卡的CSD(card specific data)，包括块长度、卡的容量等。</p>
<p>CMD12：停止命令。</p>
<p>CMD17：块读命令。</p>
<p>CMD18：多块读命令。</p>
<p>ACMD51：发送scr(SD Configuration Register)</p>
<p>CMD24：块写命令。</p>
<p>CMD25：多块写命令。</p>
<p>CMD32：擦除的起始地址。</p>
<p>CMD33：擦除的截止地址。</p>
<p>CMD38：擦除命令。</p>
<p>仅仅看SPEC上的通信协议可能略有枯燥，结合代码就比较好理解了。关于SD卡的初始化过程参见：<a href="http://www.cnblogs.com/fengeryi/p/3469782.html" target="_blank" rel="noopener">http://www.cnblogs.com/fengeryi/p/3469782.html</a></p>
<p>这个博客详细描述了SD卡的初始化（mmc_sd_init_card()）。MMC卡的初始化是mmc_init_card()，大致过程相似，比SD卡的函数长不少，但实际的代码干的事情貌似比SD的那些简单一些。这里我们用到的是MMC卡，它的初始化后面会涉及到的。</p>
<p>关于eMMC的原理图部分：</p>
<p>现在的内核使用设备树文件，来描述ARM平台上的相关硬件设备资源。对于设备树（Device Tree）这个东西资料还不是很多，网上有宋宝华写的有关设备树的文章，挺值得参考的。</p>
<p>按我自己的理解，设备树文件就是用一种类似于C语言的东西来描述具体平台相关的硬件资源。这些文件使用特定的编译器编译为.dtb文件，在uboot加载内核的时候，将dtb文件提供给内核，内核便获知了具体的硬件设置；而不再是以前那样，各种各样的硬件信息统统编译进内核。</p>
<p>所使用的硬件资源，来自于设备树文件sama5d3.dtsi（arch/arm/boot/dts/sama5d3.dtsi）与MMC设置有关的寄存器地址：0xf0000000；长度0x600。中断号21，触发模式：4（上升沿触发）。中断优先级为0 。拥有的DMA资源是dma0，寄存器的配置为0x10002200 。</p>
<p>关于设备树文件含义的一些说明，在源码目录中的Document/devicetree/bindings/下有TXT类型的描述文档。</p>
<h2 id="MMC驱动的层次结构"><a href="#MMC驱动的层次结构" class="headerlink" title="MMC驱动的层次结构"></a>MMC驱动的层次结构</h2><p>CARD层  具体的块设备驱动</p>
<p>CORE层  为card层提供操作接口，为host层注册提供机制</p>
<p>HOST层  MMC/SD/SDIO的控制器驱动层</p>
<p>我觉得之所以将整个的驱动分为三层，是为了驱动能够更好的移植到其他的硬件平台上去。CARD层是通用的MMC块设备驱动，这些代码只要是Linux都可以用的；而HOST层里的代码则是与具体平台有关的，进去看文件与函数的名字就可以猜到——我们这里HOST层中的函数常常是”atmci”开头，意思是ATMEL的媒体控制接口，这是因为我们的平台是ATMEL的ARM芯片；而CORE层，则是提供了MMC/SD的核心机制，并且为CARD层屏蔽了HOST层中具体硬件的差异。基于这些有但不完全的原因，MMC/SD的驱动自然而然的分出了三层，也就是drivers/mmc下的三个文件夹。</p>
<h2 id="Linux内核中的面向对象的思想与实现"><a href="#Linux内核中的面向对象的思想与实现" class="headerlink" title="Linux内核中的面向对象的思想与实现"></a>Linux内核中的面向对象的思想与实现</h2><p>在个人学习Linux驱动的过程中，感觉如果只是按照一个一个函数的调用，不断的来回跳，即便是能看懂单个函数的意思，对于整个体系依然是云里雾里，不知内核写了神马东西。若是按照面向对象的思想去理解这些代码，我发现内核的东西就比较容易懂了。</p>
<p>内核虽然是用面向过程的C语言写出来的，但处处体现着面向对象的思想，甚至可以称为一种编程哲学（PS.那些把内核写出来的牛人们，实在太牛了）。Linux不仅仅把设备全部抽象为文件，这种宏观的抽象对象的方法在内核代码里也是比比皆是。个人感觉看代码是在自己脑子里把程序要处理的东西，都抽象为一件件具体的物品，对理解内核代码的来龙去脉，很有帮助。</p>
<p>Linux内核中用面向过程的C语言实现了面向对象的程序架构。一种面向对象的语言，拥有三方面的特性：封装、继承、多态。Linux内核用C语言的基本特性实现了这三种面向对象的特性：使用结构体实现了封装；而某一结构体成员中含有其他结构体的实例，这样实现了一个结构体对另一个结构体的继承；多态的实现则是使用了成员是函数指针的结构体，通过对该结构体中同一个函数指针赋不同的值，调用同一个成员，实际上就会调用不同的函数。当然这些只是我个人的理解了，不一定完全正确。</p>
<p>这种编程思想在驱动中的实现，则主要体现在驱动中对”总线””驱动””设备”这三种结构体处理上：</p>
<p>可以看出来，在驱动的整体框架代码中都是在描述这三个结构体的关系，而功能的实现常常被封装起来。</p>
<p>各种的驱动（device_driver）继承于device_driver结构体；</p>
<p>各种的设备（device）继承于device结构体；</p>
<p>各种的总线（bus）都是bus_type的实例化。</p>
<p>而上述这些都是直接或间接继承于基类kobject。Linux内核通过对kobject的操作，实现了对各部分（包括设备、驱动等）的管理。</p>
<p>驱动与设备在内核中的管理通过总线来实现，对于内核来说，驱动和设备是平级的，因为他们在内核看来都是一个个的继承于kobject的结构体。这一点与我们平常感觉驱动是依附在设备上的直观感觉不同。因为这些都是在代码里体现的，都是虚拟的0与1，驱动和设备以及总线，在内核看来自然差不多了，都是kobject。</p>
<p>在驱动或设备进行probe时，都是沿着总线上的设备和驱动进行匹配的。Linux使用总线的概念来管理设备与驱动的功用。总线就是挂着一串有着相似功用的东西的一根线，同种类的设备与驱动是挂在同一根总线上的，就像拴在一根线上的蚂蚱。在内核看来：这一根上拴的都是绿蚂蚱，那一根上拴的都是黄蚂蚱……想找哪一种蚂蚱，就把哪根线扯出来，再具体看自己是想要上面具体的哪一只蚂蚱。</p>
<p>初始化过程中，添加一个设备主要的工作是初始化继承于device的设备结构体，并把它添加到对应的总线上去。在总线上将去匹配挂在该总线上的驱动。</p>
<p>添加一个驱动的过程与此类似。</p>
<h2 id="MMC-SD驱动的流程"><a href="#MMC-SD驱动的流程" class="headerlink" title="MMC/SD驱动的流程"></a>MMC/SD驱动的流程</h2><p>在Linux启动过程中，加载的有关MMC的模块有3个，分别来自：</p>
<p>/drivers/mmc/core/core.c中的subsys_initcall（优先级4）</p>
<p>/drivers/mmc/card/block.c中的module_init（宏定义来自device_initcall）（优先级6）</p>
<p>/drivers/mmc/host/atmel-mci.c中的late_initcall（优先级7）</p>
<p>优先级的数字越小越是优先。描述各种加载优先级的宏，定义在include/linux/init.h中。</p>
<p>在core.c的init中注册了mmc_bus_type总线。</p>
<p>在block.c的init中调用了mmc_blk_init() → mmc_bus_register_driver()，向mmc_bus_type总线注册了mmc的块设备驱动，并有去尝试probe的动作；但是驱动并没有匹配到设备，因为此时对应的设备还没有注册到总线上，Linux此时并不知道设备的存在，因为到此late_initcall还没有执行到，所以并没有进行probe。</p>
<p>在atmel-mci.c的init调用了platform_driver_register()，完成主机的驱动与设备的注册，之后的一系列操作调用到了mmc_attach_mmc() → mmc_add_card()向总线注册了卡设备，并匹配到了之前的卡驱动。后面会继续详细说的。</p>
<p>在代码里可以看到，整个MMC的驱动涉及了两个总线：platform_bus_type总线和mmc_bus_type总线。因为内核将MMC/SD卡控制器抽象为一个platform总线设备，将MMC/SD卡（块设备）抽象为mmc总线设备。</p>
<p>插曲：{</p>
<p>嗯，上面说到了好多次”总线”，这里再补充说明一下：这”总线”并不是实实在在存在的物理上的电路线；当然对于I2C、SPI等类型的设备，它们有自己的i2c_bus_type和spi_bus_type，它们也的确有看得见摸得着的、用于连接控制器与物理设备的电线存在；但是内核是不理会任何电气特性的，内核认得的东西都是虚拟抽象出来的概念对象。I2C、SPI使用不同方式进行通信，内核对这些不同的方式（通信协议）有不同的处理与管理的方法，因此归纳为不同的”总线”，这个”总线”的概念与物理的”电线”没有逻辑依赖关系。</p>
<p>我看宋宝华的《Linux设备驱动开发详解》有关于platform的讲解，但是我一些内容理解有偏差：”在S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device”。我当时看了，以为platform总线是比i2c总线更为广泛的概念：i2c总线来自于platform总线。但是当我接触的sama5d3的Linux代码时，发现我之前理解的那样是有问题的，platform总线与i2c总线都是struct bus_type类型的实例，是平级的。Linux引入platform总线是为了描述那些不属于常见总线（常见的，比如i2c、spi等等）的设备的一种虚拟总线。</p>
<p>不过，对于”平级”的说法，是我这个初学者的个人看法哈<del>我发现在Linux启动的时候对platform总线是有”特别照顾”的，Linux启动时，系统会加载属于platform总线的设备。是不是i2c这样平台上自带的设备也会搭载这个顺风车？我就不是很清楚了，因为我还没有研究过Linux的I2C驱动。个人感觉应该会，毕竟都是平台（platform）上自带的嘛</del>那么《Linux设备驱动开发详解》我理解的没错只是因为知识不够，所以理解不透啦<del>！哈哈</del>我是新手啊~求别喷呀。</p>
<p>}</p>
<p>整个代码运行的大致流程如下：</p>
<p>从控制器的INIT到块设备的probe。橙色方框描述的是要依赖的一些功能。</p>
<p>下面开始一段一段的说了……</p>
<h3 id="函数atmci-init"><a href="#函数atmci-init" class="headerlink" title="函数atmci_init()"></a>函数atmci_init()</h3><p>（drivers/mmc/host/atmel-mci.c）</p>
<p>在这里的初始化直接对platform_driver的控制器驱动进行了probe。</p>
<p>下面将调用到platfrom_driver_register()。向platform总线注册驱动。凡是在总线注册了的驱动或设备，才是内核所能操作的。这其实是依赖有关于kobject的k_list。</p>
<p>platform_driver_probe() 与 platform_driver_register()</p>
<p>一般来说设备是不能被热插拔的，所以可以将probe()函数放在init中，来节省driver运行时候的内存开销。</p>
<p>一个驱动注册用platform_driver_probe()，在功能和使用上与platform_driver_register()是一样的。唯一的区别是它不能被以后其他的设备probe。也就是说，这个驱动只能和一个设备绑定。而这些的实现就是上图529——534行的代码，可以看看上面的那段注释。</p>
<h3 id="函数platform-driver-register"><a href="#函数platform-driver-register" class="headerlink" title="函数platform_driver_register()"></a>函数platform_driver_register()</h3><p>（drivers/base/platform.c）</p>
<p>将struct platform_driver类型的drv中的driver（struct device_driver类型）的probe成员、remove成员、shutdown成员，填入platform驱动的函数；然后调用driver_register()函数，将驱动注册到总线。</p>
<p>就是将drv变成platform driver。（重载了platform的操作函数，之后的调用者只管使用，并不关心是哪种总线的驱动。）</p>
<h3 id="函数driver-register"><a href="#函数driver-register" class="headerlink" title="函数driver_register()"></a>函数driver_register()</h3><p>将驱动添加到总线。</p>
<p>在driver_register()中主要的就是调用：</p>
<p>  bus_add_driver(drv);</p>
<p>完成驱动向总线的添加。这方面的实现主要是：</p>
<p>  driver_attach(drv);</p>
<p>在总线的设备列表（klist_devices）中遍历，尝试匹配这个驱动。</p>
<p>如果driver_probe_device()返回0，并且dev→driver被设置，就是找到了这个驱动匹配的设备。（这是我翻译的上图中的一句注释）</p>
<h3 id="函数bus-for-each-dev"><a href="#函数bus-for-each-dev" class="headerlink" title="函数bus_for_each_dev()"></a>函数bus_for_each_dev()</h3><p>可以看出该函数里面最终是调用了__driver_attach(dev,data)</p>
<p>dev来自于klist_devices的设备；</p>
<p>data就是drv。</p>
<p>那这里之前都是注册driver的，运行到这里要在总线上为driver匹配device了。这里是找到设备的，因为我当时打印的Log发现能够继续向下运行，没见有找不到设备的样子。那么这个dev是什么时候加到总线上的？我当时找了很久，没找到。也的确不是前面涉及的那些代码添加的设备，是在Linux系统加载的时候把platform设备加到对应的总线上的。</p>
<p>在init/main.c中</p>
<p>kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()初始化platform总线。在这里目前只找到这些可以确定的信息了。</p>
<p>在这个函数中，将由__driver_attach(dev, drv)来具体地实现设备与驱动的匹配。</p>
<h3 id="函数-driver-attach"><a href="#函数-driver-attach" class="headerlink" title="函数__driver_attach()"></a>函数__driver_attach()</h3><p>（drivers/base/dd.c）</p>
<p>driver_match_device(drv, dev)中调用了drv→bus→match(dev, drv)。</p>
<p>这个match是platform_match()进行设备名字与驱动名字的比较，相同或者drv→bus→match为空将返回1。</p>
<p>如果dev→driver之前没有被设置，将执行driver_probe_device()。</p>
<p>__driver_attach()</p>
<p>→ driver_probe_device()</p>
<p>→ really_probe()</p>
<p>{</p>
<p>…</p>
<p>if(dev→bus →probe){</p>
<p>ret = dev→bus→probe(dev);</p>
<p>…</p>
<p>} else if {</p>
<p>ret = drv→probe(dev);</p>
<p>…</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>在这里将会执行drv→probe(dev)（这个probe在platform_driver_register()中被赋值）即platform_drv_probe()，这个函数中调用的其实是drv→probe(dev)。在这里的probe就是atmci_probe()了。</p>
<p>以上调用过程的总结：</p>
<p>在最开始传入的是struct platform_driver *atmci_driver（代表了MMC/SD控制器驱动）。然后使用由Linux kernel提供的platform机制对改驱动进行注册。</p>
<p>完成系统内的注册后，将交给atmci_probe()来处理具体平台相关的工作。</p>
<p>这里对probe函数的处理，就类似于面向对象的”重载”。因为不管是什么样的platform驱动都会调用platform_drv_probe()，此处则是重载到了atmci_probe()。</p>
<h3 id="函数atmci-probe"><a href="#函数atmci-probe" class="headerlink" title="函数atmci_probe()"></a>函数atmci_probe()</h3><p>这个函数的操作主要是围绕struct atmel_mci *host展开的。这个结构体的含义应该是对控制器状态的描述。</p>
<p>可以分为两段：</p>
<p>第一段是获取资源。第二段是初始化slot。</p>
<p>获取内存资源；</p>
<p>从设备树的节点里读取信息到platform_data；</p>
<p>设置引脚模式；</p>
<p>获取中断资源；</p>
<p>初始化struct atmel_mci host中的锁和队列；</p>
<p>设置中断处理函数、数据传输方式，等。</p>
<p>atmci_init_slot()函数：设置硬件的相关信息，最后用这些信息初始化struct mmc_host *mmc硬件（表示mmc的控制器）。</p>
<p>主要包含mmc_alloc_host()为控制器结构体分配空间，并初始化控制器结构体；</p>
<p>和mmc_add_host()初始化host硬件。</p>
<h3 id="函数mmc-add-host"><a href="#函数mmc-add-host" class="headerlink" title="函数mmc_add_host()"></a>函数mmc_add_host()</h3><p>在atmci_probe()中调用的atmci_init_slot()，其前半段是获取资源设置相关信息，即函数mmc_alloc_host()。后半段则是使用这些信息去初始化MMC控制器的硬件，使之能够工作，即mmc_add_host()函数。</p>
<p>在mmc_add_host()中主要起作用的是mmc_start_host()</p>
<h3 id="函数mmc-detect-change"><a href="#函数mmc-detect-change" class="headerlink" title="函数mmc_detect_change()"></a>函数mmc_detect_change()</h3><p>（drivers/mmc/core/core.c）</p>
<p>当有卡插入或移除时，应调用这个函数，MMC层将确定现有的卡正常工作，并且初始化新插入的卡。</p>
<p>最主要的是mmc_schedule_delayed_work(&amp;host→detect, delay)</p>
<p>→ queue_delayed_work(workqueue, work, delay)</p>
<p>→ queue_work(wq, &amp;dwork→work)</p>
<p>mmc_schedule_delayed_work(&amp;host→detect, delay)的意思是，把&amp;host→detect作为一个work传给了queue_delayed_work()。</p>
<p>这个函数将一个工作（work）添加到workqueue这个工作队列中。</p>
<p>在工作队列中，不久将会调用host→detect描述的函数。</p>
<p>那这个detect指向的是哪一个函数？在mmc_alloc_host()中有：</p>
<p>INIT_DELAYED_WORK(&amp;host→detect, mmc_rescan);</p>
<p>含义为：初始化一个工作mmc_rescan，由detect指向它。</p>
<p>所以在工作队列workqueue中mmc_rescan()函数将被执行。在这个函数中将调用mmc_rescan_try_freq()，接下来将会是卡的检测与初始化。</p>
<p>以上阶段的总结：</p>
<p>struct atmci_mci 代表了MMC控制器的接口状态。并非内核中MMC控制器本身，而是其parent device。</p>
<p>在内核看来每一个卡槽（slot）由一个MMC控制器（struct mmc_host）来代表。嗯嗯，我是这样理解的。</p>
<h3 id="函数mmc-rescan"><a href="#函数mmc-rescan" class="headerlink" title="函数mmc_rescan()"></a>函数mmc_rescan()</h3><p>调用函数mmc_rescan_try_freq() （drivers/mmc/core/core.c）</p>
<p>首先发送CMD0，即mmc_go_idle()；</p>
<p>然后发送CMD8，即mmc_send_if_cond()；（其实后面还会在发送这些命令的。）</p>
<p>接下来依次探测SDIO、SD、MMC。</p>
<p>我们这里是eMMC，所以进入mmc_attach_mmc()：</p>
<h3 id="函数mmc-attach-mmc"><a href="#函数mmc-attach-mmc" class="headerlink" title="函数mmc_attach_mmc()"></a>函数mmc_attach_mmc()</h3><p>（drivers/mmc/core/mmc.c）</p>
<p>mmc_init_card()对一个卡（struct mmc_card card）进行初始化。</p>
<p>mmc_add_card()将卡设备添加到内核。</p>
<h3 id="函数mmc-init-card"><a href="#函数mmc-init-card" class="headerlink" title="函数mmc_init_card()"></a>函数mmc_init_card()</h3><p>下面的两个图是极简版的代码（原版的代码好像有460多行，挺长的），有好多重要的东西省掉了，仅仅是为了结合代码标注一下CMD。</p>
<p>CMD0：让卡进入idle状态。</p>
<p>CMD1：让卡发送OCR。</p>
<p>CMD2：向卡询问CID。</p>
<p>CMD3：设置卡的相对地址。</p>
<p>CMD9：获取卡的CSD。</p>
<p>CMD7：选择一个卡。</p>
<p>CMD8：获取扩展的CSD。</p>
<p>主机与卡之间的协调设置。（如：分区、掉电通知、高速等等）</p>
<p>CMD6：为选定的卡修改模式或更改EXT_CSD。（这个命令在mmc_switch()中的，上面的图中被省略了。）</p>
<p>总之，mmc_init_card()完成了对卡的应有的全部初始化工作，包括传输速度、总线宽度等等，但是要更改这些设置是不在这个函数中改的，这里全都是MMC/SD卡协议的落实。真正要改的话是在HOST层中改一些数据，而不是在这里的CORE层中改。在后面会说到如何更改传输速度和总线宽度的。</p>
<h3 id="函数mmc-add-card"><a href="#函数mmc-add-card" class="headerlink" title="函数mmc_add_card()"></a>函数mmc_add_card()</h3><p>（drivers/mmc/core/bus.c）</p>
<p>mmc_init_card()之后，调用mmc_add_card()，作用是将这个card设备添加到内核，内部调用了device_add将card→dev添加到内核中。</p>
<p>device_add(&amp;card→dev)</p>
<p>→ bus_probe_device(dev)</p>
<p>→ device_attach(dev)</p>
<p>→ bus_for_each_drv(dev→bus, NULL, dev, __device_attach)</p>
<p><strong>device_attach()与之前的</strong>driver_attach()基本一样。</p>
<p>我们传入的dev是&amp;card→dev，这个在mmc_alloc_card()中被赋值为mmc_bus_type。（mmc.c-866; bus.c-250）</p>
<p>如前面所说的那样，在上图中的driver_match_device()将调用dev的match函数（mmc_bus_match()）而这个函数始终返回1（里面什么都没写，除了一句”return 1;”）。</p>
<p>所以执行driver_probe_device()。这里将调用really_probe()执行mmc_bus_type结构体中的probe成员（mmc_bus_probe()）。</p>
<h3 id="函数mmc-bus-probe"><a href="#函数mmc-bus-probe" class="headerlink" title="函数mmc_bus_probe()"></a>函数mmc_bus_probe()</h3><p>（drivers/mmc/core/bus.c）</p>
<p>在to_mmc_driver()，将返回含有dev→driver的mmc_driver的指针。这个结构体中的probe()则是mmc_blk_probe()函数。</p>
<p>在mmc_dev_to_card()，将返回含有dev的mmc_card的指针。</p>
<p>在这个始终返回1的match，可以看出：挂在这条总线上的driver都会如此运行，也就是说都会来执行mmc_blk_probe()函数。（之所以要始终返回1，是为了，全部的设备都去匹配MMC的块设备驱动。）</p>
<p>现在，则是由CORE层转入了CARD层了。 struct mmc_driver， mmc_blk_probe()都是在 drivers/mmc/card/block.c中定义的。</p>
<h3 id="函数mmc-blk-probe"><a href="#函数mmc-blk-probe" class="headerlink" title="函数mmc_blk_probe()"></a>函数mmc_blk_probe()</h3><p>（drivers/mmc/card/block.c）</p>
<p>mmc_blk_alloc()为块设备分配空间，并初始化请求队列。</p>
<p>mmc_add_disk()中调用了add_disk()l函数，说明之前一定有alloc_disk和初始化队列的动作。</p>
<p>其中因为调用了add_disk()，磁盘设备将被”激活”，并随时会调用它提供的方法。</p>
<p>请求队列就是在mmc_blk_alloc()函数完成的。而其中的主要成分就是mmc_blk_alloc_req()。</p>
<h3 id="函数mmc-blk-alloc-req"><a href="#函数mmc-blk-alloc-req" class="headerlink" title="函数mmc_blk_alloc_req()"></a>函数mmc_blk_alloc_req()</h3><p>（drivers/mmc/card/block.c）</p>
<p>下图红线标注的依次是：</p>
<p>allco_disk()分配gendisk结构体；</p>
<p>初始化请求队列；</p>
<p>绑定请求函数。</p>
<p>下面是初始化major、fops、queue等。</p>
<p>MMC卡驱动走的块设备驱动的套路：</p>
<p>1.alloc_disk()分配了gendisk结构体。并初始化了major，fops，queue。</p>
<p>2.mmc_init_queue()初始化了队列，并将mmc_blk_issue_rq()绑定为请求函数。</p>
<p>3.调用add_disk()将块设备加到内核。</p>
<h3 id="函数add-disk"><a href="#函数add-disk" class="headerlink" title="函数add_disk()"></a>函数add_disk()</h3><p>由mmc_add_disk()调用的内核函数。</p>
<p>其完成的任务：</p>
<p>1.验证设备号。   blk_alloc_devt(&amp;disk→part0, &amp;devt);</p>
<p>2.注册bolck_device   register_disk(disk);</p>
<p>3.注册请求队列   blk_register_queue(disk);</p>
<p>mmc_blk_probe()</p>
<p>→ mmc_blk_alloc()</p>
<p>→ mmc_blk_alloc_req()</p>
<p>→ alloc_disk()</p>
<p>&amp; mmc_init_queue()</p>
<p>&amp; mmc_add_disk()</p>
<p>→ add_disk()</p>
<p>add_disk()的调用标志着一个块设备驱动将被激活。</p>
<p>MMC驱动的加载过程也到此结束。</p>
<p>以上阶段的总结：</p>
<h2 id="对卡插入的支持"><a href="#对卡插入的支持" class="headerlink" title="对卡插入的支持"></a>对卡插入的支持</h2><p>函数atmci_init_slot() （drivers/mmc/host/atmel-mci.c）</p>
<p>在中断处理函数atmci_detect_interrupt()中，调用了mod_timer()，这个函数会重新注册定时器到内核，而不管定时器函数是否被运行过。在注册定时器到内核的函数setup_timer()中的回调函数（atmci_detect_change()）中，最终调用了mmc_detect_change()。如前所述，此函数会引起<strong>函数mmc_rescan()</strong>的调用，这个函数就是检测卡是否插入的。</p>
<p>也就是说，detect引脚有中断，就会重新注册定时器到内核，经过一段时间，将运行定时器的回调函数，最终进行了插卡的检测。</p>
<p>不过我们这里是eMMC，是直接焊在板子上的，不会有什么插卡的动作；在这里只是提一下。</p>
<h2 id="MMC-SD卡读写"><a href="#MMC-SD卡读写" class="headerlink" title="MMC/SD卡读写"></a>MMC/SD卡读写</h2><h3 id="读写在内核中的处理层次"><a href="#读写在内核中的处理层次" class="headerlink" title="读写在内核中的处理层次"></a>读写在内核中的处理层次</h3><p>过程概述：</p>
<p>Linux系统调用（SCI）的实现机制，实际上是多路汇聚以及分解。汇聚点是0x80中断入口，所有的系统调用从用户空间汇聚到0x80中断，中断处理程序运行时，将根据不同的系统调用号分别处理。</p>
<p>例如，当调用read时，库函数在保存read的SCI号及参数后，陷入0x80中断。这时库函数的工作结束，从用户空间进入到内核空间。</p>
<p>0x80中断处理程序，根据系统调用号查询系统调用表。</p>
<p>以read为例，read对应的是sys_read，传递参数并运行sys_read。</p>
<p>最终将一个请求（request）传递给块设备驱动处理。</p>
<p>对应的块设备处理函数为mmc_blk_issue_rq()（drivers/mmc/card/block.c 在上文提到过，被绑定的请求函数）</p>
<p>请求的调用层次，见下图（图中第一项多写了一个”e”）：</p>
<h3 id="驱动层上的读写"><a href="#驱动层上的读写" class="headerlink" title="驱动层上的读写"></a>驱动层上的读写</h3><p>（将会对上图进行一些说明）</p>
<p>在函数mmc_blk_alloc_req中，调用的mmc_init_queue拉起了一个内核线程，这个线程主要的作用是把上层IO的request一个个地向具体的driver发送。</p>
<p>这个线程叫做”mmcdq”，函数mmc_queue_thread是实际做事情的。</p>
<p>线程mmcqd的工作非常简单，在blk_fetch_request(q)获取一个request后，最终通过调用mq→issue_fn(mq, req)向底层发送request。</p>
<p>这个函数便是mmc_blk_issue_rq。大部分request通过</p>
<p>ret = mmc_blk_issue_rw_rq(mq, req);</p>
<p>来发送。</p>
<p>之后会调用到mmc的core部分。</p>
<p>mmc_blk_issue_rw_rq()</p>
<p>→ mmc_start_req()</p>
<p>→ __mmc_start_req()</p>
<p>→ mmc_start_request()</p>
<p>→ host→ops→request(host, mrq)</p>
<p>== atmci_request()</p>
<p>→ atmci_queue_request(host, slot, mrq)</p>
<p>→ atmci_start_request(host, slot)</p>
<p>函数atmci_request() （drivers/mmc/host/atmel-mci.c）</p>
<p>atmci_request()</p>
<p>→ atmci_queue_request()</p>
<p>→ atmci_start_request()</p>
<p>如上图所示在atmel-mci.c, atmci_probe()中就对DMA操作函数进行准备了。</p>
<p>对atmci_start_request()的过程画了一个流程图：</p>
<p>以上过程的总结：</p>
<h2 id="修改MMC的传输速度"><a href="#修改MMC的传输速度" class="headerlink" title="修改MMC的传输速度"></a>修改MMC的传输速度</h2><p>函数atmci_init_slot() （drivers/mmc/host/atmel-mci.c）</p>
<h3 id="关于时钟-55MHz与44MHz"><a href="#关于时钟-55MHz与44MHz" class="headerlink" title="关于时钟 55MHz与44MHz"></a>关于时钟 55MHz与44MHz</h3><p>（因为发现软件上设置的是55MHz，实际测出来是44MHz）</p>
<p>mmc_set_clock()→atmci_set_ios()。52MHz最终由atmci_set_ios()处理。</p>
<p>这是cpu的spec上的相关说明，其中：</p>
<p>{CLKDIV, CLKODD} + 2 == (CLKDIV * 2 + CLKODD) + 2</p>
<p>drivers/mmc/host/atmel-mci.c</p>
<p>atmci_set_ios()</p>
<p>上图红线标出的三个宏定义为：</p>
<p>#define DIV_ROUND_UP(n, d)  (((n) + (d) - 1) / (d))</p>
<p>#define ATMCI_MR_CLKDIV(x)  ((x) &lt;&lt; 0)</p>
<p>#define ATMCI_MR_CLKODD(x)  ((x) &lt;&lt; 16)</p>
<p>那么，接下来我们按照代码中的描述，自己计算一下：</p>
<p>(132M + 52M - 1) / 52M = 3</p>
<p>clkdiv = 3 - 2 = 1</p>
<p>1 &gt;&gt; 1 = 0</p>
<p>1 &amp; 1 = 1</p>
<p>mode_reg = (0 &lt;&lt; 0) | (1 &lt;&lt; 16)</p>
<p>所以写入HSMCI_MR寄存器的是：CLKODD置1；CLKDIV是00000000。</p>
<p>根据cpu的spec，得：</p>
<p>CLKDIV * 2 + CLKODD + 2 </p>
<p>= 0 * 2 + 1 + 2</p>
<p>= 3 （3分频）</p>
<p>132MHz / 3 = 44MHz</p>
<p>所以传入的52MHz，实际获得的是44MHz。之前低速的26MHz，实际获得的是22MHz。</p>
<p>在atmci_set_ios()中的这些处理，是因为bus_hz具体是多少，写程序的人是不知道的，这个是由具体的硬件来决定的（在这里就是132MHz）。所以，不能保证设置52MHz，硬件就能真的分频出52MHz，于是设计了上面的运算：根据实际的总线时钟大小（132MHz），和软件中设定的时钟（52/26MHz）；计算出一个接近设定的时钟，而且能由总线时钟分频出来的一个值（44/22MHz）。</p>
<h2 id="我在更改过程中遇到的一些错误"><a href="#我在更改过程中遇到的一些错误" class="headerlink" title="我在更改过程中遇到的一些错误"></a>我在更改过程中遇到的一些错误</h2><h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><p>drivers/mmc/core/mmc.c</p>
<p>mmc_init_card()</p>
<p>导致不能启动。</p>
<p>我刚开始改的时候，直接去找时钟在哪里设定的，然后去改那个值。就做出了上图的更改，这样是片面的；因为52MHz同时需要对高速的支持，控制器与卡之间也要保持协调。</p>
<h3 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3><p>高速8bit模式下，数据传输可能出错（windows循环冗余检查出错）</p>
<p>出现条件：线路与示波器测试头接触时，很可能出现。这个错误只会出现在硬件测量的时候，如果安静地让它去复制，就不会出错，一切正常。</p>
<p>在4bit模式下的数据传输过程中没有出现这个情况。</p>
<p>解决方法：CPU的HSMCI_CFG寄存器HSMODE置位。</p>
<p>嗯嗯，这个驱动就这样粗略地整理完了……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20EMMC%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20EMMC%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">【转载】Linux EMMC子系统分析-初始化流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-28 11:46:19 / Modified: 11:49:56" itemprop="dateCreated datePublished" datetime="2020-12-28T11:46:19+08:00">2020-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://blog.csdn.net/kickxxx/article/details/51130888】" target="_blank" rel="noopener">https://blog.csdn.net/kickxxx/article/details/51130888】</a></p>
<p>最近在解EMMC的一个bug，发现Linux EMMC有点小复杂，先整理个文档出来吧</p>
<p>用的是TI 平台，仅分析MMC，不分析SD和SDIO</p>
<h1 id="mmc-init"><a href="#mmc-init" class="headerlink" title="mmc_init"></a>mmc_init</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2769 static int __init mmc_init(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2770 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2774 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2775     workqueue = alloc_ordered_workqueue("kmmcd", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2776     if (!workqueue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2777         return -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2778 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2779     ret = mmc_register_bus();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2780     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2781         goto destroy_workqueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2782 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2783     ret = mmc_register_host_class();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2784     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2785         goto unregister_bus;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2793 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2802 &#125;</span><br></pre></td></tr></table></figure>



<p>2775分配一个workqueue，这个workqueue是专门用来处理card detect的，EMMC因为是unremovable的，所以不需要关注它</p>
<p>2779 注册mmc_bus_type，实现如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int mmc_register_bus(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return bus_register(&amp;mmc_bus_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把mmc_bus_type注册到bus系统，后面调用device_add函数时，则会辗转调用到mmc_bus_type中的probe函数，不必太纠结在这个代码</p>
<p>mmc_init调用时间比较早，会在host驱动初始化之前执行完。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subsys_initcall(mmc_init);</span><br></pre></td></tr></table></figure>



<h1 id="host驱动初始化"><a href="#host驱动初始化" class="headerlink" title="host驱动初始化"></a>host驱动初始化</h1><p>kernel/drivers/mmc/host/omap_hsmmc.c</p>
<p>host驱动位置是kernel/drivers/mmc/host/，一般来说都是platform_driver，以omap hsmmc host驱动为例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>.probe      = omap_hsmmc_probe,<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .remove     = omap_hsmmc_remove,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .driver     = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .name = DRIVER_NAME,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .pm = &amp;omap_hsmmc_dev_pm_ops,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .of_match_table = of_match_ptr(omap_mmc_of_match),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_platform_driver(omap_hsmmc_driver);</span><br></pre></td></tr></table></figure>



<p>只需要关注omap_hsmmc_probe即可，当系统匹配到platform_device时，会调用omap_hsmmc_probe，好长的一个函数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2627     base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2628     if (IS_ERR(base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2629         return PTR_ERR(base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2630 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2631     ret = omap_hsmmc_gpio_init(pdata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2632     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2633         goto err;</span><br></pre></td></tr></table></figure>

<p>devm_ioremap_resource，实质就是ioremap，设备特定io资源到内核地址的映射，自行脑补一下ioremap。</p>
<p>omap_hsmmc_gpio_init是card detect和write protect gpio的初始化，Ignore it!!!</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2635     mmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2636     if (!mmc) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2637         ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2638         goto err_alloc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2639     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...............</span><br></pre></td></tr></table></figure>

<p>mmc_alloc_host，分配一个omap_hsmmc_host结构(包含struct mmc_host)，以供后面玩耍</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2661     mmc-&gt;ops    = &amp;omap_hsmmc_ops;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2410 static const struct mmc_host_ops omap_hsmmc_ops = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2411     .enable = omap_hsmmc_enable_fclk,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2412     .disable = omap_hsmmc_disable_fclk,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2413     .post_req = omap_hsmmc_post_req,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2414     .pre_req = omap_hsmmc_pre_req,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2415     .request = omap_hsmmc_request,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2416     .set_ios = omap_hsmmc_set_ios,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2417     .get_cd = omap_hsmmc_get_cd,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2418     .get_ro = omap_hsmmc_get_ro,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2419     .init_card = omap_hsmmc_init_card,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2420     .start_signal_voltage_switch = omap_start_signal_voltage_switch,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2421     .card_busy = omap_hsmmc_card_busy,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2422     .execute_tuning = omap_execute_tuning,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2423     /* NYET -- enable_sdio_irq */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2424 &#125;;</span><br></pre></td></tr></table></figure>

<p> omap hsmmc host驱动和mmc子系统的所有接口都在这里了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">2663     mmc-&gt;f_min = OMAP_MMC_MIN_CLOCK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2675     if (pdata-&gt;max_freq &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2676         mmc-&gt;f_max = pdata-&gt;max_freq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2677         ret = clk_set_rate(host-&gt;fclk, pdata-&gt;max_freq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2678         if (ret) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2679             dev_err(dev, "failed to set clock to %d\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2680                 pdata-&gt;max_freq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2681             goto err1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2682         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2683     &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2684         mmc-&gt;f_max = OMAP_MMC_MAX_CLOCK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2685     &#125;</span><br></pre></td></tr></table></figure>

<p>定义了最小时钟400K，在系统初始化阶段为了兼容的原因会使用这个时钟。最大时钟为52MHZ，后面还有机会再修改这个时钟频率。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2724     mmc-&gt;max_segs = 1024;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2725 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2726     mmc-&gt;max_blk_size = 512;       /* Block Length at max can be 1024 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2727     mmc-&gt;max_blk_count = 0xFFFF;    /* No. of Blocks is 16 bits */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2728     mmc-&gt;max_req_size = mmc-&gt;max_blk_size * mmc-&gt;max_blk_count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2729     mmc-&gt;max_seg_size = mmc-&gt;max_req_size;</span><br></pre></td></tr></table></figure>



<p>mmc作为快设备，最主要的操作就是数据sectors读写，max_segs定义了block设备的request所支持的最大segment</p>
<p>max_blk_count 一个request中所包含的最大block数</p>
<p>其实多少都不重要，反正就是和request相关的一些上限。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">2731     mmc-&gt;caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2732              MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2733 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2734     mmc-&gt;caps |= mmc_slot(host).caps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2735     if (mmc-&gt;caps &amp; MMC_CAP_8_BIT_DATA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2736         mmc-&gt;caps |= MMC_CAP_4_BIT_DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2737     if (mmc_slot(host).nonremovable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2738         mmc-&gt;caps |= MMC_CAP_NONREMOVABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2741 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2742     if (of_property_read_bool(np, "sd-uhs-sdr12"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2743         mmc-&gt;caps |= MMC_CAP_UHS_SDR12;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2744     if (of_property_read_bool(np, "sd-uhs-sdr25"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2745         mmc-&gt;caps |= MMC_CAP_UHS_SDR25;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2746     if (of_property_read_bool(np, "sd-uhs-sdr50"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2747         mmc-&gt;caps |= MMC_CAP_UHS_SDR50;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2748     if (of_property_read_bool(np, "sd-uhs-sdr104"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2749         mmc-&gt;caps |= MMC_CAP_UHS_SDR104;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2750     if (of_property_read_bool(np, "sd-uhs-ddr50"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2751         mmc-&gt;caps |= MMC_CAP_UHS_DDR50;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2752     if (of_property_read_bool(np, "mmc-ddr-1_8v"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2753         mmc-&gt;caps |= MMC_CAP_1_8V_DDR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2754     if (of_property_read_bool(np, "mmc-hs200-1_8v"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2755         mmc-&gt;caps2 |= MMC_CAP2_HS200_1_8V_SDR;</span><br></pre></td></tr></table></figure>

<p>mmc-&gt;caps 表示host能力的标志，mmc-&gt;caps2 表示host更多的能力，也许有一天会添加mmc-&gt;caps3这个字段</p>
<p>MMCCAP_MMC_HIGHSPEED, MMC_CAP_SD_HIGHSPEED MMC_CAP_WAIT_WHILE_BUSY MMC_CAP_ERASE是最基本的能力</p>
<p>MMC_CAP_8_BIT_DATA表示数据总线是多少，EMMC 数据线支持8线，4线和1线。</p>
<p>2742 ~ 2755 通过of系统定义的一些特定能力，当前MMC_CAP_1_8V_DDR，MMC_CAP2_HS200_1_8V_SDR都很常见了。DDR是Double Date Rate的缩写，SDR是Single Data Rate的缩写</p>
<p>自行脑补百度资料DDR SDRAM， EMMC的DDR SDR与之类似。</p>
<p>DDR=Double Data Rate双倍速率同步动态随机存储器。严格的说DDR应该叫DDR SDRAM，人们习惯称为DDR，其中，SDRAM 是Synchronous Dynamic Random Access Memory的缩写，<br>即同步动态随机存取存储器。而DDR SDRAM是Double Data Rate SDRAM的缩写，是双倍速率同步动态随机存储器的意思。DDR内存是在SDRAM内存基础上发展而来的，仍然沿用SDRAM生产体系，<br>一个时钟周期内进行两次读/写操作，即在时钟的上升沿和下降沿分别执行一次读/写操作。</p>
<p>因此对于内存厂商而言，只需对制造普通SDRAM的设备稍加改进，即可实现DDR内存的生产，可有效的降低成本。Double Data Rate：与传统的单数据速率相比，DDR技术实现了一个时钟周期内进行两次读/写操作，即在时钟的上升沿和下降沿分别执行一次读/写操作。</p>
<p>注意对于EMMC CMD线来说，是没有DDR SDR说法的，CMD和response只在clock的上升沿传输，参见EMMC spec5.0 section 6.15.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2773     omap_hsmmc_conf_bus_power(host);</span><br></pre></td></tr></table></figure>

<p>设置EMMC总线电压，EMMC芯片支持3.3V, 1.8V和1.2V总线信号电压，host需要和EMMC芯片的电压匹配（就是相同了）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">2775     if (!pdev-&gt;dev.of_node) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2776         res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2777         if (!res) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2778             dev_err(mmc_dev(host-&gt;mmc), "cannot get DMA TX channel\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2779             ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2780             goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2781         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2782         tx_req = res-&gt;start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2783 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2784         res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2785         if (!res) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2786             dev_err(mmc_dev(host-&gt;mmc), "cannot get DMA RX channel\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2787             ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2788             goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2789         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2790         rx_req = res-&gt;start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2791     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2792 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2793     dma_cap_zero(mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2794     dma_cap_set(DMA_SLAVE, mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2795 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2796     host-&gt;rx_chan =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2797         dma_request_slave_channel_compat(mask, omap_dma_filter_fn,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2798                          &amp;rx_req, &amp;pdev-&gt;dev, "rx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2799 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2800     if (!host-&gt;rx_chan) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2801         dev_err(mmc_dev(host-&gt;mmc), "unable to obtain RX DMA engine channel %u\n", rx_req);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2802         ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2803         goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2804     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2805 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2806     host-&gt;tx_chan =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2807         dma_request_slave_channel_compat(mask, omap_dma_filter_fn,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2808                          &amp;tx_req, &amp;pdev-&gt;dev, "tx");</span><br></pre></td></tr></table></figure>


<p>DMA相关的代码，内核中EMMC驱动必然要使用DMA方式读写数据，</p>
<p>dma_request_slave_channel_compat分配一个DMA channel</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2816     /* Request IRQ for MMC operations */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2817     ret = devm_request_irq(&amp;pdev-&gt;dev, host-&gt;irq, omap_hsmmc_irq, 0,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2818             mmc_hostname(mmc), host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2819     if (ret) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2820         dev_err(mmc_dev(host-&gt;mmc), "Unable to grab HSMMC IRQ\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2821         goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2822     &#125;</span><br></pre></td></tr></table></figure>

<p>设置中断处理函数，omap_hsmmc_irq负责处理EMMC 命令和EMMC DMA数据传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">2864     mmc_add_host(mmc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drivers/mmc/core/host.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">538 int mmc_add_host(struct mmc_host *host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">539 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">557     mmc_start_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">562 &#125;</span><br></pre></td></tr></table></figure>

<p>初始换mmc host硬件，mmc_start_host会负责扫描mmc设备</p>
<p>mmc_start_host-&gt;_mmc_detect_change -&gt; mmc_rescan -&gt;mmc_rescan_try_freq，对于REMOVALBE设备，rescan可以进行多次，而对于mmc这样的NON-REMOVABLE设备，只需扫描一次即可。</p>
<p>host会使用不同的频率发送命令到device，因此这个函数也是尝试设置f_init的过程</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2362 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2363 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2364     host-&gt;f_init = freq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2365 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2371     mmc_power_up(host, host-&gt;ocr_avail);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2372 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2389     /* Order's important: probe SDIO, then SD, then MMC */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2390     if (!mmc_attach_sdio(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2391         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2392     if (!mmc_attach_sd(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2393         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2394     if (!mmc_attach_mmc(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2395         printk(KERN_ERR "%s: end, host-&gt;index=%d\n", __func__, host-&gt;index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2396         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2397     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2401 &#125;</span><br></pre></td></tr></table></figure>

<p>分别用400K 300K 200K 100K 频率尝试和device通信，不过400K就会成功</p>
<p>mmc_power_up Power_up流程，可参见MMC spec5.0 A6.1，首先设置总线操作电压，然后设置clock</p>
<p>mmc_attach_mmc: mmc 卡初始化函数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">1785 int mmc_attach_mmc(struct mmc_host *host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1786 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1792    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1794     /* Set correct bus mode for MMC before attempting attach */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1795     if (!mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1796         mmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1797 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1798     err = mmc_send_op_cond(host, 0, &amp;ocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1799     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1800         return err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1804 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1805     mmc_attach_bus_ops(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1806     if (host-&gt;ocr_avail_mmc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1807         host-&gt;ocr_avail = host-&gt;ocr_avail_mmc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1808 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1817 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1818     rocr = mmc_select_voltage(host, ocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1819 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1827 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1828     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1829      * Detect and init the card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1830      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1831     err = mmc_init_card(host, rocr, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1832     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1833         goto err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1834 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1835     mmc_release_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1836     err = mmc_add_card(host-&gt;card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1837     mmc_claim_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1838     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1839         goto remove_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1840 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1842     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1856 &#125;</span><br></pre></td></tr></table></figure>

<p>mmc_send_op_cond等待device完成power up过程</p>
<p>mmc_select_voltage检查前面获得的ocr，判断ocr中标称的电压，返回的ocr为处理过的ocr</p>
<p>mmc_init_card 会读取cid csd ext_csd，并根据这些寄存器的值做一些初始化操作。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">133 int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">134 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">135     struct mmc_command cmd = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">136     int i, err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">139 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">140     cmd.opcode = MMC_SEND_OP_COND;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">141     cmd.arg = mmc_host_is_spi(host) ? 0 : ocr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">142     cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">143 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">144     for (i = 100; i; i--) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">145         err = mmc_wait_for_cmd(host, &amp;cmd, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">146         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">147             break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">148 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">149         /* if we're just probing, do a single pass */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">150         if (ocr == 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">151             break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">152 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">153         /* otherwise wait until reset completes */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">154         if (mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">155             if (!(cmd.resp[0] &amp; R1_SPI_IDLE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">156                 break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">157         &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">158             if (cmd.resp[0] &amp; MMC_CARD_BUSY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">159                 break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">160         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">161 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">162         err = -ETIMEDOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">163 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">164         mmc_delay(10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">165     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">166 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">167     if (rocr &amp;&amp; !mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">168         *rocr = cmd.resp[0];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">169 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">170     return err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">171 &#125;</span><br></pre></td></tr></table></figure>

<p>145 发送CMD1并等待R3</p>
<p>158 如果发现ocr的最高位为1，表示mmc device已经完成power up，否则循环发送CMD1，直到mmc device 完成power up</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> 969 static int mmc_init_card(struct mmc_host *host, u32 ocr,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 970     struct mmc_card *oldcard)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 971 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 995 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 996     /* The extra bit indicates that we support high capacity */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 997     err = mmc_send_op_cond(host, ocr | (1 &lt;&lt; 30), &amp;rocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 998     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 999         goto err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1000 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1010     /* </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1011      * Fetch CID from card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1012      */        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1013     if (mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1014         err = mmc_send_cid(host, cid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1015     else</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1016         err = mmc_all_send_cid(host, cid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1017     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1018         goto err;</span><br></pre></td></tr></table></figure>

<p>997 ocr | (1 &lt;&lt; 30) 表示驱动支持的是sector模式，Linux EMMC 子系统强制使用sector模式。</p>
<p>1016 mmc_all_send_cid 发送CMD10，并等待device 返回R2。CMD10请求设备发送CID给host</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1047     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1048      * For native busses:  set card RCA and quit open drain mode.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1049      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1050     if (!mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1051         err = mmc_set_relative_addr(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1052         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1053             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1054 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1055         mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1056     &#125;</span><br></pre></td></tr></table></figure>

<p>对于本地总线，也就是相对于spi emmc总线，需要设置emmc chip地址，并且设置总线模式为PUSHPULL</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1058     if (!oldcard) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1059         /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1060          * Fetch CSD from card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1061          */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1062         err = mmc_send_csd(card, card-&gt;raw_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1063         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1064             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1065 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1066         err = mmc_decode_csd(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1067         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1068             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1069         err = mmc_decode_cid(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1070         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1071             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1072     &#125;</span><br></pre></td></tr></table></figure>

<p>1062 发送MMC_SEND_CSD CMD9获取设备csd寄存器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1077     if (!mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1078         err = mmc_select_card(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1079         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1080             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1081     &#125;</span><br></pre></td></tr></table></figure>

<p> 1078 发送MMC_SELECT_CARD CMD7选择设备，device的状态会从standby状态转化为transfer状态。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">1083     if (!oldcard) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1084         /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1085          * Fetch and process extended CSD.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1086          */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1087 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1088         err = mmc_get_ext_csd(card, &amp;ext_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1089         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1090             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1091         err = mmc_read_ext_csd(card, ext_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1092         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1093             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1094 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1095         /* If doing byte addressing, check if required to do sector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1096          * addressing.  Handle the case of <span class="tag">&lt;<span class="name">2GB</span> <span class="attr">cards</span> <span class="attr">needing</span> <span class="attr">sector</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1097</span>          * <span class="attr">addressing.</span>  <span class="attr">See</span> <span class="attr">section</span> <span class="attr">8.1</span> <span class="attr">JEDEC</span> <span class="attr">Standard</span> <span class="attr">JED84-A441</span>;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1098</span>          * <span class="attr">ocr</span> <span class="attr">register</span> <span class="attr">has</span> <span class="attr">bit</span> <span class="attr">30</span> <span class="attr">set</span> <span class="attr">for</span> <span class="attr">sector</span> <span class="attr">addressing.</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1099</span>          */</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">1100         if (!(mmc_card_blockaddr(card)) &amp;&amp; (rocr &amp; (1&lt;&lt;30)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1101             mmc_card_set_blockaddr(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1102 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1103         /* Erase size depends on CSD and Extended CSD */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1104         mmc_set_erase_size(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1105     &#125;</span><br></pre></td></tr></table></figure>


<p>1088 获取ext_csd，ext_csd的获取，需要发送MMC_SEND_EXT_CSD，并从data线上获取device发送回ext_csd</p>
<p>1091 解析获取的ext_csd</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">1174     if (card-&gt;ext_csd.hs_max_dtr != 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1175         err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1176         if (card-&gt;ext_csd.hs_max_dtr &gt; 52000000 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1177             host-&gt;caps2 &amp; MMC_CAP2_HS200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1178             err = mmc_select_hs200(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1179         else if (host-&gt;caps &amp; MMC_CAP_MMC_HIGHSPEED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1180             err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1181                      EXT_CSD_HS_TIMING, 1,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1182                      card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1183 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1184         if (err &amp;&amp; err != -EBADMSG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1185             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1186 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1187         if (err) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1188             pr_warning("%s: switch to highspeed failed\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1189                    mmc_hostname(card-&gt;host));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1190             err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1191         &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1192             if (card-&gt;ext_csd.hs_max_dtr &gt; 52000000 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1193                 host-&gt;caps2 &amp; MMC_CAP2_HS200) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1194                 mmc_card_set_hs200(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1195                 mmc_set_timing(card-&gt;host,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1196                            MMC_TIMING_MMC_HS200);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1198             &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1199                 mmc_card_set_highspeed(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1200                 mmc_set_timing(card-&gt;host, MMC_TIMING_MMC_HS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1202             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1203         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1204     &#125;</span><br></pre></td></tr></table></figure>

<p>ext_csd.hs_max_dtr已经在mmc_select_card_type中设置为可支持的最大速度，这个值是由ext_csd[CARD_TYPE]以及host-caps2来决定的。比如host支持HS200，device 也支持HS200</p>
<p>那么理论上总线应该能跑到HS200，此时就设置ext_csd.hs_max_dtr为MMC_HS200_MAX_DTR</p>
<p>mmc_select_hs200设置device的timing为HS200</p>
<p>mmc_set_timing则设置host的timing 为HS200</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1211     if (mmc_card_highspeed(card) || mmc_card_hs200(card)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1212         if (max_dtr &gt; card-&gt;ext_csd.hs_max_dtr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1213             max_dtr = card-&gt;ext_csd.hs_max_dtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1214         if (mmc_card_highspeed(card) &amp;&amp; (max_dtr &gt; 52000000))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1215             max_dtr = 52000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1216     &#125; else if (max_dtr &gt; card-&gt;csd.max_dtr) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1217         max_dtr = card-&gt;csd.max_dtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1218     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1219 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1220     printk(KERN_ERR "%s: mmc_set_clock() max_dtr=%d\n", __func__, max_dtr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1221     mmc_set_clock(host, max_dtr);</span><br></pre></td></tr></table></figure>


<p>设置host的最大clock</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1267         ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1268                 EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1269         err = mmc_select_powerclass(card, ext_csd_bits);</span><br></pre></td></tr></table></figure>

<p>1269 设置device 的power class。关于power class, EMMC spec为了让host端控制EMMC芯片的耗电范围，允许host设置ext_csd的POWER_CLASS[187]来控制device的耗电行为。</p>
<p>但是低耗电带来的副作用就是性能的损失，所以linux emmc core 驱动都是性能优先。</p>
<p>mmc_add_card</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">309 int mmc_add_card(struct mmc_card *card)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">310 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">351 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">352     if (mmc_card_uhs(card) &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">353         (card-&gt;sd_bus_speed <span class="tag">&lt; <span class="attr">ARRAY_SIZE</span>(<span class="attr">uhs_speeds</span>)))</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">354</span>         <span class="attr">uhs_bus_speed_mode</span> = <span class="string">uhs_speeds[card-</span>&gt;</span>sd_bus_speed];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">355 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">356     if (mmc_host_is_spi(card-&gt;host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">357         pr_info("%s: new %s%s%s card on SPI\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">358             mmc_hostname(card-&gt;host),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">359             mmc_card_highspeed(card) ? "high speed " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">360             mmc_card_ddr_mode(card) ? "DDR " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">361             type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">362     &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">363         pr_info("%s: new %s%s%s%s%s card at address %04x\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">364             mmc_hostname(card-&gt;host),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">365             mmc_card_uhs(card) ? "ultra high speed " :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">366             (mmc_card_highspeed(card) ? "high speed " : ""),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">367             (mmc_card_hs200(card) ? "HS200 " : ""),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">368             mmc_card_ddr_mode(card) ? "DDR " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">369             uhs_bus_speed_mode, type, card-&gt;rca);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">370     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">379     ret = device_add(&amp;card-&gt;dev);</span><br></pre></td></tr></table></figure>


<p>352~370会输出mmc card的一些信息，比如high speed, HS200；DDR等</p>
<p>379会调用设备模型，增加设备，因为card属于mmc_bus，会调用mmc_bus_probe</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">110 static int mmc_bus_probe(struct device *dev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">111 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">112     int ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">113     struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">114     struct mmc_card *card = mmc_dev_to_card(dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">115 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">117     ret = drv-&gt;probe(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">118 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">120     return ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">121 &#125;</span><br></pre></td></tr></table></figure>

<p>drv-&gt;probe对应的是mmc/card/block.c中的mmc_driver-.probe</p>
<p>这样理解，每个mmc设备也是一个block设备，因此这个mmc设备，也要对应一个mmc block驱动。mmc block驱动需要调用驱动本身的probe函数，探测这个block设备</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">2429 static int mmc_blk_probe(struct mmc_card *card)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2430 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2431     struct mmc_blk_data *md, *part_md;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2432     char cap_str[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2439 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2440     md = mmc_blk_alloc(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2441     if (IS_ERR(md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2442         return PTR_ERR(md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2443 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2444     string_get_size((u64)get_capacity(md-&gt;disk) &lt;&lt; 9, STRING_UNITS_2,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2445             cap_str, sizeof(cap_str));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2446     pr_info("%s: %s %s %s %s\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2447         md-&gt;disk-&gt;disk_name, mmc_card_id(card), mmc_card_name(card),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2448         cap_str, md-&gt;read_only ? "(ro)" : "");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2449 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2450     if (mmc_blk_alloc_parts(card, md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2451         goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2452 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2453     mmc_set_drvdata(card, md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2454     mmc_fixup_device(card, blk_fixups);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2455 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2456     if (mmc_add_disk(md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2457         goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2458 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2459     list_for_each_entry(part_md, &amp;md-&gt;part, part) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2460         if (mmc_add_disk(part_md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2461             goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2462     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2467     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2468      * Don't enable runtime PM for SD-combo cards here. Leave that</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2469      * decision to be taken during the SDIO init sequence instead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2470      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2471     if (card-&gt;type != MMC_TYPE_SD_COMBO) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2472         pm_runtime_set_active(&amp;card-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2473         pm_runtime_enable(&amp;card-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2474     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2475 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2476     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2477 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2478  out:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2479     mmc_blk_remove_parts(card, md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2480     mmc_blk_remove_req(md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2481     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2482 &#125;</span><br></pre></td></tr></table></figure>

<p>2440 每一个mmc_card都对应一个mmc_blk_data，mmc_blk_data管理快设备相关的数据。</p>
<p>2450 mmc设备内部可能预先分配了boot partitions，以及最多四个general purpose partitions，需要为这些内置分区分配part。注意这些分区在系统中是以通用磁盘的形式存在的，并不是传统意义上的分区。</p>
<p>2456 mmc_add_disk增加mmc 设备到系统中，mmc_add_disk会调用add_disk向系统内增加通用硬盘，这个函数比较复杂，会单独开一个帖子分析add_disk的流程。</p>
<p>mmc_add_disk结束后，mmc设备的分区信息也已经添加到系统中。</p>
<p>mmc_blk_data主要实现函数是mmc_blk_alloc_req</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2074 static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2075                           struct device *parent,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2076                           sector_t size,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2077                           bool default_ro,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2078                           const char *subname,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2079                           int area_type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2080 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2116     md-&gt;disk = alloc_disk(perdev_minors);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2117     if (md-&gt;disk == NULL) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2118         ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2119         goto err_kfree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2120     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2126     ret = mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock, subname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2127     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2128         goto err_putdisk;</span><br></pre></td></tr></table></figure>


<p>2116 alloc_disk分配一个gendisk结构，在linux内核中gendisk用来表示一个磁盘或者分区</p>
<p>2126 初始化该块设备的queue，从这里我们可以看出不管mmc_blk_data对应是磁盘还是分区，都会为它分配queue。这是合理的，比如我们可以通过/dev/mmcblk0访问设备，也可以通过/dev/mmcblk0p1访问设备。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】eMMC驱动框架分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-28 11:31:17 / Modified: 11:36:59" itemprop="dateCreated datePublished" datetime="2020-12-28T11:31:17+08:00">2020-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://www.cnblogs.com/Lioker/p/11258958.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/11258958.html】</a></p>
<h1 id="一、MMC简介"><a href="#一、MMC简介" class="headerlink" title="一、MMC简介"></a>一、MMC简介</h1><p>eMMC使用BGA封装了Nand Flash和Flash控制器，向外提供MMC标准接口，其结构图如下图所示（图来自<a href="https://files.cnblogs.com/files/Lioker/eMMC.zip" target="_blank" rel="noopener">《eMMC5.1官方标准协议》</a>）。eMMC的出现使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。</p>
<p>对于我们来说，eMMC就是在Nand Flash上添加负责ECC、管理坏块等功能的控制器。</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1542940/202002/1542940-20200223143344599-1883319230.png" alt="img"></p>
<p>在内核中，使用MMC子系统统一管理MMC、SD、SDIO等设备。从MMC规范发布至今，基于不同的考量（物理尺寸、数据位宽和clock频率等），进化出了MMC、SD、microSD、SDIO、eMMC等不同的规范。其本质是一样的，这也是内核将它们统称为MMC的原因。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728091349445-637184680.png" alt="img"></p>
<p>和MTD相同，MMC驱动也有一个单独的文件夹，位于drivers/mmc目录下，目录下的三个目录card、core、host对应MMC驱动的三个层次。</p>
<p>\1. card：区块层，用于实现卡的块设备驱动。</p>
<p>\2. core：核心层，抽象了卡的设备驱动的函数。</p>
<p>\3. host：主机控制器层，依赖于不同平台的控制器操作函数。</p>
<h1 id="二、MMC框架分析"><a href="#二、MMC框架分析" class="headerlink" title="二、MMC框架分析"></a>二、MMC框架分析</h1><p>为了方便分析框架，我们需要分析host目录，读者可在此目录下任意选择一个单板驱动文件进行分析，我选择的是s3cmci.c文件。</p>
<p>文件链接：</p>
<p><a href="https://files.cnblogs.com/files/Lioker/19_emmc.zip" target="_blank" rel="noopener">https://files.cnblogs.com/files/Lioker/19_emmc.zip</a></p>
<p>首先来看它的入口函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static int __init s3cmci_init(void)</span><br><span class="line">2 &#123;</span><br><span class="line">3     return platform_driver_register(&amp;s3cmci_driver);</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>我们进入platform_driver的probe函数中，看看它如何初始化。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __devinit s3cmci_probe(struct platform_device *pdev)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct s3cmci_host *host;</span><br><span class="line"> 4     struct mmc_host    *mmc;</span><br><span class="line"> 5 ...</span><br><span class="line"> 6     &#x2F;* 分配mmc_host *&#x2F;</span><br><span class="line"> 7     mmc &#x3D; mmc_alloc_host(sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</span><br><span class="line"> 8 ...    &#x2F;* 省略阶段做的是设置s3cmci_host成员和gpio管脚 *&#x2F;</span><br><span class="line"> 9     request_irq(host-&gt;irq_cd, s3cmci_irq_cd, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, DRIVER_NAME, host));    </span><br><span class="line">10 ...</span><br><span class="line">11     &#x2F;* 设置mmc_host *&#x2F;</span><br><span class="line">12     mmc-&gt;ops     &#x3D; &amp;s3cmci_ops;</span><br><span class="line">13     mmc-&gt;ocr_avail    &#x3D; MMC_VDD_32_33 | MMC_VDD_33_34;</span><br><span class="line">14 #ifdef CONFIG_MMC_S3C_HW_SDIO_IRQ</span><br><span class="line">15     mmc-&gt;caps    &#x3D; MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;</span><br><span class="line">16 #else</span><br><span class="line">17     mmc-&gt;caps    &#x3D; MMC_CAP_4_BIT_DATA;</span><br><span class="line">18 #endif</span><br><span class="line">19     mmc-&gt;f_min     &#x3D; host-&gt;clk_rate &#x2F; (host-&gt;clk_div * 256);</span><br><span class="line">20     mmc-&gt;f_max     &#x3D; host-&gt;clk_rate &#x2F; host-&gt;clk_div;</span><br><span class="line">21 </span><br><span class="line">22     if (host-&gt;pdata-&gt;ocr_avail)</span><br><span class="line">23         mmc-&gt;ocr_avail &#x3D; host-&gt;pdata-&gt;ocr_avail;</span><br><span class="line">24 </span><br><span class="line">25     mmc-&gt;max_blk_count    &#x3D; 4095;</span><br><span class="line">26     mmc-&gt;max_blk_size    &#x3D; 4095;</span><br><span class="line">27     mmc-&gt;max_req_size    &#x3D; 4095 * 512;</span><br><span class="line">28     mmc-&gt;max_seg_size    &#x3D; mmc-&gt;max_req_size;</span><br><span class="line">29 </span><br><span class="line">30     mmc-&gt;max_segs        &#x3D; 128;</span><br><span class="line">31 ...</span><br><span class="line">32     &#x2F;* 添加mmc_host *&#x2F;</span><br><span class="line">33     ret &#x3D; mmc_add_host(mmc);</span><br><span class="line">34 ...</span><br><span class="line">35     platform_set_drvdata(pdev, mmc);</span><br><span class="line">36 ...</span><br><span class="line">37     return ret;</span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中，</p>
<p>\1. mmc_alloc_host()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc &#x3D; mmc_alloc_host(sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</span><br><span class="line">  -&gt; host &#x3D; kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</span><br><span class="line">  &#x2F;* 初始化工作队列 *&#x2F;</span><br><span class="line">  -&gt; INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</span><br></pre></td></tr></table></figure>

<p>\2. mmc_add_host()函数调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mmc_add_host(mmc);</span><br><span class="line">  -&gt; device_add(&amp;host-&gt;class_dev);</span><br><span class="line">  -&gt; mmc_start_host(host);</span><br><span class="line">    -&gt; mmc_power_off(host);            &#x2F;* 掉电刷新 *&#x2F;</span><br><span class="line">    -&gt; mmc_detect_change(host, 0);</span><br><span class="line">      -&gt; mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</span><br><span class="line">        &#x2F;* 在工作队列中添加一个延迟的工作任务host-&gt;detect *&#x2F;</span><br><span class="line">        -&gt; return queue_delayed_work(workqueue, work, delay);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>mmc_add_host()函数最终会调用mmc_alloc_host()初始化工作队列的mmc_rescan()函数。此函数用于检测是否有卡插入了卡控制器。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1 void mmc_rescan(struct work_struct *work)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     static const unsigned freqs[] &#x3D; &#123; 400000, 300000, 200000, 100000 &#125;;</span><br><span class="line"> 4     struct mmc_host *host &#x3D; container_of(work, struct mmc_host, detect.work);</span><br><span class="line"> 5     int i;</span><br><span class="line"> 6 ...</span><br><span class="line"> 7     mmc_bus_get(host);</span><br><span class="line"> 8 </span><br><span class="line"> 9     &#x2F;* 检测卡是否仍旧存在 *&#x2F;</span><br><span class="line">10     if (host-&gt;bus_ops &amp;&amp; host-&gt;bus_ops-&gt;detect &amp;&amp; !host-&gt;bus_dead</span><br><span class="line">11         &amp;&amp; !(host-&gt;caps &amp; MMC_CAP_NONREMOVABLE))</span><br><span class="line">12         host-&gt;bus_ops-&gt;detect(host);</span><br><span class="line">13 </span><br><span class="line">14     &#x2F;* If the card was removed the bus will be marked</span><br><span class="line">15      * as dead - extend the wakelock so userspace</span><br><span class="line">16      * can respond *&#x2F;</span><br><span class="line">17     if (host-&gt;bus_dead)</span><br><span class="line">18         extend_wakelock &#x3D; 1;</span><br><span class="line">19 </span><br><span class="line">20     &#x2F;*</span><br><span class="line">21      * Let mmc_bus_put() free the bus&#x2F;bus_ops if we&#39;ve found that</span><br><span class="line">22      * the card is no longer present.</span><br><span class="line">23      *&#x2F;</span><br><span class="line">24     mmc_bus_put(host);</span><br><span class="line">25     mmc_bus_get(host);</span><br><span class="line">26 </span><br><span class="line">27     &#x2F;* 如果卡仍存在, stop here *&#x2F;</span><br><span class="line">28     if (host-&gt;bus_ops !&#x3D; NULL) &#123;</span><br><span class="line">29         mmc_bus_put(host);</span><br><span class="line">30         mmc_set_drv_state(e_inserted,host);&#x2F;&#x2F;ly</span><br><span class="line">31         goto out;</span><br><span class="line">32     &#125;</span><br><span class="line">33 </span><br><span class="line">34     &#x2F;*</span><br><span class="line">35      * Only we can add a new handler, so it&#39;s safe to</span><br><span class="line">36      * release the lock here.</span><br><span class="line">37      *&#x2F;</span><br><span class="line">38     mmc_bus_put(host);</span><br><span class="line">39 </span><br><span class="line">40     &#x2F;* 卡不存在，释放 *&#x2F;</span><br><span class="line">41     if (host-&gt;ops-&gt;get_cd &amp;&amp; host-&gt;ops-&gt;get_cd(host) &#x3D;&#x3D; 0)&#123;</span><br><span class="line">42         mmc_set_drv_state(e_removed,host);</span><br><span class="line">43         goto out;</span><br><span class="line">44     &#125;</span><br><span class="line">45     mmc_claim_host(host);</span><br><span class="line">46     for (i &#x3D; 0; i &lt; ARRAY_SIZE(freqs); i++) &#123;</span><br><span class="line">47         if (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))) &#123;</span><br><span class="line">48             extend_wakelock &#x3D; true;</span><br><span class="line">49             break;</span><br><span class="line">50         &#125;</span><br><span class="line">51         if (freqs[i] &lt;&#x3D; host-&gt;f_min)</span><br><span class="line">52             break;</span><br><span class="line">53     &#125;</span><br><span class="line">54     mmc_release_host(host);</span><br><span class="line">55 </span><br><span class="line">56  out:</span><br><span class="line">57     if (extend_wakelock)</span><br><span class="line">58         wake_lock_timeout(&amp;host-&gt;detect_wake_lock, HZ &#x2F; 2);</span><br><span class="line">59     else</span><br><span class="line">60         wake_unlock(&amp;host-&gt;detect_wake_lock);</span><br><span class="line">61     if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL) &#123;</span><br><span class="line">62         wake_lock(&amp;host-&gt;detect_wake_lock);</span><br><span class="line">63         mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</span><br><span class="line">64     &#125;</span><br><span class="line">65 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>probe()函数所做的有以下几点：</strong></p>
<p>\1. 分配、设置并添加mmc_host</p>
<p>\2. 检测卡是否插入了卡控制器</p>
<p>如果在probe()函数执行时，卡并没有插入呢？也就是除了probe()函数，一定会有其他函数最终调用了mmc_rescan()函数。现在我们需要重新看一遍probe()函数，它注册了一个中断函数s3cmci_irq_cd()。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 static irqreturn_t s3cmci_irq_cd(int irq, void *dev_id)</span><br><span class="line">2 &#123;</span><br><span class="line">3     struct s3cmci_host *host &#x3D; (struct s3cmci_host *)dev_id;</span><br><span class="line">4     dbg(host, dbg_irq, &quot;card detect\n&quot;);</span><br><span class="line">5 </span><br><span class="line">6     mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));</span><br><span class="line">7 </span><br><span class="line">8     return IRQ_HANDLED;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>之前分析过，mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));函数最终会调用mmc_rescan()函数。</p>
<p>此时如果有卡插入了，会调用到mmc_rescan()函数，此函数调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mmc_rescan(struct work_struct *work)</span><br><span class="line">  -&gt; mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))</span><br><span class="line">    -&gt; mmc_attach_sdio(host)    &#x2F;* 检测卡的类型 *&#x2F;</span><br><span class="line">    -&gt; mmc_attach_sd(host)</span><br><span class="line">    -&gt; mmc_attach_mmc(host)</span><br><span class="line">      -&gt; mmc_send_op_cond(host, 0, &amp;ocr);         &#x2F;* 发送卡的ID *&#x2F;</span><br><span class="line">      -&gt; mmc_init_card(host, host-&gt;ocr, NULL);    &#x2F;* 初始化mmc_card *&#x2F;</span><br><span class="line">        -&gt; card &#x3D; mmc_alloc_card(host, &amp;mmc_type);</span><br><span class="line">          -&gt; device_initialize(&amp;card-&gt;dev);</span><br><span class="line">          -&gt; card-&gt;dev.bus &#x3D; &amp;mmc_bus_type;   &#x2F;* 设置总线为mmc_bus_type *&#x2F;</span><br><span class="line">        -&gt; card-&gt;type &#x3D; MMC_TYPE_MMC;         &#x2F;* 设置card结构体 *&#x2F;</span><br><span class="line">      -&gt; mmc_release_host(host);</span><br><span class="line">      -&gt; mmc_add_card(host-&gt;card);            &#x2F;* 添加卡mmc_card *&#x2F;</span><br><span class="line">        -&gt; device_add(&amp;card-&gt;dev);</span><br><span class="line">      -&gt; mmc_claim_host(host);                &#x2F;* 使能host *&#x2F;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在添加mmc_card调用device_add()函数时，mmc_bus_type总线会调用match()函数匹配设备驱动，如果匹配成功会调用总线的probe()函数或设备驱动的probe()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static int mmc_bus_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">2 &#123;</span><br><span class="line">3     return 1;    &#x2F;* 匹配永远成功 *&#x2F;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>probe()函数最终会调用mmc_driver的probe()函数。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 static int mmc_bus_probe(struct device *dev)</span><br><span class="line">2 &#123;</span><br><span class="line">3     struct mmc_driver *drv &#x3D; to_mmc_driver(dev-&gt;driver);</span><br><span class="line">4     struct mmc_card *card &#x3D; mmc_dev_to_card(dev);</span><br><span class="line">5 </span><br><span class="line">6     return drv-&gt;probe(card);</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在SI4的Project中搜索struct mmc_driver，发现只有block.c文件有对此结构体的定义。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728133653404-2134305167.png" alt="img"></p>
<p>现在我们来查看mmc_driver的probe()函数。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static int mmc_blk_probe(struct mmc_card *card)</span><br><span class="line">&#123;</span><br><span class="line">    struct mmc_blk_data *md, *part_md;</span><br><span class="line">    int err;</span><br><span class="line">    char cap_str[10];</span><br><span class="line">...</span><br><span class="line">    md &#x3D; mmc_blk_alloc(card);</span><br><span class="line"></span><br><span class="line">    err &#x3D; mmc_blk_set_blksize(md, card);</span><br><span class="line">...</span><br><span class="line">    mmc_set_drvdata(card, md);</span><br><span class="line">    mmc_fixup_device(card, blk_fixups);</span><br><span class="line">...</span><br><span class="line">    if (mmc_add_disk(md))</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(part_md, &amp;md-&gt;part, part) &#123;</span><br><span class="line">        if (mmc_add_disk(part_md))</span><br><span class="line">            goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mmc_blk_remove_parts(card, md);</span><br><span class="line">    mmc_blk_remove_req(md);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中，</p>
<p>\1. mmc_blk_alloc()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">md &#x3D; mmc_blk_alloc(card);</span><br><span class="line">  -&gt; md &#x3D; mmc_blk_alloc_req(card, &amp;card-&gt;dev, size, false, NULL);</span><br><span class="line">    -&gt; md-&gt;disk &#x3D; alloc_disk(perdev_minors);</span><br><span class="line">    -&gt; ret &#x3D; mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock, subname);</span><br><span class="line">      -&gt; mq-&gt;queue &#x3D; blk_init_queue(mmc_request, lock);</span><br><span class="line">    -&gt; set_capacity(md-&gt;disk, size);</span><br></pre></td></tr></table></figure>

<p>\2. mmc_add_disk()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmc_add_disk(md)</span><br><span class="line">  -&gt; add_disk(md-&gt;disk);</span><br><span class="line">  -&gt; device_create_file(disk_to_dev(md-&gt;disk), &amp;md-&gt;force_ro);</span><br></pre></td></tr></table></figure>



<p>这个mmc_driver底层做的与块设备驱动相同：</p>
<p>\1. 分配、初始化请求队列，绑定请求队列和请求函数</p>
<p>\2. 分配、设置并添加gendisk</p>
<p>\3. 注册块设备驱动</p>
<p>队列函数为mmc_blk_issue_rq()，其调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mmc_blk_issue_rq</span><br><span class="line">  -&gt; mmc_blk_issue_secdiscard_rq(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_discard_rq(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_flush(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_rw_rq(mq, req);    &#x2F;* 上面四个函数选一个执行 *&#x2F;</span><br><span class="line">    -&gt; mmc_wait_for_req(card-&gt;host, &amp;brq.mrq);</span><br><span class="line">      -&gt; mmc_start_request(host, mrq);</span><br><span class="line">        -&gt; host-&gt;ops-&gt;request(host, mrq);    &#x2F;* s3cmci.c中host-&gt;requset &#x3D; s3cmci_request *&#x2F;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h1 id="三、MMC驱动框架总结"><a href="#三、MMC驱动框架总结" class="headerlink" title="三、MMC驱动框架总结"></a>三、MMC驱动框架总结</h1><p>\1. 各个结构体作用：</p>
<p>struct mmc_card用于描述卡，struct mmc_driver用于描述卡驱动，sutrct mmc_host用于描述卡控制器，struct mmc_host_ops用于描述卡控制器操作函数。</p>
<p>\2. 整体框架：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728144349852-2146413256.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91EMMC%20%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91EMMC%20%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">【转载】EMMC 驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-28 11:26:37 / Modified: 11:57:08" itemprop="dateCreated datePublished" datetime="2020-12-28T11:26:37+08:00">2020-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：【<a href="https://blog.csdn.net/luopingfeng/article/details/42844611】" target="_blank" rel="noopener">https://blog.csdn.net/luopingfeng/article/details/42844611】</a></p>
<p>块设备是Linux最复杂的设备之一，但是作为执着于知其然的Geek，我们总会把代码翻个遍，把道理弄个透。当然了，快速地学习一种新的东西，方法是最重要的，个人觉得： 内核当中 MMC/SD 卡驱动程序构架是学习EMMC 驱动程序的重点，只有理解了它才能真正理解该块设备驱动程序，同时才能真正理解 LINUX 块设备驱动程序。</p>
<p> ben</p>
<p>一．需要的基础知识：</p>
<p>\1.    LINUX 设备驱动的基本结构。</p>
<p>\2.    块设备驱动程序的基本构架（相信研究过 LDD3 当中的 sbull 的人应该都不成问题，如果只是走马观花的话，那可得好好再补补了）</p>
<p>\3.    LINUX 设备驱动模型。</p>
<p>\4.    EMMC的原理，是Nand Flash的基础上加上一个负责：ECC、负载均衡和坏块管理功能的controler。</p>
<p>二．驱动程序分析</p>
<p>​    首先，说明一下EMMC驱动涉及到的文件。另外，我们重点是分析驱动程序的基本构架，所以不同内核版本的差异并不是很大。 MMC/SD 卡驱动程序位于 drivers/mmc 目录下</p>
<p>Card/</p>
<p>​    block.c</p>
<p>​    queue.c/queue.h</p>
<p>core/</p>
<p>​    bus.c/bus.h</p>
<p>​    core.c/core.h</p>
<p>​    host.c/host.h</p>
<p>​    mmc.c</p>
<p>​    mmc_ops.c/mmc_ops.h 拿 MMC 卡来分析， SD 卡驱动程序流程类似。</p>
<p>host/</p>
<p>​    s3cmci.c/s3cmci.h 以 S3C24XX 的 MMC/SD 卡控制器为例，其它类型的控制器类似。</p>
<p>LINUX 当中对目录的划分是很有讲究的，这些文件被分布在 3 个目录下，正好对应 MMC/SD 驱动程序的 3 个层次（关于层的划分这里浏览一下，有个概念即可，当我们分析完了后再回头来看，你会觉得很形象）：</p>
<p>（1）    区块层</p>
<p>主要是按照 LINUX 块设备驱动程序的框架实现一个卡的块设备驱动，这 block.c 当中我们可以看到写一个块设备驱动程序时需要的 block_device_operations 结构体变量的定义，其中有 open/release/request 函数的实现，而 queue.c 则是对内核提供的请求队列的封装，我们暂时不用深入理解它，只需要知道一个块设备需要一个请求队列就可以了。</p>
<p>（2）    核心层</p>
<p>核心层封装了 MMC/SD 卡的命令，例如存储卡的识别，设置，读写。例如不管什么卡都应该有一些识别，设置，和读写的命令，这些流程都是必须要有的，只是具体对于不同的卡会有一些各自特有的操作。 Core.c 文件是由 sd.c 、 mmc.c 两个文件支撑的， core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd.c 和 sd_ops.c 、 mmc.c 和 mmc_ops.c 来完成。</p>
<p>（3）    主机控制器层</p>
<p>主机控制器则是依赖于不同的平台的，例如 s3c2410 的卡控制器和 atmel 的卡控制器必定是不一样的，所以要针对不同的控制器来实现。以 s3cmci.c 为例，它首先要进行一些设置，例如中断函数注册，全能控制器等等。然后它会向 core 层注册一个主机（ host ），用结构 mmc_host_ops 描述，这样核心层就可以拿着这个 host 来操作 s3c24xx 的卡控制器了，而具体是 s3c24xx 的卡控制器还是 atmel 的卡控制器， core 层是不用知道的。 </p>
<p>   对这几个目录有一个大概认识以后，我们来看几个重要的数据结构：</p>
<p>struct mmc_host 用来描述卡控制器</p>
<p>struct mmc_card 用来描述卡</p>
<p>struct mmc_driver 用来描述 mmc 卡驱动</p>
<p>struct mmc_host_ops 用来描述卡控制器操作集，用于从主机控制器层向 core 层注册操作函数，从而将 core 层与具体的主机控制器隔离。也就是说 core 要操作主机控制器，就用这个 ops 当中给的函数指针操作，不能直接调用具体主控制器的函数。</p>
<p>第一阶段：</p>
<p>​    从 s3cmci_init 开始往下看</p>
<p>static int __init s3cmci_init(void)</p>
<p>{</p>
<p>platform_driver_register(&amp;s3cmci_driver_2410);</p>
<p>}</p>
<p>有 platform_driver_register 函数，根据设备模型的知识，我们知道那一定会有对应的 platform_device_register 函数的，可是在哪里呢？没有看到，那是不是这个 s3cmci_driver_2410 当中给的 probe 函数就不执行了？？？当然不是， mci 接口一般都是硬件做好的（我认为是这样），所以在系统启动时一定会有调用 platform_device­_register 对板上的资源进行注册，如果没有这个硬件资源，那我们这个驱动也就没有用了。好，我们就假定是有 mci 接口的，而且也有与 s3cmci_driver_2410 对应的硬件资源注册了，那自己就会去跑 probe 函数。来看一下 s3cmci_driver_2410:</p>
<p>static struct platform_driver s3cmci_driver_2410 = {</p>
<p>​    .driver.name  = “s3c2410-sdi”,</p>
<p>​    .probe      = s3cmci_probe_2410,</p>
<p>​    .remove     = s3cmci_remove,</p>
<p>​    .suspend = s3cmci_suspend,</p>
<p>​    .resume     = s3cmci_resume,</p>
<p>};</p>
<p>我们到 s3cmci_probe_2410 函数中看，还是干脆直接看 s3cmci_probe 算了：</p>
<p>static int s3cmci_probe(struct platform_device *pdev, int is2440) // 来自 /host/s3cmci.c</p>
<p>{</p>
<p>​    struct mmc_host  *mmc;</p>
<p>​    struct s3cmci_host    *host;</p>
<p>​    int ret;</p>
<p>……</p>
<p>​    mmc = mmc_alloc_host (sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</p>
<p>​    if (!mmc) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto probe_out;</p>
<p>​    }</p>
<p>……</p>
<p>​    mmc-&gt;ops   = &s3cmci_ops;</p>
<p>……</p>
<p>​    ret = mmc_add_host (mmc);</p>
<p>​    if (ret) {</p>
<p>​       dev_err(&amp;pdev-&gt;dev, “failed to add mmc host./n”);</p>
<p>​       goto free_dmabuf;</p>
<p>​    }</p>
<p>……</p>
<p>​    platform_set_drvdata(pdev, mmc);</p>
<p>​    return 0;</p>
<p>……</p>
<p>}</p>
<p>这个函数很长，做的事件也很多，但我们关心的整个驱动的构架 / 流程，所以过滤掉一些细节的东西，只看 2 个最重要的函数： mmc_alloc_host 、 mmc_add_host 。函数命名已经很形象了，前者是申请一个 mmc_host ，而后者是添加一个 mmc_host 。中间还有一个操作，就是给 mmc 的 ops 成员赋上了 s3cmci_ops 这个值。申请 mmc_host 当然很简单，就是申请一个结构体（我们暂且这样认为，因为他里面还做的其它事情，后面会看到），而添加又是添加到哪里去呢？看 mmc_add_host 函数：</p>
<p>int mmc_add_host(struct mmc_host *host) // 来自 core/host.c</p>
<p>{</p>
<p>​    int err;</p>
<p>……</p>
<p>​    err = device_add(&amp;host-&gt;class_dev);</p>
<p>​    if (err)</p>
<p>​       return err;</p>
<p>​    mmc_start_host(host);</p>
<p>​    return 0;</p>
<p>}</p>
<p>很简单，就是增加了一个 device ，然后就调用 mmc_start_host 了，那就先跳过 device_add 这个动作，来看 mmc_start_host:</p>
<p>void mmc_start_host(struct mmc_host *host) // 来自 /host/core.c</p>
<p>{</p>
<p>​    mmc_power_off(host);        // 掉电一下</p>
<p>​    mmc_detect_change(host, 0);       // ？？？</p>
<p>}</p>
<p>看上去只有两行代码，不过浓缩才是精华， mmc_power_off(host) 光看名子都知道是在干什么，先跳过，来看 mmc_detect_change ，那么它到底干了些什么呢？看一下就知道了：</p>
<p>void mmc_detect_change(struct mmc_host *host, unsigned long delay)  // core/core.c</p>
<p>{</p>
<p>​    mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</p>
<p>}</p>
<p>static int mmc_schedule_delayed_work(struct delayed_work *work, unsigned long delay)</p>
<p>{</p>
<p>​    return queue_delayed_work(workqueue, work, delay);</p>
<p>}</p>
<p>mmc_detect_change 又跳了一下，最后调用了 queue_delayed_work ，不知道这个函数功能的去查一下〈〈 LDD3 〉〉和〈〈深入理解 LINUX 内核〉〉，这几个代码告诉我们在 workqueue 这个工作队列当中添加一个延迟的工作任务，而这个工作任务就是由 host-&gt;detect 来描述的，在随后的 delay 个 jiffies 后会有一个记录在 host-&gt;detect 里面的函数被执行，那么到这里 s3cmci_probe 这个函数算是结束了，但事情还没有完， workqueue 这个工作队列还在忙，不一会儿它就会调用 host-&gt;detect 里面那个函数，这个函数到底是哪个函数，到底是用来干什么的呢？好像没有看到， detect 包含在 host 里面，那估计是在刚才那个申请的地方设置的那个函数，回过头来看一下 mmc_alloc_host:</p>
<p>struct mmc_host *mmc_alloc_host(int extra, struct device *dev) // 来自 core/host.c</p>
<p>{</p>
<p>​    struct mmc_host *host;</p>
<p>​    host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</p>
<p>​    if (!host)</p>
<p>​       return NULL;</p>
<p>​    INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</p>
<p>​    return host;</p>
<p>}</p>
<p>如果你看了 queue_delayed_work 这个函数功能介绍，相信对 INIT_DELAYED_WORK 也不会陌生了吧。不废话了，来看 mmc_rescan ：</p>
<p>// 来自 core/host.c</p>
<p>void mmc_rescan(struct work_struct *work)  // // 来自 core/host.c</p>
<p>{</p>
<p>​    struct mmc_host *host =   container_of(work, struct mmc_host, detect.work);</p>
<p>​    u32 ocr;</p>
<p>​    int err;</p>
<p>……</p>
<p>​    /* detect a newly inserted card */</p>
<p>……</p>
<p>​    /*</p>
<p>​     * First we search for SDIO…</p>
<p>​     */</p>
<p>​    err = mmc_send_io_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_sdio(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * …then normal SD…</p>
<p>​     */</p>
<p>​    err = mmc_send_app_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_sd(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * …and finally MMC.</p>
<p>​     */</p>
<p>​    err = mmc_send_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_mmc(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    mmc_release_host(host);</p>
<p>​    mmc_power_off(host);</p>
<p>out:</p>
<p>​    if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</p>
<p>​       mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</p>
<p>}</p>
<p>浏览一个这个函数，看看函数名，再看看注释，知道什么了吗？它是在检测是不是有卡插入了卡控制器，如果有卡挺入就要采取相应的行动了。这里要明白一点，我们平时用的 SD/MMC 卡就是一个卡，如果要操作它得用 SD/MMC 卡控制器才行，所以可以看到有 struct mmc_card,struct mmc_host 的区分。</p>
<p>​    到这里了，来回忆一下 s3cmci_probe 这个函数做的事情，大概就是准备一个 mmc_host 结构，然后添加一个主控制器设备到内核，最后又调用了一下 mmc_rescan 来检测是不是有卡插入了。</p>
<p>​    如果有卡插入了还好，可以去操作卡了，那如果没有卡插入呢？ mmc_rescan 不是白调用了一次吗？是啊，的确是白调用了一次。可是卡插入时为什么 PC 还是能检测到呢？看来卡检测的动作不光是在 probe 的最后一步做了一次，其它地方也有做。卡插入一般都是人为地随时去插入的，像这种情况一般都是会用中断机制去提供系统有外来侵入，然后再去采取行动。 SD/MMC 卡也的确是这样做的，找来找去，发现在 s3cmci_probe 里面注册了一个中断函数 s3cmci_irq_cd( 函数名的意思应该是 irq card detect) ，就是这个了，看看这个函数先：</p>
<p>static irqreturn_t s3cmci_irq_cd(int irq, void *dev_id)  // host/s3cmci.c</p>
<p>{</p>
<p>​    struct s3cmci_host *host = (struct s3cmci_host *)dev_id;</p>
<p>​    mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));</p>
<p>​    return IRQ_HANDLED;</p>
<p>}</p>
<p>看到这个函数想都不用想，直接跳到 mmc_rescan 里面去看就行了。前面已经知道了 mmc_rescan 里面就是在检测卡是不是插入了，既然卡随时插入我们都能检测到了，那就来看卡插入后都做了些什么动作吧。</p>
<p>第二阶段：</p>
<p>​    mmc_rescan 里面既要检测 sd 卡，又要检测 mmc 卡的，我们就照着一个往下走，假定有个人插入了 MMC 卡，那就应该走下面这几行：</p>
<p>​    err = mmc_send_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_mmc(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>mmc_send_op_cond 这个函数据说是读了一下卡的什么值，这个值是什么意义我也不清楚，这就像检测 FLASH 时读 FLASH 的 ID 一样，网卡也是这样的，不用管这个值的意义了，只要知道它能标识是一个 MMC 卡插入就行了。如果取这个值没有错误的话就得进 mmc_attach_mmc 了：</p>
<p>/*</p>
<p> * Starting point for MMC card init.</p>
<p> */</p>
<p>int mmc_attach_mmc(struct mmc_host *host, u32 ocr) // core/mmc.c</p>
<p>{</p>
<p>​    int err;</p>
<p>……</p>
<p>​    mmc_attach_bus_ops(host);     // 这个与总线的电源管理有关，暂时跳过</p>
<p>……</p>
<p>​    /*</p>
<p>​     * Detect and init the card.</p>
<p>​     */</p>
<p>​    err = mmc_init_card(host, host-&gt;ocr, NULL);</p>
<p>​    if (err)</p>
<p>​       goto err;</p>
<p>……</p>
<p>​    mmc_release_host(host);</p>
<p>​    err = mmc_add_card(host-&gt;card);</p>
<p>​    if (err)</p>
<p>​       goto remove_card;</p>
<p>​    return 0;</p>
<p>remove_card:</p>
<p>……</p>
<p>err:</p>
<p>……</p>
<p>​    return err;</p>
<p>}</p>
<p>还是找几个关键函数来看 mmc_init_card 从函数名来看就是初始化一个 card ，这个 card 就用 struct mmc_card 结构来描述，然后又调用 mmc_add_card 将卡设备添加到了内核，先来看 mmc_init_card 都做了些什么事情：</p>
<p>static int mmc_init_card(struct mmc_host *host, u32 ocr,</p>
<p>​    struct mmc_card *oldcard)</p>
<p>{</p>
<p>​    struct mmc_card *card;</p>
<p>​    int err;</p>
<p>​    u32 cid[4];</p>
<p>​    unsigned int max_dtr;</p>
<p>……</p>
<p>​       /*</p>
<p>​        * Allocate card structure.</p>
<p>​        */</p>
<p>​       card = mmc_alloc_card(host, &amp;mmc_type);</p>
<p>​       if (IS_ERR(card)) {</p>
<p>​           err = PTR_ERR(card);</p>
<p>​           goto err;</p>
<p>​       }</p>
<p>​       card-&gt;type = MMC_TYPE_MMC;</p>
<p>​       card-&gt;rca = 1;</p>
<p>​       memcpy(card-&gt;raw_cid, cid, sizeof(card-&gt;raw_cid));</p>
<p>……</p>
<p>​       host-&gt;card = card;</p>
<p>​    return 0;</p>
<p>free_card:</p>
<p>……</p>
<p>err:</p>
<p>……</p>
<p>​    return err;</p>
<p>}</p>
<p>将与硬件操作相关的全部删掉，最后对我们有用的也就这几行了 mmc_alloc_card 申请了一个 struct mmc_card 结构，然后给 card-&gt;type 赋上 MMC_TYPE_MMC ，最后将 card 又赋给了 host-&gt;card ，这和具体硬件还是挺像的，因为一个主控制器一般就插一个卡，有卡时 host-&gt;card 有值，没有卡时 host-&gt;card 自己就是 NULL 了。</p>
<p>​    钻进 mmc_alloc_card 里面来看看：</p>
<p>/*</p>
<p> * Allocate and initialise a new MMC card structure.</p>
<p> */</p>
<p>struct mmc_card *mmc_alloc_card(struct mmc_host *host, struct device_type *type)</p>
<p>{</p>
<p>​    struct mmc_card *card;</p>
<p>​    card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);</p>
<p>​    if (!card)</p>
<p>​       return ERR_PTR(-ENOMEM);</p>
<p>​    card-&gt;host = host;</p>
<p>​    device_initialize(&amp;card-&gt;dev);</p>
<p>​    card-&gt;dev.parent = mmc_classdev(host);</p>
<p>​    card-&gt;dev.bus = &mmc_bus_type;</p>
<p>​    card-&gt;dev.release = mmc_release_card;</p>
<p>​    card-&gt;dev.type = type;</p>
<p>​    return card;</p>
<p>}</p>
<p>Struct mmc_card 结构里面包含了一个 struct device 结构， mmc_alloc_card 不但申请了内存，而且还填充了 struct device 中的几个成员，尤其 card-&gt;dev.bus = &mmc_bus_type; 这一句要重点对待。</p>
<p>​    申请一个 mmc_card 结构，并简单初始化后， mmc_init_card 的使命就完成了，然后再调用 mmc_add_card 将这个 card 设备添加到内核。 mmc_add_card 其实很简单，就是调用 device_add 将 card-&gt;dev 添加到内核当中去。</p>
<p>​    知道总线模型这个东西的人都明白，理到 device_add 里面总线就应该有动作了，具体是哪个总线呢？那就得看你调用 device_add 时送的那个 dev 里面指定的是哪个总线了，我们送的 card-&gt;dev ，那么 card-&gt;dev.bus 具体指向什么呢？很明现是那个 mmc_bus_type ：</p>
<p>static struct bus_type mmc_bus_type = {</p>
<p>​    .name       = “mmc”,</p>
<p>​    .dev_attrs    = mmc_dev_attrs,</p>
<p>​    .match      = mmc_bus_match,</p>
<p>​    .uevent      = mmc_bus_uevent,</p>
<p>​    .probe      = mmc_bus_probe,</p>
<p>​    .remove     = mmc_bus_remove,</p>
<p>​    .suspend = mmc_bus_suspend,</p>
<p>​    .resume     = mmc_bus_resume,</p>
<p>};</p>
<p>在 device_add 里面，设备对应的总线会拿着你这个设备和挂在这个总线上的所有驱动程序去匹配（ match ），此时会调用 match 函数，如果匹配到了就会调用总线的 probe 函数或驱动的 probe 函数，那我们看一下这里的 mmc_bus_match 是如何进行匹配的：</p>
<p>static int mmc_bus_match(struct device *dev, struct device_driver *drv)</p>
<p>{</p>
<p>​    return 1;</p>
<p>}</p>
<p>看来 match 永远都能成功，那就去执行 probe 吧：</p>
<p>static int mmc_bus_probe(struct device *dev)</p>
<p>{</p>
<p>​    struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</p>
<p>​    struct mmc_card *card = dev_to_mmc_card(dev);</p>
<p>​    return drv-&gt;probe(card);</p>
<p>}</p>
<p>这里就有点麻烦了，在这个函数里面又调用了一下 drv-&gt;probe() ，那这个 drv 是什么呢？上面有： struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</p>
<p>match 函数总是返回 1 ，那看来只要是挂在这条总线上的 driver 都有可能跑到这里来了，事实的确也是这样的，不过好在挂在这条总线上的 driver 只有一个，它是这样定义的：</p>
<p>static struct mmc_driver mmc_driver = {</p>
<p>​    .drv    = {</p>
<p>​       .name   = “mmcblk”,</p>
<p>​    },</p>
<p>​    .probe      = mmc_blk_probe,</p>
<p>​    .remove     = mmc_blk_remove,</p>
<p>​    .suspend   = mmc_blk_suspend,</p>
<p>​    .resume     = mmc_blk_resume,</p>
<p>};</p>
<p>看到这里时， card/core/host 几个已经全部被扯进来了，边看 mmc_driver 中的几个函数，他们几个如何联系起来也就慢慢明白了。那我们继续吧。</p>
<p>第三阶段：</p>
<p>前面已经看到了，在总线的 probe 里面调用了 drv-&gt;probe, 而这个函数就对应的是 mmc_blk_probe ，具体这个 mmc_driver 是怎么挂到 mmc_bus 上的，自己去看 mmc_blk_init() ，就几行代码，应该不难。</p>
<p>static int mmc_blk_probe(struct mmc_card *card) // 来自 card/block.c</p>
<p>{</p>
<p>​    struct mmc_blk_data *md;</p>
<p>​    int err;</p>
<p>……</p>
<p>​    md = mmc_blk_alloc(card);</p>
<p>​    if (IS_ERR(md))</p>
<p>​       return PTR_ERR(md);</p>
<p>……</p>
<p>​    add_disk(md-&gt;disk);</p>
<p>​    return 0;</p>
<p> out:</p>
<p>​    mmc_blk_put(md);</p>
<p>​    return err;</p>
<p>}</p>
<p>还是捡重要的函数看，一看到这个函数最后调用了 add_disk ，你应该可以想到些什么吧？如果你不知道我在说些什么，那我估计你没有看过 LDD3 ，或者看了也是走马观花了。我来告诉你：如果看到 add_disk ，那说明前面一定会有 alloc_disk 和初始化队列的动作，在 mmc_blk_probe 时面没有体现出来，那就看 mmc_blk_alloc(card) 那一行：</p>
<p>static struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)</p>
<p>{</p>
<p>​    struct mmc_blk_data *md;</p>
<p>​    int devidx, ret;</p>
<p>​    devidx = find_first_zero_bit(dev_use, MMC_NUM_MINORS);</p>
<p>​    if (devidx &gt;= MMC_NUM_MINORS)</p>
<p>​       return ERR_PTR(-ENOSPC);</p>
<p>​    __set_bit(devidx, dev_use);</p>
<p>​    md = kzalloc(sizeof(struct mmc_blk_data), GFP_KERNEL);</p>
<p>​    if (!md) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * Set the read-only status based on the supported commands</p>
<p>​     * and the write protect switch.</p>
<p>​     */</p>
<p>​    md-&gt;read_only = mmc_blk_readonly(card);</p>
<p>​    md-&gt;disk = alloc_disk(1 &lt;&lt; MMC_SHIFT);</p>
<p>​    if (md-&gt;disk == NULL) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto err_kfree;</p>
<p>​    }</p>
<p>​    spin_lock_init(&amp;md-&gt;lock);</p>
<p>​    md-&gt;usage = 1;</p>
<p>​    ret = mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock);</p>
<p>​    if (ret)</p>
<p>​       goto err_putdisk;</p>
<p>​    md-&gt;queue.issue_fn = mmc_blk_issue_rq;</p>
<p>​    md-&gt;queue.data = md;</p>
<p>​    md-&gt;disk-&gt;major  = MMC_BLOCK_MAJOR;</p>
<p>​    md-&gt;disk-&gt;first_minor = devidx &lt;&lt; MMC_SHIFT;</p>
<p>​    md-&gt;disk-&gt;fops = &mmc_bdops;</p>
<p>​    md-&gt;disk-&gt;private_data = md;</p>
<p>​    md-&gt;disk-&gt;queue = md-&gt;queue.queue;</p>
<p>​    md-&gt;disk-&gt;driverfs_dev = &amp;card-&gt;dev;</p>
<p>​    /*</p>
<p>​     * As discussed on lkml, GENHD_FL_REMOVABLE should:</p>
<p>​     *</p>
<p>​     * - be set for removable media with permanent block devices</p>
<p>​     * - be unset for removable block devices with permanent media</p>
<p>​     *</p>
<p>​     * Since MMC block devices clearly fall under the second</p>
<p>​     * case, we do not set GENHD_FL_REMOVABLE. Userspace</p>
<p>​     * should use the block device creation/destruction hotplug</p>
<p>​     * messages to tell when the card is present.</p>
<p>​     */</p>
<p>​    sprintf(md-&gt;disk-&gt;disk_name, “mmcblk%d”, devidx);</p>
<p>​    blk_queue_logical_block_size(md-&gt;queue.queue, 512);</p>
<p>​    if (!mmc_card_sd(card) &amp;&amp; mmc_card_blockaddr(card)) {</p>
<p>​       /*</p>
<p>​        * The EXT_CSD sector count is in number or 512 byte</p>
<p>​        * sectors.</p>
<p>​        */</p>
<p>​       set_capacity(md-&gt;disk, card-&gt;ext_csd.sectors);</p>
<p>​    } else {</p>
<p>​       /*</p>
<p>​        * The CSD capacity field is in units of read_blkbits.</p>
<p>​        * set_capacity takes units of 512 bytes.</p>
<p>​        */</p>
<p>​       set_capacity(md-&gt;disk,</p>
<p>​           card-&gt;csd.capacity &lt;&lt; (card-&gt;csd.read_blkbits - 9));</p>
<p>​    }</p>
<p>​    return md;</p>
<p> err_putdisk:</p>
<p>​    put_disk(md-&gt;disk);</p>
<p> err_kfree:</p>
<p>​    kfree(md);</p>
<p> out:</p>
<p>​    return ERR_PTR(ret);</p>
<p>}</p>
<p>看到这个函数的代码，我们自然就回忆起了块设备驱动的整个套路了：</p>
<p>\1.    分配、初始化请求队列，并绑定请求队列和请求函数。</p>
<p>\2.    分配，初始化 gendisk ，给 gendisk 的 major ， fops ， queue 等成员赋值，最后添加 gendisk 。</p>
<p>\3.    注册块设备驱动。</p>
<p>我们看看 MMC 卡驱动程序有没有按这个套路走，</p>
<p>1 、 mmc_init_queue 初始了队列，并将 mmc_blk_issue_rq; 函数绑定成请求函数；</p>
<p>2 、 alloc_disk 分配了 gendisk 结构，并初始化了 major ， fops ，和 queue ；</p>
<p>3 、最后调用 add_disk 将块设备加到 KERNEL 中去。</p>
<p>到这里虽然 mmc_blk_probe 已经结束了，但我们别停下来。记得 LDD3 上在讲 sbull 实例时说过， add_disk 的调用标志着一个块设备驱动将被激活，所以在这之前必须把其它所有准备工作全部做好，作者为什么会这样说是有理由的，因为在 add_disk 里面 kernel 会去调用你绑定到队列中的请求函数，目的是去你的块设备上读分区表。而且是在 add_disk 内部就要做的，而不是 add_disk 返回后再做，具体为什么会这样，去看 add_disk 的代码实现就知道了。</p>
<p>既然要调用请求函数去读，那我们就来看看请求函数： mmc_blk_issue_rq</p>
<p>static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)</p>
<p>{</p>
<p>​    struct mmc_blk_data *md = mq-&gt;data;</p>
<p>​    struct mmc_card *card = md-&gt;queue.card;</p>
<p>​    struct mmc_blk_request brq;</p>
<p>​    int ret = 1, disable_multi = 0;</p>
<p>​    do {</p>
<p>​       mmc_wait_for_req(card-&gt;host, &amp;brq.mrq);</p>
<p>​       /*</p>
<p>​        * A block was successfully transferred.</p>
<p>​        */</p>
<p>​       spin_lock_irq(&amp;md-&gt;lock);</p>
<p>​       ret = __blk_end_request(req, 0, brq.data.bytes_xfered);</p>
<p>​       spin_unlock_irq(&amp;md-&gt;lock);</p>
<p>​    } while (ret);</p>
<p>​    return 1;</p>
<p>}</p>
<p>这个函数实在太长了，好在我们不用全部看，大部分读数据的准备代码和出错处理的代码已经被我删掉了，只要知道读数据都是在这里完成的就够了。看不懂这个函数的，拿上 LDD3 找个人少的地方，将 sbull 研究透了也就明白这个函数了。不过这个函数里涉及的东西还挺不少，“散列表”，“回弹”都在这里出现了，有时间慢慢去研究吧。</p>
<p>​    在块设备驱动当中你只需要抓住请求队列和请求函数就可以了，具体那些 block_device_operations 里面赋值的函数可不像字符设备驱动里面那么受关注了。</p>
<p>​    分析到这里， MMC/SD 卡的驱动整个构架基本也就很明析了，说简单了就是做了两件事：</p>
<p>\1.    卡的检测；</p>
<p>\2.    卡数据的读取。</p>
<p>最后再将这两个过程大概串一下：</p>
<p>\1.    卡的检测：</p>
<p>S3cmci_probe(host/s3cmci.c)</p>
<p>​    Mmc_alloc_host(core/core.c)</p>
<p>​       Mmc_rescan(core/core.c)</p>
<p>​           Mmc_attach_mmc(core/mmc.c)</p>
<p>​              Mmc_init_card(core/mmc.c)</p>
<p>​              mmc_add_card(core/bus.c)</p>
<p>​                  device_add</p>
<p>​                     mmc_bus_match(core/bus.c)</p>
<p>​                     mmc_bus_probe(core/bus.c)</p>
<p>​                         mmc_blk_probe(card/block.c)</p>
<p>​                            alloc_disk/add_disk</p>
<p>\2.    读写数据：</p>
<p>mmc_blk_issue_rq （ card/block.c ）</p>
<p>​    mmc_wait_for_req(core/core.c)</p>
<p>​       mmc_start_request(core/core.c)</p>
<p>​           host-&gt;ops-&gt;request(host, mrq)  // s3cmci 中 s3cmci_request</p>
<p>MMC/SD 卡的驱动分析完了，是不是有些复杂，不过这样设计的目的是为了分层，让具体平台的驱动编写更加省事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E5%9F%BA%E4%BA%8EOMAP335x%20eMMC%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E5%9F%BA%E4%BA%8EOMAP335x%20eMMC%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">基于OMAP335x eMMC驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-25 17:17:04 / Modified: 21:01:09" itemprop="dateCreated datePublished" datetime="2020-12-25T17:17:04+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="驱动程序分析"><a href="#驱动程序分析" class="headerlink" title="驱动程序分析"></a>驱动程序分析</h2><h3 id="软件层次划分"><a href="#软件层次划分" class="headerlink" title="软件层次划分"></a>软件层次划分</h3><p>MMC framework的软件架构，如下图</p>
<p><img src="http://jiali.clouddn.com/20201225_020.png" alt=""></p>
<p>​                                                                                                                                图 mmc 软件架构</p>
<p>eMMC使用MMC驱动模块，mmc驱动位于driver/mmc目录下，该文件夹包含card、core和host目录，每个目录跟mmc相关的文件如下：</p>
<blockquote>
<p>Card/</p>
<pre><code>block.c

queue.c/queue.h</code></pre><p>core/</p>
<pre><code>bus.c/bus.h

core.c/core.h

host.c/host.h

mmc.c

mmc_ops.c/mmc_ops.h</code></pre><p>host/</p>
<pre><code>omap_hsmmc.c 表示 omap335x 的 MMC/SD 卡控制器，代表emmc控制器的硬件操作</code></pre></blockquote>
<p>三个目录对应mmc驱动三个层次：</p>
<p>（1）       块设备层（card）</p>
<p>主要是按照 LINUX 块设备驱动程序的框架实现一个卡的块设备驱动，这 block.c 当中我们可以看到写一个块设备驱动程序时需要的 block_device_operations 结构体变量的定义，其中有 open/release/request 函数的实现，而 queue.c 则是对内核提供的请求队列的封装。</p>
<p>（2）       核心层(core)</p>
<p>核心层封装了 MMC/SD 卡的命令，例如存储卡的识别，设置，读写。例如不管什么卡都应该有一些识别，设置，和读写的命令，这些流程都是必须要有的，只是具体对于不同的卡会有一些各自特有的操作。 Core.c 文件是由 sd.c 、 mmc.c 两个文件支撑的， core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd.c 和 sd_ops.c 、 mmc.c 和 mmc_ops.c 来完成。</p>
<p>（3）       硬件控制层(host)</p>
<p>主机控制器则是依赖于不同的平台的，例如 omap335x 的卡控制器和 atmel 的卡控制器必定是不一样的，所以要针对不同的控制器来实现。以 omap_hsmmc.c 为例，它首先要进行一些设置，例如中断函数注册，全能控制器等等。然后它会向 core 层注册一个主机（ host ），用结构 mmc_host_ops 描述，这样核心层就可以拿着这个 host 来操作omap335x 的卡控制器了，而具体是 omap335x 的卡控制器还是 atmel 的卡控制器， core 层是不用知道的。 </p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="关于mmc的几个重要数据结构"><a href="#关于mmc的几个重要数据结构" class="headerlink" title="关于mmc的几个重要数据结构"></a>关于mmc的几个重要数据结构</h4><blockquote>
<p>struct mmc_host 用来描述卡控制器</p>
<p>struct mmc_card 用来描述卡</p>
<p>struct mmc_driver 用来描述 mmc 卡驱动</p>
<p>struct mmc_host_ops 用来描述卡控制器操作集，用于从主机控制器层向 core 层注册操作函数，从而将 core 层与具体的主机控制器隔离。也就是说 core 要操作主机控制器，就用这个 ops 当中给的函数指针操作，不能直接调用具体主控制器的函数。</p>
</blockquote>
<h4 id="mmc模式初始化"><a href="#mmc模式初始化" class="headerlink" title="mmc模式初始化"></a>mmc模式初始化</h4><p>在Linux 启动过程中，依次初始化下面的模块：</p>
<blockquote>
<p>1、subsys_initcall(mmc_init) //注册了mmc_bus_type总线</p>
<p>2、module_init(mmc_blk_init) //注册一个mmc块设备，并向mmc_bus_type总线添加mmc驱动</p>
<p>3、module_init(omap_hsmmc_init) //注册一个MMC/SD卡控制器为platform总线设备，mmc的一系列初始化，从这个入口开始。</p>
</blockquote>
<h4 id="注册mmc总线"><a href="#注册mmc总线" class="headerlink" title="注册mmc总线"></a>注册mmc总线</h4><p>drivers/mmc/core/core.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int __init mmc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	workqueue &#x3D; alloc_ordered_workqueue(&quot;kmmcd&quot;, 0);</span><br><span class="line">	if (!workqueue)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; mmc_register_bus();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto destroy_workqueue;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; mmc_register_host_class();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto unregister_bus;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; sdio_register_bus();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto unregister_host_class;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">unregister_host_class:</span><br><span class="line">	mmc_unregister_host_class();</span><br><span class="line">unregister_bus:</span><br><span class="line">	mmc_unregister_bus();</span><br><span class="line">destroy_workqueue:</span><br><span class="line">	destroy_workqueue(workqueue);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mmc_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	sdio_unregister_bus();</span><br><span class="line">	mmc_unregister_host_class();</span><br><span class="line">	mmc_unregister_bus();</span><br><span class="line">	destroy_workqueue(workqueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(mmc_init);</span><br><span class="line">module_exit(mmc_exit);</span><br></pre></td></tr></table></figure>

<p>drivers/mmc/core/bus.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static struct bus_type mmc_bus_type &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;mmc&quot;,</span><br><span class="line">	.dev_attrs	&#x3D; mmc_dev_attrs,</span><br><span class="line">	.match		&#x3D; mmc_bus_match,</span><br><span class="line">	.uevent		&#x3D; mmc_bus_uevent,</span><br><span class="line">	.probe		&#x3D; mmc_bus_probe,</span><br><span class="line">	.remove		&#x3D; mmc_bus_remove,</span><br><span class="line">	.pm		&#x3D; &amp;mmc_bus_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int mmc_register_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">	return bus_register(&amp;mmc_bus_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册-mmc-bus-driver"><a href="#注册-mmc-bus-driver" class="headerlink" title="注册 mmc bus driver"></a>注册 mmc bus driver</h4><p>drivers/mmc/card/block.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static struct mmc_driver mmc_driver &#x3D; &#123;</span><br><span class="line">	.drv		&#x3D; &#123;</span><br><span class="line">		.name	&#x3D; &quot;mmcblk&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe		&#x3D; mmc_blk_probe,</span><br><span class="line">	.remove		&#x3D; mmc_blk_remove,</span><br><span class="line">	.suspend	&#x3D; mmc_blk_suspend,</span><br><span class="line">	.resume		&#x3D; mmc_blk_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init mmc_blk_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	if (perdev_minors !&#x3D; CONFIG_MMC_BLOCK_MINORS)</span><br><span class="line">		pr_info(&quot;mmcblk: using %d minors per device\n&quot;, perdev_minors);</span><br><span class="line"></span><br><span class="line">	max_devices &#x3D; 256 &#x2F; perdev_minors;</span><br><span class="line"></span><br><span class="line">	res &#x3D; register_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	res &#x3D; mmc_register_driver(&amp;mmc_driver);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out2;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"> out2:</span><br><span class="line">	unregister_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line"> out:</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mmc_blk_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	mmc_unregister_driver(&amp;mmc_driver);</span><br><span class="line">	unregister_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mmc_blk_init);</span><br><span class="line">module_exit(mmc_blk_exit);</span><br></pre></td></tr></table></figure>

<h4 id="注册主机MMC-SD卡控制器为platform总线设备"><a href="#注册主机MMC-SD卡控制器为platform总线设备" class="headerlink" title="注册主机MMC/SD卡控制器为platform总线设备"></a>注册主机MMC/SD卡控制器为platform总线设备</h4><p>drivers/mmc/host/omap_hsmmc.c</p>
<p>入口函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static struct platform_driver omap_hsmmc_driver &#x3D; &#123;</span><br><span class="line">	.remove		&#x3D; omap_hsmmc_remove,</span><br><span class="line">	.driver		&#x3D; &#123;</span><br><span class="line">		.name &#x3D; DRIVER_NAME,</span><br><span class="line">		.owner &#x3D; THIS_MODULE,</span><br><span class="line">		.pm &#x3D; &amp;omap_hsmmc_dev_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init omap_hsmmc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Register the MMC driver *&#x2F;</span><br><span class="line">	return platform_driver_probe(&amp;omap_hsmmc_driver, omap_hsmmc_probe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit omap_hsmmc_cleanup(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Unregister MMC driver *&#x2F;</span><br><span class="line">	platform_driver_unregister(&amp;omap_hsmmc_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(omap_hsmmc_init);</span><br><span class="line">module_exit(omap_hsmmc_cleanup);</span><br></pre></td></tr></table></figure>

<p>这里注册一个名为DRIVER_NANE(omap_hsmmc)的platform_driver,因此，在系统启动时一定会有调用 platform_device­_register 对板上的资源进行注册。这里注册成功就会调用omap_hsmmc_probe()函数来初始化mmc设备，最后把mmc设备加入mmc bus ,完成mmc 块设备的创建。</p>
<p><strong>第一阶段：初始化mmc控制器，并检测卡</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line">static int __init omap_hsmmc_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_mmc_platform_data *pdata &#x3D; pdev-&gt;dev.platform_data;</span><br><span class="line">	struct mmc_host *mmc;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D; NULL;</span><br><span class="line">	struct resource *res, *dma_tx, *dma_rx;</span><br><span class="line">	int ret, irq;</span><br><span class="line"></span><br><span class="line">	if (pdata &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, &quot;Platform Data is missing\n&quot;);</span><br><span class="line">		return -ENXIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;nr_slots &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, &quot;No Slots\n&quot;);</span><br><span class="line">		return -ENXIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">	irq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">	if (res &#x3D;&#x3D; NULL || irq &lt; 0)</span><br><span class="line">		return -ENXIO;</span><br><span class="line"></span><br><span class="line">	res-&gt;start +&#x3D; pdata-&gt;reg_offset;</span><br><span class="line">	res-&gt;end +&#x3D; pdata-&gt;reg_offset;</span><br><span class="line">	res &#x3D; request_mem_region(res-&gt;start, resource_size(res), pdev-&gt;name);</span><br><span class="line">	if (res &#x3D;&#x3D; NULL)</span><br><span class="line">		return -EBUSY;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; omap_hsmmc_gpio_init(pdata);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto err;</span><br><span class="line"></span><br><span class="line">	mmc &#x3D; mmc_alloc_host(sizeof(struct omap_hsmmc_host), &amp;pdev-&gt;dev);&#x2F;&#x2F;分配mmc_host</span><br><span class="line">	if (!mmc) &#123;</span><br><span class="line">		ret &#x3D; -ENOMEM;</span><br><span class="line">		goto err_alloc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host		&#x3D; mmc_priv(mmc);</span><br><span class="line">	host-&gt;mmc	&#x3D; mmc;</span><br><span class="line">	host-&gt;pdata	&#x3D; pdata;</span><br><span class="line">	host-&gt;dev	&#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">	host-&gt;use_dma	&#x3D; 1;</span><br><span class="line">	host-&gt;dev-&gt;dma_mask &#x3D; &amp;pdata-&gt;dma_mask;</span><br><span class="line">	host-&gt;dma_ch	&#x3D; -1;</span><br><span class="line">	host-&gt;irq	&#x3D; irq;</span><br><span class="line">	host-&gt;id	&#x3D; pdev-&gt;id;</span><br><span class="line">	host-&gt;slot_id	&#x3D; 0;</span><br><span class="line">	host-&gt;mapbase	&#x3D; res-&gt;start;</span><br><span class="line">	host-&gt;base	&#x3D; ioremap(host-&gt;mapbase, SZ_4K);</span><br><span class="line">	host-&gt;power_mode &#x3D; MMC_POWER_OFF;</span><br><span class="line">	host-&gt;next_data.cookie &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, host);</span><br><span class="line">	INIT_WORK(&amp;host-&gt;mmc_carddetect_work, omap_hsmmc_detect);</span><br><span class="line">    &#x2F;&#x2F;初始化mmc_host配置</span><br><span class="line">	mmc-&gt;ops	&#x3D; &amp;omap_hsmmc_ops;&#x2F;&#x2F;跟主机的硬件操作相关</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If regulator_disable can only put vcc_aux to sleep then there is</span><br><span class="line">	 * no off state.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (mmc_slot(host).vcc_aux_disable_is_sleep)</span><br><span class="line">		mmc_slot(host).no_off &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;f_min	&#x3D; OMAP_MMC_MIN_CLOCK;</span><br><span class="line"></span><br><span class="line">	if(mmc-&gt;index &#x3D;&#x3D; 0)</span><br><span class="line">		mmc-&gt;f_max	&#x3D; OMAP_MMC_MAX_CLOCK_SD;</span><br><span class="line">	if(mmc-&gt;index &#x3D;&#x3D; 1)</span><br><span class="line">		mmc-&gt;f_max	&#x3D; OMAP_MMC_MAX_CLOCK_EMMC;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;host-&gt;irq_lock);</span><br><span class="line"></span><br><span class="line">	host-&gt;fclk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;fck&quot;);</span><br><span class="line">	if (IS_ERR(host-&gt;fclk)) &#123;</span><br><span class="line">		ret &#x3D; PTR_ERR(host-&gt;fclk);</span><br><span class="line">		host-&gt;fclk &#x3D; NULL;</span><br><span class="line">		goto err1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_context_save(host);</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; MMC_CAP_DISABLE;</span><br><span class="line">	if (host-&gt;pdata-&gt;controller_flags &amp; OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) &#123;</span><br><span class="line">		dev_info(&amp;pdev-&gt;dev, &quot;multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\n&quot;);</span><br><span class="line">		mmc-&gt;caps2 |&#x3D; MMC_CAP2_NO_MULTI_READ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm_runtime_enable(host-&gt;dev);</span><br><span class="line">	pm_runtime_get_sync(host-&gt;dev);</span><br><span class="line">	pm_runtime_set_autosuspend_delay(host-&gt;dev, MMC_AUTOSUSPEND_DELAY);</span><br><span class="line">	pm_runtime_use_autosuspend(host-&gt;dev);</span><br><span class="line"></span><br><span class="line">	if (cpu_is_omap2430()) &#123;</span><br><span class="line">		host-&gt;dbclk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;mmchsdb_fck&quot;);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * MMC can still work without debounce clock.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (IS_ERR(host-&gt;dbclk))</span><br><span class="line">			dev_warn(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Failed to get debounce clock\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			host-&gt;got_dbclk &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		if (host-&gt;got_dbclk)</span><br><span class="line">			if (clk_enable(host-&gt;dbclk) !&#x3D; 0)</span><br><span class="line">				dev_dbg(mmc_dev(host-&gt;mmc), &quot;Enabling debounce&quot;</span><br><span class="line">							&quot; clk failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Since we do only SG emulation, we can have as many segs</span><br><span class="line">	 * as we want. *&#x2F;</span><br><span class="line">	if (pdata-&gt;version &#x3D;&#x3D; MMC_CTRL_VERSION_2)</span><br><span class="line">		mmc-&gt;max_segs &#x3D; 1;</span><br><span class="line">	else</span><br><span class="line">		mmc-&gt;max_segs &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;max_blk_size &#x3D; 512;       &#x2F;* Block Length at max can be 1024 *&#x2F;</span><br><span class="line">	mmc-&gt;max_blk_count &#x3D; 0xFFFF;    &#x2F;* No. of Blocks is 16 bits *&#x2F;</span><br><span class="line">	mmc-&gt;max_req_size &#x3D; mmc-&gt;max_blk_size * mmc-&gt;max_blk_count;</span><br><span class="line">	mmc-&gt;max_seg_size &#x3D; mmc-&gt;max_req_size;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |</span><br><span class="line">		     MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; mmc_slot(host).caps;</span><br><span class="line">	if (mmc-&gt;caps &amp; MMC_CAP_8_BIT_DATA)</span><br><span class="line">		mmc-&gt;caps |&#x3D; MMC_CAP_4_BIT_DATA;</span><br><span class="line"></span><br><span class="line">	if (mmc_slot(host).nonremovable)</span><br><span class="line">		mmc-&gt;caps |&#x3D; MMC_CAP_NONREMOVABLE;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;pm_caps &#x3D; mmc_slot(host).pm_caps;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_conf_bus_power(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Select DMA lines *&#x2F;</span><br><span class="line">	if (pdata-&gt;version &#x3D;&#x3D; MMC_CTRL_VERSION_2) &#123;</span><br><span class="line">		dma_rx &#x3D; platform_get_resource_byname(pdev,</span><br><span class="line">							IORESOURCE_DMA, &quot;rx&quot;);</span><br><span class="line">		if (!dma_rx) &#123;</span><br><span class="line">			ret &#x3D; -EINVAL;</span><br><span class="line">			goto err1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dma_tx &#x3D; platform_get_resource_byname(pdev,</span><br><span class="line">							IORESOURCE_DMA, &quot;tx&quot;);</span><br><span class="line">		if (!dma_tx) &#123;</span><br><span class="line">			ret &#x3D; -EINVAL;</span><br><span class="line">			goto err1;</span><br><span class="line">		&#125;</span><br><span class="line">		host-&gt;dma_line_tx &#x3D; dma_tx-&gt;start;</span><br><span class="line">		host-&gt;dma_line_rx &#x3D; dma_rx-&gt;start;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		switch (host-&gt;id) &#123;</span><br><span class="line">		case OMAP_MMC1_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP24XX_DMA_MMC1_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP24XX_DMA_MMC1_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC2_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP24XX_DMA_MMC2_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP24XX_DMA_MMC2_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC3_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP34XX_DMA_MMC3_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP34XX_DMA_MMC3_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC4_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP44XX_DMA_MMC4_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP44XX_DMA_MMC4_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC5_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP44XX_DMA_MMC5_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP44XX_DMA_MMC5_RX;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			dev_err(mmc_dev(host-&gt;mmc), &quot;Invalid MMC id\n&quot;);</span><br><span class="line">			goto err_irq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Request IRQ for MMC operations *&#x2F;</span><br><span class="line">	ret &#x3D; request_irq(host-&gt;irq, omap_hsmmc_irq, 0,</span><br><span class="line">			mmc_hostname(mmc), host);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_dbg(mmc_dev(host-&gt;mmc), &quot;Unable to grab HSMMC IRQ\n&quot;);</span><br><span class="line">		goto err_irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;init !&#x3D; NULL) &#123;</span><br><span class="line">		if (pdata-&gt;init(&amp;pdev-&gt;dev) !&#x3D; 0) &#123;</span><br><span class="line">			dev_dbg(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Unable to configure MMC IRQs\n&quot;);</span><br><span class="line">			goto err_irq_cd_init;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (omap_hsmmc_have_reg() &amp;&amp; !mmc_slot(host).set_power) &#123;</span><br><span class="line">		ret &#x3D; omap_hsmmc_reg_get(host);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err_reg;</span><br><span class="line">		host-&gt;use_reg &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;ocr_avail &#x3D; mmc_slot(host).ocr_mask;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Request IRQ for card detect *&#x2F;</span><br><span class="line">	if ((mmc_slot(host).card_detect_irq)) &#123;</span><br><span class="line">		ret &#x3D; request_irq(mmc_slot(host).card_detect_irq,</span><br><span class="line">				  omap_hsmmc_cd_handler,</span><br><span class="line">				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">				  mmc_hostname(mmc), host);</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			dev_dbg(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Unable to grab MMC CD IRQ\n&quot;);</span><br><span class="line">			goto err_irq_cd;</span><br><span class="line">		&#125;</span><br><span class="line">		pdata-&gt;suspend &#x3D; omap_hsmmc_suspend_cdirq;</span><br><span class="line">		pdata-&gt;resume &#x3D; omap_hsmmc_resume_cdirq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_disable_irq(host);</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_protect_card(host);</span><br><span class="line"></span><br><span class="line">	mmc_add_host(mmc);&#x2F;&#x2F;添加mmc_host</span><br><span class="line"></span><br><span class="line">	if (mmc_slot(host).name !&#x3D; NULL) &#123;</span><br><span class="line">		ret &#x3D; device_create_file(&amp;mmc-&gt;class_dev, &amp;dev_attr_slot_name);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err_slot_name;</span><br><span class="line">	&#125;</span><br><span class="line">	if (mmc_slot(host).card_detect_irq &amp;&amp; mmc_slot(host).get_cover_state) &#123;</span><br><span class="line">		ret &#x3D; device_create_file(&amp;mmc-&gt;class_dev,</span><br><span class="line">					&amp;dev_attr_cover_switch);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err_slot_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_debugfs(mmc);</span><br><span class="line">	pm_runtime_mark_last_busy(host-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(host-&gt;dev);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_slot_name:</span><br><span class="line">	mmc_remove_host(mmc);</span><br><span class="line">	free_irq(mmc_slot(host).card_detect_irq, host);</span><br><span class="line">err_irq_cd:</span><br><span class="line">	if (host-&gt;use_reg)</span><br><span class="line">		omap_hsmmc_reg_put(host);</span><br><span class="line">err_reg:</span><br><span class="line">	if (host-&gt;pdata-&gt;cleanup)</span><br><span class="line">		host-&gt;pdata-&gt;cleanup(&amp;pdev-&gt;dev);</span><br><span class="line">err_irq_cd_init:</span><br><span class="line">	free_irq(host-&gt;irq, host);</span><br><span class="line">err_irq:</span><br><span class="line">	pm_runtime_mark_last_busy(host-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(host-&gt;dev);</span><br><span class="line">	clk_put(host-&gt;fclk);</span><br><span class="line">	if (host-&gt;got_dbclk) &#123;</span><br><span class="line">		clk_disable(host-&gt;dbclk);</span><br><span class="line">		clk_put(host-&gt;dbclk);</span><br><span class="line">	&#125;</span><br><span class="line">err1:</span><br><span class="line">	iounmap(host-&gt;base);</span><br><span class="line">	platform_set_drvdata(pdev, NULL);</span><br><span class="line">	mmc_free_host(mmc);</span><br><span class="line">err_alloc:</span><br><span class="line">	omap_hsmmc_gpio_free(pdata);</span><br><span class="line">err:</span><br><span class="line">	release_mem_region(res-&gt;start, resource_size(res));</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>probe()函数所做的有以下几点：</strong></p>
<ol>
<li><p>分配、设置并添加mmc_host</p>
</li>
<li><p>检测卡是否插入了卡控制器</p>
</li>
</ol>
</blockquote>
<p>看 mmc_alloc_host 函数:</p>
<p>来自drivers/mmc/core/host.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_alloc_host - initialise the per-host structure.</span><br><span class="line"> *	@extra: sizeof private data structure</span><br><span class="line"> *	@dev: pointer to host device model structure</span><br><span class="line"> *</span><br><span class="line"> *	Initialise the per-host structure.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct mmc_host *mmc_alloc_host(int extra, struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line">	struct mmc_host *host;</span><br><span class="line"></span><br><span class="line">	if (!idr_pre_get(&amp;mmc_host_idr, GFP_KERNEL))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	host &#x3D; kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</span><br><span class="line">	if (!host)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;mmc_host_lock);</span><br><span class="line">	err &#x3D; idr_get_new(&amp;mmc_host_idr, host, &amp;host-&gt;index);</span><br><span class="line">	spin_unlock(&amp;mmc_host_lock);</span><br><span class="line">	if (err)</span><br><span class="line">		goto free;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;host-&gt;class_dev, &quot;mmc%d&quot;, host-&gt;index);</span><br><span class="line"></span><br><span class="line">	host-&gt;parent &#x3D; dev;</span><br><span class="line">	host-&gt;class_dev.parent &#x3D; dev;</span><br><span class="line">	host-&gt;class_dev.class &#x3D; &amp;mmc_host_class;</span><br><span class="line">	device_initialize(&amp;host-&gt;class_dev);</span><br><span class="line"></span><br><span class="line">	mmc_host_clk_init(host);</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;host-&gt;lock);</span><br><span class="line">	init_waitqueue_head(&amp;host-&gt;wq);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);&#x2F;&#x2F;初始化工作队列，向host-&gt;detect注册一个mmc_rescan函数</span><br><span class="line">	INIT_DELAYED_WORK_DEFERRABLE(&amp;host-&gt;disable, mmc_host_deeper_disable);</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	host-&gt;pm_notify.notifier_call &#x3D; mmc_pm_notify;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * By default, hosts do not support SGIO or large requests.</span><br><span class="line">	 * They have to set these according to their abilities.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	host-&gt;max_segs &#x3D; 1;</span><br><span class="line">	host-&gt;max_seg_size &#x3D; PAGE_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">	host-&gt;max_req_size &#x3D; PAGE_CACHE_SIZE;</span><br><span class="line">	host-&gt;max_blk_size &#x3D; 512;</span><br><span class="line">	host-&gt;max_blk_count &#x3D; PAGE_CACHE_SIZE &#x2F; 512;</span><br><span class="line"></span><br><span class="line">	return host;</span><br><span class="line"></span><br><span class="line">free:</span><br><span class="line">	kfree(host);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mmc_add_host函数做了什么？</p>
<p>drivers/mmc/core/host.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_add_host - initialise host hardware</span><br><span class="line"> *	@host: mmc host</span><br><span class="line"> *</span><br><span class="line"> *	Register the host with the driver model. The host must be</span><br><span class="line"> *	prepared to start servicing requests before this function</span><br><span class="line"> *	completes.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int mmc_add_host(struct mmc_host *host)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	WARN_ON((host-&gt;caps &amp; MMC_CAP_SDIO_IRQ) &amp;&amp;</span><br><span class="line">		!host-&gt;ops-&gt;enable_sdio_irq);</span><br><span class="line"></span><br><span class="line">	err &#x3D; device_add(&amp;host-&gt;class_dev); </span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	led_trigger_register_simple(dev_name(&amp;host-&gt;class_dev), &amp;host-&gt;led);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_FS</span><br><span class="line">	mmc_add_host_debugfs(host);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mmc_start_host(host);</span><br><span class="line">	register_pm_notifier(&amp;host-&gt;pm_notify);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看mmc_start_host()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void mmc_start_host(struct mmc_host *host)</span><br><span class="line">&#123;</span><br><span class="line">	mmc_power_off(host); &#x2F;&#x2F;掉电重启</span><br><span class="line">	mmc_detect_change(host, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看mmc_detect_change（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_detect_change - process change of state on a MMC socket</span><br><span class="line"> *	@host: host which changed state.</span><br><span class="line"> *	@delay: optional delay to wait before detection (jiffies)</span><br><span class="line"> *</span><br><span class="line"> *	MMC drivers should call this when they detect a card has been</span><br><span class="line"> *	inserted or removed. The MMC layer will confirm that any</span><br><span class="line"> *	present card is still functional, and initialize any newly</span><br><span class="line"> *	inserted.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void mmc_detect_change(struct mmc_host *host, unsigned long delay)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MMC_DEBUG</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	spin_lock_irqsave(&amp;host-&gt;lock, flags);</span><br><span class="line">	WARN_ON(host-&gt;removed);</span><br><span class="line">	spin_unlock_irqrestore(&amp;host-&gt;lock, flags);</span><br><span class="line">#endif</span><br><span class="line">	host-&gt;detect_change &#x3D; 1;</span><br><span class="line">	mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);&#x2F;&#x2F;等待一会，在调度host-&gt;detect，执行mmc_rescan()函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看 mmc_rescan函数做了什么?</p>
<p>来自drivers/mmc/core/core.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void mmc_rescan(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	static const unsigned freqs[] &#x3D; &#123; 400000, 300000, 200000, 100000 &#125;;</span><br><span class="line">	struct mmc_host *host &#x3D;</span><br><span class="line">		container_of(work, struct mmc_host, detect.work);</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;rescan_disable)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	mmc_bus_get(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * if there is a _removable_ card registered, check whether it is</span><br><span class="line">	 * still present</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (host-&gt;bus_ops &amp;&amp; host-&gt;bus_ops-&gt;detect &amp;&amp; !host-&gt;bus_dead</span><br><span class="line">	    &amp;&amp; !(host-&gt;caps &amp; MMC_CAP_NONREMOVABLE))</span><br><span class="line">		host-&gt;bus_ops-&gt;detect(host);</span><br><span class="line"></span><br><span class="line">	host-&gt;detect_change &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Let mmc_bus_put() free the bus&#x2F;bus_ops if we&#39;ve found that</span><br><span class="line">	 * the card is no longer present.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	mmc_bus_put(host);</span><br><span class="line">	mmc_bus_get(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;* if there still is a card present, stop here *&#x2F;</span><br><span class="line">	if (host-&gt;bus_ops !&#x3D; NULL) &#123;</span><br><span class="line">		mmc_bus_put(host);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Only we can add a new handler, so it&#39;s safe to</span><br><span class="line">	 * release the lock here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	mmc_bus_put(host);</span><br><span class="line"></span><br><span class="line">	if (host-&gt;ops-&gt;get_cd &amp;&amp; host-&gt;ops-&gt;get_cd(host) &#x3D;&#x3D; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	mmc_claim_host(host);</span><br><span class="line">	for (i &#x3D; 0; i &lt; ARRAY_SIZE(freqs); i++) &#123;</span><br><span class="line">		if (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min)))</span><br><span class="line">			break;</span><br><span class="line">		if (freqs[i] &lt;&#x3D; host-&gt;f_min)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	mmc_release_host(host);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</span><br><span class="line">		mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是在检测是不是有卡插入了卡控制器，如果有卡挺入就要采取相应的行动了。这里要明白一点，我们平时用的 SD/MMC 卡就是一个卡，如果要操作它得用 SD/MMC 卡控制器才行，所以可以看到有 struct mmc_card,struct mmc_host 的区分。</p>
<p>如果在probe()函数执行时，卡并没有插入呢？也就是除了probe()函数，一定会有其他函数最终调用了mmc_rescan()函数。现在我们需要重新看一遍omap_hsmmc_probe()函数，它注册了一个中断函数omap_hsmmc_cd_handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * ISR for handling card insertion and removal</span><br><span class="line"> *&#x2F;</span><br><span class="line">static irqreturn_t omap_hsmmc_cd_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D; (struct omap_hsmmc_host *)dev_id;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;suspended)</span><br><span class="line">		return IRQ_HANDLED;</span><br><span class="line">	schedule_work(&amp;host-&gt;mmc_carddetect_work); &#x2F;&#x2F;调度队列，最后执行mmc_rescan()</span><br><span class="line"></span><br><span class="line">	return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在omap_hsmmc_probe函数，注册host-&gt;mmc_carddetect_work队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;host-&gt;mmc_carddetect_work, omap_hsmmc_detect);</span><br></pre></td></tr></table></figure>

<p>来看看omap_hsmmc_detect()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Work Item to notify the core about card insertion&#x2F;removal</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void omap_hsmmc_detect(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D;</span><br><span class="line">		container_of(work, struct omap_hsmmc_host, mmc_carddetect_work);</span><br><span class="line">	struct omap_mmc_slot_data *slot &#x3D; &amp;mmc_slot(host);</span><br><span class="line">	int carddetect;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;suspended)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	sysfs_notify(&amp;host-&gt;mmc-&gt;class_dev.kobj, NULL, &quot;cover_switch&quot;);</span><br><span class="line"></span><br><span class="line">	if (slot-&gt;card_detect)</span><br><span class="line">		carddetect &#x3D; slot-&gt;card_detect(host-&gt;dev, host-&gt;slot_id);</span><br><span class="line">	else &#123;</span><br><span class="line">		omap_hsmmc_protect_card(host);</span><br><span class="line">		carddetect &#x3D; -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;*检测到卡，执行mmc_detect_change()*&#x2F;</span><br><span class="line">	if (carddetect)</span><br><span class="line">		mmc_detect_change(host-&gt;mmc, (HZ * 200) &#x2F; 1000);</span><br><span class="line">	else</span><br><span class="line">		mmc_detect_change(host-&gt;mmc, (HZ * 50) &#x2F; 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段分析完毕，当检测到卡，执行mmc_rescan（）函数，进入第二阶段。</p>
<p><strong>第二阶段，初始化卡，注册mmc块设备</strong></p>
<p>mmc_rescan()函数，调用关系如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mmc_rescan(struct work_struct *work)</span><br><span class="line">  -&gt; mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))</span><br><span class="line">    -&gt; mmc_attach_sdio(host)    &#x2F;* 检测卡的类型 *&#x2F;</span><br><span class="line">    -&gt; mmc_attach_sd(host)</span><br><span class="line">    -&gt; mmc_attach_mmc(host)</span><br><span class="line">      -&gt; mmc_send_op_cond(host, 0, &amp;ocr);         &#x2F;* 发送卡的ID *&#x2F;</span><br><span class="line">      -&gt; mmc_init_card(host, host-&gt;ocr, NULL);    &#x2F;* 初始化mmc_card *&#x2F;</span><br><span class="line">        -&gt; card &#x3D; mmc_alloc_card(host, &amp;mmc_type);</span><br><span class="line">          -&gt; device_initialize(&amp;card-&gt;dev);</span><br><span class="line">          -&gt; card-&gt;dev.bus &#x3D; &amp;mmc_bus_type;   &#x2F;* 设置总线为mmc_bus_type *&#x2F;</span><br><span class="line">        -&gt; card-&gt;type &#x3D; MMC_TYPE_MMC;         &#x2F;* 设置card结构体 *&#x2F;</span><br><span class="line">      -&gt; mmc_release_host(host);</span><br><span class="line">      -&gt; mmc_add_card(host-&gt;card);            &#x2F;* 添加卡mmc_card *&#x2F;</span><br><span class="line">        -&gt; device_add(&amp;card-&gt;dev);            &#x2F;*把卡设备加入mmc bus *&#x2F;</span><br><span class="line">      -&gt; mmc_claim_host(host);                &#x2F;* 使能host *&#x2F;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在mmc_add_card函数中调用device_add()函数时，mmc_bus_type总线会调用match()函数匹配设备驱动，如果匹配成功会调用总线的probe()函数或设备驱动的probe()函数完成块设备创建。</p>
<p>这个mmc_driver底层做的与块设备驱动相同：</p>
<ol>
<li><p>分配、初始化请求队列，绑定请求队列和请求函数</p>
</li>
<li><p>分配、设置并添加gendisk</p>
</li>
<li><p>注册块设备驱动</p>
</li>
</ol>
<h2 id="mmc驱动总结"><a href="#mmc驱动总结" class="headerlink" title="mmc驱动总结"></a>mmc驱动总结</h2><ol>
<li>各个结构体作用：</li>
</ol>
<p>struct mmc_card用于描述卡，struct mmc_driver用于描述卡驱动，sutrct mmc_host用于描述卡控制器，struct mmc_host_ops用于描述卡控制器操作函数。</p>
<ol start="2">
<li><p>整体框架：</p>
<p><img src="http://jiali.clouddn.com/20201225_019.png" alt=""></p>
</li>
</ol>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/Lioker/p/11258958.html" target="_blank" rel="noopener">eMMC驱动框架分析</a></p>
<p><a href="https://blog.csdn.net/luopingfeng/article/details/42844611" target="_blank" rel="noopener">EMMC 驱动</a></p>
<p><a href="https://blog.csdn.net/kickxxx/article/details/51130888" target="_blank" rel="noopener">Linux EMMC子系统分析-初始化流程</a></p>
<p><a href="https://www.daimajiaoliu.com/daima/4794cd5a29003fc" target="_blank" rel="noopener">eMMC驱动分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E4%B8%89%E6%98%9FeMMC%E8%8A%AF%E7%89%87KLM4G1FEPD-B031%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E4%B8%89%E6%98%9FeMMC%E8%8A%AF%E7%89%87KLM4G1FEPD-B031%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">三星eMMC芯片KLM4G1FEPD-B031使用说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-25 11:34:46 / Modified: 17:14:24" itemprop="dateCreated datePublished" datetime="2020-12-25T11:34:46+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>三星eMMC是一种以BGA封装形式设计的嵌入式MMC解决方案。eMMC操作与MMC设备相同，因此非常简单使用MMC协议v5.0（行业标准）读取和写入内存。</p>
<p>eMMC标准规格书可以在jedec官网获取，emmc v5.1【<a href="https://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf】。" target="_blank" rel="noopener">https://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf】。</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>embedded MultiMediaCard Ver. 5.0 compatible. Detail description is referenced by JEDEC Standard</li>
<li>SAMSUNG eMMC supports features of eMMC5.0 which are defined in JEDEC Standard</li>
</ul>
<p>​      – Supported Features : Packed command, Cache, Discard, Sanitize, Power Off Notification, Data Tag,<br>​      –  Partition types, Context ID, Real Time Clock, Dynamic Device Capacity, HS200, HS400,Field Firmware Update.</p>
<ul>
<li>Non-supported Features : Large Sector Size (4KB)</li>
<li>Full backward compatibility with previous MultiMediaCard system specification (1bit data bus, multi-eMMC systems)</li>
<li>Data bus width : 1bit (Default), 4bit and 8bit</li>
<li>MMC I/F Clock Frequency : 0 ~ 200MHz<br>MMC I/F Boot Frequency : 0 ~ 52MHz</li>
<li>Temperature : Operation (-25C ~ 85C), Storage without operation (-40摄氏度 ~ 85摄氏度)</li>
<li>Power : Interface power → VDD(VCCQ) (1.70V ~ 1.95V or 2.7V ~ 3.6V) , Memory power → VDDF(VCC) (2.7V ~ 3.6V)</li>
</ul>
<h2 id="芯片结构图"><a href="#芯片结构图" class="headerlink" title="芯片结构图"></a>芯片结构图</h2><p><img src="http://jiali.clouddn.com/20201225_008.png" alt=""></p>
<p>​                                                                                                  图 eMMC 内部结构</p>
<p><strong>eMMC接口信号</strong></p>
<p><img src="http://jiali.clouddn.com/20201225_009.png" alt=""></p>
<p>​                                                                                                             表 eMMC引脚信号</p>
<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>The device initially consists of two Boot Partitions and RPMB Partition and User Data Area.</p>
<p>The User Data Area can be divided into four General Purpose Area Partitions and User Data Area partition. Each of the General Purpose Area partitions<br>and a section of User Data Area partition can be configured as enhanced partition.</p>
<p><strong>设备出厂默认四个分区，分别是两个Boot分区、RPMB分区和User Data分区。设备支持从User Data分区中再划分出四个General Purpose分区。四个General Purpose分区和User Data分区中的一段区域，它们的属性可以配置为enhanced partition。分区属性，有些芯片只能配置一次，终生有效，再次配置就会失败。比如Micron 的MTFC8GAKAJCN-1M，但是三星的KLM4G1FEPD-B031，支持多次配置</strong>。</p>
<p><strong>Enhanced Partition (Area)</strong></p>
<p>SAMSUNG eMMC adopts Enhanced User Data Area as SLC Mode. Therefore when master adopts some portion as enhanced user data area in User<br>Data Area, that area occupies triple size of original set up size. ( ex&gt; if master set 1MB for enhanced mode, total 3MB user data area is needed to generate 1MB enhanced area)</p>
<p><strong>（注意：把分区属性改为 Enhanced，就是把MLC模式改为SLC模式，这样做导致容量比原来少三倍。比如，配置1MBenhanced user data area，需要3MB user data area。）</strong></p>
<p>Max Enhanced User Data Area size is defined as (MAX_ENH_SIZE_MULT x HC_WP_GRP_SIZE x HC_ERASE_GRP_SIZE x 512kBytes)</p>
<p>如下图所示，设置支持最大八个分区，其中，4个General Purpose分区，默认不配置。如果主机需要General Purpose分区，可以通过配置General Purpose Partition Size寄存器。Enhanced Partition可以理解为从User Data区域，划分出一段区域并配置为Enhanced属性。</p>
<p><img src="http://jiali.clouddn.com/20201225_010.png" alt=""></p>
<p>​                                                                                                            图 eMMC分区管理</p>
<p>想查看设备分区支持哪些属性，可以查询PARTITIONING_SUPPORT寄存器。寄存器定义如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_011.png" alt=""></p>
<p>​                                                                                          图 PARTITIONING_SUPPORT寄存器</p>
<p><strong>General Purpose分区大小设置</strong></p>
<p>General Purpose Partition Size为12 byte,每个分区大小配置占3byte。大小配置如下图</p>
<p><img src="http://jiali.clouddn.com/20201225_012.png" alt=""></p>
<p>​                                                                                                      图 GP_SIZE_MULT_GP0 - GP_SIZE_MULT_GP3大小配置</p>
<p>HC_WP_GRP_SIZE和HC_ERASE_GRP_SIZE大小如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_014.png" alt=""></p>
<p>​                                                                                                                图HC_WP_GRP_SIZE和HC_ERASE_GRP_SIZE</p>
<p><strong>Enhanced User Data Area大小设置</strong> </p>
<p>配置寄存器如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_015.png" alt=""></p>
<p>​                                                                                             图ENH_SIZE_MULT和ENH_START_ADDR寄存器</p>
<p>Linux内核配置Enhanced User Data Area代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for (i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">				 EXT_CSD_ENH_START_ADDR+i,</span><br><span class="line">				 0,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">		err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">				 EXT_CSD_ENH_SIZE_MULT+i,</span><br><span class="line">				 ext_csd[EXT_CSD_MAX_ENH_SIZE_MULT+i],card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line">	&#125;</span><br><span class="line">	err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">			 EXT_CSD_PARTITION_ATTRIBUTE, ext_csd[EXT_CSD_PARTITION_ATTRIBUTE] | 0x01,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">			 EXT_CSD_PARTITION_SETTING,</span><br><span class="line">			 0x01,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br></pre></td></tr></table></figure>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>每个eMMC设备都有一组寄存器，如下</p>
<p><img src="http://jiali.clouddn.com/20201225_016.png" alt=""></p>
<p>​                                                                                                             图 eMMC寄存器</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>测试1：首次配置分区属性</p>
<p><img src="http://jiali.clouddn.com/20201225_017.png" alt=""></p>
<p>可以看出，成功识别EMMC.</p>
<p>测试2，非首次配置分区属性</p>
<p><img src="http://jiali.clouddn.com/20201225_018.png" alt=""></p>
<p>可以，看出，err返回-74，配置分区属性失败。</p>
<p><strong>总结：</strong></p>
<p>eMMC标准协议规定分区属性，只能配置一次，终生有效。但是有些芯片不遵守这个规定，比如三星的KLM4G1FEPD-B031。因此，编写Linux驱动时候，注意兼容性。</p>
<p>参考：</p>
<p>Storage【<a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/】" target="_blank" rel="noopener">https://linux.codingbelief.com/zh/storage/flash_memory/emmc/】</a></p>
<p>eMMC协议【<a href="https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html】" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html】</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%EF%BC%88%E2%91%A0%E4%BB%8B%E7%BB%8D%E2%91%A1%E5%91%BD%E4%BB%A4%E9%99%90%E5%88%B6%E2%91%A2%E9%85%8D%E7%BD%AE%E5%88%86%E5%8C%BA%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%EF%BC%88%E2%91%A0%E4%BB%8B%E7%BB%8D%E2%91%A1%E5%91%BD%E4%BB%A4%E9%99%90%E5%88%B6%E2%91%A2%E9%85%8D%E7%BD%AE%E5%88%86%E5%8C%BA%EF%BC%89/" class="post-title-link" itemprop="url">【转载】eMMC分区管理（①介绍②命令限制③配置分区）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-25 11:02:47 / Modified: 11:08:11" itemprop="dateCreated datePublished" datetime="2020-12-25T11:02:47+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>1、存储设备的默认区域包括一个用于存储数据的<strong>用户数据区域</strong>，两个可能的用于boot的<strong>boot区域</strong>分区和一个用于保护已验证身份的数据的重放保护的内存块<strong>RPMB区域分区</strong>，还有一个要我们自己分配的GPP区域</p>
<p><img src="https://img-blog.csdnimg.cn/20200326185611446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>2、嵌入式设备还为主机提供了配置其他本地内存分区的可能性<br>具有独立的地址空间，从逻辑地址0x00000000开始，用于不同的使用模型。<br>因此，存储块区域可以分类如下：<br>（1）两个引导区分区，其大小为128 KB的倍数，可以在其中执行从e•MMC的引导<br>（2）通过受信任机制访问的一个RPMB分区，其大小定义为以下各项的倍数：<br>128 KB。<br>（3）四个通用区域分区，用于存储敏感数据或用于其他主机使用模型，<br>大小是写保护组的倍数。<br>每个通用区域分区都可以通过增强或扩展的技术功能（例如更好的可靠性）来实现，这些功能可以将它们与默认存储介质区分开。 如果设备支持增强存储媒体功能，则默认情况下，引导和RPMB区域分区应实现为增强存储媒体。</p>
<p>3、引导区和RPMB区域分区的大小和属性由内存制造商定义（只读），而通用区域分区的大小和属性只能由主机在设备生命周期中进行一次编程（一次可编程）。<br>此外，主机可以自由配置用户数据区域中的一个网段，以实现为增强型存储介质，并根据写保护组来指定其起始位置和大小。 在设备生命周期内，该增强型用户数据区的属性只能编程一次（可以一次编程）。<br>可能的最终配置如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200326190259812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>主机对通用分区和增强型用户数据区域的配置可能会影响先前存储的数据（它们将被销毁）和设备初始化时间。 特别是，由于内部控制器可以执行操作来设置主机指定的配置，因此配置之后的第一个电源循环之后的初始化时间可能会超过规范定义的最大初始化时间。</p>
<p>4、各分区的命令限制：<br>定义了可以发布到每个分区的命令的一些限制：<br>（1）引导分区<br>不允许使用命令class6（写保护）和class7（锁定设备）。<br>（2）RPMB分区<br>仅允许使用Class0，Class2和Class4类的命令。 仍然使用除CMD0，CMD6，CMD8，CMD12，CMD13，CMD15以外的任何其他命令或在6.6.22中定义的命令为非法命令。<br>（3）通用分区<br>允许使用命令class0、2、4、5、6。<br>可以为每个分区中的每个写保护组分别设置写保护。 因此，主机可以在每个写保护组中设置不同的写保护类型。<br>在增强型用户数据区中，可以发出用户数据区中允许的class的所有命令。</p>
<p>5、扩展分区属性<br>每个通用分区可以具有不同的扩展分区属性。 属性类型列表包括：<br>（1）默认-未设置任何扩展属性<br>（2）系统代码–很少更新的分区，包含重要的系统文件（例如，包含<br>主机操作系统的可执行文件）<br>（3）非持久性-用于临时信息的分区（例如，交换文件以扩展主机虚拟内存空间）</p>
<p><strong>单个分区不能同时为其设置增强和扩展属性。</strong></p>
<p>6、配置分区<br>（1）扩展CSD寄存器中“属性”段的PARTITIONING_SUPPORT字段【160】中的 位0（PARTITIONING_EN）指示存储设备是否支持分区属性。 同一字段中的位1（ENH_ATTRIBUTE_EN）指示存储设备是否支持增强功能。位2（EXT_ATTRIBUTE_EN）指示存储设备是否支持“通用分区”中的扩展分区属性</p>
<p><img src="https://img-blog.csdnimg.cn/20200327112445193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）通用分区-最多4个分区的大小和属性。 要设置的EXT_CSD寄存器的Modes段中的字段是：<br>① <strong>GP_SIZE_MULT_GP0-GP_SIZE_MULT_GP3</strong>【154:143】设置大小：（此寄存器<strong>定义通用分区长度</strong>。通用分区长度应以<strong>大容量写保护分组为单位</strong>来表示）<br>②<strong>PARTITIONS_ATTRIBUTE</strong>设置<strong>增强属性</strong>【156】：（此寄存器用来设置哪个分区的增强属性。）<br>③ <strong>EXT_PARTITIONS_ATTRIBUTE</strong>设置<strong>扩展属性</strong>【53:52】：（此寄存器位设置通用分区的扩展属性）<br>（3）增强型用户数据区-区域的起始地址和属性。 要设置的EXT_CSD寄存器的Modes段中的字段是：<br>① ENH_START_ADDR【139:136】设置起始地址（此寄存器定义增强用户数据区的起始地址。<br>增强用户数据区段的起始地址在用户数据区内（对于大容量设备，以字节或扇区表示））<br>② ENH_SIZE_MULT【142:140】设置大小（此寄存器定义增强用户数据区长度。增强用户数据区长度应以大容量写保护分组为单位来表示。）<br>③ PARTITIONS_ATTRIBUTE【156】设置增强属性：（此寄存器用来设置哪个分区的增强属性。）</p>
<p>增强用户数据区的起始地址要求与写保护分组对齐。它是分组地址，对于最大 2GB 容<br>量，以字节为单位，对于大于 2GB 的容量，以扇区为单位。设备将忽略小于分组大小的低<br>位，将增强用户数据区起始地址与所属写保护分组地址（按字节或扇区）对齐。</p>
<p>增强用户数据区域的地址空间与剩下的用户数据区域的地址连续（增强用户数据区域与其余用户数据区域之间没有地址间隙。</p>
<p>通用分区和增强型用户数据区的粒度以大容量写保护组大小为单位。<br>配置分区参数后，应将ERASE_GROUP_DEF【175】位置1。以表示将使用大容量擦除组大小和大容量写保护组大小。如果在设置ERASE_GROUP_DEF位之前将分区参数通过CMD6发送到设备，则从站将显示SWITCH_ERROR。</p>
<p>如果先通过CMD6把分区参数发送给device，再设置ERASE_GROUP_DEF【175】位为1，device将显示将显示SWITCH_ERROR。</p>
<p>一旦设备被分区且配置固定，所有的命令类 5 和 6 命令将被看作是对于大容量擦除分组和大容量写保护分组的。</p>
<p>除了配置分区参数外，我们还得设置PARTITION_SETTING_COMPLETED【155】的bit0为1。（该位被置位则是告知设备，参数定义已经完成，设备可以启动其内部配置活动。若此位尚未置位时发生了突然掉电，则分区配置无效，给主机一个可以重新正确完成的机会）</p>
<p><img src="https://img-blog.csdnimg.cn/20200327134738274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>主机应发出CMD13，以确保正确设置所有参数。 如果任何一个分区参数不正确，设备将引发SWITCH_ERROR。</p>
<p>由于在设置PARTITION_SETTING_COMPLETED位之前，设备不会知道配置分区和用户区域的总大小，因此，如果配置分区和用户数据区域的总大小不适合设备的可用空间，则当主机设置PARTITION_SETTING_COMPLETED位时，设备可能会显示SWITCH_ERROR。在这种情况下，所有设置将在下一次电源循环后清除。所以主机需要再次在每个分区配置寄存器字节中设置正确的值</p>
<p>The device will actually configure itself, according to the partition parameters in the Extended CSD, only<br>after a power cycle. Any valid commands issued after PARTITION_SETTING_COMPLETED bit is set<br>but before a power cycle takes place will be normally executed. Any previous incomplete partitioning<br>configuration sequence before this bit is set will be cancelled upon a power cycle.</p>
<p>在一个电源周期下会配置分区，2 GB的设备的C_SIZE值和超过2GB的设备的SEC_COUNT值将被更改，以表示在配置后的用户数据区的大小，这个大小应该为配置分区之前的的用户数据区大小（对应2GB设备），而对于配置分区之前的2 GB以上的设备，即使分区大小减小到2 GB以下，SEC_COUNT也应始终表示配置分区之后的用户数据区的大小。）</p>
<p>用户数据区域的大小包括用户区域中增强用户数据区域的大小。 因此，主机可能需要在电源关闭后读取这些值，以计算用户数据区域的大小。 配置分区后，访问模式应保持不变。</p>
<p>如果主机上电后按照配置过程尝试使用CMD6更改通用分区和增强型用户数据区功能。设备将在没有执行任何内部动作的情况下将CMD 6响应的状态寄存器中的SWITCH_ERROR 断言（assert）。</p>
<p>分区配置参数存储在扩展CSD寄存器的一次性可编程字段中。 即使尚未设置PARTITION_SETTING_COMPLETED，主机也可以通过CMD8读取它们，但是只有在随后的加电之后，分区的执行才会发生。由于它们是一次性可编程字段，因此建议在读取后避免更改这些参数。</p>
<p>主机应遵循上图16中的流程图来配置通用区域分区和增强型用户数据区域的参数。 否则可能导致未定义的行为。</p>
<p>注：本文转自【<a href="https://blog.csdn.net/weixin_44773006/article/details/105125490】" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44773006/article/details/105125490】</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">【转载】eMMC总线协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-25 10:55:32 / Modified: 10:58:51" itemprop="dateCreated datePublished" datetime="2020-12-25T10:55:32+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/" itemprop="url" rel="index"><span itemprop="name">Flash Memory</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/storage/Flash-Memory/mmc/" itemprop="url" rel="index"><span itemprop="name">mmc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="1-eMMC-总线接口"><a href="#1-eMMC-总线接口" class="headerlink" title="1. eMMC 总线接口"></a>1. eMMC 总线接口</h2><p>eMMC 总线接口定义如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_host_interfaces.png" alt="img"></p>
<p>各个信号的描述如下：</p>
<p><strong>CLK</strong></p>
<p>CLK 信号用于从 Host 端输出时钟信号，进行数据传输的同步和设备运作的驱动。<br>在一个时钟周期内，CMD 和 DAT0-7 信号上都可以支持传输 1 个比特，即 SDR (Single Data Rate) 模式。此外，DAT0-7 信号还支持配置为 DDR (Double Data Rate) 模式，在一个时钟周期内，可以传输 2 个比特。<br>Host 可以在通讯过程中动态调整时钟信号的频率（注，频率范围需要满足 Spec 的定义）。通过调整时钟频率，可以实现省电或者数据流控（避免 Over-run 或者 Under-run）功能。 在一些场景中，Host 端还可以关闭时钟，例如 eMMC 处于 Busy 状态时，或者接收完数据，进入 Programming State 时。</p>
<p><strong>CMD</strong></p>
<p>CMD 信号主要用于 Host 向 eMMC 发送 Command 和 eMMC 向 Host 发送对于的 Response。Command 和 Response 的细节会在后续章节中介绍。</p>
<p><strong>DAT0-7</strong></p>
<p>DAT0-7 信号主要用于 Host 和 eMMC 之间的数据传输。在 eMMC 上电或者软复位后，只有 DAT0 可以进行数据传输，完成初始化后，可配置 DAT0-3 或者 DAT0-7 进行数据传输，即数据总线可以配置为 4 bits 或者 8 bits 模式。</p>
<p><strong>Data Strobe</strong></p>
<p>Data Strobe 时钟信号由 eMMC 发送给 Host，频率与 CLK 信号相同，用于 Host 端进行数据接收的同步。Data Strobe 信号只能在 HS400 模式下配置启用，启用后可以提高数据传输的稳定性，省去总线 tuning 过程。</p>
<blockquote>
<p><strong>NOTE:</strong><br>Extended CSD byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h2 id="2-eMMC-总线模型"><a href="#2-eMMC-总线模型" class="headerlink" title="2. eMMC 总线模型"></a>2. eMMC 总线模型</h2><p>eMMC 总线中，可以有一个 Host，多个 eMMC Devices。总线上的所有通讯都由 Host 端以一个 Command 开发发起，Host 一次只能与一个 eMMC Device 通讯。</p>
<p>系统在上电启动后，Host 会为所有 eMMC Device 逐个分配地址（RCA，Relative device Address）。当 Host 需要和某一个 eMMC Device 通讯时，会先根据 RCA 选中该 eMMC Device，只有被选中的 eMMC Device 才会响应 Host 的 Command。</p>
<blockquote>
<p>NOTE:<br>更详细的工作原理请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html" target="_blank" rel="noopener">eMMC 工作模式</a> 章节。</p>
</blockquote>
<h3 id="2-1-速率模式"><a href="#2-1-速率模式" class="headerlink" title="2.1 速率模式"></a>2.1 速率模式</h3><p>随着 eMMC 协议的版本迭代，eMMC 总线的速率越来越高。为了兼容旧版本的 eMMC Device，所有 Devices 在上电启动或者 Reset 后，都会先进入兼容速率模式（Backward Compatible Mode）。在完成 eMMC Devices 的初始化后，Host 可以通过特定的流程，让 Device 进入其他高速率模式，目前支持以下的几种速率模式。</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Data Rate</th>
<th>Bus Width</th>
<th>Frequency</th>
<th>Max Data Transfer (x8)</th>
</tr>
</thead>
<tbody><tr>
<td>Backward Compatible</td>
<td>Single</td>
<td>x1, x4, x8</td>
<td>0-26 MHz</td>
<td>26 MB/s</td>
</tr>
<tr>
<td>High Speed SDR</td>
<td>Single</td>
<td>x1, x4, x8</td>
<td>0-52 MHz</td>
<td>52 MB/s</td>
</tr>
<tr>
<td>High Speed DDR</td>
<td>Dual</td>
<td>x4, x8</td>
<td>0-52 MHz</td>
<td>104 MB/s</td>
</tr>
<tr>
<td>HS200</td>
<td>Single</td>
<td>x4, x8</td>
<td>0-200 MHz</td>
<td>200 MB/s</td>
</tr>
<tr>
<td>HS400</td>
<td>Dual</td>
<td>x8</td>
<td>0-200 MHz</td>
<td>400 MB/s</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>NOTE:</strong><br>Extended CSD byte[185] HS_TIMING 寄存器可以配置总线速率模式<br>Extended CSD byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h3 id="2-2-通信模型"><a href="#2-2-通信模型" class="headerlink" title="2.2 通信模型"></a>2.2 通信模型</h3><p>Host 与 eMMC Device 之间的通信都是由 Host 以一个 Command 开始发起的，eMMC Device 在完成 Command 所指定的任务后，则返回一个 Response。</p>
<h4 id="2-2-1-Read-Data"><a href="#2-2-1-Read-Data" class="headerlink" title="2.2.1 Read Data"></a>2.2.1 Read Data</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/multi_block_read.png" alt="img"></p>
<p>Host 从 eMMC Device 读取数据的流程如上图所示。</p>
<p>如果 Host 发送的是 Single Block Read 的 Command，那么 eMMC Device 只会发送一个 Block 的数据（一个 Block 的数据的字节数由 Host 设定或者为 eMMC Device 的默认值，更多细节请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html" target="_blank" rel="noopener">eMMC 工作模式</a> 章节）。<br>如果 Host 发送的是 Multiple Block Read 的 Command，那么 eMMC Device 会持续发送数据，直到 Host 主动发送 Stop Command。</p>
<blockquote>
<p><strong>NOTE:</strong><br>从 eMMC Device 读数据都是按 Block 读取的。</p>
</blockquote>
<h4 id="2-2-2-Write-Data"><a href="#2-2-2-Write-Data" class="headerlink" title="2.2.2 Write Data"></a>2.2.2 Write Data</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/multi_block_write.png" alt="img"></p>
<p>Host 向 eMMC Device 写入数据的流程如上图所示。</p>
<p>如果 Host 发送的是 Single Block Write Command，那么 eMMC Device 只会将后续第一个 Block 的数据写入的存储器中。<br>如果 Host 发送的是 Multiple Block Write Command，那么 eMMC Device 会持续地将接收到的数据写入到存储器中，直到 Host 主动发送 Stop Command。</p>
<p>eMMC Device 在接收到一个 Block 的数据后，会进行 CRC 校验，然后将校验结果通过 CRC Token 发送给 Host。<br>发送完 CRC Token 后，如果 CRC 校验成功，eMMC Device 会将数据写入到内部存储器时，此时 DAT0 信号会拉低，作为 Busy 信号。Host 会持续检测 DAT0 信号，直到为高电平时，才会接着发送下一个 Block 的数据。如果 CRC 校验失败，那么 eMMC Device 不会进行数据写入，此次传输后续的数据都会被忽略。</p>
<blockquote>
<p><strong>NOTE:</strong><br>向 eMMC Device 写数据都是按 Block 写入的。</p>
</blockquote>
<h4 id="2-2-3-No-Data"><a href="#2-2-3-No-Data" class="headerlink" title="2.2.3 No Data"></a>2.2.3 No Data</h4><p>在 Host 与 eMMC Device 的通信中，有部分交互是不需要进行数据传输的，还有部分交互甚至不需要 eMMC Device 的回复 Response。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/no_resp_or_data.png" alt="img"></p>
<h4 id="2-2-4-Command"><a href="#2-2-4-Command" class="headerlink" title="2.2.4 Command"></a>2.2.4 Command</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/command_token_format.png" alt="img"></p>
<p>如上图所示，eMMC Command 由 48 Bits 组成，各个 Bits 的解析如下所示：</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>Start Bit</th>
<th>Transmission Bit</th>
<th>Command Index</th>
<th>Argument</th>
<th>CRC7</th>
<th>End Bit</th>
</tr>
</thead>
<tbody><tr>
<td>Bit position</td>
<td>47</td>
<td>46</td>
<td>[45:40]</td>
<td>[39:8]</td>
<td>[7:1]</td>
<td>0</td>
</tr>
<tr>
<td>Width (bits)</td>
<td>1</td>
<td>1</td>
<td>6</td>
<td>32</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>Value</td>
<td>“0”</td>
<td>“1”</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>“1”</td>
</tr>
</tbody></table>
<p>Start Bit 固定为 “0”，在没有数据传输的情况下，CMD 信号保持高电平，当 Host 将 Start Bit 发送到总线上时，eMMC Device 可以很方便检测到该信号，并开始接收 Command。</p>
<p>Transmission Bit 固定为 “1”，指示了该数据包的传输方向为 Host 发送到 eMMC Device。</p>
<p>Command Index 和 Argument 为 Command 的具体内容，不同的 Command 有不同的 Index，不同的 Command 也有各自的 Argument。 更多的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_commands.html" target="_blank" rel="noopener">eMMC Commands</a> 章节。</p>
<p>CRC7 是包含 Start Bit、Transmission Bit、 Command Index 和 Argument 内容的 CRC 校验值。</p>
<p>End Bit 为结束标志位，固定为”1”。</p>
<blockquote>
<p><strong>NOTE:</strong><br>CRC 校验简单来说，是发送方将需要传输的数据“除于”（模2除）一个约定的数，并将得到的余数附在数据上一并发送出去。接收方收到数据后，再做同样的“除法”，然后校验得到余数是否与接收的余数相同。如果不相同，那么意味着数据在传输过程中发生了改变。更多的细节不在本文展开描述，感兴趣的读者可以参考 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC wiki</a> 中的介绍。</p>
</blockquote>
<h4 id="2-2-5-Response"><a href="#2-2-5-Response" class="headerlink" title="2.2.5 Response"></a>2.2.5 Response</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/respone_token_format.png" alt="img"></p>
<p>eMMC Response 有两种长度的数据包，分别为 48 Bits 和 136 Bits。</p>
<p>Start Bit 与 Command 一样，固定为 “0”，在没有数据传输的情况下，CMD 信号保持高电平，当 eMMC Device 将 Start Bit 发送到总线上时，Host 可以很方便检测到该信号，并开始接收 Response。</p>
<p>Transmission Bit 固定为 “0”，指示了该数据包的传输方向为 eMMC Device 发送到 Host。</p>
<p>Content 为 Response 的具体内容，不同的 Command 会有不同的 Content。 更多的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_responses.html" target="_blank" rel="noopener">eMMC Responses</a> 章节。</p>
<p>CRC7 是包含 Start Bit、Transmission Bit 和 Content 内容的 CRC 校验值。</p>
<p>End Bit 为结束标志位，固定为”1”。</p>
<h4 id="2-2-6-Data-Block"><a href="#2-2-6-Data-Block" class="headerlink" title="2.2.6 Data Block"></a>2.2.6 Data Block</h4><p>Data Block 由 Start Bit、Data、CRC16 和 End Bit 组成。以下是不同总线宽度和 Data Rate 下，Data Block 详细格式。</p>
<p><strong>1 Bit Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/1_bit_bus_sdr.png" alt="img"></p>
<p>CRC 为 Data 的 16 bit CRC 校验值，不包含 Start Bit。</p>
<p><strong>4 Bits Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/4_bits_bus_sdr.png" alt="img"></p>
<p>各个 Data Line 上的 CRC 为对应 Data Line 的 Data 的 16 bit CRC 校验值。</p>
<p><strong>8 Bits Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/8_bits_bus_sdr.png" alt="img"></p>
<p>各个 Data Line 上的 CRC 为对应 Data Line 的 Data 的16 bit CRC 校验值。</p>
<p><strong>4 Bits Bus DDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/4_bits_bus_ddr.png" alt="img"></p>
<p><strong>8 Bits Bus DDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/8_bits_bus_ddr.png" alt="img"></p>
<p>在 DDR 模式下，Data Line 在时钟的上升沿和下降沿都会传输数据，其中上升沿传输数据的奇数字节 （Byte 1,3,5 …），下降沿则传输数据的偶数字节（Byte 2,4,6 …）。<br>此外，在 DDR 模式下，1 个 Data Line 上有两个相互交织的 CRC16，上升沿的 CRC 比特组成 odd CRC16，下降沿的 CRC 比特组成 even CRC16。odd CRC16 用于校验该 Data Line 上所有上升沿比特组成的数据，even CRC16 则用于校验该 Data Line 上所有下降沿比特组成的数据。</p>
<blockquote>
<p><strong>NOTE:</strong><br>DDR 模式下使用两个 CRC16 作为校验，可能是为了更可靠的校验，选用 CRC16 而非 CRC32 则可能是出于兼容性设计的考虑。</p>
</blockquote>
<h4 id="2-2-7-CRC-Status-Token"><a href="#2-2-7-CRC-Status-Token" class="headerlink" title="2.2.7 CRC Status Token"></a>2.2.7 CRC Status Token</h4><p>在写数据传输中，eMMC Device 接收到 Host 发送的一个 Data Block 后，会进行 CRC 校验，如果校验成功，eMMC 会在对应的 Data Line 上向 Host 发回一个 Positive CRC status token (010)，如果校验失败，则会在对应的 Data Line 上发送一个 Negative CRC status token (101)。</p>
<blockquote>
<p><strong>NOTE:</strong><br>读数据时，Host 接收到 eMMC Device 发送的 Data Block 后，也会进行 CRC 校验，但是不管校验成功或者失败，都不会向 eMMC Device 发送 CRC Status Token。</p>
</blockquote>
<p>详细格式如下图所示：</p>
<p><strong>Positive CRC status token</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/positive_crc_status_token.png" alt="img"></p>
<p><strong>Negative CRC status token</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/negative_crc_status_token.png" alt="img"></p>
<h2 id="3-eMMC-总线测试过程"><a href="#3-eMMC-总线测试过程" class="headerlink" title="3. eMMC 总线测试过程"></a>3. eMMC 总线测试过程</h2><p>当 eMMC Device 处于 SDR 模式时，Host 可以发送 CMD19 命令，触发总线测试过程（Bus testing procedure），测试总线硬件上的连通性。如果 eMMC Device 支持总线测试，那么 eMMC Device 在接收到 CMD19 后，会发回对应的 Response，接着 eMMC Device 会发送一组固定的测试数据给 Host。Host 接收到数据后，检查数据正确与否，即可得知总线是否正确连通。</p>
<blockquote>
<p><strong>NOTE:</strong> 如果 eMMC Device 不支持总线测试，那么接收到 CMD19 时，不会发回 Response。<br>总线测试不支持在 DDR 模式下进行。</p>
</blockquote>
<p>测试数据如下所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/bus_testing_data.png" alt="img"></p>
<blockquote>
<p><strong>NOTE:</strong> 总线宽度为 1 时，只发送 DAT0 上的数据，总线宽度为 4 时，则只发送 DAT0-3 上的数据</p>
</blockquote>
<h2 id="4-eMMC-总线-Sampling-Tuning"><a href="#4-eMMC-总线-Sampling-Tuning" class="headerlink" title="4. eMMC 总线 Sampling Tuning"></a>4. eMMC 总线 Sampling Tuning</h2><p>由于芯片制造工艺、PCB 走线、电压、温度等因素的影响，数据信号从 eMMC Device 到达 Host 端的时间是存在差异的，Host 接收数据时采样的时间点也需要相应的进行调整。而 Host 端最佳采样时间点，则是通过 Sampling Tuning 流程得到。</p>
<blockquote>
<p><strong>NOTE:</strong><br>不同 eMMC Device 最佳的采样点可能不同，同一 eMMC Device 在不同的环境下运作时的最佳采样点也可能不同。<br>在 eMMC 标准中，定义了在 HS200 模式下可以进行 Sampling Tuning。</p>
</blockquote>
<h3 id="4-1-Sampling-Tuning-流程"><a href="#4-1-Sampling-Tuning-流程" class="headerlink" title="4.1 Sampling Tuning 流程"></a>4.1 Sampling Tuning 流程</h3><p>Sampling Tuning 是用于计算 Host 最佳采样时间点的流程，大致的流程如下：</p>
<ol>
<li>Host 将采样时间点重置为默认值</li>
<li>Host 向 eMMC Device 发送 Send Tuning Block 命令</li>
<li>eMMC Device 向 Host 发送固定的 Tuning Block 数据</li>
<li>Host 接收到 Tuning Block 并进行校验</li>
<li>Host 修改采样时点，重新从第 2 步开始执行，直到 Host 获取到一个有效采样时间点区间</li>
<li>Host 取有效采样时间点区间的中间值作为采样时间点，并推出 Tuning 流程</li>
</ol>
<blockquote>
<p><strong>NOTE:</strong><br>上述流程仅仅是一个示例。Tuning 流程执行的时机、频率和具体的步骤是由 Host 端的 eMMC Controller 具体实现而定的。</p>
</blockquote>
<h3 id="4-2-Tuning-Block-数据"><a href="#4-2-Tuning-Block-数据" class="headerlink" title="4.2 Tuning Block 数据"></a>4.2 Tuning Block 数据</h3><p>Tuning Block 是专门为了 Tuning 而设计的一组特殊数据。相对于普通的数据，这组特殊数据在传输过程中，会更高概率的出现 high SSO noise、deterministic jitter、ISI、timing errors 等问题。这组数据的具体内容如下所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/tuning_block_pattern.png" alt="img"></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/tuning_block_on_data_lines.png" alt="img"></p>
<blockquote>
<p><strong>NOTE:</strong> 总线宽度为 1 时，只发送 DAT0 上的数据，总线宽度为 4 时，则只发送 DAT0-3 上的数据</p>
</blockquote>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ol>
<li><a href="http://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf" target="_blank" rel="noopener">Embedded Multi-Media Card (e•MMC) Electrical Standard (5.1)</a> [PDF]</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.296.5338&rep=rep1&type=pdf" target="_blank" rel="noopener">SD/MMC Controller, Hard Processor System (HPS) Technical Reference Manual (TRM)</a> [PDF]</li>
<li><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC wiki</a> [WEB]</li>
</ol>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_bus_protocol.html】" target="_blank" rel="noopener">www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_bus_protocol.html】</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
