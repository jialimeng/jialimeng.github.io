<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="冒险，创新，永不放弃">
<meta property="og:type" content="website">
<meta property="og:title" content="Tech Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="冒险，创新，永不放弃">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="David Meng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/jialimeng" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android(Linux)%20%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android(Linux)%20%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">【转载】Android(Linux) 输入子系统解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:30:07 / Modified: 19:35:02" itemprop="dateCreated datePublished" datetime="2021-01-07T19:30:07+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：githubpage–<a href="http://huaqianlee.github.io/" target="_blank" rel="noopener">Andy.Lee’s Blog</a>【<a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/】" target="_blank" rel="noopener">http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/】</a></p>
<h1 id="Android-Linux-输入子系统解析"><a href="#Android-Linux-输入子系统解析" class="headerlink" title="Android(Linux) 输入子系统解析"></a>Android(Linux) 输入子系统解析</h1><p> Posted on Nov 23 2017  Edited on Apr 6 2019  In <a href="http://huaqianlee.github.io/categories/Android/" target="_blank" rel="noopener">Android</a></p>
<p>Android 源码分析系列综述博文： <a href="http://huaqianlee.github.io/2100/11/21/Android/A-summary-of-Android-source-analysis/" target="_blank" rel="noopener">Android 系统源码分析综述</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android/Linux 输入设备总类繁杂，常见的有按键、键盘、触摸屏、鼠标、摇杆等，之前其驱动都是采用字符设备、misc 设备处理的，但是如此多的设备就导致驱动混乱，所以 Linux 引入了输入子系统在字符设备等上抽象出一层来统一输入设备的驱动。本文就基于 MTK Android 7.0 源码来分析一下输入子系统。</p>
<h1 id="输入子系统架构"><a href="#输入子系统架构" class="headerlink" title="输入子系统架构"></a>输入子系统架构</h1><p>输入子系统的系统架构如下图所示：<br><img src="https://andylee-1258982386.cos.ap-chengdu.myqcloud.com/android/mtk/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="input_system_arch"></p>
<blockquote>
<p>Framework 层以上只是简单跟了一下源码，没有深入查看</p>
</blockquote>
<h1 id="输入子系统分层解析"><a href="#输入子系统分层解析" class="headerlink" title="输入子系统分层解析"></a>输入子系统分层解析</h1><h2 id="Hardware层"><a href="#Hardware层" class="headerlink" title="Hardware层"></a>Hardware层</h2><p>硬件层主要就是按键、触摸屏、Sensor等各种输入设备。</p>
<h2 id="Kernel层"><a href="#Kernel层" class="headerlink" title="Kernel层"></a>Kernel层</h2><p>Kernel 层主要分为三层，如下：</p>
<ol>
<li>Input 设备驱动层: 采集输入设备的数据信息，通过 Input Core 的 API 上报数据。</li>
<li>Input Core（核心层）：为事件处理层和设备驱动层提供接口API。</li>
<li>Event Handler（事件处理层）：通过核心层的API获取输入事件上报的数据，定义API与应用层交互。</li>
</ol>
<p>Kernel 层重要的数据结构如下：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>定义位置</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>struct input_dev</td>
<td>input.h</td>
<td>Input 设备驱动中实例化</td>
</tr>
<tr>
<td>struct evdev struct mousedev struct keybdev</td>
<td>evdev.c mousedev.c keybdev.c</td>
<td>Event Handler 层逻辑 input 设备的数据结构</td>
</tr>
<tr>
<td>struct input_handler</td>
<td>Input.h</td>
<td>Event handler 的结构，handler 层实例化</td>
</tr>
<tr>
<td>Struct input_handle</td>
<td>Input.h</td>
<td>用于创建驱动层 input_dev 和 handler 链表的链表项结构</td>
</tr>
</tbody></table>
<h3 id="数据结构部分"><a href="#数据结构部分" class="headerlink" title="数据结构部分"></a>数据结构部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># alps\kernel-3.18\include\linux\input.h</span><br><span class="line">&#x2F;* 输入设备的语言描述 *&#x2F;</span><br><span class="line">struct input_dev &#123;  &#x2F;&#x2F; 代表一个输入设备</span><br><span class="line">    const char *name;  &#x2F;&#x2F; 设备名字，sys 文件名</span><br><span class="line">    struct input_id id; &#x2F;&#x2F; 与 handler 匹配，总线类型、厂商、版本等信息</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 输入设备支持事件的位图（bitmap）*&#x2F;</span><br><span class="line">    unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; &#x2F;&#x2F; 所有事件</span><br><span class="line">    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F; 按键事件</span><br><span class="line">    unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;&#x2F; 相对位移事件</span><br><span class="line">    ...</span><br><span class="line">    unsigned int keycodemax;  &#x2F;&#x2F; 支持按键值个数</span><br><span class="line">    unsigned int repeat_key; &#x2F;&#x2F; 最近一次按键值，用于连击</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int (*setkeycode)()   &#x2F;&#x2F; 修改当前 keymap</span><br><span class="line">    int (*getkeycode)()   &#x2F;&#x2F; 检索keymap</span><br><span class="line">	...</span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];&#x2F;&#x2F; 设备当前按键状态</span><br><span class="line">	...</span><br><span class="line">	int (*open)()</span><br><span class="line">	int (*flush)();&#x2F;&#x2F; 处理传递给设备的事件，如：LED事件和声音事件</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    struct input_handle __rcu *grab; &#x2F;&#x2F; 当前占用该设备的 input_handle</span><br><span class="line">    </span><br><span class="line">	struct list_head	h_list; &#x2F;&#x2F; handle 链表，链接此input_dev</span><br><span class="line">	struct list_head	node; &#x2F;&#x2F;  链入 input_dev_list</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 事件处理，类似于中断处理函数 *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	void (*event)(); &#x2F;&#x2F; 处理设备驱动报告的事件</span><br><span class="line">	int (*connect)();  &#x2F;&#x2F; 连接 handler 和 input_dev</span><br><span class="line">	void (*disconnect)(); &#x2F;&#x2F; 断开连接</span><br><span class="line">	void (*start)();  &#x2F;&#x2F; 启动指定 handle 的 handler 函数</span><br><span class="line"></span><br><span class="line">	const char *name; &#x2F;&#x2F; handler 名</span><br><span class="line"></span><br><span class="line">	const struct input_device_id *id_table; &#x2F;&#x2F; 输入设备id列表，匹配 input_dev</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list; &#x2F;&#x2F; 链入handle 链表</span><br><span class="line">	struct list_head	node;  &#x2F;&#x2F; 链入 input_handler_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"> * 连接 input_dev 和 handler 的桥梁</span><br><span class="line"> * 一个 input_dev 可以对应多个 handler ， 一个 handler 也可以对应多个dev</span><br><span class="line">*&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line"></span><br><span class="line">	int open; &#x2F;&#x2F; 设备打开次数（上层访问次数）</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	struct input_dev *dev;  &#x2F;&#x2F; 所属 input_dev</span><br><span class="line">	struct input_handler *handler; &#x2F;&#x2F; 所属 handler</span><br><span class="line"></span><br><span class="line">	struct list_head	d_node; &#x2F;&#x2F; 链入对应 input_dev 的 h_list</span><br><span class="line">	struct list_head	h_node; &#x2F;&#x2F; 链入对应 handler de h_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># alps&#x2F;kernel-3.18&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;input.h</span><br><span class="line">&#x2F;* 事件载体，输入子系统的事件包装为 input_event 上传到 Framework*&#x2F;</span><br><span class="line">struct input_event &#123;</span><br><span class="line"> struct timeval time; &#x2F;&#x2F; 时间戳</span><br><span class="line"> __u16 type;  &#x2F;&#x2F; 事件类型</span><br><span class="line"> __u16 code;  &#x2F;&#x2F; 事件代码</span><br><span class="line"> __s32 value;  &#x2F;&#x2F; 事件值，如坐标的偏移值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Input-设备驱动层"><a href="#Input-设备驱动层" class="headerlink" title="Input 设备驱动层"></a>Input 设备驱动层</h3><p>这部分主要实现各种输入设备的自己硬件相关的驱动并上报事件，这部分驱动基本遵循如下流程：</p>
<ol>
<li>声明实例化input_dev 对象</li>
<li>注册 input_dev<ul>
<li>input_allocate_device() 给设备分配空间，设置dev （实现于 input.c）</li>
<li>通过 input_register_device() 注册 （实现于 input.c）</li>
</ul>
</li>
<li>硬件初始化，中断初始化，定义中断处理程序</li>
<li>设置input_dev对象</li>
<li>定义中断处理程序，上报事件</li>
</ol>
<p>由于我自己有个外设系列源码分析，这里就不详细查看相关源码了，主要分析输入子系统的通用部分。设备驱动路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alps\kernel-3.18\drivers\input</span><br></pre></td></tr></table></figure>

<h3 id="Input-Core"><a href="#Input-Core" class="headerlink" title="Input Core"></a>Input Core</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\input\input.c</span><br><span class="line">input_init()</span><br><span class="line">    class_register(&amp;input_class); &#x2F;&#x2F; 注册为输入设备类，创建 input_class</span><br><span class="line">    input_proc_init(); &#x2F;&#x2F; 创建 proc&#x2F;bus&#x2F;input 路径下设备文件</span><br><span class="line">        proc_mkdir(&quot;bus&#x2F;input&quot;, NULL);</span><br><span class="line">        proc_create(&quot;devices&quot;..&amp;input_devices_fileops);  &#x2F;&#x2F; </span><br><span class="line">		proc_create(&quot;handlers&quot;..&amp;input_handlers_fileops);	    </span><br><span class="line">    register_chrdev_region(MKDEV(INPUT_MAJOR, 0),INPUT_MAX_CHAR_DEVICES, &quot;input&quot;);</span><br><span class="line"></span><br><span class="line">input_register_device() &#x2F;&#x2F; 通过 input core 注册 input_dev ，为设备驱动所调用 </span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit); &#x2F;&#x2F; 设为 EV_SYN&#x2F;SYN_REPORT 事件，所有设备默认支持</span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit); &#x2F;&#x2F; KEY_RESERVED 事件不支持上传到用户空间</span><br><span class="line">    ... &#x2F;&#x2F; 设置 input_dev </span><br><span class="line">    device_add(&amp;dev-&gt;dev); &#x2F;&#x2F; 将 input_dev 注册到 sysfs</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); &#x2F;&#x2F; 将 input_dev 加入input_dev_list</span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);   &#x2F;&#x2F; 配对并 connect handler 和 input_dev</span><br><span class="line">		</span><br><span class="line">input_attach_handler()	</span><br><span class="line">    input_match_device(handler, dev) &#x2F;&#x2F; 配对handler 和 input_dev</span><br><span class="line">    handler-&gt;connect(handler, dev, id); &#x2F;&#x2F; connect</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">input_register_handler  &#x2F;&#x2F; 注册一个 input_handler </span><br><span class="line">	INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">	list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">	list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);  &#x2F;&#x2F; 同上</span><br><span class="line">		</span><br><span class="line">input_event() &#x2F;&#x2F; 上报新事件</span><br><span class="line">    input_handle_event()&#x2F;input_repeat_key()</span><br><span class="line">      input_get_disposition &#x2F;&#x2F; 处理事件类型</span><br><span class="line">        input_pass_values()</span><br><span class="line">            input_to_handler()</span><br><span class="line">                handler-&gt;events() &#x2F;&#x2F; 对应 evdev.c 中 evdev_event()</span><br><span class="line">            input_start_autorepeat() &#x2F;&#x2F; 根据需要启动或停止自动重复上报</span><br><span class="line">            input_stop_autorepeat(dev)</span><br><span class="line">      input_handle_abs_event()      </span><br><span class="line">        input_abs_set_val(dev, ABS_MT_SLOT, mt-&gt;slot) &#x2F;&#x2F; 刷新等待槽事件</span><br><span class="line">input_start_autorepeat() &#x2F;&#x2F; 启动定时器，自动重复上报</span><br><span class="line"></span><br><span class="line">&#x2F;* 类似于 input_event() , 不过忽略已经被捕获的事件和非拥有 dev 注入事件 *&#x2F;</span><br><span class="line">input_inject_event() </span><br><span class="line">    input_handle_event()</span><br><span class="line"></span><br><span class="line">input_open_device</span><br><span class="line">    handle-&gt;open++</span><br><span class="line">    dev-&gt;open(dev) &#x2F;&#x2F; 设备 open</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_dev_suspend()    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\include\linux\input.h</span><br><span class="line">input_report_xx() &#x2F;&#x2F; 上报事件，如键值</span><br><span class="line">	input_event()</span><br><span class="line">input_sync &#x2F;&#x2F; 同步事件</span><br><span class="line">	input_event()</span><br><span class="line"></span><br><span class="line">&#x2F;*********************************************************************</span><br><span class="line"> * 基于 input system 封装了一层轮询设备，为需要轮询的设备驱动提供支持</span><br><span class="line"> *********************************************************************&#x2F;</span><br><span class="line"># alps\kernel-3.18\include\linux\input-polldev.h</span><br><span class="line">struct input_polled_dev</span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\drivers\input\input-polldev.c</span><br><span class="line">input_register_polled_device()</span><br><span class="line">    NIT_DELAYED_WORK(&amp;dev-&gt;work, input_polled_device_work);</span><br><span class="line">input_open_polled_device()</span><br><span class="line">input_polldev_set_poll()</span><br></pre></td></tr></table></figure>

<h3 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h3><p>Event Handler 层以通用的 evdev.c 为例来解析，上层和 Kernel 层的交互在此文件完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\input\evdev.c</span><br><span class="line">static struct input_handler evdev_handler &#x3D; &#123;   &#x2F;&#x2F; input_handler</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">	.events		&#x3D; evdev_events,</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.legacy_minors	&#x3D; true,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line">truct file_operations evdev_fops &#x3D; &#123;  &#x2F;&#x2F; 对应于上层的操作函数</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.read		&#x3D; evdev_read,</span><br><span class="line">	.write		&#x3D; evdev_write,</span><br><span class="line">	.poll		&#x3D; evdev_poll,</span><br><span class="line">	.open		&#x3D; evdev_open,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">struct evdev_client &#123;</span><br><span class="line">	unsigned int head;</span><br><span class="line">	unsigned int tail;</span><br><span class="line">    ....</span><br><span class="line">	struct wake_lock wake_lock;</span><br><span class="line">	struct list_head node;</span><br><span class="line">	struct input_event buffer[];  &#x2F;&#x2F; 事件存储 buffer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">evdev_init()</span><br><span class="line">    input_register_handler(&amp;evdev_handler) &#x2F;&#x2F; 定义于 input.c</span><br><span class="line">    </span><br><span class="line">evdev_connect()    </span><br><span class="line">    struct evdev *evdev;</span><br><span class="line">    &#x2F;* 设置evdev *&#x2F;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, dev_no); &#x2F;&#x2F; 根据设备号命名handler</span><br><span class="line">    &#x2F;* 完成dev 和 handler 的连接关系*&#x2F;</span><br><span class="line">    evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); &#x2F;&#x2F;绑定 File 操作函数 </span><br><span class="line">    device_add(&amp;evdev-&gt;dev);&#x2F;&#x2F;注册设备到内核，会在 &#x2F;dev&#x2F;input 生成设备</span><br><span class="line">    </span><br><span class="line">evdev_event()</span><br><span class="line">    evdev_events()</span><br><span class="line">        evdev_pass_values()</span><br><span class="line">            __pass_event() &#x2F;&#x2F; 将事件加入 evdev_client， 并加入EV_SYN</span><br><span class="line">            wake_up_interruptible(&amp;evdev-&gt;wait) &#x2F;&#x2F; 唤醒，让上层读取事件数据（存于 evdev buffer）</span><br><span class="line">            </span><br><span class="line">evdev_flush()</span><br><span class="line">    input_flush_device() &#x2F;&#x2F; input.c</span><br><span class="line">    </span><br><span class="line">evdev_write()   &#x2F;&#x2F; 上层写入数据</span><br><span class="line">    input_event_from_user()</span><br><span class="line">    input_inject_event()</span><br><span class="line">evdev_read()   &#x2F;&#x2F;  上层读取数据</span><br><span class="line">    </span><br><span class="line">&#x2F;* 内核与用户空间交互函数实现 *&#x2F;    </span><br><span class="line"># alps\kernel-3.18\drivers\input\input-compat.c </span><br><span class="line">input_event_from_user()</span><br><span class="line">    copy_from_user()  </span><br><span class="line">input_event_to_user()</span><br></pre></td></tr></table></figure>

<h2 id="Framework-层"><a href="#Framework-层" class="headerlink" title="Framework 层"></a>Framework 层</h2><p>Framework 层涉及面太广，内容也多，我现在阅读这部分上层源码也有些吃力，再加上时间原因，只简单跟读了几个关键文件。以后抽时间再跟读一下源码，产出一篇博客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* native 部分关键路径*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger</span><br><span class="line"># alps\frameworks\native\libs\input</span><br><span class="line">&#x2F;* 从设备文件（&#x2F;dev&#x2F;input）获取信息）*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\EventHub.cpp</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputManager.cpp</span><br><span class="line">&#x2F;* 从 EventHub 获取事件信息*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputReader.cpp</span><br><span class="line">&#x2F;* 分发事件信息*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputDispatcher.cpp</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputListener.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* framework 部分关键路径*&#x2F;</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\input</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\wm</span><br><span class="line"></span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\input\InputManagerService.java</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\wm\WindowManagerService.java</span><br></pre></td></tr></table></figure>

<h1 id="附-Shell-操作路径"><a href="#附-Shell-操作路径" class="headerlink" title="附 Shell 操作路径"></a>附 Shell 操作路径</h1><p>在 Kernel 层生成三个路径及相关设备文件，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;sys&#x2F;class&#x2F;input&#x2F;</span><br><span class="line">event0  event11 event4 event7 input0  input11 input4 input7</span><br><span class="line">event1  event2  event5 event8 input1  input2  input5 input8</span><br><span class="line">event10 event3  event6 event9 input10 input3  input6 input9</span><br><span class="line"></span><br><span class="line"># &#x2F;dev&#x2F;input </span><br><span class="line">event0 event10 event2 event4 event6 event8</span><br><span class="line">event1 event11 event3 event5 event7 event9</span><br><span class="line"></span><br><span class="line"># &#x2F;proc&#x2F;bus&#x2F;input  </span><br><span class="line">devices handlers</span><br><span class="line"># cat devices  查看总线上的已经注册上的输入设备</span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;ACCDET&quot;</span><br><span class="line">P: Phys&#x3D;</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;gpufreq_ib event0</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;40 0 0 0 0 0 0 1000000000 c000001800000 0</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0001</span><br><span class="line">N: Name&#x3D;&quot;fingerprint_key&quot;</span><br><span class="line">P: Phys&#x3D;</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;gpufreq_ib event2</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;2000100000000000 180001f 8000000000000000</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cat handlers &#x2F;&#x2F; 查看注册的handler</span><br><span class="line">N: Number&#x3D;0 Name&#x3D;gpufreq_ib</span><br><span class="line">N: Number&#x3D;1 Name&#x3D;evdev Minor&#x3D;64</span><br></pre></td></tr></table></figure>

<p><a href="http://huaqianlee.github.io/tags/源码分析/" target="_blank" rel="noopener"># 源码分析</a> <a href="http://huaqianlee.github.io/tags/MTK/" target="_blank" rel="noopener"># MTK</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">【转载】电容触摸屏驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:27:41 / Modified: 19:29:36" itemprop="dateCreated datePublished" datetime="2021-01-07T19:27:41+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：博客园–<a href="https://home.cnblogs.com/u/Lioker/" target="_blank" rel="noopener">Lioker</a>【<a href="https://www.cnblogs.com/Lioker/p/10990633.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/10990633.html】</a></p>
<p>在读者学习本章以及后续章节之前，最好拥有ADC和触摸屏裸机基础，可以参考：<a href="http://wiki.100ask.org/第018课_ADC和触摸屏" target="_blank" rel="noopener">ADC和触摸屏编程</a>。</p>
<p>和按键驱动类似，触摸屏也是通过电平来体现按下或松开。因此如果想要写出通用的触摸屏驱动，需要使用<a href="https://www.cnblogs.com/Lioker/p/10871151.html" target="_blank" rel="noopener">输入子系统</a>完成。</p>
<h1 id="一、电容触摸屏检测原理"><a href="#一、电容触摸屏检测原理" class="headerlink" title="一、电容触摸屏检测原理"></a>一、电容触摸屏检测原理</h1><p>此段来源于百度百科，读者可查看：<a href="https://baike.baidu.com/item/电容式触摸屏/7533199?fr=aladdin" target="_blank" rel="noopener">电容式触摸屏</a>。</p>
<p>电容式触摸屏技术是利用人体的电流感应进行工作的。</p>
<p>电容式触摸屏是一块四层复合玻璃屏，玻璃屏的内表面和夹层各涂有一层ITO（导电玻璃），最外层是一薄层矽土玻璃保护层，夹层ITO涂层作为工作面，四个角上引出四个电极，内层ITO为屏蔽层以保证良好的工作环境。</p>
<p>当用户触摸电容屏时，由于人体电场，用户手指和工作面形成一个耦合电容，因为工作面上接有高频信号，于是手指吸收走一个很小的电流，这个电流分别从屏的四个角上的电极中流出，且理论上流经四个电极的电流与手指头到四角的距离成比例，控制器通过对四个电流比例的精密计算得出位置。可以达到99%的精确度，具备小于3ms的响应速度。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190608142517953-2146917656.png" alt="img"></p>
<h1 id="二、电容触摸屏控制芯片驱动分析"><a href="#二、电容触摸屏控制芯片驱动分析" class="headerlink" title="二、电容触摸屏控制芯片驱动分析"></a>二、电容触摸屏控制芯片驱动分析</h1><p>我使用的开发板iTOP4412的触摸屏IC为ft5406，对应的驱动文件是drivers/input/touchscreen/ft5x06_ts.c。下面来分析此文件。</p>
<p>首先从init()函数分析：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __init ft5x0x_ts_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int ret;</span><br><span class="line"> 4     int type;</span><br><span class="line"> 5 </span><br><span class="line"> 6     type &#x3D; get_lcd_type();</span><br><span class="line"> 7 </span><br><span class="line"> 8     &#x2F;* 设置GPIO引脚 *&#x2F;</span><br><span class="line"> 9     ret &#x3D; gpio_request(EXYNOS4_GPL0(2), &quot;TP1_EN&quot;);</span><br><span class="line">10 ...</span><br><span class="line">11     gpio_direction_output(EXYNOS4_GPL0(2), 1);</span><br><span class="line">12 </span><br><span class="line">13     s3c_gpio_cfgpin(EXYNOS4_GPL0(2), S3C_GPIO_OUTPUT);</span><br><span class="line">14     gpio_free(EXYNOS4_GPL0(2));</span><br><span class="line">15 </span><br><span class="line">16     mdelay(5);</span><br><span class="line">17 </span><br><span class="line">18     printk(&quot;&#x3D;&#x3D;%s: reset&#x3D;&#x3D;\n&quot;, __FUNCTION__);</span><br><span class="line">19     ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">20 ...</span><br><span class="line">21     gpio_direction_output(EXYNOS4_GPX0(3), 0);</span><br><span class="line">22     mdelay(200);</span><br><span class="line">23     &#x2F;* 给触摸芯片复位 *&#x2F;</span><br><span class="line">24     gpio_direction_output(EXYNOS4_GPX0(3), 1);</span><br><span class="line">25 </span><br><span class="line">26     s3c_gpio_cfgpin(EXYNOS4_GPX0(3), S3C_GPIO_OUTPUT);</span><br><span class="line">27     gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">28     msleep(300);</span><br><span class="line">29 ...</span><br><span class="line">30     &#x2F;* 注册I2C驱动 *&#x2F;</span><br><span class="line">31     return i2c_add_driver(&amp;ft5x0x_ts_driver);</span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>此触摸屏使用的是i2c驱动，我们来看看此驱动结构体定义了什么。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 static struct i2c_driver ft5x0x_ts_driver &#x3D; &#123;</span><br><span class="line">2     .probe        &#x3D; ft5x0x_ts_probe,</span><br><span class="line">3     .remove        &#x3D; __devexit_p(ft5x0x_ts_remove),</span><br><span class="line">4     .id_table    &#x3D; ft5x0x_ts_id,</span><br><span class="line">5     .driver    &#x3D; &#123;</span><br><span class="line">6         .name    &#x3D; FT5X0X_NAME,    &#x2F;&#x2F; #define FT5X0X_NAME &quot;ft5x0x_ts&quot;</span><br><span class="line">7         .owner    &#x3D; THIS_MODULE,</span><br><span class="line">8     &#125;,</span><br><span class="line">9 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>接下来，我们来查看probe()函数：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">  1 static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">  2 &#123;</span><br><span class="line">  3     struct ft5x0x_i2c_platform_data *pdata;</span><br><span class="line">  4     struct ft5x0x_ts_data *ts;</span><br><span class="line">  5     struct input_dev *input_dev;</span><br><span class="line">  6     unsigned char val;</span><br><span class="line">  7     int err &#x3D; -EINVAL;</span><br><span class="line">  8     &#x2F;* 判断是否为i2c设备 *&#x2F;</span><br><span class="line">  9     if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) &#123;</span><br><span class="line"> 10 ...</span><br><span class="line"> 11     &#125;</span><br><span class="line"> 12     &#x2F;* 分配空间，此结构体用于存储坐标, 压力值, 事件 *&#x2F;</span><br><span class="line"> 13     ts &#x3D; kzalloc(sizeof(*ts), GFP_KERNEL);</span><br><span class="line"> 14 ...</span><br><span class="line"> 15     &#x2F;* 获取dev的平台数据 *&#x2F;</span><br><span class="line"> 16     pdata &#x3D; client-&gt;dev.platform_data;</span><br><span class="line"> 17 </span><br><span class="line"> 18     ts-&gt;screen_max_x &#x3D; pdata-&gt;screen_max_x;</span><br><span class="line"> 19     ts-&gt;screen_max_y &#x3D; pdata-&gt;screen_max_y;</span><br><span class="line"> 20     ts-&gt;pressure_max &#x3D; pdata-&gt;pressure_max;</span><br><span class="line"> 21     &#x2F;* 设置引脚为中断模式 *&#x2F;</span><br><span class="line"> 22     ts-&gt;gpio_irq &#x3D; pdata-&gt;gpio_irq;</span><br><span class="line"> 23     if (ts-&gt;gpio_irq !&#x3D; -EINVAL) &#123;</span><br><span class="line"> 24         client-&gt;irq &#x3D; gpio_to_irq(ts-&gt;gpio_irq);</span><br><span class="line"> 25     &#125; else &#123;</span><br><span class="line"> 26         goto exit_no_pdata;</span><br><span class="line"> 27     &#125;</span><br><span class="line"> 28     if (pdata-&gt;irq_cfg) &#123;</span><br><span class="line"> 29         s3c_gpio_cfgpin(ts-&gt;gpio_irq, pdata-&gt;irq_cfg);</span><br><span class="line"> 30         s3c_gpio_setpull(ts-&gt;gpio_irq, S3C_GPIO_PULL_NONE);</span><br><span class="line"> 31     &#125;</span><br><span class="line"> 32 </span><br><span class="line"> 33     ts-&gt;gpio_wakeup &#x3D; pdata-&gt;gpio_wakeup;</span><br><span class="line"> 34     ts-&gt;gpio_reset &#x3D; pdata-&gt;gpio_reset;</span><br><span class="line"> 35     &#x2F;* 创建工作队列 *&#x2F;</span><br><span class="line"> 36     INIT_WORK(&amp;ts-&gt;work, ft5x0x_ts_pen_irq_work);</span><br><span class="line"> 37     this_client &#x3D; client;</span><br><span class="line"> 38     i2c_set_clientdata(client, ts);</span><br><span class="line"> 39 </span><br><span class="line"> 40     ts-&gt;queue &#x3D; create_singlethread_workqueue(dev_name(&amp;client-&gt;dev));</span><br><span class="line"> 41 ...</span><br><span class="line"> 42     &#x2F;* 分配设置注册输入子系统 *&#x2F;</span><br><span class="line"> 43     input_dev &#x3D; input_allocate_device();</span><br><span class="line"> 44     ts-&gt;input_dev &#x3D; input_dev;</span><br><span class="line"> 45 </span><br><span class="line"> 46     set_bit(EV_SYN, input_dev-&gt;evbit);    &#x2F;* 同步事件 *&#x2F;</span><br><span class="line"> 47     set_bit(EV_ABS, input_dev-&gt;evbit);    &#x2F;* 绝对位移事件，存储坐标 *&#x2F;</span><br><span class="line"> 48     set_bit(EV_KEY, input_dev-&gt;evbit);    &#x2F;* 按键事件 *&#x2F;</span><br><span class="line"> 49 </span><br><span class="line"> 50 #ifdef CONFIG_FT5X0X_MULTITOUCH</span><br><span class="line"> 51     set_bit(ABS_MT_TRACKING_ID, input_dev-&gt;absbit);</span><br><span class="line"> 52     set_bit(ABS_MT_TOUCH_MAJOR, input_dev-&gt;absbit);</span><br><span class="line"> 53     set_bit(ABS_MT_WIDTH_MAJOR, input_dev-&gt;absbit);</span><br><span class="line"> 54     set_bit(ABS_MT_POSITION_X, input_dev-&gt;absbit);</span><br><span class="line"> 55     set_bit(ABS_MT_POSITION_Y, input_dev-&gt;absbit);</span><br><span class="line"> 56 </span><br><span class="line"> 57     input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, ts-&gt;screen_max_x, 0, 0);</span><br><span class="line"> 58     input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, ts-&gt;screen_max_y, 0, 0);</span><br><span class="line"> 59     input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, ts-&gt;pressure_max, 0, 0);</span><br><span class="line"> 60     input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);</span><br><span class="line"> 61     input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, FT5X0X_PT_MAX, 0, 0);</span><br><span class="line"> 62 #else</span><br><span class="line"> 63     set_bit(ABS_X, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的x坐标 *&#x2F;</span><br><span class="line"> 64     set_bit(ABS_Y, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的y坐标 *&#x2F;</span><br><span class="line"> 65     set_bit(ABS_PRESSURE, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的压力值 *&#x2F;</span><br><span class="line"> 66     set_bit(BTN_TOUCH, input_dev-&gt;keybit);        &#x2F;* 按键事件中的触摸屏事件 *&#x2F;</span><br><span class="line"> 67     &#x2F;* 设置x, y, 压力值的范围和初始值 *&#x2F;</span><br><span class="line"> 68     input_set_abs_params(input_dev, ABS_X, 0, ts-&gt;screen_max_x, 0, 0);</span><br><span class="line"> 69     input_set_abs_params(input_dev, ABS_Y, 0, ts-&gt;screen_max_y, 0, 0);</span><br><span class="line"> 70     input_set_abs_params(input_dev, ABS_PRESSURE, 0, ts-&gt;pressure_max, 0 , 0);</span><br><span class="line"> 71 #endif</span><br><span class="line"> 72 </span><br><span class="line"> 73     input_dev-&gt;name &#x3D; FT5X0X_NAME;</span><br><span class="line"> 74     input_dev-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line"> 75     input_dev-&gt;id.vendor &#x3D; 0x12FA;</span><br><span class="line"> 76     input_dev-&gt;id.product &#x3D; 0x2143;</span><br><span class="line"> 77     input_dev-&gt;id.version &#x3D; 0x0100;</span><br><span class="line"> 78 </span><br><span class="line"> 79     err &#x3D; input_register_device(input_dev);</span><br><span class="line"> 80 ...</span><br><span class="line"> 81     &#x2F;* 读取芯片硬件信息 *&#x2F;</span><br><span class="line"> 82     msleep(3);</span><br><span class="line"> 83     err &#x3D; ft5x0x_read_fw_ver(&amp;val);</span><br><span class="line"> 84 </span><br><span class="line"> 85     err &#x3D; request_irq(client-&gt;irq, ft5x0x_ts_interrupt, IRQ_TYPE_EDGE_FALLING, &quot;ft5x0x_ts&quot;, ts);</span><br><span class="line"> 86     disable_irq(client-&gt;irq);</span><br><span class="line"> 87     dev_info(&amp;client-&gt;dev, &quot;Firmware version 0x%02x\n&quot;, val);</span><br><span class="line"> 88     &#x2F;* 支持休眠功能 *&#x2F;</span><br><span class="line"> 89 #ifdef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line"> 90     ts-&gt;early_suspend.level &#x3D; EARLY_SUSPEND_LEVEL_BLANK_SCREEN;&#x2F;&#x2F;EARLY_SUSPEND_LEVEL_DISABLE_FB + 1;</span><br><span class="line"> 91     ts-&gt;early_suspend.suspend &#x3D; ft5x0x_ts_suspend;</span><br><span class="line"> 92     ts-&gt;early_suspend.resume &#x3D; ft5x0x_ts_resume;</span><br><span class="line"> 93     register_early_suspend(&amp;ts-&gt;early_suspend);</span><br><span class="line"> 94 #endif</span><br><span class="line"> 95 </span><br><span class="line"> 96     enable_irq(client-&gt;irq);</span><br><span class="line"> 97 </span><br><span class="line"> 98     dev_info(&amp;client-&gt;dev, &quot;FocalTech ft5x0x TouchScreen initialized\n&quot;);</span><br><span class="line"> 99 </span><br><span class="line">100     return err;</span><br><span class="line">101 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>probe()函数所做的事情主要有：</strong></p>
<p>\1. 判断是否为i2c设备</p>
<p>\2. 分配并设置struct ft5x0x_ts_data，此结构体中存储有最大y坐标，最大压力值，工作队列等。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct ft5x0x_ts_data &#123;</span><br><span class="line"> 2     struct input_dev *input_dev;</span><br><span class="line"> 3     struct ft5x0x_event event;</span><br><span class="line"> 4 </span><br><span class="line"> 5     uint32_t gpio_irq;</span><br><span class="line"> 6     uint32_t gpio_wakeup;</span><br><span class="line"> 7     uint32_t gpio_reset;</span><br><span class="line"> 8 </span><br><span class="line"> 9     int screen_max_x;</span><br><span class="line">10     int screen_max_y;</span><br><span class="line">11     int pressure_max;</span><br><span class="line">12 </span><br><span class="line">13     struct work_struct work;</span><br><span class="line">14     struct workqueue_struct *queue;</span><br><span class="line">15 </span><br><span class="line">16 #ifdef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">17     struct early_suspend early_suspend;</span><br><span class="line">18 #endif</span><br><span class="line">19 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>\3. 设置中断</p>
<p>\4. 初始化工作队列（工作队列可以休眠）</p>
<p>\5. 分配、设置并注册input_device</p>
<p>当有触摸屏事件发生时，会跳转到probe()函数中注册的中断处理函数ft5x0x_ts_interrupt()中执行，由于在probe()函数中设置了工作队列，因此中断函数会跳转至工作队列函数ft5x0x_ts_pen_irq_work()：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 static irqreturn_t ft5x0x_ts_interrupt(int irq, void *dev_id) &#123;</span><br><span class="line"> 2     struct ft5x0x_ts_data *ts &#x3D; dev_id;</span><br><span class="line"> 3 </span><br><span class="line"> 4     disable_irq_nosync(this_client-&gt;irq);</span><br><span class="line"> 5 </span><br><span class="line"> 6     if (!work_pending(&amp;ts-&gt;work)) &#123;</span><br><span class="line"> 7         queue_work(ts-&gt;queue, &amp;ts-&gt;work);</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9 </span><br><span class="line">10     return IRQ_HANDLED;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由于i2c读取函数底层可能拥有休眠操作，但是中断中并不允许休眠，因此需要设置工作队列。</p>
<p>在工作队列函数中，首先完成读取x，y和压力值等参数的工作，之后完成参数的上报工作。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  1 static int ft5x0x_read_data(struct ft5x0x_ts_data *ts) &#123;</span><br><span class="line">  2     struct ft5x0x_event *event &#x3D; &amp;ts-&gt;event;</span><br><span class="line">  3     u8 buf[64] &#x3D; &#123; 0 &#125;;</span><br><span class="line">  4     int ret;</span><br><span class="line">  5 ...</span><br><span class="line">  6     ret &#x3D; ft5x0x_i2c_rxdata(buf, 7);</span><br><span class="line">  7 ...</span><br><span class="line">  8     memset(event, 0, sizeof(struct ft5x0x_event));</span><br><span class="line">  9     event-&gt;touch_point &#x3D; buf[2] &amp; 0x0F;</span><br><span class="line"> 10 </span><br><span class="line"> 11     if (!event-&gt;touch_point) &#123;</span><br><span class="line"> 12         ft5x0x_ts_release(ts);</span><br><span class="line"> 13         return 1;</span><br><span class="line"> 14     &#125;</span><br><span class="line"> 15     &#x2F;* 判断有几个点按下，也就是支持多指触控 *&#x2F;</span><br><span class="line"> 16 #ifdef CONFIG_FT5X0X_MULTITOUCH</span><br><span class="line"> 17     switch (event-&gt;touch_point) &#123;</span><br><span class="line"> 18         case 10:</span><br><span class="line"> 19             event-&gt;x[9] &#x3D; (s16)(buf[57] &amp; 0x0F)&lt;&lt;8 | (s16)buf[58];</span><br><span class="line"> 20             event-&gt;y[9] &#x3D; (s16)(buf[59] &amp; 0x0F)&lt;&lt;8 | (s16)buf[60];</span><br><span class="line"> 21         case 9:</span><br><span class="line"> 22             event-&gt;x[8] &#x3D; (s16)(buf[51] &amp; 0x0F)&lt;&lt;8 | (s16)buf[52];</span><br><span class="line"> 23             event-&gt;y[8] &#x3D; (s16)(buf[53] &amp; 0x0F)&lt;&lt;8 | (s16)buf[54];</span><br><span class="line"> 24         case 8:</span><br><span class="line"> 25             event-&gt;x[7] &#x3D; (s16)(buf[45] &amp; 0x0F)&lt;&lt;8 | (s16)buf[46];</span><br><span class="line"> 26             event-&gt;y[7] &#x3D; (s16)(buf[47] &amp; 0x0F)&lt;&lt;8 | (s16)buf[48];</span><br><span class="line"> 27         case 7:</span><br><span class="line"> 28             event-&gt;x[6] &#x3D; (s16)(buf[39] &amp; 0x0F)&lt;&lt;8 | (s16)buf[40];</span><br><span class="line"> 29             event-&gt;y[6] &#x3D; (s16)(buf[41] &amp; 0x0F)&lt;&lt;8 | (s16)buf[42];</span><br><span class="line"> 30         case 6:</span><br><span class="line"> 31             event-&gt;x[5] &#x3D; (s16)(buf[33] &amp; 0x0F)&lt;&lt;8 | (s16)buf[34];</span><br><span class="line"> 32             event-&gt;y[5] &#x3D; (s16)(buf[35] &amp; 0x0F)&lt;&lt;8 | (s16)buf[36];</span><br><span class="line"> 33         case 5:</span><br><span class="line"> 34             event-&gt;x[4] &#x3D; (s16)(buf[0x1b] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x1c];</span><br><span class="line"> 35             event-&gt;y[4] &#x3D; (s16)(buf[0x1d] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x1e];</span><br><span class="line"> 36         case 4:</span><br><span class="line"> 37             event-&gt;x[3] &#x3D; (s16)(buf[0x15] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x16];</span><br><span class="line"> 38             event-&gt;y[3] &#x3D; (s16)(buf[0x17] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x18];</span><br><span class="line"> 39             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[3], event-&gt;y[3]);</span><br><span class="line"> 40         case 3:</span><br><span class="line"> 41             event-&gt;x[2] &#x3D; (s16)(buf[0x0f] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x10];</span><br><span class="line"> 42             event-&gt;y[2] &#x3D; (s16)(buf[0x11] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x12];</span><br><span class="line"> 43             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[2], event-&gt;y[2]);</span><br><span class="line"> 44         case 2:</span><br><span class="line"> 45             event-&gt;x[1] &#x3D; (s16)(buf[0x09] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x0a];</span><br><span class="line"> 46             event-&gt;y[1] &#x3D; (s16)(buf[0x0b] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x0c];</span><br><span class="line"> 47             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[1], event-&gt;y[1]);</span><br><span class="line"> 48         case 1:</span><br><span class="line"> 49             event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line"> 50             event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line"> 51             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[0], event-&gt;y[0]);</span><br><span class="line"> 52             break;</span><br><span class="line"> 53         default:</span><br><span class="line"> 54             printk(&quot;%s: invalid touch data, %d\n&quot;, __func__, event-&gt;touch_point);</span><br><span class="line"> 55             return -1;</span><br><span class="line"> 56     &#125;</span><br><span class="line"> 57 #else</span><br><span class="line"> 58     if (event-&gt;touch_point &#x3D;&#x3D; 1) &#123;</span><br><span class="line"> 59         event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line"> 60         event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line"> 61     &#125;</span><br><span class="line"> 62 #endif</span><br><span class="line"> 63 </span><br><span class="line"> 64     event-&gt;pressure &#x3D; 200;</span><br><span class="line"> 65 </span><br><span class="line"> 66     return 0;</span><br><span class="line"> 67 &#125;</span><br><span class="line"> 68 </span><br><span class="line"> 69 static void ft5x0x_ts_report(struct ft5x0x_ts_data *ts) &#123;</span><br><span class="line"> 70     struct ft5x0x_event *event &#x3D; &amp;ts-&gt;event;</span><br><span class="line"> 71     int x, y;</span><br><span class="line"> 72     int i &#x3D; 0;</span><br><span class="line"> 73     &#x2F;* 上报事件 *&#x2F;</span><br><span class="line"> 74     if (event-&gt;touch_point &#x3D;&#x3D; 1) &#123;</span><br><span class="line"> 75         if (swap_xy) &#123;</span><br><span class="line"> 76             x &#x3D; event-&gt;y[i];</span><br><span class="line"> 77             y &#x3D; event-&gt;x[i];</span><br><span class="line"> 78         &#125; else &#123;</span><br><span class="line"> 79             x &#x3D; event-&gt;x[i];</span><br><span class="line"> 80             y &#x3D; event-&gt;y[i];</span><br><span class="line"> 81         &#125;</span><br><span class="line"> 82 </span><br><span class="line"> 83         if (scal_xy) &#123;</span><br><span class="line"> 84             x &#x3D; (x * ts-&gt;screen_max_x) &#x2F; TOUCH_MAX_X;</span><br><span class="line"> 85             y &#x3D; (y * ts-&gt;screen_max_y) &#x2F; TOUCH_MAX_Y;</span><br><span class="line"> 86         &#125;</span><br><span class="line"> 87 </span><br><span class="line"> 88         input_report_abs(ts-&gt;input_dev, ABS_X, x);</span><br><span class="line"> 89         input_report_abs(ts-&gt;input_dev, ABS_Y, y);</span><br><span class="line"> 90         input_report_abs(ts-&gt;input_dev, ABS_PRESSURE, event-&gt;pressure);</span><br><span class="line"> 91     &#125;</span><br><span class="line"> 92 </span><br><span class="line"> 93     input_report_key(ts-&gt;input_dev, BTN_TOUCH, 1);</span><br><span class="line"> 94 </span><br><span class="line"> 95     input_sync(ts-&gt;input_dev);</span><br><span class="line"> 96 &#125;</span><br><span class="line"> 97 </span><br><span class="line"> 98 static void ft5x0x_ts_pen_irq_work(struct work_struct *work) &#123;</span><br><span class="line"> 99     struct ft5x0x_ts_data *ts &#x3D; container_of(work, struct ft5x0x_ts_data, work);</span><br><span class="line">100 </span><br><span class="line">101     if (!ft5x0x_read_data(ts)) &#123;</span><br><span class="line">102         ft5x0x_ts_report(ts);</span><br><span class="line">103     &#125;</span><br><span class="line">104 </span><br><span class="line">105     enable_irq(this_client-&gt;irq);</span><br><span class="line">106 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面我们来总结一下整体过程：</p>
<p>\1. 设置GPIO引脚</p>
<p>\2. 注册i2c设备驱动</p>
<p>\3. 分配、设置和注册struct input_dev</p>
<p>\4. 设置、注册触摸屏中断，注册触摸屏中断函数底半部函数</p>
<p>\5. 中断函数中调用工作队列</p>
<p>\6. 工作队列中读取数据后上报数据</p>
<p>下一章我们根据分析的文件来自己实现触摸屏驱动。</p>
<h1 id="三、自己实现触摸屏驱动"><a href="#三、自己实现触摸屏驱动" class="headerlink" title="三、自己实现触摸屏驱动"></a>三、自己实现触摸屏驱动</h1><p>触摸屏驱动源代码：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">  1 #include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">  2 #include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">  3 #include &lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">  4 #include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">  5 #include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">  6 #include &lt;linux&#x2F;input.h&gt;</span><br><span class="line">  7 #include &lt;linux&#x2F;delay.h&gt;</span><br><span class="line">  8 #include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">  9 #include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line"> 10 #include &lt;linux&#x2F;workqueue.h&gt;</span><br><span class="line"> 11 #include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line"> 12 #include &lt;linux&#x2F;mod_devicetable.h&gt;</span><br><span class="line"> 13 #include &lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line"> 14 #include &lt;linux&#x2F;regulator&#x2F;consumer.h&gt;</span><br><span class="line"> 15 </span><br><span class="line"> 16 #include &lt;asm&#x2F;io.h&gt;</span><br><span class="line"> 17 #include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"> 18 </span><br><span class="line"> 19 #include &lt;mach&#x2F;gpio.h&gt;</span><br><span class="line"> 20 #include &lt;mach&#x2F;regs-gpio.h&gt;</span><br><span class="line"> 21 </span><br><span class="line"> 22 #include &lt;plat&#x2F;gpio-cfg.h&gt;</span><br><span class="line"> 23 </span><br><span class="line"> 24 static struct work_struct wq;</span><br><span class="line"> 25 </span><br><span class="line"> 26 struct ft5x0x_event &#123;</span><br><span class="line"> 27     int touch_point;</span><br><span class="line"> 28     u16 x[2];</span><br><span class="line"> 29     u16 y[2];</span><br><span class="line"> 30     u16 pressure;</span><br><span class="line"> 31 &#125;;</span><br><span class="line"> 32 </span><br><span class="line"> 33 int TOUCH_MAX_X &#x3D; 1024;</span><br><span class="line"> 34 int TOUCH_MAX_Y &#x3D; 768;</span><br><span class="line"> 35 </span><br><span class="line"> 36 static struct input_dev *ftinput;</span><br><span class="line"> 37 </span><br><span class="line"> 38 static struct i2c_client *ft5x0x_client;</span><br><span class="line"> 39 </span><br><span class="line"> 40 static int swap_xy;</span><br><span class="line"> 41 static int touch_size;</span><br><span class="line"> 42 </span><br><span class="line"> 43 static void ft5x0x_release(void)</span><br><span class="line"> 44 &#123;</span><br><span class="line"> 45     input_report_abs(ftinput, ABS_PRESSURE, 0);</span><br><span class="line"> 46     input_report_key(ftinput, BTN_TOUCH, 0);</span><br><span class="line"> 47     input_sync(ftinput);</span><br><span class="line"> 48 &#125;</span><br><span class="line"> 49 </span><br><span class="line"> 50 static void ft5x0x_report(struct ft5x0x_event *event)</span><br><span class="line"> 51 &#123;</span><br><span class="line"> 52     int x, y;</span><br><span class="line"> 53     int i &#x3D; 0;</span><br><span class="line"> 54 </span><br><span class="line"> 55     if (swap_xy) &#123;</span><br><span class="line"> 56         x &#x3D; event-&gt;y[i];</span><br><span class="line"> 57         y &#x3D; event-&gt;x[i];</span><br><span class="line"> 58     &#125;</span><br><span class="line"> 59     else &#123;</span><br><span class="line"> 60         x &#x3D; event-&gt;x[i];</span><br><span class="line"> 61         y &#x3D; event-&gt;y[i];</span><br><span class="line"> 62     &#125;</span><br><span class="line"> 63 </span><br><span class="line"> 64     input_report_abs(ftinput, ABS_X, x);</span><br><span class="line"> 65     input_report_abs(ftinput, ABS_Y, y);</span><br><span class="line"> 66     input_report_abs(ftinput, ABS_PRESSURE, event-&gt;pressure);</span><br><span class="line"> 67 </span><br><span class="line"> 68     input_report_key(ftinput, BTN_TOUCH, 1);</span><br><span class="line"> 69 </span><br><span class="line"> 70     input_sync(ftinput);</span><br><span class="line"> 71 &#125;</span><br><span class="line"> 72 </span><br><span class="line"> 73 </span><br><span class="line"> 74 static int master_rx(char *rxdata, int length) &#123;</span><br><span class="line"> 75     int ret;</span><br><span class="line"> 76     struct i2c_msg msgs[] &#x3D; &#123;</span><br><span class="line"> 77         &#123;</span><br><span class="line"> 78             .addr    &#x3D; ft5x0x_client-&gt;addr,</span><br><span class="line"> 79             .flags    &#x3D; 0,</span><br><span class="line"> 80             .len    &#x3D; 1,</span><br><span class="line"> 81             .buf    &#x3D; rxdata,</span><br><span class="line"> 82         &#125;,</span><br><span class="line"> 83         &#123;</span><br><span class="line"> 84             .addr    &#x3D; ft5x0x_client-&gt;addr,</span><br><span class="line"> 85             .flags    &#x3D; I2C_M_RD,</span><br><span class="line"> 86             .len    &#x3D; length,</span><br><span class="line"> 87             .buf    &#x3D; rxdata,</span><br><span class="line"> 88         &#125;,</span><br><span class="line"> 89     &#125;;</span><br><span class="line"> 90 </span><br><span class="line"> 91     ret &#x3D; i2c_transfer(ft5x0x_client-&gt;adapter, msgs, 2);</span><br><span class="line"> 92     if (ret &lt; 0)</span><br><span class="line"> 93         printk(KERN_ERR &quot;i2c_transfer error\n&quot;);</span><br><span class="line"> 94 </span><br><span class="line"> 95     return ret;</span><br><span class="line"> 96 &#125;</span><br><span class="line"> 97 </span><br><span class="line"> 98 static int ft5x0x_read_data(struct ft5x0x_event *event)</span><br><span class="line"> 99 &#123;</span><br><span class="line">100     int ret;</span><br><span class="line">101     u8 buf[64] &#x3D; &#123; 0 &#125;;</span><br><span class="line">102 </span><br><span class="line">103     ret &#x3D; master_rx(buf, 7);</span><br><span class="line">104 </span><br><span class="line">105     memset(event, 0, sizeof(struct ft5x0x_event));</span><br><span class="line">106 </span><br><span class="line">107     event-&gt;touch_point &#x3D; buf[2] &amp; 0x0F;</span><br><span class="line">108     if (!event-&gt;touch_point) &#123;</span><br><span class="line">109         ft5x0x_release();</span><br><span class="line">110         return 1;</span><br><span class="line">111     &#125;</span><br><span class="line">112 </span><br><span class="line">113     event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line">114     event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line">115 </span><br><span class="line">116     event-&gt;pressure &#x3D; 200;</span><br><span class="line">117 </span><br><span class="line">118     return 0;</span><br><span class="line">119 &#125;</span><br><span class="line">120 </span><br><span class="line">121 static void i2c_wq_irq(unsigned long arg)</span><br><span class="line">122 &#123;</span><br><span class="line">123     struct ft5x0x_event event;</span><br><span class="line">124     </span><br><span class="line">125     if (!ft5x0x_read_data(&amp;event)) &#123;</span><br><span class="line">126         ft5x0x_report(&amp;event);</span><br><span class="line">127     &#125;</span><br><span class="line">128     </span><br><span class="line">129     printk(&quot;(%d, %d)\n&quot;, event.x[0], event.y[0]);</span><br><span class="line">130 &#125;</span><br><span class="line">131 </span><br><span class="line">132 static irqreturn_t ft5x0x_irq(int irq, void *arg)</span><br><span class="line">133 &#123;</span><br><span class="line">134     schedule_work(&amp;wq);</span><br><span class="line">135     return IRQ_HANDLED;</span><br><span class="line">136 &#125;</span><br><span class="line">137 </span><br><span class="line">138 static int read_device_info(u8 addr, u8 *val) </span><br><span class="line">139 &#123;</span><br><span class="line">140     int ret;</span><br><span class="line">141     u8 buf &#x3D; &#123; 0 &#125;;</span><br><span class="line">142     struct i2c_msg msgs[2];</span><br><span class="line">143 </span><br><span class="line">144     msgs[0].addr  &#x3D; ft5x0x_client-&gt;addr;</span><br><span class="line">145     msgs[0].buf      &#x3D; &amp;buf;</span><br><span class="line">146     msgs[0].flags &#x3D; 0;</span><br><span class="line">147     msgs[0].len   &#x3D; 1;</span><br><span class="line">148 </span><br><span class="line">149     msgs[1].addr  &#x3D; ft5x0x_client-&gt;addr;</span><br><span class="line">150     msgs[1].buf      &#x3D; &amp;buf;</span><br><span class="line">151     msgs[1].flags &#x3D; 1;</span><br><span class="line">152     msgs[1].len   &#x3D; 1;</span><br><span class="line">153 </span><br><span class="line">154     buf &#x3D; addr;</span><br><span class="line">155     ret &#x3D; i2c_transfer(ft5x0x_client-&gt;adapter, msgs, 2);</span><br><span class="line">156     if (ret &lt; 0)</span><br><span class="line">157         printk(KERN_ERR &quot;i2c_transfer addr 0x%02x error!&quot;, buf);</span><br><span class="line">158     else</span><br><span class="line">159         *val &#x3D; buf;</span><br><span class="line">160 </span><br><span class="line">161     return ret;</span><br><span class="line">162 &#125;</span><br><span class="line">163 </span><br><span class="line">164 static int device_info(unsigned char *val)</span><br><span class="line">165 &#123;</span><br><span class="line">166     int ret;</span><br><span class="line">167 </span><br><span class="line">168     ret &#x3D; read_device_info(0xA6, val);</span><br><span class="line">169 </span><br><span class="line">170     printk(&quot;device_info: %d\n&quot;,*val);</span><br><span class="line">171 </span><br><span class="line">172     return ret;</span><br><span class="line">173 &#125;</span><br><span class="line">174 </span><br><span class="line">175 static int ft5x0x_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">176 &#123;</span><br><span class="line">177     int ret;</span><br><span class="line">178     ft5x0x_client &#x3D; client;</span><br><span class="line">179     unsigned char val &#x3D; 0;</span><br><span class="line">180 </span><br><span class="line">181     &#x2F;* 设置中断引脚 *&#x2F;</span><br><span class="line">182     client-&gt;irq &#x3D; gpio_to_irq(EXYNOS4_GPX0(4));</span><br><span class="line">183     s3c_gpio_cfgpin(client-&gt;irq, S3C_GPIO_SFN(0xf));</span><br><span class="line">184     s3c_gpio_setpull(client-&gt;irq, S3C_GPIO_PULL_NONE);</span><br><span class="line">185 </span><br><span class="line">186     &#x2F;* 分配设置input_device *&#x2F;</span><br><span class="line">187     ftinput &#x3D; input_allocate_device();</span><br><span class="line">188 </span><br><span class="line">189     set_bit(EV_ABS, ftinput-&gt;evbit);</span><br><span class="line">190     set_bit(EV_KEY, ftinput-&gt;evbit);</span><br><span class="line">191     set_bit(EV_SYN, ftinput-&gt;evbit);</span><br><span class="line">192     </span><br><span class="line">193     set_bit(ABS_X, ftinput-&gt;absbit);</span><br><span class="line">194     set_bit(ABS_Y, ftinput-&gt;absbit);</span><br><span class="line">195     set_bit(ABS_PRESSURE, ftinput-&gt;absbit);</span><br><span class="line">196     set_bit(BTN_TOUCH, ftinput-&gt;keybit);</span><br><span class="line">197 </span><br><span class="line">198     input_set_abs_params(ftinput, ABS_X, 0, 768, 0, 0);</span><br><span class="line">199     input_set_abs_params(ftinput, ABS_Y, 0, 1024, 0, 0);</span><br><span class="line">200     input_set_abs_params(ftinput, ABS_PRESSURE, 0, 255, 0 , 0);</span><br><span class="line">201 </span><br><span class="line">202     ftinput-&gt;name &#x3D; &quot;ft5x0x&quot;;</span><br><span class="line">203     ftinput-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">204 </span><br><span class="line">205     ret &#x3D; input_register_device(ftinput);</span><br><span class="line">206     if (ret) &#123;</span><br><span class="line">207         printk(KERN_ERR &quot;input_register_device error\n&quot;);</span><br><span class="line">208         input_free_device(ftinput);</span><br><span class="line">209     &#125;</span><br><span class="line">210 </span><br><span class="line">211     ret &#x3D; request_irq(client-&gt;irq, ft5x0x_irq, IRQ_TYPE_EDGE_FALLING, &quot;ft5x0x&quot;, NULL);</span><br><span class="line">212     if (ret &lt; 0) &#123;</span><br><span class="line">213         printk(KERN_ERR &quot;request_irq %d error\n&quot;, client-&gt;irq);</span><br><span class="line">214         goto exit_irq_request_failed;</span><br><span class="line">215     &#125;</span><br><span class="line">216 </span><br><span class="line">217     &#x2F;* 注册中断底半部 *&#x2F;</span><br><span class="line">218     INIT_WORK(&amp;wq, i2c_wq_irq);</span><br><span class="line">219     </span><br><span class="line">220     device_info(&amp;val);</span><br><span class="line">221     </span><br><span class="line">222     return 0;</span><br><span class="line">223 </span><br><span class="line">224 exit_irq_request_failed:</span><br><span class="line">225     input_unregister_device(ftinput);</span><br><span class="line">226 </span><br><span class="line">227     return ret;</span><br><span class="line">228 &#125;</span><br><span class="line">229 </span><br><span class="line">230 static int ft5x0x_remove(struct i2c_client *client)</span><br><span class="line">231 &#123;</span><br><span class="line">232     &#x2F;* 镜像注销 *&#x2F;</span><br><span class="line">233     input_unregister_device(ftinput);</span><br><span class="line">234     cancel_work_sync(&amp;wq);</span><br><span class="line">235     client-&gt;irq &#x3D; gpio_to_irq(EXYNOS4_GPX0(4));</span><br><span class="line">236     free_irq(client-&gt;irq, NULL);</span><br><span class="line">237     </span><br><span class="line">238     return 0;</span><br><span class="line">239 &#125;</span><br><span class="line">240 </span><br><span class="line">241 static const struct i2c_device_id ft5x0x_table[] &#x3D; &#123;</span><br><span class="line">242     &#123; &quot;ft5x0x&quot;, 0 &#125;,</span><br><span class="line">243     &#123; &#125;,</span><br><span class="line">244 &#125;;</span><br><span class="line">245 </span><br><span class="line">246 static struct i2c_driver ft5x0x_driver &#x3D; &#123;</span><br><span class="line">247     .driver &#x3D; &#123;</span><br><span class="line">248         .name    &#x3D; &quot;ft5x0x&quot;,</span><br><span class="line">249         .owner    &#x3D; THIS_MODULE,</span><br><span class="line">250     &#125;,</span><br><span class="line">251     .probe        &#x3D; ft5x0x_probe,</span><br><span class="line">252     .remove        &#x3D; __devexit_p(ft5x0x_remove),</span><br><span class="line">253     .id_table    &#x3D; ft5x0x_table,</span><br><span class="line">254 &#125;;</span><br><span class="line">255 </span><br><span class="line">256 static int ft5x0x_init(void)</span><br><span class="line">257 &#123;</span><br><span class="line">258     int ret;</span><br><span class="line">259     ret &#x3D; gpio_request(EXYNOS4_GPL0(2), &quot;TP1_EN&quot;);</span><br><span class="line">260     if (ret)</span><br><span class="line">261         printk(KERN_ERR &quot;failed to request TP1_EN for I2C control\n&quot;);</span><br><span class="line">262     </span><br><span class="line">263     gpio_direction_output(EXYNOS4_GPL0(2), 1);</span><br><span class="line">264 </span><br><span class="line">265     s3c_gpio_cfgpin(EXYNOS4_GPL0(2), S3C_GPIO_OUTPUT);</span><br><span class="line">266     gpio_free(EXYNOS4_GPL0(2));</span><br><span class="line">267 </span><br><span class="line">268     mdelay(5);</span><br><span class="line">269     </span><br><span class="line">270     ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">271     if (ret) &#123;</span><br><span class="line">272         gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">273         ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">274         if (ret) &#123;</span><br><span class="line">275             printk(KERN_ERR &quot;failed to request GPX0_3 \n&quot;);</span><br><span class="line">276         &#125;</span><br><span class="line">277     &#125;</span><br><span class="line">278     gpio_direction_output(EXYNOS4_GPX0(3), 0);</span><br><span class="line">279     mdelay(200);</span><br><span class="line">280 </span><br><span class="line">281     gpio_direction_output(EXYNOS4_GPX0(3), 1);</span><br><span class="line">282 </span><br><span class="line">283     s3c_gpio_cfgpin(EXYNOS4_GPX0(3), S3C_GPIO_OUTPUT);</span><br><span class="line">284     gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">285     msleep(300);</span><br><span class="line">286 </span><br><span class="line">287     touch_size &#x3D; 1;</span><br><span class="line">288     swap_xy &#x3D; 1;</span><br><span class="line">289     </span><br><span class="line">290     return i2c_add_driver(&amp;ft5x0x_driver);</span><br><span class="line">291 &#125;</span><br><span class="line">292 </span><br><span class="line">293 static void ft5x0x_exit(void)</span><br><span class="line">294 &#123;</span><br><span class="line">295     i2c_del_driver(&amp;ft5x0x_driver);</span><br><span class="line">296 &#125;</span><br><span class="line">297 </span><br><span class="line">298 module_init(ft5x0x_init);</span><br><span class="line">299 module_exit(ft5x0x_exit);</span><br><span class="line">300 </span><br><span class="line">301 MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Makefile：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 KERN_DIR &#x3D; &#x2F;work&#x2F;itop4412&#x2F;tools&#x2F;linux-3.5</span><br><span class="line"> 2 </span><br><span class="line"> 3 all:</span><br><span class="line"> 4     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules </span><br><span class="line"> 5 </span><br><span class="line"> 6 clean:</span><br><span class="line"> 7     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules clean</span><br><span class="line"> 8     rm -rf modules.order</span><br><span class="line"> 9 </span><br><span class="line">10 obj-m    +&#x3D; ts.o</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由于触摸屏驱动已经被编译到了内核，我们要先取消它：</p>
<p>$ make menuconfig</p>
<p>Device Drivers —&gt;</p>
<p>Input device support —&gt;</p>
<p>Touchscreens —&gt;</p>
<p>去掉FT5X0X based touchscreens</p>
<p>我并没有编写i2c_client层，而是在mach-itop4412.c中进行更改：</p>
<p>在第2078行代码的基础上，加入#else内容：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_TOUCHSCREEN_FT5X0X)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;ft5x0x_ts&quot;, 0x70&gt;&gt;1),</span><br><span class="line">        .irq &#x3D; IRQ_EINT(4),</span><br><span class="line">        .platform_data &#x3D; &amp;ft5x0x_pdata,</span><br><span class="line">    &#125;,</span><br><span class="line">&#x2F;* 加入的代码 *&#x2F;</span><br><span class="line">#else</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;ft5x0x&quot;, 0x70 &gt;&gt; 1),</span><br><span class="line">    &#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在重新编译烧写内核后，insmod自己的触摸屏驱动，点击屏幕可发现如下现象：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190618112327792-1691058261.png" alt="img"></p>
<p>下一章  <a href="https://www.cnblogs.com/Lioker/p/10933171.html" target="_blank" rel="noopener">16、USB驱动</a></p>
<p>作者：<a href="https://www.cnblogs.com/Lioker/" target="_blank" rel="noopener">Lioker</a></p>
<p>邮箱：<a href="mailto:lioker@outlook.com">lioker@outlook.com</a></p>
<p>作者水平有限，欢迎拍砖。转载请注明出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">【转载】输入子系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:22:14 / Modified: 19:25:59" itemprop="dateCreated datePublished" datetime="2021-01-07T19:22:14+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：博客园–<a href="https://home.cnblogs.com/u/Lioker/" target="_blank" rel="noopener">Lioker</a>【<a href="https://www.cnblogs.com/Lioker/p/10871151.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/10871151.html】</a></p>
<p>前面几章我们写的按键驱动程序虽然已经足够完善，但是这个驱动只有知道/dev/key设备节点和write()格式的人才能使用，不具有适应性</p>
<p>故本节引入标准的输入子系统，来编写通用的输入类设备。输入子系统是对所有的标准输入类设备的统一的管理系统，使用这个模型可以跨平台的处理所有的输入类设备</p>
<h1 id="一、输入子系统分层"><a href="#一、输入子系统分层" class="headerlink" title="一、输入子系统分层"></a>一、输入子系统分层</h1><p>输入子系统将一个输入设备的输入过程分成了<strong>设备</strong>驱动（input device driver）和<strong>事件</strong>驱动（input event driver）两层。设备驱动负责从底层硬件采集数据，事件驱动负责给用户程序提供接口。通过分层设计，将不同的设备统一到几种驱动接口上。同一种事件驱动可以用来处理多个同类设备；同一个设备也可以和多种事件驱动相衔接。而事件驱动和设备驱动则由输入核心层进行连接，匹配。分层结构如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515135645745-1155511406.png" alt="img"></p>
<p>输入子系统核心层定义在drivers/input/input.c中</p>
<p>由于输入子系统也是字符设备驱动程序，因此它一定也会有创建类、注册字符设备的过程，而且会有file_operations等结构体，我们可以从此进行分析</p>
<h1 id="二、input-c分析"><a href="#二、input-c分析" class="headerlink" title="二、input.c分析"></a>二、input.c分析</h1><p>在input_init()函数中所做的和按键驱动程序中所做的大致相同，如创建类、注册名为input的字符设备</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    err &#x3D; class_register(&amp;input_class);</span><br><span class="line">    ...</span><br><span class="line">    err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其file_operations结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations input_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open &#x3D; input_open_file,</span><br><span class="line">    .llseek &#x3D; noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>当我们应用程序open()时，会调用file_operations input_fops对应的open()函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">    handler &#x3D; input_table[iminor(inode) &gt;&gt; 5];</span><br><span class="line">    if (handler)</span><br><span class="line">        new_fops &#x3D; fops_get(handler-&gt;fops);</span><br><span class="line">        ...</span><br><span class="line">    old_fops &#x3D; file-&gt;f_op;</span><br><span class="line">    file-&gt;f_op &#x3D; new_fops;</span><br><span class="line"></span><br><span class="line">    err &#x3D; new_fops-&gt;open(inode, file);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由上述代码可知：</p>
<p>\1. input_table[]根据次设备号存储handler</p>
<p>\2. <strong>open()函数使用新的fops（设备驱动中的fops）代替了旧的fops，这个操作也就解释了为什么file_operations结构体中没有读写函数</strong></p>
<p>\3. open()函数在替换之后，调用了新的fops的open()函数</p>
<p>handler是我们之前没有分析的，它定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct input_handler *input_table[8];</span><br></pre></td></tr></table></figure>

<p>至于数组大小为什么是8，这是因为目前常用的handler只有三种：<strong>evdev</strong>，mousedev，joydev。而且evdev是通用的handler，定义8个应该够用了</p>
<p>handler结构体定义为：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handler - implements one of interfaces for input devices</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line">    void *private;</span><br><span class="line"></span><br><span class="line">    void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">    bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">    bool (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">    void (*disconnect)(struct input_handle *handle);</span><br><span class="line">    void (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    const struct file_operations *fops;</span><br><span class="line">    int minor;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    const struct input_device_id *id_table;</span><br><span class="line"></span><br><span class="line">    struct list_head    h_list;</span><br><span class="line">    struct list_head    node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>根据注释信息，handler应该就是输入事件驱动程序的结构体</p>
<p>在input_handler结构体中使用了input_handle结构体，其定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handle - links input device with an input handler</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line">    void *private;</span><br><span class="line"></span><br><span class="line">    int open;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    struct input_dev *dev;</span><br><span class="line">    struct input_handler *handler;</span><br><span class="line"></span><br><span class="line">    struct list_head    d_node;</span><br><span class="line">    struct list_head    h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>根据注释信息，<strong>input_handle用于连接input_dev和input_handler</strong>，三者关系在下面分析</p>
<p>分析完了input.c文件，我们来一一分析input_handler、input_handle以及两者的连接过程</p>
<h1 id="三、input-dev"><a href="#三、input-dev" class="headerlink" title="三、input_dev"></a>三、input_dev</h1><p>input_dev使用方法遵循：分配、设置、注册</p>
<p><strong>分配：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void)</span><br></pre></td></tr></table></figure>



<p><strong>设置（首先设置事件类，然后设置具体事件）：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)</span><br><span class="line">&#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">    case EV_KEY:    &#x2F;&#x2F; 按键事件类，可指定按键如KEY_1、KEY_Q、KEY_ENTER等</span><br><span class="line">        __set_bit(code, dev-&gt;keybit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case EV_REL:    &#x2F;&#x2F; 相对位移事件类，可指定相对位移如REL_X、REL_Y等</span><br><span class="line">        __set_bit(code, dev-&gt;relbit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case EV_ABS:    &#x2F;&#x2F; 绝对位移事件类，可指定绝对位移如ABS_X、ABS_Y等</span><br><span class="line">        __set_bit(code, dev-&gt;absbit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __set_bit(type, dev-&gt;evbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>也可以使用set_bit()函数，两函数代码类似（实际只是去设置某一个bit），在此仅给出__set_bit()函数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 static inline void __set_bit(int nr, volatile unsigned long *addr) &#123;</span><br><span class="line">2     unsigned long mask &#x3D; BIT_MASK(nr);</span><br><span class="line">3     unsigned long *p &#x3D; ((unsigned long *)addr) + BIT_WORD(nr);</span><br><span class="line">4 </span><br><span class="line">5     *p  |&#x3D; mask;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p>源代码中使用set_bit()</p>
<p><strong>注册：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 通用的同步事件 *&#x2F;</span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    &#x2F;* 注册的设备名字为input0, 1, 2, ... *&#x2F;</span><br><span class="line">    dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,</span><br><span class="line">             (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 添加device *&#x2F;</span><br><span class="line">    error &#x3D; device_add(&amp;dev-&gt;dev);</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 把dev结构放到链表里面 *&#x2F;</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 对每一个input_handler都调用input_attach_handler()函数 *&#x2F;</span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        &#x2F;* 匹配dev和handler *&#x2F;</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中的input_attach_handler(dev, handler);对应input_handle，因为之前说过<strong>input_handle用于连接input_dev和input_handler</strong></p>
<p>在注册完成后，若<strong>input_dev获得数据，需要向核心层上报事件</strong>，上报事件使用如下函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 上报事件</span><br><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报绝对坐标</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报相对坐标</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报键值</span><br><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报同步事件</span><br><span class="line">void input_sync(struct input_dev *dev)</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>代码中后四个函数均使用input_event()函数实现，input_event()函数调用过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_event()</span><br><span class="line">  -&gt; input_handle_event()</span><br><span class="line">    -&gt; input_pass_event()</span><br><span class="line">      -&gt; handler-&gt;event(handle, type, code, value);</span><br></pre></td></tr></table></figure>



<p><strong>上报事件最终会调用handler-&gt;event()函数</strong></p>
<p>之前说过evdev是通用的handler，在此我便以/drivers/input/evdev.c进行分析</p>
<p>evdev_read()会进行休眠，<strong>evdev_event()在上报事件被调用后会唤醒休眠进程</strong>，从而完成read()操作</p>
<p><strong>注销：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注销</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br></pre></td></tr></table></figure>





<h1 id="四、input-handler"><a href="#四、input-handler" class="headerlink" title="四、input_handler"></a>四、input_handler</h1><p><strong>注册：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int input_register_handler(struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 设置input_table *&#x2F;</span><br><span class="line">    if (handler-&gt;fops !&#x3D; NULL) &#123;</span><br><span class="line">        if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;</span><br><span class="line">            retval &#x3D; -EBUSY;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 把handler放入input_handler_list *&#x2F;</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 对每一个dev调用input_attach_handler匹配handler *&#x2F;</span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>注销：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void input_unregister_handler(struct input_handler *handler)</span><br></pre></td></tr></table></figure>





<h1 id="五、input-dev和input-handler的连接过程"><a href="#五、input-dev和input-handler的连接过程" class="headerlink" title="五、input_dev和input_handler的连接过程"></a>五、input_dev和input_handler的连接过程</h1><p>两者匹配使用的是input_attach_handler()函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    id &#x3D; input_match_device(handler, dev);</span><br><span class="line">...</span><br><span class="line">    error &#x3D; handler-&gt;connect(handler, dev, id);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_match_device()函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static const struct input_device_id *input_match_device(struct input_handler *handler,</span><br><span class="line">                            struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">    for (id &#x3D; handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 默认的匹配过程，使用handler-&gt;id_table和dev-&gt;id进行匹配</span><br><span class="line"></span><br><span class="line">        if (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在代码中，匹配成功退出调用handler的connect()函数，否则调用handler的match()函数</p>
<p>在此还是以evdev为例，其连接函数为evdev_connect()定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line">             const struct input_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 分配evdev *&#x2F;</span><br><span class="line">    evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 设置handle *&#x2F;</span><br><span class="line">    evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">    evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 注册handle *&#x2F;</span><br><span class="line">    error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line"></span><br><span class="line">    error &#x3D; evdev_install_chrdev(evdev);</span><br><span class="line">    error &#x3D; device_add(&amp;evdev-&gt;dev);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_dev、input_handler和input_handle三者关系如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515161307876-106298749.png" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p><strong>1. input_init()初始化输入子系统</strong></p>
<p>1.1 调用register_chrdev(13, “input”, &amp;input_fops);</p>
<p><strong>2. open()输入子系统文件：int input_open_file()</strong></p>
<p>2.1 替换替换file_oprations</p>
<p>2.2 执行new_fops-&gt;open()函数</p>
<p><strong>3. 注册input_handler：input_register_handler()</strong></p>
<p>3.1 添加handler到input_table[]数组</p>
<p>3.2 添加handler到input_handler_list链表</p>
<p>3.3 调用input_attach_handler()</p>
<p><strong>4. 注册input_dev：input_register_device()</strong></p>
<p>4.1 添加dev到input_dev链表</p>
<p>4.2 调用input_attach_handler()</p>
<p><strong>5. 匹配：input_attach_handler()</strong></p>
<p>5.1 匹配dev-&gt;id和handler-&gt;id_table</p>
<p>5.2 成功，调用input_handler-&gt;connect()</p>
<p><strong>6. 连接：input_handler-&gt;connect()</strong></p>
<p>6.1 创建input_handle，三者连接</p>
<p><strong>7. event发生（如按键中断），在中断函数中上报事件：input_event()</strong></p>
<p>7.1 调用input_handler-&gt;event()</p>
<h1 id="七、更改key-c为输入子系统"><a href="#七、更改key-c为输入子系统" class="headerlink" title="七、更改key.c为输入子系统"></a>七、更改key.c为输入子系统</h1><p>主要更改的函数有keys_init()和key_timer_func()：</p>
<p><strong>keys_init()：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int keys_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     &#x2F;* 1. 分配 *&#x2F;</span><br><span class="line"> 4     inputdev &#x3D; input_allocate_device();</span><br><span class="line"> 5 </span><br><span class="line"> 6     &#x2F;* 2. 设置 *&#x2F;</span><br><span class="line"> 7     &#x2F;* 2.1 设置事件类 *&#x2F;</span><br><span class="line"> 8     set_bit(EV_KEY, inputdev-&gt;evbit);</span><br><span class="line"> 9     set_bit(EV_REP, inputdev-&gt;evbit);    &#x2F;* 重复类事件 *&#x2F;</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* 2.2 设置按键事件 *&#x2F;</span><br><span class="line">12     set_bit(KEY_L, inputdev-&gt;keybit);</span><br><span class="line">13     set_bit(KEY_S, inputdev-&gt;keybit);</span><br><span class="line">14     set_bit(KEY_ENTER, inputdev-&gt;keybit);</span><br><span class="line">15     set_bit(KEY_LEFTSHIFT, inputdev-&gt;keybit);</span><br><span class="line">16 </span><br><span class="line">17     &#x2F;* 3. 注册 *&#x2F;</span><br><span class="line">18     input_register_device(inputdev);</span><br><span class="line">19 ...</span><br><span class="line">20 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>set_bit(EV_REP, inputdev-&gt;evbit);表示可产生重复类事件</strong>，也就是长按按键，就会产生多次按键效果 </p>
<p><strong>key_timer_func()：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1 static void key_timer_func(unsigned long arg)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3 ...</span><br><span class="line"> 4     if (pinval) &#x2F;* 松开 *&#x2F; &#123;</span><br><span class="line"> 5         &#x2F;* 上传数据 *&#x2F;</span><br><span class="line"> 6         input_event(inputdev, EV_KEY, pindesc-&gt;val, 0);</span><br><span class="line"> 7         input_sync(inputdev);</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9     else &#x2F;* 按下 *&#x2F; &#123;</span><br><span class="line">10         input_event(inputdev, EV_KEY, pindesc-&gt;val, 1);</span><br><span class="line">11         input_sync(inputdev);</span><br><span class="line">12     &#125;</span><br><span class="line">13 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>input_sync(inputdev);表示已完成当前上报工作</strong></p>
<p>key源代码：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">  1 #include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">  2 #include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">  3 #include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">  4 #include &lt;linux&#x2F;cdev.h&gt;</span><br><span class="line">  5 #include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">  6 #include &lt;linux&#x2F;device.h&gt;</span><br><span class="line">  7 #include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">  8 #include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">  9 #include &lt;linux&#x2F;wait.h&gt;</span><br><span class="line"> 10 #include &lt;linux&#x2F;timer.h&gt;</span><br><span class="line"> 11 #include &lt;linux&#x2F;gpio.h&gt;</span><br><span class="line"> 12 #include &lt;linux&#x2F;sched.h&gt;</span><br><span class="line"> 13 #include &lt;linux&#x2F;input.h&gt;</span><br><span class="line"> 14 </span><br><span class="line"> 15 #include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"> 16 #include &lt;asm&#x2F;irq.h&gt;</span><br><span class="line"> 17 #include &lt;asm&#x2F;io.h&gt;</span><br><span class="line"> 18 </span><br><span class="line"> 19 #include &lt;mach&#x2F;gpio.h&gt;</span><br><span class="line"> 20 </span><br><span class="line"> 21 #define KEY_MAJOR        255</span><br><span class="line"> 22 </span><br><span class="line"> 23 struct pin_desc &#123;</span><br><span class="line"> 24     unsigned int gpio;</span><br><span class="line"> 25     int val;</span><br><span class="line"> 26     char *name;</span><br><span class="line"> 27 &#125;;</span><br><span class="line"> 28 </span><br><span class="line"> 29 static struct timer_list    key_timer;</span><br><span class="line"> 30 static struct pin_desc*        pindesc;</span><br><span class="line"> 31 static struct input_dev*    inputdev;</span><br><span class="line"> 32 </span><br><span class="line"> 33 static struct pin_desc desc[4] &#x3D; &#123;</span><br><span class="line"> 34     &#123; EXYNOS4_GPX3(2), KEY_L, &quot;KEY0&quot; &#125;,</span><br><span class="line"> 35     &#123; EXYNOS4_GPX3(3), KEY_S, &quot;KEY1&quot; &#125;,</span><br><span class="line"> 36     &#123; EXYNOS4_GPX3(4), KEY_ENTER, &quot;KEY2&quot; &#125;,</span><br><span class="line"> 37     &#123; EXYNOS4_GPX3(5), KEY_LEFTSHIFT, &quot;KEY3&quot; &#125;,</span><br><span class="line"> 38 &#125;;</span><br><span class="line"> 39 </span><br><span class="line"> 40 static void key_timer_func(unsigned long arg)</span><br><span class="line"> 41 &#123;</span><br><span class="line"> 42     struct pin_desc *irq_pd &#x3D; pindesc;</span><br><span class="line"> 43 </span><br><span class="line"> 44     if (!irq_pd)</span><br><span class="line"> 45         return ;</span><br><span class="line"> 46     </span><br><span class="line"> 47     unsigned int pinval;</span><br><span class="line"> 48 </span><br><span class="line"> 49     pinval &#x3D; gpio_get_value(pindesc-&gt;gpio);</span><br><span class="line"> 50 </span><br><span class="line"> 51     if (pinval) &#x2F;* 松开 *&#x2F; &#123;</span><br><span class="line"> 52         &#x2F;* 上传数据 *&#x2F;</span><br><span class="line"> 53         input_event(inputdev, EV_KEY, pindesc-&gt;val, 0);</span><br><span class="line"> 54         input_sync(inputdev);</span><br><span class="line"> 55     &#125;</span><br><span class="line"> 56     else &#x2F;* 按下 *&#x2F; &#123;</span><br><span class="line"> 57         input_event(inputdev, EV_KEY, pindesc-&gt;val, 1);</span><br><span class="line"> 58         input_sync(inputdev);</span><br><span class="line"> 59     &#125;</span><br><span class="line"> 60 &#125;</span><br><span class="line"> 61 </span><br><span class="line"> 62 static irqreturn_t key_interrupt(int irq, void *dev_id)</span><br><span class="line"> 63 &#123;</span><br><span class="line"> 64     pindesc &#x3D; (struct pin_desc *)dev_id;</span><br><span class="line"> 65 </span><br><span class="line"> 66     mod_timer(&amp;key_timer, jiffies + HZ &#x2F; 100);</span><br><span class="line"> 67 </span><br><span class="line"> 68     return IRQ_HANDLED;</span><br><span class="line"> 69 &#125;</span><br><span class="line"> 70 </span><br><span class="line"> 71 static int keys_init(void)</span><br><span class="line"> 72 &#123;</span><br><span class="line"> 73     &#x2F;* 1. 分配 *&#x2F;</span><br><span class="line"> 74     inputdev &#x3D; input_allocate_device();</span><br><span class="line"> 75 </span><br><span class="line"> 76     &#x2F;* 2. 设置 *&#x2F;</span><br><span class="line"> 77     &#x2F;* 2.1 设置事件类 *&#x2F;</span><br><span class="line"> 78     set_bit(EV_KEY, inputdev-&gt;evbit);</span><br><span class="line"> 79     set_bit(EV_REP, inputdev-&gt;evbit);    &#x2F;* 重复类事件 *&#x2F;</span><br><span class="line"> 80 </span><br><span class="line"> 81     &#x2F;* 2.2 设置按键事件 *&#x2F;</span><br><span class="line"> 82     set_bit(KEY_L, inputdev-&gt;keybit);</span><br><span class="line"> 83     set_bit(KEY_S, inputdev-&gt;keybit);</span><br><span class="line"> 84     set_bit(KEY_ENTER, inputdev-&gt;keybit);</span><br><span class="line"> 85     set_bit(KEY_LEFTSHIFT, inputdev-&gt;keybit);</span><br><span class="line"> 86 </span><br><span class="line"> 87     &#x2F;* 3. 注册 *&#x2F;</span><br><span class="line"> 88     input_register_device(inputdev);</span><br><span class="line"> 89 </span><br><span class="line"> 90     &#x2F;* 注册中断 *&#x2F;</span><br><span class="line"> 91     int irq, i;</span><br><span class="line"> 92     for (i &#x3D; 0; i &lt; ARRAY_SIZE(desc); i++) &#123;</span><br><span class="line"> 93         irq &#x3D; gpio_to_irq(desc[i].gpio);</span><br><span class="line"> 94         request_irq(irq, key_interrupt, IRQ_TYPE_EDGE_BOTH, desc[i].name, (void *)&amp;desc[i]);</span><br><span class="line"> 95     &#125;</span><br><span class="line"> 96     </span><br><span class="line"> 97     init_timer(&amp;key_timer);</span><br><span class="line"> 98     key_timer.function &#x3D; key_timer_func;</span><br><span class="line"> 99     add_timer(&amp;key_timer);</span><br><span class="line">100 </span><br><span class="line">101     return 0;</span><br><span class="line">102 &#125;</span><br><span class="line">103 </span><br><span class="line">104 static void keys_exit(void)</span><br><span class="line">105 &#123;    </span><br><span class="line">106     &#x2F;&#x2F; 释放中断</span><br><span class="line">107     int irq, i;</span><br><span class="line">108 </span><br><span class="line">109     for (i &#x3D; 0; i &lt; ARRAY_SIZE(desc); i++) &#123;</span><br><span class="line">110         irq &#x3D; gpio_to_irq(desc[i].gpio);</span><br><span class="line">111         free_irq(irq, (void *)&amp;desc[i]);</span><br><span class="line">112     &#125;</span><br><span class="line">113 </span><br><span class="line">114     del_timer(&amp;key_timer);</span><br><span class="line">115 </span><br><span class="line">116     input_unregister_device(inputdev);</span><br><span class="line">117     input_free_device(inputdev);</span><br><span class="line">118 &#125;</span><br><span class="line">119 </span><br><span class="line">120 module_init(keys_init);</span><br><span class="line">121 module_exit(keys_exit);</span><br><span class="line">122 </span><br><span class="line">123 MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Makefile：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 KERN_DIR &#x3D; &#x2F;work&#x2F;tiny4412&#x2F;tools&#x2F;linux-3.5</span><br><span class="line"> 2 </span><br><span class="line"> 3 all:</span><br><span class="line"> 4     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules </span><br><span class="line"> 5 </span><br><span class="line"> 6 clean:</span><br><span class="line"> 7     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules clean</span><br><span class="line"> 8     rm -rf modules.order</span><br><span class="line"> 9 </span><br><span class="line">10 obj-m    +&#x3D; key.o</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>测试文件：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;stdio.h&gt;</span><br><span class="line"> 2 #include &lt;unistd.h&gt;</span><br><span class="line"> 3 #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"> 4 #include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"> 5 #include &lt;fcntl.h&gt;</span><br><span class="line"> 6 #include &lt;string.h&gt;</span><br><span class="line"> 7 </span><br><span class="line"> 8 int main(int argc, char** argv)</span><br><span class="line"> 9 &#123;</span><br><span class="line">10     if (argc !&#x3D; 2) &#123;</span><br><span class="line">11         printf(&quot;Usage:\n&quot;);</span><br><span class="line">12         printf(&quot;%s &lt;event1|event2&gt;\n&quot;, argv[0]);</span><br><span class="line">13         return 0;</span><br><span class="line">14     &#125;</span><br><span class="line">15     </span><br><span class="line">16     char buf[100] &#x3D; &quot;&#x2F;dev&#x2F;&quot;;</span><br><span class="line">17     strcat(buf, argv[1]);</span><br><span class="line">18     printf(&quot;You Will Open %s\n&quot;, buf);</span><br><span class="line">19     </span><br><span class="line">20     int fd;</span><br><span class="line">21     </span><br><span class="line">22     fd &#x3D; open(buf, O_RDWR);</span><br><span class="line">23     if (fd &lt; 0) &#123;</span><br><span class="line">24         printf(&quot;can&#39;t open %s\n&quot;, buf);</span><br><span class="line">25         return -1;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     unsigned char key_val;</span><br><span class="line">29     </span><br><span class="line">30     while (1) &#123;</span><br><span class="line">31         read(fd, &amp;key_val, 1);</span><br><span class="line">32         printf(&quot;key_val &#x3D; 0x%x\n&quot;, key_val);</span><br><span class="line">33     &#125;</span><br><span class="line">34     </span><br><span class="line">35     close(fd);</span><br><span class="line">36 </span><br><span class="line">37     return 0;</span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>测试：</strong></p>
<p>在编译并在开发板上insmod后，会出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;6&gt;input: Unspecified device as &#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input3</span><br></pre></td></tr></table></figure>



<p>这是由于未设置input_dev的名字所导致的，暂时不需要管</p>
<p>接下来执行：</p>
<p># ps -ef</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200347113-1161513239.png" alt="img"></p>
<p>确定-/bin/sh的pid为108（不同开发板-/bin/sh的pid不同）</p>
<p># ls -l /proc/108/fd</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200548748-631729914.png" alt="img"></p>
<p>确定使用tty1</p>
<p># exec 0&lt;/dev/tty1</p>
<p>接下来按键，效果如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200914935-24962756.png" alt="img"></p>
<p>下一章  <a href="https://www.cnblogs.com/Lioker/p/10893768.html" target="_blank" rel="noopener">9、总线设备驱动模型</a></p>
<p>作者：<a href="https://www.cnblogs.com/Lioker/" target="_blank" rel="noopener">Lioker</a></p>
<p>邮箱：<a href="mailto:lioker@outlook.com">lioker@outlook.com</a></p>
<p>作者水平有限，欢迎拍砖。转载请注明出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%20(%E8%AF%A6%E8%A7%A3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%20(%E8%AF%A6%E8%A7%A3)/" class="post-title-link" itemprop="url">【转载】Linux键盘按键驱动 (详解)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:16:24 / Modified: 19:19:48" itemprop="dateCreated datePublished" datetime="2021-01-07T19:16:24+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：博客园–<a href="https://www.cnblogs.com/lifexy/" target="_blank" rel="noopener">诺谦</a> 【<a href="https://www.cnblogs.com/lifexy/p/7553861.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7553861.html】</a></p>
<h1 id="13-Linux键盘按键驱动-详解"><a href="#13-Linux键盘按键驱动-详解" class="headerlink" title="13.Linux键盘按键驱动 (详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener">13.Linux键盘按键驱动 (详解)</a></h1><p>在<strong><a href="http://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">上一节分析输入子系统</a></strong>内的intput_handler软件处理部分后,接下来我们开始写input_dev驱动</p>
<p><strong>本节目标:</strong></p>
<p>​    实现键盘驱动,让开发板的4个按键代表键盘中的L、S、空格键、回车键</p>
<hr>
<p><strong>1.先来介绍以下几个结构体使用和函数,下面代码中会用到</strong></p>
<p><strong>1)input_dev驱动设备结构体中常用成员如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev &#123;      </span><br><span class="line"></span><br><span class="line">       void *private;</span><br><span class="line">       const char *name;  &#x2F;&#x2F;设备名字</span><br><span class="line">       const char *phys;  &#x2F;&#x2F;文件路径,比如 input&#x2F;buttons</span><br><span class="line">       const char *uniq;   </span><br><span class="line">       struct input_id id;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">       unsigned long evbit[NBITS(EV_MAX)];  &#x2F;&#x2F;表示支持哪类事件,常用有以下几种事件(可以多选)</span><br><span class="line">       &#x2F;&#x2F;EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件</span><br><span class="line">       &#x2F;&#x2F;EV_KEY       键盘事件</span><br><span class="line">       &#x2F;&#x2F;EV_REL       (relative)相对坐标事件，比如鼠标</span><br><span class="line">       &#x2F;&#x2F;EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应</span><br><span class="line">       &#x2F;&#x2F;EV_MSC      其他事件,功能</span><br><span class="line">       &#x2F;&#x2F;EV_LED       LED灯事件</span><br><span class="line">       &#x2F;&#x2F;EV_SND      (sound)声音事件</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_REP       重复键盘按键事件</span><br><span class="line">  &#x2F;&#x2F;(内部会定义一个定时器,若有键盘按键事件一直按下&#x2F;松开,就重复定时,时间一到就上报事件)   </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_FF         受力事件</span><br><span class="line">       &#x2F;&#x2F;EV_PWR      电源事件</span><br><span class="line">       &#x2F;&#x2F;EV_FF_STATUS  受力状态事件</span><br><span class="line"></span><br><span class="line">       unsigned long keybit[NBITS(KEY_MAX)];   &#x2F;&#x2F;存放支持的键盘按键值</span><br><span class="line">                                    &#x2F;&#x2F;键盘变量定义在:include&#x2F;linux&#x2F;input.h, 比如: KEY_L(按键L)</span><br><span class="line"></span><br><span class="line">       unsigned long relbit[NBITS(REL_MAX)];    &#x2F;&#x2F;存放支持的相对坐标值</span><br><span class="line">       unsigned long absbit[NBITS(ABS_MAX)];   &#x2F;&#x2F;存放支持的绝对坐标值</span><br><span class="line">       unsigned long mscbit[NBITS(MSC_MAX)];   &#x2F;&#x2F;存放支持的其它事件,也就是功能</span><br><span class="line">       unsigned long ledbit[NBITS(LED_MAX)];    &#x2F;&#x2F;存放支持的各种状态LED</span><br><span class="line">       unsigned long sndbit[NBITS(SND_MAX)];    &#x2F;&#x2F;存放支持的各种声音</span><br><span class="line">       unsigned long ffbit[NBITS(FF_MAX)];       &#x2F;&#x2F;存放支持的受力设备</span><br><span class="line">       unsigned long swbit[NBITS(SW_MAX)];     &#x2F;&#x2F;存放支持的开关功能</span><br><span class="line"></span><br><span class="line"> ... ...</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>2)函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void);  &#x2F;&#x2F;向内核中申请一个input_dev设备,然后返回这个设备</span><br><span class="line">  </span><br><span class="line">input_unregister_device(struct input_dev *dev);   &#x2F;&#x2F;卸载&#x2F;sys&#x2F;class&#x2F;input目录下的input_dev这个类设备, 一般在驱动出口函数写</span><br><span class="line"> </span><br><span class="line">input_free_device(struct input_dev *dev);   &#x2F;&#x2F;释放input_dev这个结构体, 一般在驱动出口函数写</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_bit(nr,p);                  &#x2F;&#x2F;设置某个结构体成员p里面的某位等于nr,支持这个功能</span><br><span class="line">&#x2F;* 比如:</span><br><span class="line">set_bit(EV_KEY,buttons_dev-&gt;evbit);   &#x2F;&#x2F;设置input_dev结构体buttons_dev-&gt;evbit支持EV_KEY</span><br><span class="line">set_bit(KEY_S,buttons_dev-&gt;keybit);  &#x2F;&#x2F;设置input_dev结构体buttons_dev-&gt;keybit支持按键”S”</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);  &#x2F;&#x2F;上报事件</span><br><span class="line"> &#x2F;&#x2F; input_dev *dev :要上报哪个input_dev驱动设备的事件</span><br><span class="line"> &#x2F;&#x2F; type : 要上报哪类事件, 比如按键事件,则填入: EV_KEY</span><br><span class="line"> &#x2F;&#x2F; code: 对应的事件里支持的哪个变量，比如按下按键L则填入: KEY_L</span><br><span class="line"> &#x2F;&#x2F;value:对应的变量里的数值,比如松开按键则填入1,松开按键则填入0</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_sync(struct input_dev *dev); &#x2F;&#x2F;同步事件通知</span><br></pre></td></tr></table></figure>

<p>为什么使用了input_event()上报事件函数,就要使用这个函数？</p>
<p>因为input_event()函数只是个事件函数,所以需要这个input_sync()同步事件函数来通知系统,然后系统才会知道</p>
<p>input_sync()代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline void input_sync(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">input_event(dev, EV_SYN, SYN_REPORT, 0); &#x2F;&#x2F;就是上报同步事件,告诉内核:input_event()事件执行完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.然后开始写代码</strong></p>
<p>1)向内核申请input_dev结构体</p>
<p>2)设置input_dev的成员</p>
<p>3)注册input_dev 驱动设备</p>
<p>4)初始化定时器和中断</p>
<p>5)写中断服务函数</p>
<p>6)写定时器超时函数</p>
<p>7)在出口函数中 释放中断函数,删除定时器,卸载释放驱动</p>
<p>具体代码如下(都加了注释):</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;version.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sched.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;pm.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sysctl.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;proc_fs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;delay.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;gpio_keys.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;gpio.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">struct input_dev *buttons_dev;            &#x2F;&#x2F;  定义一个input_dev结构体  </span><br><span class="line">static struct ping_desc *buttons_id;          &#x2F;&#x2F;保存dev_id,在定时器中用</span><br><span class="line">static struct timer_list buttons_timer;    &#x2F;&#x2F;定时器结构体  </span><br><span class="line"></span><br><span class="line">struct  ping_desc&#123;</span><br><span class="line"></span><br><span class="line">       unsigned  char  *name;          &#x2F;&#x2F;中断设备名称</span><br><span class="line">       int            pin_irq;          &#x2F;&#x2F;按键的外部中断标志位</span><br><span class="line">       unsigned  int    pin;                &#x2F;&#x2F;引脚</span><br><span class="line">       unsigned int  irq_ctl;           &#x2F;&#x2F;触发中断状态:   IRQ_TYPE_EDGE_BOTH</span><br><span class="line">       unsigned  int    button;         &#x2F;&#x2F;dev_id,对应键盘的 L ,  S,  空格,  enter      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; KEY1 -&gt; L</span><br><span class="line">        &#x2F;&#x2F; KEY2 -&gt; S</span><br><span class="line">        &#x2F;&#x2F; KEY3 -&gt; 空格</span><br><span class="line">        &#x2F;&#x2F; KEY4 -&gt; enter</span><br><span class="line">static  struct ping_desc   buttons_desc[5]&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">       &#123;&quot;s1&quot;, IRQ_EINT0,   S3C2410_GPF0,  IRQ_TYPE_EDGE_BOTH,KEY_L&#125;,</span><br><span class="line">       &#123;&quot;s2&quot;, IRQ_EINT2,   S3C2410_GPF2,  IRQ_TYPE_EDGE_BOTH,KEY_S&#125;,</span><br><span class="line">       &#123;&quot;s3&quot;, IRQ_EINT11, S3C2410_GPG3 , IRQ_TYPE_EDGE_BOTH,KEY_SPACE&#125;,</span><br><span class="line">       &#123;&quot;s4&quot;, IRQ_EINT19, S3C2410_GPG11,IRQ_TYPE_EDGE_BOTH,KEY_ENTER&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;*5. 写中断服务函数*&#x2F;</span><br><span class="line">static irqreturn_t  buttons_irq (int irq, void *dev_id)       &#x2F;&#x2F;中断服务函数</span><br><span class="line">&#123;</span><br><span class="line">       buttons_id&#x3D;(struct ping_desc *)dev_id;             &#x2F;&#x2F;保存当前的dev_id</span><br><span class="line">       mod_timer(&amp;buttons_timer, jiffies+HZ&#x2F;100 );   &#x2F;&#x2F;更新定时器值 10ms </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;*6.写定时器超时函数*&#x2F;</span><br><span class="line">void buttons_timer_function(unsigned long i)</span><br><span class="line">&#123;</span><br><span class="line">   int val;</span><br><span class="line">   val&#x3D;s3c2410_gpio_getpin(buttons_id-&gt;pin);             &#x2F;&#x2F;获取是什么电平 </span><br><span class="line">  if(val)         &#x2F;&#x2F;高电平,松开</span><br><span class="line">       &#123;</span><br><span class="line">         &#x2F;*上报事件*&#x2F;</span><br><span class="line">         input_event(buttons_dev,EV_KEY,buttons_id-&gt;button, 0);  &#x2F;&#x2F;上报EV_KEY类型,button按键,0(没按下)</span><br><span class="line">         input_sync(buttons_dev);         &#x2F;&#x2F; 上传同步事件,告诉系统有事件出现                       </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  else      &#x2F;&#x2F;低电平，按下</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;*上报事件*&#x2F;</span><br><span class="line">         input_event(buttons_dev, EV_KEY, buttons_id-&gt;button, 1);  &#x2F;&#x2F;上报EV_KEY类型,button按键,1(按下)</span><br><span class="line">         input_sync(buttons_dev);       &#x2F;&#x2F; 上传同步事件,告诉系统有事件出现</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int buttons_init(void)   &#x2F;&#x2F;入口函数</span><br><span class="line">&#123;</span><br><span class="line">       int i;      </span><br><span class="line">       buttons_dev&#x3D;input_allocate_device();  &#x2F;&#x2F;1.向内核 申请input_dev结构体</span><br><span class="line">       &#x2F;*2.设置input_dev ,  *&#x2F;</span><br><span class="line">       set_bit(EV_KEY,buttons_dev-&gt;evbit);       &#x2F;&#x2F;支持键盘事件</span><br><span class="line">       set_bit(EV_REP,buttons_dev-&gt;evbit);       &#x2F;&#x2F;支持键盘重复按事件</span><br><span class="line">    </span><br><span class="line">       set_bit(KEY_L,buttons_dev-&gt;keybit);                  &#x2F;&#x2F;支持按键 L</span><br><span class="line">       set_bit(KEY_S,buttons_dev-&gt;keybit);                &#x2F;&#x2F;支持按键 S</span><br><span class="line">       set_bit(KEY_SPACE,buttons_dev-&gt;keybit);      &#x2F;&#x2F;支持按键 空格</span><br><span class="line">       set_bit(KEY_ENTER,buttons_dev-&gt;keybit);     &#x2F;&#x2F;支持按键 enter</span><br><span class="line"></span><br><span class="line">       &#x2F;*3.注册input_dev *&#x2F;</span><br><span class="line">       input_register_device(buttons_dev);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       &#x2F;*4. 初始化硬件:初始化定时器和中断*&#x2F;      </span><br><span class="line">       &#x2F;&#x2F; KEY1 -&gt; L</span><br><span class="line">       &#x2F;&#x2F; KEY2 -&gt; S</span><br><span class="line">       &#x2F;&#x2F; KEY3 -&gt; 空格</span><br><span class="line">       &#x2F;&#x2F; KEY4 -&gt; enter</span><br><span class="line">       init_timer(&amp;buttons_timer);</span><br><span class="line">       buttons_timer.function&#x3D;buttons_timer_function;</span><br><span class="line">       add_timer(&amp;buttons_timer);</span><br><span class="line"></span><br><span class="line">       for(i&#x3D;0;i&lt;4;i++)</span><br><span class="line">       request_irq(buttons_desc[i].pin_irq, buttons_irq, buttons_desc[i].irq_ctl, buttons_desc[i].name, &amp;buttons_desc[i]);</span><br><span class="line"></span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int buttons_exit(void)  &#x2F;&#x2F;出口函数</span><br><span class="line">&#123;</span><br><span class="line">       &#x2F;*7.释放中断函数,删除定时器,卸载释放驱动*&#x2F;</span><br><span class="line">       int i;</span><br><span class="line">       for(i&#x3D;0;i&lt;4;i++)</span><br><span class="line">              free_irq(buttons_desc[i].pin_irq,&amp;buttons_desc[i]);    &#x2F;&#x2F;释放中断函数</span><br><span class="line"></span><br><span class="line">       del_timer(&amp;buttons_timer);   &#x2F;&#x2F;删除定时器</span><br><span class="line"></span><br><span class="line">       input_unregister_device(buttons_dev);     &#x2F;&#x2F;卸载类下的驱动设备</span><br><span class="line">       input_free_device(buttons_dev);                &#x2F;&#x2F;释放驱动结构体</span><br><span class="line">       return 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(buttons_init);</span><br><span class="line">module_exit(buttons_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>3.测试运行:</strong></p>
<p>挂载键盘驱动后, 如下图,可以通过 ls -l /dev/event*  命令查看已挂载的设备节点:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170929163002590-1100491904.png" alt="img"></p>
<p>在<strong><a href="http://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">上一节输入子系统里分析</a></strong>到:输入子系统的主设备号为13,其中event驱动本身的此设备号是从64开始的,如上图,内核启动时,会加载自带触摸屏驱动,所以我们的键盘驱动的次设备号=64+1</p>
<p><strong>3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令</strong></p>
<p>(exec命令详解入口地址: <strong><a href="http://www.cnblogs.com/lifexy/p/7553228.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7553228.html</a></strong>)</p>
<p>方法1:</p>
<p>cat /dev/tty1   //tty1:LCD终端,就会通过tty_io.c来访问键盘驱动,然后打印在tty1终端上</p>
<p>方法2:</p>
<p>exec 0&lt;/dev/tty1   //将/dev/tty1挂载到-sh进程描述符0下,此时的键盘驱动就会直接打印在tty1终端上</p>
<p><strong>3.2 调试:</strong></p>
<p><strong>若测试不成功,板子又在QT下进行的:</strong></p>
<p>1)可以使用vi命令,在记事本中按按键试</p>
<p>2)或者删除/etc/init.d/rcS 里面有关QT自启动的命令,然后重启</p>
<p><strong>若板子没在QT下进行,也无法测试成功:</strong></p>
<p>1)可以使用hexdump命令来调试代码</p>
<p>(hexdump命令调试代码详解地址:<strong><a href="http://www.cnblogs.com/lifexy/p/7553550.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7553550.html</a></strong>)</p>
<p>接下来开始学习:</p>
<h1 id="14-linux-platform机制实现驱动层分离-详解"><a href="#14-linux-platform机制实现驱动层分离-详解" class="headerlink" title="14.linux-platform机制实现驱动层分离(详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7569371.html" target="_blank" rel="noopener">14.linux-platform机制实现驱动层分离(详解)</a></h1><hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/" class="post-title-link" itemprop="url">【转载】Linux之输入子系统分析(详解)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:11:00 / Modified: 19:16:05" itemprop="dateCreated datePublished" datetime="2021-01-07T19:11:00+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转自：博客园–<a href="https://www.cnblogs.com/lifexy/" target="_blank" rel="noopener">诺谦</a> 【<a href="https://www.cnblogs.com/lifexy/p/7542989.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7542989.html】</a></p>
<h1 id="12-Linux之输入子系统分析-详解"><a href="#12-Linux之输入子系统分析-详解" class="headerlink" title="12.Linux之输入子系统分析(详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">12.Linux之输入子系统分析(详解)</a></h1><p>在此节之前，我们学的都是简单的字符驱动，涉及的内容有<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>字符驱动的框架</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>自动创建设备节点</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506718.html" target="_blank" rel="noopener"><strong>linux中断</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508633.html" target="_blank" rel="noopener"><strong>poll机制</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508791.html" target="_blank" rel="noopener"><strong>异步通知</strong></a>、<strong><a href="http://www.cnblogs.com/lifexy/p/7515488.html" target="_blank" rel="noopener">同步互斥/非阻塞</a></strong>、<a href="http://www.cnblogs.com/lifexy/p/7522122.html" target="_blank" rel="noopener"><strong>定时器去抖动</strong></a>。</p>
<p>其中<strong>驱动框架</strong>如下:</p>
<p>1)写file_operations结构体的成员函数: .open()、.read()、.write()</p>
<p>2)在入口函数里通过register_chrdev()创建驱动名,生成主设备号,赋入file_operations结构体</p>
<p>3)在出口函数里通过unregister_chrdev() 卸载驱动</p>
<p>若有多个不同的驱动程序时,应用程序就要打开多个不同的驱动设备，由于是自己写肯定会很清楚,如果给别人来使用时是不是很麻烦？</p>
<p>所以需要使用<strong>输入子系统</strong>, 使应用程序无需打开多个不同的驱动设备便能实现</p>
<hr>
<p><strong>1.输入子系统简介</strong></p>
<p>同样的输入子系统也需要输入驱动的框架,好来辨认应用程序要打开的是哪个输入驱动</p>
<p>比如: 鼠标、键盘、游戏手柄等等这些都属于输入设备；这些输入设备的驱动都是通过输入子系统来实现的（当然，这些设备也依赖于usb子系统）</p>
<p>这些输入设备都各有不同，那么输入子系统也就只能实现他们的共性，差异性则由设备驱动来实现。差异性又体现在哪里？</p>
<p>最直观的就表现在这些设备功能上的不同了。对于我们写驱动的人来说在设备驱动中就只要使用输入子系统提供的工具（也就是函数）来完成这些“差异”就行了，其他的则是输入子系统的工作。这个思想不仅存在于输入子系统，其他子系统也是一样(比如:usb子系统、video子系统等)</p>
<p>所以我们先来分析下输入子系统<strong>input.c</strong>的代码,然后怎么来使用输入子系统(在内核中以input来形容输入子系统)</p>
<p><strong>2.打开input.c,位于内核deivers/input</strong></p>
<p>有以下这么两段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subsys_initcall(input_init);   &#x2F;&#x2F;修饰入口函数</span><br><span class="line"></span><br><span class="line">module_exit(input_exit);     &#x2F;&#x2F;修饰出口函数</span><br></pre></td></tr></table></figure>



<p><strong>显然输入子系统是作为一个模块存在,我们先来分析下input_int()入口函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int __init input_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3        int err;</span><br><span class="line"> 4        err &#x3D; class_register(&amp;input_class);   &#x2F;&#x2F;(1)注册类,放在&#x2F;sys&#x2F;class</span><br><span class="line"> 5        if (err) &#123;</span><br><span class="line"> 6               printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);</span><br><span class="line"> 7               return err;</span><br><span class="line"> 8        &#125;</span><br><span class="line"> 9  </span><br><span class="line">10        err &#x3D; input_proc_init();    &#x2F;&#x2F;在&#x2F;proc下面建立相关的文件</span><br><span class="line">11        if (err)</span><br><span class="line">12               goto fail1;</span><br><span class="line">13 </span><br><span class="line">14        err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops); &#x2F;&#x2F;(2)注册驱动</span><br><span class="line">15        if (err) &#123;</span><br><span class="line">16               printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">17               goto fail2;</span><br><span class="line">18        &#125;</span><br><span class="line">19 </span><br><span class="line">20  </span><br><span class="line">21 </span><br><span class="line">22        return 0;</span><br><span class="line">23 </span><br><span class="line">24  </span><br><span class="line">25 </span><br><span class="line">26  fail2:     input_proc_exit();</span><br><span class="line">27 </span><br><span class="line">28  fail1:     class_unregister(&amp;input_class);</span><br><span class="line">29 </span><br><span class="line">30        return err;</span><br><span class="line">31 </span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1)<strong>上面第4行”err = class_register(&amp;input_class);”</strong>是在/sys/class 里创建一个 input类, input_class变量如下图:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125656056-1309527087.png" alt="img"></p>
<p>如下图,我们启动内核,再启动一个input子系统的驱动后，也可以看到创建了个”input”类 :</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190208915-1448414250.png" alt="img"></p>
<p>为什么这里代码只创建类，没有使用class_device_create()函数在类下面创建驱动设备？</p>
<p>在下面第8小结会详细讲到,这里简单描述:当注册input子系统的驱动后，才会有驱动设备，此时这里的代码是没有驱动的</p>
<p>(2)<strong>上面第14行</strong>通过register_chrdev创建驱动设备,其中变量INPUT_MAJOR =13,所以创建了一个主设备为13的”input”设备。</p>
<p>然后我们来看看它的操作结构体input_fops,如下图:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125709915-1132827718.png" alt="img"></p>
<p>只有一个.open函数,比如当我们挂载一个新的input驱动,则内核便会调用该.open函数,接下来分析该.open函数</p>
<p><strong>3 然后进入input_open_file函数(drivers/input/input.c)</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line"> 2  &#123;</span><br><span class="line"> 3      struct input_handler *handler &#x3D; input_table[iminor(inode) &gt;&gt; 5]; &#x2F;&#x2F; (1)</span><br><span class="line"> 4      const struct file_operations *old_fops, *new_fops &#x3D; NULL;</span><br><span class="line"> 5      int err;</span><br><span class="line"> 6 </span><br><span class="line"> 7      if (!handler || !(new_fops &#x3D; fops_get(handler-&gt;fops)))  &#x2F;&#x2F;(2)</span><br><span class="line"> 8           return -ENODEV; </span><br><span class="line"> 9 </span><br><span class="line">10     if (!new_fops-&gt;open) &#123;</span><br><span class="line">11            fops_put(new_fops);</span><br><span class="line">12            return -ENODEV;</span><br><span class="line">13     &#125;</span><br><span class="line">14 </span><br><span class="line">15     old_fops &#x3D; file-&gt;f_op;</span><br><span class="line">16     file-&gt;f_op &#x3D; new_fops;     &#x2F;&#x2F;(3)</span><br><span class="line">17 </span><br><span class="line">18     err &#x3D; new_fops-&gt;open(inode, file);   &#x2F;&#x2F;(4)</span><br><span class="line">19     if (err) &#123;</span><br><span class="line">20           fops_put(file-&gt;f_op);</span><br><span class="line">21            file-&gt;f_op &#x3D; fops_get(old_fops);</span><br><span class="line">22    &#125;</span><br><span class="line">23 </span><br><span class="line">24    fops_put(old_fops);</span><br><span class="line">25 </span><br><span class="line">26     return err;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第3行中</strong>,其中iminor (inode)函数调用了MINOR(inode-&gt;i_rdev);读取子设备号,然后将子设备除以32,找到新挂载的input驱动的数组号,然后放在input_handler 驱动处理函数handler中 </p>
<p><strong>(2)第7行中</strong>,若handler有值,说明挂载有这个驱动,就将handler结构体里的成员file_operations * fops赋到新的file_operations *new_fops里面</p>
<p><strong>(3)第16行中</strong>, 再将新的file_operations *new_fops赋到file-&gt; file_operations  *f_op里, 此时input子系统的file_operations就等于新挂载的input驱动的file_operations结构体,实现一个偷天换日的效果.</p>
<p><strong>(4)第18行中</strong>,然后调用新挂载的input驱动的*new_fops里面的成员.open函数</p>
<p><strong>4.上面代码的input_table[]数组在初始时是没有值的,</strong></p>
<p><strong>所以我们来看看input_table数组里面的数据又是在哪个函数里被赋值</strong></p>
<p>在input.c函数(drivers/input/input.c)中搜索input_table,找到它在input_register_handler()函数中被赋值,代码如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 int input_register_handler(struct input_handler *handler)</span><br><span class="line">2 &#123;</span><br><span class="line">3 ... ...</span><br><span class="line">4 input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;   &#x2F;&#x2F;input_table[]被赋值</span><br><span class="line">5 ... ...</span><br><span class="line">6 list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); &#x2F;&#x2F;然后将这个input_handler放到input_handler_list链表中  </span><br><span class="line">7 ... ...</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是将驱动处理程序input_handler注册到input_table[]中，然后放在input_handler_list链表中,后面会讲这个链表</p>
<p><strong>5继续来搜索input_register_handler,看看这个函数被谁来调用</strong></p>
<p>如下图所示,有evdev.c(事件设备)，tsdev.c(触摸屏设备)，joydev.c(joystick操作杆设备)，keyboard.c(键盘设备)，mousedev.c(鼠标设备) 这5个内核自带的设备处理函数注册到input子系统中</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125734228-444718177.png" alt="img"></p>
<p>我们以evdev.c为例,它在evdev_ini()函数中注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">       return input_register_handler(&amp;evdev_handler);  &#x2F;&#x2F;注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>6我们来看看这个evdev_handler变量是什么结构体,:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">2        .event &#x3D;  evdev_event,    </span><br><span class="line">3        .connect &#x3D;      evdev_connect,  &#x2F;&#x2F;(4)</span><br><span class="line">4        .disconnect &#x3D; evdev_disconnect,</span><br><span class="line">5        .fops &#x3D;           &amp;evdev_fops,    &#x2F;&#x2F;(1)</span><br><span class="line">6        .minor &#x3D;  EVDEV_MINOR_BASE, &#x2F;&#x2F;(2)</span><br><span class="line">7        .name &#x3D;         &quot;evdev&quot;,</span><br><span class="line">8        .id_table &#x3D;      evdev_ids, &#x2F;&#x2F;(3)</span><br><span class="line">9 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是我们之前看的input_handler驱动处理结构体</p>
<p>(1) <strong>第5行中.fops:</strong>文件操作结构体,其中evdev_fops函数就是自己的写的操作函数,然后赋到.fops中</p>
<p>(2)<strong>第6行中 .minor:</strong>用来存放次设备号</p>
<p>其中EVDEV_MINOR_BASE=64, 然后调用input_register_handler(&amp;evdev_handler)后,由于EVDEV_MINOR_BASE/32=2,所以存到input_table[2]中</p>
<p> 所以当open打开这个input设备,就会进入 input_open_file()函数,执行evdev_handler-&gt; evdev_fops -&gt; .open函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125751978-2110731647.png" alt="img"></p>
<p>(3)<strong>第8行中.id_table :</strong> 表示能支持哪些输入设备，比如某个驱动设备的input_dev-&gt;的id和某个input_handler的id_table相匹配，就会调用.connect连接函数,如下图</p>
<p>(4)<strong>第3行中.connect:</strong>连接函数，将设备input_dev和某个input_handler建立连接,如下图</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125805775-128197571.png" alt="img"></p>
<p><strong>7我们先来看看上图的input_register_device()函数,如何创建驱动设备的</strong></p>
<p>搜索input_register_device,发现内核自己就已经注册了很多驱动设备</p>
<p><strong>7.1然后进入input_register_device()函数,代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备</span><br><span class="line">2 &#123;</span><br><span class="line">3  ... ...</span><br><span class="line">4        list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中</span><br><span class="line">5  ... ...</span><br><span class="line">6        list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)</span><br><span class="line">7        input_attach_handler(dev, handler); </span><br><span class="line">8  ... ...</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第4行中,</strong>将要注册的input_dev驱动设备放在input_dev_list链表中</p>
<p><strong>(2)第6行中,</strong>其中input_handler_list在前面讲过,就是存放每个input_handle驱动处理结构体,</p>
<p>然后list_for_each_entry()函数会将每个input_handle从链表中取出,放到handler中</p>
<p>最后会调用input_attach_handler()函数,将每个input_handle的id_table进行判断,若两者支持便进行连接。</p>
<p><strong>7.2然后我们在回过头来看注册input_handler的input_register_handler()函数,如下图所示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125828931-1140237004.png" alt="img"></p>
<p>所以,不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支持, 若两者支持便进行连接。</p>
<p><strong>7.3我们来看看input_attach_handler()如何实现匹配两者id的:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line">id &#x3D; input_match_device(handler-&gt;id_table, dev);  &#x2F;&#x2F;匹配两者</span><br><span class="line"></span><br><span class="line">if (!id)                                     &#x2F;&#x2F;若不匹配,return退出</span><br><span class="line">return -ENODEV; </span><br><span class="line"></span><br><span class="line">error &#x3D; handler-&gt;connect(handler, dev, id);  &#x2F;&#x2F;调用input_handler -&gt;connect函数建立连接</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若两者匹配成功，就会自动进入input_handler 的connect函数建立连接</p>
<p><strong>8我们还是以evdev.c(事件驱动) 的evdev_handler-&gt;connect函数</strong></p>
<p><strong>来分析**</strong>是怎样建立连接的,如下图:**</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125845790-1398162479.png" alt="img"></p>
<p><strong>8.1 evdev_handler的.connect函数是evdev_connect(),代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)     </span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3 ... ... </span><br><span class="line"> 4 for (minor &#x3D; 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++); &#x2F;&#x2F;查找驱动设备的子设备号</span><br><span class="line"> 5     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  &#x2F;&#x2F; EVDEV_MINORS&#x3D;32,所以该事件下的驱动设备最多存32个,</span><br><span class="line"> 6         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);</span><br><span class="line"> 7         return -ENFILE;                &#x2F;&#x2F;没找到驱动设备</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9  ... ...</span><br><span class="line">10  evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);   &#x2F;&#x2F;分配一个input_handle全局结构体(没有r)</span><br><span class="line">11  ... ...</span><br><span class="line">12  evdev-&gt;handle.dev &#x3D; dev;              &#x2F;&#x2F;指向参数input_dev驱动设备</span><br><span class="line">13 evdev-&gt;handle.name &#x3D; evdev-&gt;name;</span><br><span class="line">14 evdev-&gt;handle.handler &#x3D; handler;    &#x2F;&#x2F;指向参数 input_handler驱动处理结构体</span><br><span class="line">15 evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line">16 sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);    &#x2F;&#x2F;(1)保存驱动设备名字, event%d</span><br><span class="line">17 ... ...</span><br><span class="line">18 devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  &#x2F;&#x2F;(2) 将主设备号和次设备号转换成dev_t类型</span><br><span class="line">19 cdev &#x3D; class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name);                                                            &#x2F;&#x2F; (3)在input类下创建驱动设备</span><br><span class="line">20 </span><br><span class="line">21 ... ...</span><br><span class="line">22 error &#x3D; input_register_handle(&amp;evdev-&gt;handle); &#x2F;&#x2F;(4)注册这个input_handle结构体</span><br><span class="line">23 </span><br><span class="line">24 ... ...</span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1) 第16行中,是在保存驱动设备名字,名为event%d, 比如下图(键盘驱动)event1: 因为没有设置子设备号，默认从小到大排列,其中event0是表示这个input子系统,所以这个键盘驱动名字就是event1</p>
<p>(2)第18行中,是在保存驱动设备的主次设备号,其中主设备号INPUT_MAJOR=13,因为EVDEV_MINOR_BASE=64,所以此设备号=64+驱动程序本事子设备号, 比如下图(键盘驱动)event1:  主次设备号就是13,65</p>
<p>(3)在之前在2小结里就分析了input_class类结构，所以第19行中,会在/sys/class/input类下创建驱动设备event%d，比如下图(键盘驱动)event1:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190616478-260239851.png" alt="img"></p>
<p>(4)最终会进入input_register_handle()函数来注册,代码在下面</p>
<p>8.2 <strong>input_register_handle()函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_handle(struct input_handle *handle)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3       struct input_handler *handler &#x3D; handle-&gt;handler; &#x2F;&#x2F;handler&#x3D; input_handler驱动处理结构体 </span><br><span class="line"> 4 </span><br><span class="line"> 5       list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;(1)</span><br><span class="line"> 6       list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; (2)</span><br><span class="line"> 7  </span><br><span class="line"> 8       if (handler-&gt;start)</span><br><span class="line"> 9              handler-&gt;start(handle);</span><br><span class="line">10       return 0;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)在第5行中,</strong> 因为handle-&gt;dev指向input_dev驱动设备,所以就是将handle-&gt;d_node放入到input_dev驱动设备的h_list链表中,</p>
<p>即input_dev驱动设备的h_list链表就指向handle-&gt;d_node</p>
<p><strong>(2) 在第6行中,</strong> 同样, input_handler驱动处理结构体的h_list也指向了handle-&gt;h_node</p>
<p>最终如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125909525-684596795.png" alt="img"></p>
<p>两者的.h_list都指向了同一个handle结构体，然后通过.h_list 来找到handle的成员.dev和handler,便能找到对方,便建立了连接</p>
<p><strong>9建立了连接后，又如何读取evdev.c(事件驱动) 的evdev_handler-&gt;.fops-&gt;.read函数？</strong></p>
<p>事件驱动的.read函数是evdev_read()函数,我们来分析下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *      buffer, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line"> ... ...</span><br><span class="line">&#x2F;*判断应用层要读取的数据是否正确*&#x2F;</span><br><span class="line">if (count &lt; evdev_event_size())</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">&#x2F;*在非阻塞操作情况下,若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),则return返回*&#x2F;</span><br><span class="line"> if (client-&gt;head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">return -EAGAIN;</span><br><span class="line"> </span><br><span class="line">&#x2F;*若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),等待中断进入睡眠状态  *&#x2F;</span><br><span class="line">  retval &#x3D; wait_event_interruptible(evdev-&gt;wait,client-&gt;head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">  ... ...           &#x2F;&#x2F;上传数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>10若read函数进入了休眠状态，又是谁来唤醒？</strong></p>
<p>我们搜索这个evdev-&gt;wait这个等待队列变量,找到evdev_event函数里唤醒:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line"> wake_up_interruptible(&amp;evdev-&gt;wait);   &#x2F;&#x2F;有事件触发，便唤醒等待中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中evdev_event()是evdev.c(事件驱动) 的evdev_handler-&gt;.event成员,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125924681-419081807.png" alt="img"></p>
<p>当有事件发生了,比如对于按键驱动,当有按键按下时,就会进入.event函数中处理事件</p>
<p><strong>11分析下,是谁调用evdev_event()这个.event事件驱动函数</strong></p>
<p>应该就是之前分析的input_dev那层调用的</p>
<p>我们来看看内核 gpio_keys_isr()函数代码例子就知道了 (driver/input/keyboard/gpio_key.c)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t gpio_keys_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*获取按键值,赋到state里*&#x2F;</span><br><span class="line"> ... ...</span><br><span class="line"></span><br><span class="line">&#x2F;*上报事件*&#x2F;</span><br><span class="line">input_event(input, type, button-&gt;code, !!state);  </span><br><span class="line">input_sync(input);                        &#x2F;&#x2F;同步信号通知,表示事件发送完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>显然就是通过input_event()来调用.event事件函数,我们来看看:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">struct input_handle *handle;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#x2F;* 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体*&#x2F;</span><br><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)    </span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若之前驱动input_dev和处理input_handler已经通过input_handler 的.connect函数建立起了连接,那么就调用evdev_event()的.event事件函数，如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125942290-1009610213.png" alt="img"></p>
<p><strong>12本节总结分析:</strong></p>
<p><strong>1.**</strong>注册输入子系统<strong><strong>,</strong></strong>进入<strong>**put_init():</strong></p>
<p>1)创建主设备号为13的”input”字符设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br></pre></td></tr></table></figure>



<p><strong>2.open打开**</strong>驱动<strong><strong>,</strong></strong>进入<strong>**input_open_file():</strong></p>
<p>1)更新设备的file_oprations</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;f_op&#x3D;fops_get(handler-&gt;fops);</span><br></pre></td></tr></table></figure>



<p>2)执行file_oprations-&gt;open函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; new_fops-&gt;open(inode, file);</span><br></pre></td></tr></table></figure>



<p><strong>3.**</strong>注册<strong><strong>input_handler,</strong></strong>进入<strong>**input_register_handler():</strong></p>
<p>1)添加到input_table[]处理数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;</span><br></pre></td></tr></table></figure>



<p>2）添加到input_handler_list链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br></pre></td></tr></table></figure>



<p>3)判断input_dev的id,是否有支持这个驱动的设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(dev, &amp;input_dev_list, node)   &#x2F;&#x2F;遍历查找input_dev_list链表里所有input_dev</span><br><span class="line"></span><br><span class="line">input_attach_handler(dev, handler);             &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>

<p><strong>4.**</strong>注册<strong><strong>input_dev</strong></strong>，进入<strong>**input_register_device():</strong></p>
<p>1)放在input_dev_list链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br></pre></td></tr></table></figure>



<p>2)判断input_handler的id，是否有支持这个设备的驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;遍历查找input_handler_list链表里所有input_handler</span><br><span class="line">input_attach_handler(dev, handler);                      &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>



<p><strong>5.**</strong>判断<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的<strong><strong>id,</strong></strong>进入<strong>**input_attach_handler():</strong></p>
<p>1）匹配两者id,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_match_device(handler-&gt;id_table, dev);        &#x2F;&#x2F;匹配input_handler和dev的id,不成功退出函数</span><br></pre></td></tr></table></figure>



<p>2)匹配成功调用input_handler -&gt;connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler-&gt;connect(handler, dev, id);              &#x2F;&#x2F;建立连接</span><br></pre></td></tr></table></figure>

<p><strong>6.**</strong>建立<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的连接，进入<strong>**input_handler-&gt;connect():</strong></p>
<p>1)创建全局结构体,通过input_handle结构体连接双方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);    &#x2F;&#x2F;创建两者连接的input_handle全局结构体</span><br><span class="line">list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;连接input_dev-&gt;h_list</span><br><span class="line">list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; 连接input_handle-&gt;h_list</span><br></pre></td></tr></table></figure>

<p><strong>7.**</strong>有事件发生时<strong><strong>,</strong></strong>比如按键中断<strong><strong>,</strong></strong>在中断函数中需要进入<strong><strong>input_event()</strong></strong>上报事件<strong>**:</strong></p>
<p>1)找到驱动处理结构体，然后执行input_handler-&gt;event()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)     &#x2F;&#x2F; 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体</span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体(有可能一个驱动设备在不同情况下有不同的驱动处理方式)</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数</span><br></pre></td></tr></table></figure>





<p><strong>然后在<a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener">下一节便开始</a></strong><a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener"><strong>实现**</strong>输入子系统的键盘按键驱动**</a></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">【转载】input子系统全面分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 19:02:37 / Modified: 19:07:13" itemprop="dateCreated datePublished" datetime="2021-01-07T19:02:37+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3293302.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3293302.html】</a></p>
<h1 id="【驱动】input子系统全面分析"><a href="#【驱动】input子系统全面分析" class="headerlink" title="【驱动】input子系统全面分析"></a><a href="https://www.cnblogs.com/lcw/p/3293302.html" target="_blank" rel="noopener">【驱动】input子系统全面分析</a></h1><h2 id="初识linux输入子系统"><a href="#初识linux输入子系统" class="headerlink" title="初识linux输入子系统"></a>初识linux输入子系统</h2><p>　　linux输入子系统（linux input subsystem）从上到下由三层实现，分别为：输入子系统事件处理层（EventHandler）、输入子系统核心层（InputCore）和输入子系统设备驱动层。</p>
<ol>
<li>设备驱动层：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</li>
<li>核心层：为设备驱动层提供了规范和接口。设备驱动层只要关心如何驱动硬件并获得硬件数据（例如按下的按键数据），然后调用核心层提供的接口，核心层会自动把数据提交给事件处理层。</li>
<li>事件处理层：则是用户编程的接口（设备节点），并处理驱动层提交的数据处理。</li>
</ol>
<hr>
<h2 id="input输入子系统框架分析"><a href="#input输入子系统框架分析" class="headerlink" title="input输入子系统框架分析"></a>input输入子系统框架分析</h2><p>　　输入子系统由输入子系统核心层（ Input Core ），驱动层和事件处理层（Event Handler）三部份组成。</p>
<p>　　一个输入事件，如鼠标移动，键盘按键按下，joystick的移动等等通过 input driver -&gt; Input core -&gt; Event handler -&gt; userspace 到达用户空间传给应用程序。</p>
<p><img src="https://images0.cnblogs.com/blog/536940/201308/31142437-2490ff18237f466a85a3f23cadd89895.jpg" alt="img"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-系统核心层"><a href="#1-系统核心层" class="headerlink" title="1.系统核心层"></a><strong>1.系统核心层</strong></h3><p>　　主要功能</p>
<ol>
<li>注册主设备号</li>
<li>对于swi进入的open函数进行第一层处理，并通过次设备号选择handler进入第二层open，也就是真正的open所在的file_operation,并返回该file_opration的fd</li>
<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler</li>
</ol>
<h3 id="2-handler层（事件处理层）"><a href="#2-handler层（事件处理层）" class="headerlink" title="2.handler层（事件处理层）"></a><strong>2.handler层（事件处理层）</strong></h3><p>　　handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等，但是没有设计到硬件方面的操作</p>
<p>　　对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下</p>
<blockquote>
<p>　　　　.id_table　　　一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</p>
<p>　　　　.fops　　　　　该handler的file_operation</p>
<p>　　　　.connect　　　连接该handler跟所支持device的函数</p>
<p>　　　　.disconnect　　断开该连接</p>
<p>　　　　.event　　　　事件处理函数，让device调用</p>
<p>　　　　h_list　　　　也是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</p>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="3-device层（驱动层）"><a href="#3-device层（驱动层）" class="headerlink" title="3.device层（驱动层）"></a><strong>3.device层（驱动层）</strong></h3><p>　　device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</p>
<p>　　对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</p>
<p>　　该结构体内部也包含着一个h_list</p>
<h3 id="4：input-handler-list和input-device-list"><a href="#4：input-handler-list和input-device-list" class="headerlink" title="4：input_handler_list和input_device_list"></a><strong>4：input_handler_list和input_device_list</strong></h3><p>　　对于handler和device，分别用链表input_handler_list和input_device_list进行维护，</p>
<p>　　当handler或者device增加或减少的时候，分别往这两链表增加或删除节点。</p>
<h3 id="5-input子系统框架图"><a href="#5-input子系统框架图" class="headerlink" title="5.input子系统框架图"></a>5.input子系统框架图</h3><p><img src="https://images0.cnblogs.com/blog/536940/201308/31143339-81be7c9975fe480f9f89449b57b6aab1.jpg" alt="img"></p>
<hr>
<h2 id="input子系统调用过程分析"><a href="#input子系统调用过程分析" class="headerlink" title="input子系统调用过程分析"></a>input子系统调用过程分析</h2><p>　　1.当外部应用程序需要调用输入子系统的open函数时，会先通过主设备号进入到核心层，然后通过次设备号进入handler层，再调用.fops内的open函数返回fd；</p>
<p>　　2.当外部应用程序需要调用输入子系统的read函数时，会通过返回的fd调用.fop内的read函数，然后休眠，等待被.event函数唤醒</p>
<p>　　3.当外部中断到达的时候，会先确定中断事件，然后用input_event上报事件，再通过h_list里面的所有handle调用对应的handler中的.event函数，对read进行唤醒，然后在read中返回（也就是当device有多个对应的handler的时候,input_event会向所有的handler上报事件）</p>
<p>　　4.当需要加入新的handler时，需要先构建handler结构体，然后调用input_register_handler对该handler进行注册</p>
<p>　　input_register_handler的内部实现：往input_handler_list加入新增的handler节点，然后对input_device_list的所有结点（也就是所有的device）进行遍历，通过.id_table查看该device是否支持该handler,对支持的device调用.connect,一一地构建input_handle结构体,连接handler跟device</p>
<p>　　5.当需要加入新的device时，需要先构建input_dev结构体，然后调用input_register_device对该input_dev进行注册</p>
<p>　　</p>
<p>　　<strong>input_register_dev的内部实现</strong>：往input_device_list加入新增的device节点，然后对input_handler_list的所有结点（也就是所有的handler）进行遍历，通过handler　的.id_table查看该handler是否支持该device,对支持的device调用该handler的.connect,一一地构建input_handle结构体,连接handler跟device</p>
<p>　　在输入子系统框架下，我们一般的编写驱动也就是对device部分进行编写（分配input_dev并配置，驱动入口，出口，中断时进行中断判断，然后上报事件等），然后对该device的input_dev进行注册</p>
<hr>
<h2 id="Input输入子系统数据结构分析"><a href="#Input输入子系统数据结构分析" class="headerlink" title="Input输入子系统数据结构分析"></a><strong>Input输入子系统数据结构分析</strong></h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="input-dev"><a href="#input-dev" class="headerlink" title="input_dev"></a>input_dev</h3><p>　　input_dev 这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构，成员比较多 </p>
<p>　　<strong>（1）有以下几个数组：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long evbit[BITS_TO_LONGS(EV_CNT)];   &#x2F;&#x2F;事件支持的类型  </span><br><span class="line"> &#x2F;&#x2F; 下面是每种类型支持的编码  </span><br><span class="line">unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];   &#x2F;&#x2F;按键    </span><br><span class="line">unsigned long relbit[BITS_TO_LONGS(REL_CNT)];     </span><br><span class="line">unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];   &#x2F;&#x2F;绝对坐标，其中触摸屏驱动使用的就是这个  </span><br><span class="line">unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];  </span><br><span class="line">unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];  </span><br><span class="line">unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];  </span><br><span class="line">unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];  </span><br><span class="line">unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evbit[BITS_TO_LONGS(EV_CNT)]; 这个数组以位掩码的形式，代表了这个设备支持的事件的类型。</p>
<p>　　设置方式：<br>　　dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS)<br>　　absbit[BITS_TO_LONGS(ABS_CNT)]; 这个数组也是以位掩码的形式，代表这个类型的事件支持的编码<br>　　触摸屏驱动支持EV_ABS,所以要设置这个数组， 有一个专门设置这个数组的函数input_set_abs_params</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline void input_set_abs_params(struct input_dev *dev, int axis, int min, int max, int fuzz, int flat)  </span><br><span class="line">&#123;  </span><br><span class="line">    dev-&gt;absmin[axis] &#x3D; min;  </span><br><span class="line">    dev-&gt;absmax[axis] &#x3D; max;  </span><br><span class="line">    dev-&gt;absfuzz[axis] &#x3D; fuzz;  </span><br><span class="line">    dev-&gt;absflat[axis] &#x3D; flat;  </span><br><span class="line">  </span><br><span class="line">    dev-&gt;absbit[BIT_WORD(axis)] |&#x3D; BIT_MASK(axis);  &#x2F;&#x2F;填充了absbit这个数组  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　触摸屏驱动中是这样调用的</p>
<p>　　input_set_abs_params(dev, ABS_X, 0, 0x3FF, 0, 0)；  //这个是设置ad转换的x坐标<br>　　input_set_abs_params(dev, ABS_Y, 0, 0x3FF, 0, 0);  //这个是设置ad转换的y坐标<br>　　input_set_abs_params(dev, ABS_PRESSURE, 0, 1, 0, 0); //这个是设置触摸屏是否按下的标志<br>　　设置ABS_X编码值范围为0-0x3ff，因为mini2440的AD转换出的数据最大为10位，所以不会超过0x3ff。</p>
<p>　<strong>（2） struct input_id id 成员</strong><br>　　这个是标识设备驱动特征的</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct input_id &#123;  </span><br><span class="line">    __u16 bustype;   &#x2F;&#x2F;总线类型  </span><br><span class="line">    __u16 vendor;    &#x2F;&#x2F;生产厂商  </span><br><span class="line">    __u16 product;   &#x2F;&#x2F;产品类型  </span><br><span class="line">    __u16 version;   &#x2F;&#x2F;版本  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　如果需要特定的事件处理器来处理这个设备的话，这几个就非常重要，因为子系统核心是通过他们，将设备驱动与事件处理层联系起来的。但是因为触摸屏驱动所用的事件处理器为evdev，匹配所有，所有这个初始化也无关紧要。</p>
<h3 id="input-handler"><a href="#input-handler" class="headerlink" title="input_handler"></a>input_handler</h3><p>　　input_handler 这是事件处理器的数据结构，代表一个事件处理器</p>
<p>　　<strong>（1）几个操作函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">void (*disconnect)(struct input_handle *handle);</span><br><span class="line">void (*start)(struct input_handle *handle);</span><br></pre></td></tr></table></figure>

<p>　　event 函数是当事件处理器接收到了来自input设备传来的事件时调用的处理函数，负责处理事件，<strong>非常重要</strong>。<br>　　connect 函数是当一个input设备模块注册到内核的时候调用的，将事件处理器与输入设备联系起来的函数，也就是将input_dev和input_handler配对的函数。<br>　　disconnect 函数实现connect相反的功能。</p>
<p>　　<strong>（2） 两个id</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　const struct input_device_id *id_table; &#x2F;&#x2F;这个是事件处理器所支持的input设备</span><br><span class="line">　　const struct input_device_id *blacklist; &#x2F;&#x2F;这个是事件处理器应该忽略的input设备</span><br></pre></td></tr></table></figure>

<p>　　这两个数组都会用在connect函数中，input_device_id结构与input_id结构类似，但是input_device_id有一个flag，用来让程序选择比较哪项，如：busytype,vendor还是其他。</p>
<p>　　<strong>（3） 两个链表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct list_headh_list;  &#x2F;&#x2F;这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span><br><span class="line">struct list_headnode;    &#x2F;&#x2F;链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span><br></pre></td></tr></table></figure>



<h3 id="input-handle"><a href="#input-handle" class="headerlink" title="input_handle"></a>input_handle</h3><p>　　input_handle 结构体代表一个成功配对的input_dev和input_handler</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct input_handle &#123;  </span><br><span class="line">    void *private;   &#x2F;&#x2F;每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。  </span><br><span class="line">    int open;        &#x2F;&#x2F;打开标志，每个input_handle 打开后才能操作，这个一般通过事件处理器的open方法间接设置  </span><br><span class="line">    const char *name;   </span><br><span class="line">    struct input_dev *dev;  &#x2F;&#x2F;关联的input_dev结构  </span><br><span class="line">    struct input_handler *handler; &#x2F;&#x2F;关联的input_handler结构  </span><br><span class="line">    struct list_head    d_node;  &#x2F;&#x2F;input_handle通过d_node连接到了input_dev上的h_list链表上  </span><br><span class="line">    struct list_head    h_node;  &#x2F;&#x2F;input_handle通过h_node连接到了input_handler的h_list链表上  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="三个数据结构之间的关系"><a href="#三个数据结构之间的关系" class="headerlink" title="三个数据结构之间的关系"></a>三个数据结构之间的关系</h3><p>　　input_dev 是硬件驱动层，代表一个input设备<br>　　input_handler 是事件处理层，代表一个事件处理器<br>　　input_handle 属于核心层，代表一个配对的input设备与input事件处理器<br>　　input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。<br>　　input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）</p>
<p>　　input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。</p>
<p>　　通过input_dev 和input_handler就可以找到input_handle 在设备注册和事件处理器， 注册的时候都要进行配对工作，配对后就会实现链接。</p>
<p>　　通过input_handle也可以找到input_dev和input_handler。</p>
<h3 id="补充两个结构体"><a href="#补充两个结构体" class="headerlink" title="补充两个结构体"></a>补充两个结构体</h3><p>　　<strong>（1） evdev设备结构</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct evdev &#123;  </span><br><span class="line">    int exist;  </span><br><span class="line">    int open;           &#x2F;&#x2F;打开标志  </span><br><span class="line">    int minor;          &#x2F;&#x2F;次设备号  </span><br><span class="line">    struct input_handle handle;  &#x2F;&#x2F;关联的input_handle  </span><br><span class="line">    wait_queue_head_t wait;      &#x2F;&#x2F;等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面  </span><br><span class="line">    struct evdev_client *grab;   &#x2F;&#x2F;强制绑定的evdev_client结构，这个结构后面再分析  </span><br><span class="line">    struct list_head client_list;  &#x2F;&#x2F;evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备  </span><br><span class="line">    spinlock_t client_lock; &#x2F;* protects client_list *&#x2F;  </span><br><span class="line">    struct mutex mutex;  </span><br><span class="line">    struct device dev;       &#x2F;&#x2F;device结构，说明这是一个设备结构  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)。</p>
<p>　　如触摸屏驱动的event0，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input0。这个设备结构生成之后保存在evdev_table中，索引值是minor</p>
<p>　　<strong>（2） evdev用户端结构</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct evdev_client &#123;  </span><br><span class="line">    struct input_event buffer[EVDEV_BUFFER_SIZE];    </span><br><span class="line">        &#x2F;&#x2F;这个是一个input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span><br><span class="line">    int head;              &#x2F;&#x2F;针对buffer数组的索引  </span><br><span class="line">    int tail;              &#x2F;&#x2F;针对buffer数组的索引，当head与tail相等的时候，说明没有事件  </span><br><span class="line">    spinlock_t buffer_lock; &#x2F;* protects access to buffer, head and tail *&#x2F;  </span><br><span class="line">    struct fasync_struct *fasync;  &#x2F;&#x2F;异步通知函数  </span><br><span class="line">    struct evdev *evdev;           &#x2F;&#x2F;evdev设备  </span><br><span class="line">    struct list_head node;         &#x2F;&#x2F; evdev_client 链表项  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个结构在进程打开event0设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。</p>
<h3 id="Input输入子系统数据结构关系图"><a href="#Input输入子系统数据结构关系图" class="headerlink" title="Input输入子系统数据结构关系图"></a><strong>Input输入子系统数据结构关系图</strong></h3><p><strong><img src="https://images0.cnblogs.com/blog/536940/201308/31151249-8e3914e534a0414288a29215109f75b9.jpg" alt="img"></strong></p>
<hr>
<h2 id="input输入子系统主要函数分析"><a href="#input输入子系统主要函数分析" class="headerlink" title="input输入子系统主要函数分析"></a>input输入子系统主要函数分析</h2><h3 id="各种注册函数"><a href="#各种注册函数" class="headerlink" title="各种注册函数"></a>各种注册函数</h3><p>　　每种数据结构都代表一类对象，所以每种数据结构都会对应一个注册函数，他们都定义在子系统核心的input.c文件中。</p>
<p>　　主要有三个注册函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input_register_device    &#x2F;&#x2F;向内核注册一个input设备</span><br><span class="line">input_register_handle    &#x2F;&#x2F;向内核注册一个handle结构</span><br><span class="line">input_register_handler   &#x2F;&#x2F;注册一个事件处理器</span><br></pre></td></tr></table></figure>





<h4 id="1-input-register-device"><a href="#1-input-register-device" class="headerlink" title="1.input_register_device"></a>1.input_register_device</h4><p>　　input_register_device 注册一个input输入设备，这个注册函数在三个注册函数中是驱动程序唯一调用的。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     static atomic_t input_no &#x3D; ATOMIC_INIT(0);    </span><br><span class="line"> 4         &#x2F;&#x2F;这个原子变量，代表总共注册的input设备，每注册一个加1，因为是静态变量，所以每次调用都不会清零的  </span><br><span class="line"> 5     struct input_handler *handler;  </span><br><span class="line"> 6     const char *path;  </span><br><span class="line"> 7     int error;  </span><br><span class="line"> 8   </span><br><span class="line"> 9     __set_bit(EV_SYN, dev-&gt;evbit);  &#x2F;&#x2F;EN_SYN 这个是设备都要支持的事件类型，所以要设置  </span><br><span class="line">10   </span><br><span class="line">11     &#x2F;* </span><br><span class="line">12      * If delay and period are pre-set by the driver, then autorepeating </span><br><span class="line">13      * is handled by the driver itself and we don&#39;t do it in input.c. </span><br><span class="line">14      *&#x2F;  </span><br><span class="line">15         &#x2F;&#x2F; 这个内核定时器是为了重复按键而设置的  </span><br><span class="line">16     init_timer(&amp;dev-&gt;timer);  </span><br><span class="line">17     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;  </span><br><span class="line">18         dev-&gt;timer.data &#x3D; (long) dev;  </span><br><span class="line">19         dev-&gt;timer.function &#x3D; input_repeat_key;  </span><br><span class="line">20         dev-&gt;rep[REP_DELAY] &#x3D; 250;  </span><br><span class="line">21         dev-&gt;rep[REP_PERIOD] &#x3D; 33;  </span><br><span class="line">22         &#x2F;&#x2F;如果没有定义有关重复按键的相关值，就用内核默认的  </span><br><span class="line">23     &#125;  </span><br><span class="line">24   </span><br><span class="line">25     if (!dev-&gt;getkeycode)  </span><br><span class="line">26         dev-&gt;getkeycode &#x3D; input_default_getkeycode;  </span><br><span class="line">27     if (!dev-&gt;setkeycode)  </span><br><span class="line">28         dev-&gt;setkeycode &#x3D; input_default_setkeycode;  </span><br><span class="line">29         &#x2F;&#x2F;以上设置的默认函数由input核心提供  </span><br><span class="line">30     dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,  </span><br><span class="line">31              (unsigned long) atomic_inc_return(&amp;input_no) - 1);  </span><br><span class="line">32         &#x2F;&#x2F;设置input_dev中device的名字，这个名字会在&#x2F;class&#x2F;input中出现  </span><br><span class="line">33     error &#x3D; device_add(&amp;dev-&gt;dev);  </span><br><span class="line">34         &#x2F;&#x2F;将device加入到linux设备模型中去  </span><br><span class="line">35     if (error)  </span><br><span class="line">36         return error;  </span><br><span class="line">37   </span><br><span class="line">38     path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);  </span><br><span class="line">39     printk(KERN_INFO &quot;input: %s as %s\n&quot;,  </span><br><span class="line">40         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);  </span><br><span class="line">41     kfree(path);  </span><br><span class="line">42         &#x2F;&#x2F;这个得到路径名称，并打印出来  </span><br><span class="line">43     error &#x3D; mutex_lock_interruptible(&amp;input_mutex);  </span><br><span class="line">44     if (error) &#123;  </span><br><span class="line">45         device_del(&amp;dev-&gt;dev);  </span><br><span class="line">46         return error;  </span><br><span class="line">47     &#125;  </span><br><span class="line">48   </span><br><span class="line">49     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);  </span><br><span class="line">50         &#x2F;&#x2F; 将新分配的input设备连接到input_dev_list链表上  </span><br><span class="line">51     list_for_each_entry(handler, &amp;input_handler_list, node)  </span><br><span class="line">52         input_attach_handler(dev, handler);  </span><br><span class="line">53         &#x2F;&#x2F;遍历input_handler_list链表，配对 input_dev 和 input_handler  </span><br><span class="line">54         &#x2F;&#x2F;input_attach_handler 这个函数是配对的关键 </span><br><span class="line">55     input_wakeup_procfs_readers();  </span><br><span class="line">56         &#x2F;&#x2F; 和proc文件系统有关 </span><br><span class="line">57     mutex_unlock(&amp;input_mutex);  </span><br><span class="line">58   </span><br><span class="line">59     return 0;  </span><br><span class="line">60    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　input_register_device完成的主要功能就是：初始化一些默认的值，将自己的device结构添加到linux设备模型当中，将input_dev添加到input_dev_list链表中，然后寻找合适的handler与input_handler配对,配对的核心函数是input_attach_handler。</p>
<p>　　下面看看input_attach_handler函数</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     const struct input_device_id *id;  </span><br><span class="line"> 4     int error;  </span><br><span class="line"> 5   </span><br><span class="line"> 6     if (handler-&gt;blacklist &amp;&amp; input_match_device(handler-&gt;blacklist, dev))  </span><br><span class="line"> 7         return -ENODEV;  </span><br><span class="line"> 8         &#x2F;&#x2F;blacklist是handler因该忽略的input设备类型，如果应该忽略的input设备也配对上了，那就出错了  </span><br><span class="line"> 9     id &#x3D; input_match_device(handler-&gt;id_table, dev);  </span><br><span class="line">10         &#x2F;&#x2F;这个是主要的配对函数，主要比较id中的各项</span><br><span class="line">11     if (!id)  </span><br><span class="line">12         return -ENODEV;  </span><br><span class="line">13   </span><br><span class="line">14     error &#x3D; handler-&gt;connect(handler, dev, id);  </span><br><span class="line">15         &#x2F;&#x2F;配对成功调用handler的connect函数，这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构</span><br><span class="line">16     if (error &amp;&amp; error !&#x3D; -ENODEV)  </span><br><span class="line">17         printk(KERN_ERR  </span><br><span class="line">18             &quot;input: failed to attach handler %s to device %s, &quot;  </span><br><span class="line">19             &quot;error: %d\n&quot;,  </span><br><span class="line">20             handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);  </span><br><span class="line">21         &#x2F;&#x2F;出错处理  </span><br><span class="line">22     return error;  </span><br><span class="line">23  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　input_attach_handler的主要功能就是调用了两个函数，一个input_match_device进行配对，一个connect处理配对成功后续工作。</p>
<p>　　下面看看input_match_device函数</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 static const struct input_device_id *input_match_device(const struct input_device_id *id,  </span><br><span class="line"> 2                             struct input_dev *dev)  </span><br><span class="line"> 3 &#123;  </span><br><span class="line"> 4     int i;  </span><br><span class="line"> 5         &#x2F;&#x2F;函数传入的参数是所要配对handler的id_table，下面遍历这个id_table寻找合适的id进行配对  </span><br><span class="line"> 6     for (; id-&gt;flags || id-&gt;driver_info; id++) &#123;  </span><br><span class="line"> 7         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)  </span><br><span class="line"> 8             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)  </span><br><span class="line"> 9                 continue;  </span><br><span class="line">10                 ......  </span><br><span class="line">11                 &#x2F;&#x2F;针对handler-&gt;id-&gt;flag，比较不同的类型  </span><br><span class="line">12                 &#x2F;&#x2F;如果比较成功进入下面的宏，否则进入下一个id  </span><br><span class="line">13                 MATCH_BIT(evbit,  EV_MAX);  </span><br><span class="line">14             ......    </span><br><span class="line">15         MATCH_BIT(swbit,  SW_MAX);  </span><br><span class="line">16   </span><br><span class="line">17   </span><br><span class="line">18         return id;  </span><br><span class="line">19     &#125;  </span><br><span class="line">20  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　此函数主要是比较input_dev中的id和handler支持的id,这个存放在handler的id_table中。</p>
<p>　　首先看id-&gt;driver_info有没有设置，如果设置了说明它匹配所有的id，evdev就是这个样的handler<br>　　然后依据id-&gt;flag来比较内容，如果都比较成功进入MATCH_BIT，这个宏是用来按位进行比较的，功能是比较所支持事件的类型，只有所有的位都匹配才成功返回，否则进行下一个id的比较。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 #define MATCH_BIT(bit, max) \  </span><br><span class="line">2 for (i &#x3D; 0; i &lt; BITS_TO_LONGS(max); i++) \  </span><br><span class="line">3     if ((id-&gt;bit[i] &amp; dev-&gt;bit[i]) !&#x3D; id-&gt;bit[i]) \  </span><br><span class="line">4         break; \  </span><br><span class="line">5 if (i !&#x3D; BITS_TO_LONGS(max)) \  </span><br><span class="line">6     continue;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个宏对于每种事件类型，以及每种事件类型支持的编码所有的位都比较一次，看handler的id是否支持，如果有一个不支持就不会比较成功，进入下一个id进行比较。<br>　　对于connect函数，每种事件处理器的实现都有差异，但原理都相同。</p>
<p>　　因为触摸屏用的事件处理器为evdev，下面看看evdev的connect函数evdev_connect</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev,  </span><br><span class="line"> 2              const struct input_device_id *id)  </span><br><span class="line"> 3 &#123;  </span><br><span class="line"> 4         &#x2F;&#x2F;此函数传入三个参数，分别是：handler，dev,id  </span><br><span class="line"> 5     struct evdev *evdev;  </span><br><span class="line"> 6     int minor;  </span><br><span class="line"> 7     int error;  </span><br><span class="line"> 8   </span><br><span class="line"> 9   </span><br><span class="line">10     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)  </span><br><span class="line">11         if (!evdev_table[minor])  </span><br><span class="line">12             break;  </span><br><span class="line">13         &#x2F;&#x2F;EVDEV_MINORS为32，说明evdev这个handler可以同时有32个输入设备和他配对，evdev_table中以minor（非次设备号，但是有一个换算关系）存放evdev结构体，后面要详细分析这个结构体  </span><br><span class="line">14     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  </span><br><span class="line">15         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);  </span><br><span class="line">16         return -ENFILE;  </span><br><span class="line">17     &#125;  </span><br><span class="line">18         &#x2F;&#x2F;这个说明32个位置全都被占用了，连接失败  </span><br><span class="line">19     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);  </span><br><span class="line">20         &#x2F;&#x2F;分配一个evdev结构体，这个结构体是evdev事件处理器特有的，后面会详细分析  </span><br><span class="line">21     if (!evdev)  </span><br><span class="line">22         return -ENOMEM;  </span><br><span class="line">23   </span><br><span class="line">24   </span><br><span class="line">25     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);  </span><br><span class="line">26     spin_lock_init(&amp;evdev-&gt;client_lock);  </span><br><span class="line">27     mutex_init(&amp;evdev-&gt;mutex);  </span><br><span class="line">28     init_waitqueue_head(&amp;evdev-&gt;wait);  </span><br><span class="line">29         &#x2F;&#x2F;初始化结构体的一些成员  </span><br><span class="line">30     dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);  </span><br><span class="line">31         &#x2F;&#x2F;这个是设置evdev中device的名字，他将出现在&#x2F;class&#x2F;input中。  </span><br><span class="line">32         &#x2F;&#x2F;前面也有一个device是input_dev的，名字是input（n），注意与他的不同  </span><br><span class="line">33         &#x2F;&#x2F;这个结构是配对后的虚拟设备结构，没有对应的硬件，但是通过它可以找到相关的硬件  </span><br><span class="line">34     evdev-&gt;exist &#x3D; 1;  </span><br><span class="line">35     evdev-&gt;minor &#x3D; minor;  </span><br><span class="line">36   </span><br><span class="line">37   </span><br><span class="line">38     evdev-&gt;handle.dev &#x3D; input_get_device(dev);  </span><br><span class="line">39     evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);  </span><br><span class="line">40     evdev-&gt;handle.handler &#x3D; handler;  </span><br><span class="line">41     evdev-&gt;handle.private &#x3D; evdev;  </span><br><span class="line">42         &#x2F;&#x2F;因为evdev中包含handle了，所以初始化它就可以了，这样就连接了input_handler与input_dev  </span><br><span class="line">43     evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor); &#x2F;&#x2F;注意：这个minor不是真正的次设备号，还要加上EVDEV_MINOR_BASE  </span><br><span class="line">44     evdev-&gt;dev.class &#x3D; &amp;input_class;  </span><br><span class="line">45     evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;  </span><br><span class="line">46         &#x2F;&#x2F;配对生成的device，父设备是与他相关连的input_dev  </span><br><span class="line">47     evdev-&gt;dev.release &#x3D; evdev_free;  </span><br><span class="line">48     device_initialize(&amp;evdev-&gt;dev);  </span><br><span class="line">49   </span><br><span class="line">50   </span><br><span class="line">51     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);  </span><br><span class="line">52         &#x2F;&#x2F;注册handle结构体,这个函数后面详细分析  </span><br><span class="line">53     if (error)  </span><br><span class="line">54         goto err_free_evdev;  </span><br><span class="line">55   </span><br><span class="line">56   </span><br><span class="line">57     error &#x3D; evdev_install_chrdev(evdev);  </span><br><span class="line">58         &#x2F;&#x2F;这个函数只做了一件事，就是把evdev结构保存到evdev_table中，这个数组也minor为索引  </span><br><span class="line">59     if (error)  </span><br><span class="line">60         goto err_unregister_handle;  </span><br><span class="line">61   </span><br><span class="line">62   </span><br><span class="line">63     error &#x3D; device_add(&amp;evdev-&gt;dev);  </span><br><span class="line">64         &#x2F;&#x2F;注册到linux设备模型中  </span><br><span class="line">65     if (error)  </span><br><span class="line">66         goto err_cleanup_evdev;  </span><br><span class="line">67   </span><br><span class="line">68   </span><br><span class="line">69     return 0;  </span><br><span class="line">70   </span><br><span class="line">71   </span><br><span class="line">72   err_cleanup_evdev:  </span><br><span class="line">73     evdev_cleanup(evdev);  </span><br><span class="line">74   err_unregister_handle:  </span><br><span class="line">75     input_unregister_handle(&amp;evdev-&gt;handle);  </span><br><span class="line">76   err_free_evdev:  </span><br><span class="line">77     put_device(&amp;evdev-&gt;dev);  </span><br><span class="line">78     return error;  </span><br><span class="line">79 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evdev_connect函数做配对后的善后工作，分配一个evdev结构体，并初始化相关成员，evdev结构体中有input_handle结构，初始化并注册之。</p>
<h4 id="2-input-register-handle"><a href="#2-input-register-handle" class="headerlink" title="2.input_register_handle"></a>2.input_register_handle</h4><p>　　input_register_handle 注册一个input_handle结构体，比较简单</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_handle(struct input_handle *handle)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     struct input_handler *handler &#x3D; handle-&gt;handler;  </span><br><span class="line"> 4     struct input_dev *dev &#x3D; handle-&gt;dev;  </span><br><span class="line"> 5     int error;  </span><br><span class="line"> 6   </span><br><span class="line"> 7   </span><br><span class="line"> 8     &#x2F;* </span><br><span class="line"> 9      * We take dev-&gt;mutex here to prevent race with </span><br><span class="line">10      * input_release_device(). </span><br><span class="line">11      *&#x2F;  </span><br><span class="line">12     error &#x3D; mutex_lock_interruptible(&amp;dev-&gt;mutex);  </span><br><span class="line">13     if (error)  </span><br><span class="line">14         return error;  </span><br><span class="line">15     list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);  </span><br><span class="line">16         &#x2F;&#x2F;将handle的d_node，链接到其相关的input_dev的h_list链表中  </span><br><span class="line">17     mutex_unlock(&amp;dev-&gt;mutex);  </span><br><span class="line">18   </span><br><span class="line">19   </span><br><span class="line">20     list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);  </span><br><span class="line">21         &#x2F;&#x2F;将handle的h_node，链接到其相关的input_handler的h_list链表中  </span><br><span class="line">22     if (handler-&gt;start)  </span><br><span class="line">23         handler-&gt;start(handle);  </span><br><span class="line">24   </span><br><span class="line">25   </span><br><span class="line">26     return 0;  </span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个函数基本没做什么事，就是把一个handle结构体通过d_node链表项，分别链接到input_dev的h_list,input_handler的h_list上。</p>
<p>　　以后通过这个h_list就可以遍历相关的input_handle了。</p>
<h4 id="3-input-register-handler"><a href="#3-input-register-handler" class="headerlink" title="3. input_register_handler"></a>3. input_register_handler</h4><p> 　input_register_handler 注册一个input_handler结构体</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_handler(struct input_handler *handler)  </span><br><span class="line"> 2  &#123;  </span><br><span class="line"> 3     struct input_dev *dev;  </span><br><span class="line"> 4     int retval;  </span><br><span class="line"> 5   </span><br><span class="line"> 6   </span><br><span class="line"> 7     retval &#x3D; mutex_lock_interruptible(&amp;input_mutex);  </span><br><span class="line"> 8     if (retval)  </span><br><span class="line"> 9         return retval;  </span><br><span class="line">10   </span><br><span class="line">11   </span><br><span class="line">12     INIT_LIST_HEAD(&amp;handler-&gt;h_list);  </span><br><span class="line">13   </span><br><span class="line">14   </span><br><span class="line">15     if (handler-&gt;fops !&#x3D; NULL) &#123;  </span><br><span class="line">16         if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;  </span><br><span class="line">17             retval &#x3D; -EBUSY;  </span><br><span class="line">18             goto out;  </span><br><span class="line">19         &#125;  </span><br><span class="line">20         input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;  </span><br><span class="line">21     &#125;  </span><br><span class="line">22         &#x2F;&#x2F;input_table，每个注册的handler都会将自己保存到这里，索引值为handler-&gt;minor右移5为，也就是除以32  </span><br><span class="line">23         &#x2F;&#x2F;为什么会这样呢，因为每个handler都会处理最大32个input_dev，所以要以minor的32为倍数对齐,这个minor是传进来的handler的MINOR_BASE  </span><br><span class="line">24         &#x2F;&#x2F;每一个handler都有一个这一个MINOR_BASE，以evdev为例,EVDEV_MINOR_BASE &#x3D; 64,可以看出系统总共可以注册8个handler  </span><br><span class="line">25     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);  </span><br><span class="line">26         &#x2F;&#x2F;连接到input_handler_list链表中  </span><br><span class="line">27     list_for_each_entry(dev, &amp;input_dev_list, node)  </span><br><span class="line">28         input_attach_handler(dev, handler);  </span><br><span class="line">29         &#x2F;&#x2F;又是配对，不过这次遍历input_dev，和注册input_dev过程一样的  </span><br><span class="line">30     input_wakeup_procfs_readers();  </span><br><span class="line">31   </span><br><span class="line">32   </span><br><span class="line">33  out:  </span><br><span class="line">34     mutex_unlock(&amp;input_mutex);  </span><br><span class="line">35     return retval;  </span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个函数其实和input_register_device大同小异，都是注册，都要配对。</p>
<h4 id="4-函数调用流程"><a href="#4-函数调用流程" class="headerlink" title="4.函数调用流程"></a>4.函数调用流程</h4><p> <img src="https://images0.cnblogs.com/blog/536940/201309/01010919-d1f3032c7fa24c259b80144a7d409e25.png" alt="img"></p>
<hr>
<h2 id="input输入子系统事件处理机制"><a href="#input输入子系统事件处理机制" class="headerlink" title="input输入子系统事件处理机制"></a>input输入子系统事件处理机制</h2><p><img src="https://images0.cnblogs.com/blog/536940/201308/31170413-da662445d343456eb67d784b342e4ffe.png" alt="img"></p>
<p>　　作为输入设备的驱动开发者，需要做以下几步：</p>
<ol>
<li>在驱动加载模块中，设置你的input设备支持的事件类型，类型参见表1设置</li>
<li>注册中断处理函数，例如键盘设备需要编写按键的抬起、放下，触摸屏设备需要编写按下、抬起、绝对移动，鼠标设备需要编写单击、抬起、相对移动，并且需要在必要的时候提交硬件数据（键值/坐标/状态等等）</li>
<li>将输入设备注册到输入子系统中</li>
</ol>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.chinaunix.net/uid/26620753.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid/26620753.html</a></p>
<p><a href="http://blog.csdn.net/ielife/article/details/7798952" target="_blank" rel="noopener">http://blog.csdn.net/ielife/article/details/7798952</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%88%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E4%B8%BA%E4%BE%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%88%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E4%B8%BA%E4%BE%8B%EF%BC%89/" class="post-title-link" itemprop="url">【转载】input子系统整体流程全面分析（触摸屏驱动为例）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-07 18:54:21 / Modified: 19:02:09" itemprop="dateCreated datePublished" datetime="2021-01-07T18:54:21+08:00">2021-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3294356.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3294356.html】</a></p>
<h1 id="【驱动】input子系统整体流程全面分析（触摸屏驱动为例）"><a href="#【驱动】input子系统整体流程全面分析（触摸屏驱动为例）" class="headerlink" title="【驱动】input子系统整体流程全面分析（触摸屏驱动为例）"></a><a href="https://www.cnblogs.com/lcw/p/3294356.html" target="_blank" rel="noopener">【驱动】input子系统整体流程全面分析（触摸屏驱动为例）</a></h1><h2 id="input输入子系统整体流程"><a href="#input输入子系统整体流程" class="headerlink" title="input输入子系统整体流程"></a>input输入子系统整体流程</h2><p>　　</p>
<p>　　input子系统在内核中的实现，包括输入子系统（Input Core），事件处理层（Event Handler）和设备驱动层。</p>
<p>　　在开头部分会从设备驱动层做为线索，分析输入子系统和事件处理层是如何配合的，最后从用户角度出发，从“/dev/input/*”接口如何使用输入子系统提供的服务。</p>
<p>　　既然需要详细分析，有一个这样的流程图能够帮助我们在被绕进代码的过程中，找到出口，你能够知道你现在位于代码框架的什么位置，不会忘记正在分析的代码的“身份”。</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/01112058-b025a20bc60a469cb1ae2def7eeeab84.png" alt="img"></p>
<h2 id="设备驱动层注册到input子系统"><a href="#设备驱动层注册到input子系统" class="headerlink" title="设备驱动层注册到input子系统"></a>设备驱动层注册到input子系统</h2><p>　　以S3C2440触摸屏的驱动代码代例，初始化函数定义了struct input_dev input结构体，它用于描述一个输入子系统设备。</p>
<p>　　任何驱动设备如果想标明自己是输入设备，都应该通过初始化这样的结构体，并且调用input_allocate_device（）函数进行注册。</p>
<p>　　了解这一过程，先看一下struct input_dev结构体的内容：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_dev &#123;  </span><br><span class="line"> 2   </span><br><span class="line"> 3     void *private;              &#x2F;&#x2F;输入设备私有指针，一般指向用于描述设备驱动层的设备结构  </span><br><span class="line"> 4   </span><br><span class="line"> 5     const char *name;           &#x2F;&#x2F;提供给用户的输入设备的名称  </span><br><span class="line"> 6     const char *phys;           &#x2F;&#x2F;提供给编程者的设备节点的名称  </span><br><span class="line"> 7     const char *uniq;           &#x2F;&#x2F;指定唯一的ID号，就像MAC地址一样  </span><br><span class="line"> 8     struct input_id id;         &#x2F;&#x2F;输入设备标识ID，用于和事件处理层进行匹配  </span><br><span class="line"> 9   </span><br><span class="line">10     unsigned long evbit[NBITS(EV_MAX)];     &#x2F;&#x2F;位图，记录设备支持的事件类型  </span><br><span class="line">11     unsigned long keybit[NBITS(KEY_MAX)];       &#x2F;&#x2F;位图，记录设备支持的按键类型  </span><br><span class="line">12     unsigned long relbit[NBITS(REL_MAX)];       &#x2F;&#x2F;位图，记录设备支持的相对坐标  </span><br><span class="line">13     unsigned long absbit[NBITS(ABS_MAX)];       &#x2F;&#x2F;位图，记录设备支持的绝对坐标  </span><br><span class="line">14     unsigned long mscbit[NBITS(MSC_MAX)];   &#x2F;&#x2F;位图，记录设备支持的其他功能  </span><br><span class="line">15     unsigned long ledbit[NBITS(LED_MAX)];       &#x2F;&#x2F;位图，记录设备支持的指示灯  </span><br><span class="line">16     unsigned long sndbit[NBITS(SND_MAX)];       &#x2F;&#x2F;位图，记录设备支持的声音或警报  </span><br><span class="line">17     unsigned long ffbit[NBITS(FF_MAX)];     &#x2F;&#x2F;位图，记录设备支持的作用力功能  </span><br><span class="line">18     unsigned long swbit[NBITS(SW_MAX)];     &#x2F;&#x2F;位图，记录设备支持的开关功能  </span><br><span class="line">19   </span><br><span class="line">20     unsigned int keycodemax;        &#x2F;&#x2F;设备支持的最大按键值个数  </span><br><span class="line">21     unsigned int keycodesize;       &#x2F;&#x2F;每个按键的字节大小  </span><br><span class="line">22     void *keycode;              &#x2F;&#x2F;指向按键池，即指向按键值数组首地址  </span><br><span class="line">23     int (*setkeycode)(struct input_dev *dev, int scancode, int keycode);    &#x2F;&#x2F;修改按键值  </span><br><span class="line">24     int (*getkeycode)(struct input_dev *dev, int scancode, int *keycode);   &#x2F;&#x2F;获取按键值  </span><br><span class="line">25   </span><br><span class="line">26     struct ff_device *ff;           &#x2F;&#x2F;用于强制更新输入设备的部分内容  </span><br><span class="line">27   </span><br><span class="line">28     unsigned int repeat_key;        &#x2F;&#x2F;重复按键的键值  </span><br><span class="line">29     struct timer_list timer;        &#x2F;&#x2F;设置当有连击时的延时定时器  </span><br><span class="line">30   </span><br><span class="line">31     int state;      &#x2F;&#x2F;设备状态  </span><br><span class="line">32   </span><br><span class="line">33     int sync;       &#x2F;&#x2F;同步事件完成标识，为1说明事件同步完成  </span><br><span class="line">34   </span><br><span class="line">35     int abs[ABS_MAX + 1];       &#x2F;&#x2F;记录坐标的值  </span><br><span class="line">36     int rep[REP_MAX + 1];       &#x2F;&#x2F;记录重复按键的参数值  </span><br><span class="line">37   </span><br><span class="line">38     unsigned long key[NBITS(KEY_MAX)];      &#x2F;&#x2F;位图，按键的状态  </span><br><span class="line">39     unsigned long led[NBITS(LED_MAX)];      &#x2F;&#x2F;位图，led的状态  </span><br><span class="line">40     unsigned long snd[NBITS(SND_MAX)];      &#x2F;&#x2F;位图，声音的状态  </span><br><span class="line">41     unsigned long sw[NBITS(SW_MAX)];            &#x2F;&#x2F;位图，开关的状态  </span><br><span class="line">42   </span><br><span class="line">43     int absmax[ABS_MAX + 1];                    &#x2F;&#x2F;位图，记录坐标的最大值  </span><br><span class="line">44     int absmin[ABS_MAX + 1];                    &#x2F;&#x2F;位图，记录坐标的最小值  </span><br><span class="line">45     int absfuzz[ABS_MAX + 1];                   &#x2F;&#x2F;位图，记录坐标的分辨率  </span><br><span class="line">46     int absflat[ABS_MAX + 1];                   &#x2F;&#x2F;位图，记录坐标的基准值  </span><br><span class="line">47   </span><br><span class="line">48     int (*open)(struct input_dev *dev);         &#x2F;&#x2F;输入设备打开函数  </span><br><span class="line">49     void (*close)(struct input_dev *dev);           &#x2F;&#x2F;输入设备关闭函数  </span><br><span class="line">50     int (*flush)(struct input_dev *dev, struct file *file); &#x2F;&#x2F;输入设备断开后刷新函数  </span><br><span class="line">51     int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);   &#x2F;&#x2F;事件处理  </span><br><span class="line">52   </span><br><span class="line">53     struct input_handle *grab;      &#x2F;&#x2F;类似私有指针，可以直接访问到事件处理接口event  </span><br><span class="line">54   </span><br><span class="line">55     struct mutex mutex;     &#x2F;&#x2F;用于open、close函数的连续访问互斥  </span><br><span class="line">56     unsigned int users;     &#x2F;&#x2F;设备使用计数  </span><br><span class="line">57   </span><br><span class="line">58     struct class_device cdev;   &#x2F;&#x2F;输入设备的类信息  </span><br><span class="line">59     union &#123;             &#x2F;&#x2F;设备结构体  </span><br><span class="line">60         struct device *parent;  </span><br><span class="line">61     &#125; dev;  </span><br><span class="line">62   </span><br><span class="line">63     struct list_head    h_list; &#x2F;&#x2F;handle链表  </span><br><span class="line">64     struct list_head    node;   &#x2F;&#x2F;input_dev链表  </span><br><span class="line">65 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　就这样赤裸裸的看上面的结构体，会觉得摸不着头脑，但是有一点是确定的，我们在写输入设备驱动时会定义这样一个输入设备结构体，并调用input_allocate_device()函数，这个函数的功能是为新添加的输入设备分配内存，如果成功，将返回input_dev *的指针结构，因此在写驱动的时候应该接受返回值，作为驱动层获得了一个新的输入设备操作的接口。</p>
<p>　　那么<strong>input_allocate_device()</strong>函数做了什么呢？打开函数看一下（input.c中实现）：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_dev *input_allocate_device(void)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     struct input_dev *dev;  </span><br><span class="line"> 4   </span><br><span class="line"> 5 &#x2F;&#x2F;动态申请内存，使用GFP_KERNEL方式，注意GFP_KERNEL可能导致睡眠，不能在中断中调用这个函数  </span><br><span class="line"> 6     dev &#x3D; kzalloc(sizeof(struct input_dev), GFP_KERNEL);  </span><br><span class="line"> 7 &#x2F;&#x2F;分配成功执行的代码，进行成员的默认填充  </span><br><span class="line"> 8     if (dev) &#123;  </span><br><span class="line"> 9         dev-&gt;cdev.class &#x3D; &amp;input_class;          &#x2F;&#x2F;支持热插拔的结构体  </span><br><span class="line">10         dev-&gt;cdev.groups &#x3D; input_dev_attr_groups; &#x2F;&#x2F;描述设备的硬件信息和支持的事件类型  </span><br><span class="line">11         class_device_initialize(&amp;dev-&gt;cdev);     &#x2F;&#x2F;类设备初始化，添加进input类设备模型中  </span><br><span class="line">12         mutex_init(&amp;dev-&gt;mutex);             &#x2F;&#x2F;初始化互斥锁  </span><br><span class="line">13         INIT_LIST_HEAD(&amp;dev-&gt;h_list);        &#x2F;&#x2F;初始化handle链表  </span><br><span class="line">14         INIT_LIST_HEAD(&amp;dev-&gt;node);          &#x2F;&#x2F;初始化输入设备链表  </span><br><span class="line">15   </span><br><span class="line">16     &#125;  </span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　通过input_allocate_device()函数，我们设备驱动现在持有的input_dev里面就被赋予了input的“形象”，但是还需要我们去充实一下“内在”，因此，设备驱动程序，还需要为自己的设备增加自己的特性，才能创造独有的设备“形象”。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_dev *input_dev &#x3D; input_allocate_device();  </span><br><span class="line"> 2 input_dev-&gt;name &#x3D; &quot;s3c2410 Touchscreen&quot;;  </span><br><span class="line"> 3 input_dev-&gt;phys &#x3D; &quot;s3c2410ts&#x2F;input0&quot;;  </span><br><span class="line"> 4 input_dev-&gt;id.bustype &#x3D; BUS_HOST;  </span><br><span class="line"> 5 input_dev-&gt;id.vendor &#x3D; 0x0001;  </span><br><span class="line"> 6 input_dev-&gt;id.product &#x3D; 0x0002;  </span><br><span class="line"> 7 input_dev-&gt;id.version &#x3D; 0x0100;  </span><br><span class="line"> 8 input_dev-&gt;evbit[0] &#x3D; BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);  </span><br><span class="line"> 9 input_dev-&gt;keybit[BIT_WORD(BTN_TOUCH)] &#x3D; BIT_MASK(BTN_TOUCH);   </span><br><span class="line">10 input_set_abs_params(input_dev, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);  </span><br><span class="line">11 input_set_abs_params(input_dev, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);  </span><br><span class="line">12 input_set_abs_params(input_dev, ABS_PRESSURE, PRESSURE_MIN, PRESSURE_MAX, 0, 0);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这部分完成了输入设备的初始化工作。但是这仅是初始化自己的“特点”，还需要通知输入子系统有这样一个新设备诞生了，这就需要调用输入子系统的注册函数input_register_device（input_dev）来完成。</p>
<p>　　<strong>input_register_device()</strong>用于注册一个输入设备。那么<strong>注册过程是怎样的呢？这是一个重点，</strong>在下面的代码中进行注释分析：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     &#x2F;* 用于记录输入设备名称的索引值 *&#x2F;  </span><br><span class="line"> 4     static atomic_t input_no &#x3D; ATOMIC_INIT(0);  </span><br><span class="line"> 5     &#x2F;* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 *&#x2F;  </span><br><span class="line"> 6     struct input_handler *handler;  </span><br><span class="line"> 7     const char *path;  </span><br><span class="line"> 8     int error;  </span><br><span class="line"> 9   </span><br><span class="line">10     &#x2F;* 默认所有的输入设备都支持EV_SYN同步事件 *&#x2F;  </span><br><span class="line">11     set_bit(EV_SYN, dev-&gt;evbit);  </span><br><span class="line">12   </span><br><span class="line">13     &#x2F;* </span><br><span class="line">14      * 如果设备驱动没有指定重复按键（连击），系统默认提供以下的支持 </span><br><span class="line">15      * 其中init_timer为连击产生的定时器，时间到调用input_repeat_key函数 </span><br><span class="line">16      * 上报，REP_DELAY用于设置重复按键的键值，REP_PERIOD设置延时时间 </span><br><span class="line">17      *&#x2F;  </span><br><span class="line">18     init_timer(&amp;dev-&gt;timer);  </span><br><span class="line">19     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;  </span><br><span class="line">20         dev-&gt;timer.data &#x3D; (long) dev;  </span><br><span class="line">21         dev-&gt;timer.function &#x3D; input_repeat_key;  </span><br><span class="line">22         dev-&gt;rep[REP_DELAY] &#x3D; 250;  </span><br><span class="line">23         dev-&gt;rep[REP_PERIOD] &#x3D; 33;  </span><br><span class="line">24     &#125;  </span><br><span class="line">25   </span><br><span class="line">26     &#x2F;* 如果设备驱动没有设置自己的获取键值的函数，系统默认 *&#x2F;  </span><br><span class="line">27     if (!dev-&gt;getkeycode)  </span><br><span class="line">28         dev-&gt;getkeycode &#x3D; input_default_getkeycode;  </span><br><span class="line">29   </span><br><span class="line">30     &#x2F;* 如果设备驱动没有指定按键重置函数，系统默认 *&#x2F;  </span><br><span class="line">31     if (!dev-&gt;setkeycode)  </span><br><span class="line">32         dev-&gt;setkeycode &#x3D; input_default_setkeycode;  </span><br><span class="line">33   </span><br><span class="line">34     &#x2F;* 重要，把设备挂到全局的input子系统设备链表input_dev_list上 *&#x2F;  </span><br><span class="line">35     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);  </span><br><span class="line">36   </span><br><span class="line">37     &#x2F;* 动态获取input设备的ID号，名称为input*，其中后面的“*”动态获得，唯一的 *&#x2F;  </span><br><span class="line">38     snprintf(dev-&gt;cdev.class_id, sizeof(dev-&gt;cdev.class_id),  </span><br><span class="line">39          &quot;input%ld&quot;, (unsigned long) atomic_inc_return(&amp;input_no) - 1);  </span><br><span class="line">40   </span><br><span class="line">41     &#x2F;* 如果这个值没有设置，系统把输入设备挂入设备链表 *&#x2F;  </span><br><span class="line">42     if (!dev-&gt;cdev.dev)  </span><br><span class="line">43         dev-&gt;cdev.dev &#x3D; dev-&gt;dev.parent;  </span><br><span class="line">44   </span><br><span class="line">45     &#x2F;* 在&#x2F;sys目录下创建设备目录和文件 *&#x2F;  </span><br><span class="line">46     error &#x3D; class_device_add(&amp;dev-&gt;cdev);  </span><br><span class="line">47     if (error)  </span><br><span class="line">48         return error;  </span><br><span class="line">49   </span><br><span class="line">50     &#x2F;* 获取并打印设备的绝对路径名称 *&#x2F;  </span><br><span class="line">51     path &#x3D; kobject_get_path(&amp;dev-&gt;cdev.kobj, GFP_KERNEL);  </span><br><span class="line">52     printk(KERN_INFO &quot;input: %s as %s\n&quot;,  </span><br><span class="line">53         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);  </span><br><span class="line">54     kfree(path);  </span><br><span class="line">55   </span><br><span class="line">56     &#x2F;* 核心重点，input设备在增加到input_dev_list链表上之后，会查找 </span><br><span class="line">57      * input_handler_list事件处理链表上的handler进行匹配，这里的匹配 </span><br><span class="line">58      * 方式与设备模型的device和driver匹配过程很相似，所有的input </span><br><span class="line">59      * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list </span><br><span class="line">60      * 上，进行“匹配相亲”*&#x2F;  </span><br><span class="line">61     list_for_each_entry(handler, &amp;input_handler_list, node)  </span><br><span class="line">62         input_attach_handler(dev, handler);  </span><br><span class="line">63   </span><br><span class="line">64     input_wakeup_procfs_readers();  </span><br><span class="line">65   </span><br><span class="line">66     return 0;  </span><br><span class="line">67 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p>
<ul>
<li><p>进一步初始化输入设备，例如连击事件；</p>
</li>
<li><p>注册输入设备到input类中；</p>
</li>
<li><p>把输入设备挂到输入设备链表input_dev_list中；</p>
</li>
<li><p>查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p>
<p>　我们需要再分析下这个匹配的过程，但是需要注意的是下面分析的代码是我们暂时无法分析的，因为那样会使得情况变得更加复杂，当我们从应用层往下分析的时候一切都会明白。<strong>input_attach_handler</strong>匹配过程如下：</p>
</li>
</ul>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 const struct input_device_id *id;  </span><br><span class="line"> 2     int error;  </span><br><span class="line"> 3   </span><br><span class="line"> 4 &#x2F;* 如果handler的blacklist被赋值了并且则优先匹配 *&#x2F;  </span><br><span class="line"> 5     if (handler-&gt;blacklist &amp;&amp; input_match_device(handler-&gt;blacklist, dev))  </span><br><span class="line"> 6         return -ENODEV;  </span><br><span class="line"> 7   </span><br><span class="line"> 8     &#x2F;* 否则利用handler-&gt;id_table和dev进行匹配，后面讲述匹配什么和过程 *&#x2F;  </span><br><span class="line"> 9     id &#x3D; input_match_device(handler-&gt;id_table, dev);  </span><br><span class="line">10     if (!id)  </span><br><span class="line">11         return -ENODEV;  </span><br><span class="line">12   </span><br><span class="line">13     &#x2F;* 这是一根“红线”，虽然你可能觉的是黑色的，但不可否认，他们真的匹配上了 </span><br><span class="line">14          * 调用handler-&gt;connnect函数进行匹配，匹配详细过程后面讲述 </span><br><span class="line">15         *&#x2F;  </span><br><span class="line">16     error &#x3D; handler-&gt;connect(handler, dev, id);  </span><br><span class="line">17     if (error &amp;&amp; error !&#x3D; -ENODEV)  </span><br><span class="line">18         printk(KERN_ERR  </span><br><span class="line">19             &quot;input: failed to attach handler %s to device %s, &quot;  </span><br><span class="line">20             &quot;error: %d\n&quot;,  </span><br><span class="line">21             handler-&gt;name, kobject_name(&amp;dev-&gt;cdev.kobj), error);  </span><br><span class="line">22   </span><br><span class="line">23     return error;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　先来看下<strong>input_match_device()</strong>函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么？</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1 &#x2F;* 事件处理层中的对应flags如果设置或者driver_info被设置则进行匹配 *&#x2F;  </span><br><span class="line"> 2     for (; id-&gt;flags || id-&gt;driver_info; id++) &#123;  </span><br><span class="line"> 3         &#x2F;* 以下通过flags中设置的位来匹配设备的总线类型、经销商、生产ID和版本ID </span><br><span class="line"> 4           如果没有匹配上将进行MATCH_BIT匹配 *&#x2F;  </span><br><span class="line"> 5         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)  </span><br><span class="line"> 6             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)  </span><br><span class="line"> 7                 continue;  </span><br><span class="line"> 8   </span><br><span class="line"> 9         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)  </span><br><span class="line">10             if (id-&gt;vendor !&#x3D; dev-&gt;id.vendor)  </span><br><span class="line">11                 continue;  </span><br><span class="line">12   </span><br><span class="line">13         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)  </span><br><span class="line">14             if (id-&gt;product !&#x3D; dev-&gt;id.product)  </span><br><span class="line">15                 continue;  </span><br><span class="line">16   </span><br><span class="line">17         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)  </span><br><span class="line">18             if (id-&gt;version !&#x3D; dev-&gt;id.version)  </span><br><span class="line">19                 continue;  </span><br><span class="line">20           </span><br><span class="line">21         &#x2F;* MATCH_BIT用于匹配设备驱动中是否设置了这些为，MATCH_BIT的宏 </span><br><span class="line">22         * 被定义在input.c中，我们在设备驱动中设置的事件类型会与事件链表中的 </span><br><span class="line">23         * 所有事件类型进行比较，匹配成功了将返回id，证明真的很合适，否则NULL </span><br><span class="line">24         *&#x2F;  </span><br><span class="line">25         MATCH_BIT(evbit,  EV_MAX);  </span><br><span class="line">26         MATCH_BIT(keybit, KEY_MAX);  </span><br><span class="line">27         MATCH_BIT(relbit, REL_MAX);  </span><br><span class="line">28         MATCH_BIT(absbit, ABS_MAX);  </span><br><span class="line">29         MATCH_BIT(mscbit, MSC_MAX);  </span><br><span class="line">30         MATCH_BIT(ledbit, LED_MAX);  </span><br><span class="line">31         MATCH_BIT(sndbit, SND_MAX);  </span><br><span class="line">32         MATCH_BIT(ffbit,  FF_MAX);  </span><br><span class="line">33         MATCH_BIT(swbit,  SW_MAX);  </span><br><span class="line">34   </span><br><span class="line">35         return id;  </span><br><span class="line">36     &#125;  </span><br><span class="line">37   </span><br><span class="line">38     return NULL;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　既然证明是合适的，接下来就应该登记注册，并公证了。还记得handler-&gt;connect(handler, dev, id)函数吧。</p>
<p>　　当input_match_device（）找到最合适的事件处理层驱动时，便执行<strong>handler-&gt;connect</strong>函数进行公证了，看下面这部分代码（假如说找到了evdev类型的驱动，在input/evdev.c中）：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct evdev *evdev;  </span><br><span class="line"> 2     struct class_device *cdev;  </span><br><span class="line"> 3     dev_t devt;  </span><br><span class="line"> 4     int minor;  </span><br><span class="line"> 5     int error;  </span><br><span class="line"> 6   </span><br><span class="line"> 7     &#x2F;* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev *&#x2F;  </span><br><span class="line"> 8     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++);  </span><br><span class="line"> 9     &#x2F;* 这说明内核已经没办法再分配这种类型的设备了 *&#x2F;  </span><br><span class="line">10     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  </span><br><span class="line">11         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);  </span><br><span class="line">12         return -ENFILE;  </span><br><span class="line">13     &#125;  </span><br><span class="line">14     &#x2F;* 开始给evdev事件层驱动分配空间了 *&#x2F;  </span><br><span class="line">15     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);  </span><br><span class="line">16     if (!evdev)  </span><br><span class="line">17         return -ENOMEM;  </span><br><span class="line">18   </span><br><span class="line">19     &#x2F;* 初始化client_list列表和evdev_wait队列，后面介绍 *&#x2F;  </span><br><span class="line">20     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);  </span><br><span class="line">21     init_waitqueue_head(&amp;evdev-&gt;wait);  </span><br><span class="line">22   </span><br><span class="line">23     &#x2F;* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 *&#x2F;  </span><br><span class="line">24     evdev-&gt;exist &#x3D; 1;  </span><br><span class="line">25     evdev-&gt;minor &#x3D; minor;  </span><br><span class="line">26     evdev-&gt;handle.dev &#x3D; dev;  </span><br><span class="line">27     evdev-&gt;handle.name &#x3D; evdev-&gt;name;  </span><br><span class="line">28     evdev-&gt;handle.handler &#x3D; handler;  </span><br><span class="line">29     evdev-&gt;handle.private &#x3D; evdev;  </span><br><span class="line">30     sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);  </span><br><span class="line">31   </span><br><span class="line">32     &#x2F;* 重要，上层访问时通过次设备号找到事件处理的接口 *&#x2F;  </span><br><span class="line">33     evdev_table[minor] &#x3D; evdev;  </span><br><span class="line">34   </span><br><span class="line">35     &#x2F;* evdev事件设备的此设备号的基准值INPUT_MAJOR, EVDEV_MINOR_BASE *&#x2F;  </span><br><span class="line">36     devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  </span><br><span class="line">37   </span><br><span class="line">38     &#x2F;* 创建用户事件驱动层设备访问接口&#x2F;dev&#x2F;input&#x2F;event* *&#x2F;  </span><br><span class="line">39     cdev &#x3D; class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,  </span><br><span class="line">40                    dev-&gt;cdev.dev, evdev-&gt;name);  </span><br><span class="line">41     if (IS_ERR(cdev)) &#123;  </span><br><span class="line">42         error &#x3D; PTR_ERR(cdev);  </span><br><span class="line">43         goto err_free_evdev;  </span><br><span class="line">44     &#125;  </span><br><span class="line">45   </span><br><span class="line">46     &#x2F;* 提供&#x2F;sys目录的用户空间接口 *&#x2F;  </span><br><span class="line">47     error &#x3D; sysfs_create_link(&amp;input_class.subsys.kobj,  </span><br><span class="line">48                   &amp;cdev-&gt;kobj, evdev-&gt;name);  </span><br><span class="line">49     if (error)  </span><br><span class="line">50         goto err_cdev_destroy;  </span><br><span class="line">51   </span><br><span class="line">52     &#x2F;* input_dev设备驱动和handler事件处理层的关联，由handle完成 *&#x2F;  </span><br><span class="line">53     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　通过上述代码的执行，最终，输入设备在<strong>input_register_handle()</strong>的关联下与已经匹配上的handler结合</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 struct input_handler *handler &#x3D; handle-&gt;handler;  </span><br><span class="line"> 2     &#x2F;* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上 </span><br><span class="line"> 3     * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以 </span><br><span class="line"> 4     * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备 </span><br><span class="line"> 5     *&#x2F;  </span><br><span class="line"> 6     list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list);  </span><br><span class="line"> 7     list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);  </span><br><span class="line"> 8   </span><br><span class="line"> 9     &#x2F;* 如果start函数有定义则调用，但是evdev结构体中并未初始化这个函数 *&#x2F;  </span><br><span class="line">10     if (handler-&gt;start)  </span><br><span class="line">11         handler-&gt;start(handle);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　</p>
<p>　　<strong>以上是输入设备驱动注册的全过程</strong>，牵涉的代码比较多，需要从宏观上理顺。</p>
<p>　　<strong>纵观整个过程：</strong></p>
<p>　　<strong>输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件驱动再去处理呢？</strong></p>
<p>　　<strong>知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。</strong></p>
<p>　　由于以上的这些原因，才有了上述代码的关联过程，看一下整个关联注册的过程：</p>
<p>　<br>　　<img src="https://images0.cnblogs.com/blog/536940/201309/01112129-4e175a1a4f82477b8cb262b24359fd1a.png" alt="img"></p>
<p>　　通过上图我们可以看到input输入设备匹配关联的关键过程以及涉及到的关键函数和数据。</p>
<p>　　以上主要是从input设备驱动程序的角度去看输入子系统的注册过程和三层之间的关联。</p>
<p>　　下面将从应用层的角度分析事件的接受过程和处理过程以及三层之间是如何配合处理输入事件的。</p>
<hr>
<h2 id="从应用层的角度出发看input子系统"><a href="#从应用层的角度出发看input子系统" class="headerlink" title="从应用层的角度出发看input子系统"></a>从应用层的角度出发看input子系统</h2><p>　　以上部分已经借助input子系统把input设备驱动层与事件驱动层进行了关联，以s3c2440_ts.c（输入设备层驱动）和evdev.c（事件处理层驱动）为例，来分析这一过程。</p>
<p>由于s3c2440_ts.c中上报的事件类型为按键、绝对值坐标，而evdev事件驱动程序是全匹配的，因此早在s3c2440_ts.c注册的过程中，就会创建设备节点/dev/input/event0（假设内核中没有其他的event类型的输入设备，这里就是event0）</p>
<p>　　我们知道，应用层使用设备的第一步，是open(“/dev/event0”)，因此这里event0的主设备号成为关键，因为主设备号将表明你是什么设备，我们ls -l查看/dev/event0发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw-r-----1 root root 13, 64 2012-07-26 14:32 &#x2F;dev&#x2F;input&#x2F;event0</span><br></pre></td></tr></table></figure>

<p>　　由此可见主设备是13，输入命令cat /proc/devices查看主设备为13的是input设备，因此可以确定当我们执行open函数打开event0设备的时候，会调用input设备的open驱动函数，这个函数在input.c中，为了说明这一问题，需要<strong>从input驱动注册过程开始</strong>，还是input.c文件：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;* 输入设备初始化函数 *&#x2F;  </span><br><span class="line">2 static int __init input_init(void)  </span><br><span class="line">3 &#123;  </span><br><span class="line">4        class_register(&amp;input_class);  </span><br><span class="line">5        input_proc_init();  </span><br><span class="line">6        register_chrdev(INPUT_MAJOR,&quot;input&quot;, &amp;input_fops);  </span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　可以看到，输入设备初始化的过程首先建立了input类，初始化input在proc下的节点，然后注册input设备，设备名称为input，操作接口是input_fops，主设备号是INPUT_MAJOR=13。</p>
<p>　　由以上可知，只要是主设备号为13的设备驱动程序，都是用input_fops接口，即当event0设备使用open函数打开时，会调用到input_fops接口中的open驱动函数，这个结构体的初始化为：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 static const struct file_operations input_fops &#x3D; &#123;  </span><br><span class="line">2        .owner &#x3D; THIS_MODULE,  </span><br><span class="line">3        .open &#x3D; input_open_file,  </span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　可以看到，只实现了一个open功能字段，再看<strong>input_open_file</strong>的实现：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct input_handler *handler &#x3D;input_table[iminor(inode) &gt;&gt; 5];  </span><br><span class="line"> 4        const struct file_operations *old_fops,*new_fops &#x3D; NULL;  </span><br><span class="line"> 5        if (!handler || !(new_fops &#x3D;fops_get(handler-&gt;fops)))  </span><br><span class="line"> 6               return -ENODEV;  </span><br><span class="line"> 7        old_fops &#x3D; file-&gt;f_op;  </span><br><span class="line"> 8        file-&gt;f_op &#x3D; new_fops;  </span><br><span class="line"> 9        new_fops-&gt;open(inode, file);  </span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　以上代码的功能为找到对应事件驱动层的fops，即进行fops的接口转换，指向对应设备的事件处理接口。</p>
<p>　　其中input_table[iminor(inode)]&gt;&gt;5的input_table是一个全局的input_handler类型的数组，iminor(inode)取得次设备号，并且右移5位索引input_table表中对应的位置，为什么这样做呢？这是因为这个表格中填写的就是事件处理的指针，待会分析。</p>
<p>　　继续查看下面的代码。if中将判断是否为空并且事件处理层中的fops有没有初始化，如果没有就不能进行接口转换，报出设备不存在的错误，如果设备存在则把input设备的f_op驱动接口指向input_table表中存在的接口，并调用其open函数。</p>
<p>　　那么这个<strong>input_table里面到底存放了什么呢？</strong>我们还是拿触摸屏驱动来讲解。由于触摸屏驱动已经完成了和evdev.c事件处理层的匹配，且次设备号为64，设备名称为/dev/event0，这是我们通过分析驱动注册中获得的内容，既然input核心设备注册了，s3c2440触摸屏驱动也注册了，那会不会evdev设备也会注册了呢？答案是肯定的，要想知道input_table里面放了什么，必须要去查看<strong>evdev设备的注册过程</strong>，打开input/evdev.c查看它的注册过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 static struct input_handler evdev_handler &#x3D; &#123;  </span><br><span class="line"> 2        .event &#x3D;   evdev_event,                               &#x2F;&#x2F;事件处理  </span><br><span class="line"> 3        .connect &#x3D;      evdev_connect,                    &#x2F;&#x2F;设备连接  </span><br><span class="line"> 4        .disconnect &#x3D;  evdev_disconnect,                &#x2F;&#x2F;注销连接  </span><br><span class="line"> 5        .fops &#x3D;           &amp;evdev_fops,                      &#x2F;&#x2F;驱动功能接口  </span><br><span class="line"> 6        .minor &#x3D;  EVDEV_MINOR_BASE,              &#x2F;&#x2F;evdev的值为64  </span><br><span class="line"> 7        .name &#x3D;          &quot;evdev&quot;,                              &#x2F;&#x2F;设备名称  </span><br><span class="line"> 8        .id_table &#x3D;      evdev_ids,                           &#x2F;&#x2F;用于匹配设备驱动的数组  </span><br><span class="line"> 9 &#125;;  </span><br><span class="line">10    </span><br><span class="line">11 static int __init evdev_init(void)  </span><br><span class="line">12 &#123;  </span><br><span class="line">13        return input_register_handler(&amp;evdev_handler);          &#x2F;&#x2F;evdev设备驱动注册  </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　由以上的内容可以知道evdev_handler也被作为一个设备来操作，但是它属于input handler事件处理设备，然而我们在evdev_handler结构体的.fops字段又发现它的驱动接口为字符设备类型，在input中，如果input_table匹配到了evdev_handler，将会把file-&gt;f_op=&amp;evdev_fops，那么如果使用read、write等函数操作，将会调用到evdev_fops中的read、write。</p>
<p>　　为了进一步查看<strong>input_table表中的内容是如何填充的</strong>，还需要查看这个注册的过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 int input_register_handler(struct input_handler *handler)  </span><br><span class="line">2 &#123;  </span><br><span class="line">3     ……  </span><br><span class="line">4            input_table[handler-&gt;minor&gt;&gt; 5] &#x3D; handler;  </span><br><span class="line">5     ……  </span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　当然这个注册过程并不是只有这么一句话，看到这条语句，相信应该知道什么意思了。</p>
<p>　　在input的open函数执行之前，即我们的open代码打开之前，input_table中的字段已经被事件处理层填充了。</p>
<p>　　由于evdev的次设备号在初始化的时候就设置成了64，因此这里相当于：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_table[2]&#x3D;&amp;evdev_handler；</span><br></pre></td></tr></table></figure>

<p>　　回到input_open_file函数查看new_fops-&gt;open(inode, file)便知道了调用的是:</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evdev_handler.evdev_fops.open（inode, file）；</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　在分析open函数之前，解释一下<strong>为什么要右移5位？</strong></p>
<p>　　这说明一个问题，次设备号的低5位被忽略，这说明evdev的最大支持的输入设备驱动个数为2^5次方等于32个，你可能会看到你的/dev目录下面有event0、event1、event2等设备，他们的次设备号分别为64、65、66等等。但最大是64+32-1，因此input_table为这些输入设备增加的一个统一接口，通过上层打开设备时，只要次设备号在64+32-1之间的设备都会重新定位到evdev_handler中，即event*设备打开后执行的底层函数将被重新定义到evdev_handler中。</p>
<p>　　相信上面的问题已经描述清楚，如果还是不明白，最起码应该知道的是，input设备中的open函数只是一个接口，通过次设备号才找到了真正的事件处理接口。接下来要看新的open接口的实现了，evdev_handler-&gt; fops-&gt;open实现如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> 1 &#x2F;*evdev字符设备驱动接口 *&#x2F;  </span><br><span class="line"> 2 static const struct file_operations evdev_fops &#x3D; &#123;  </span><br><span class="line"> 3        .owner &#x3D; THIS_MODULE,  </span><br><span class="line"> 4        .read &#x3D;           evdev_read,  </span><br><span class="line"> 5        .write &#x3D;   evdev_write,  </span><br><span class="line"> 6        .poll &#x3D;            evdev_poll,  </span><br><span class="line"> 7        .open &#x3D;          evdev_open,  </span><br><span class="line"> 8        .release &#x3D; evdev_release,  </span><br><span class="line"> 9        .unlocked_ioctl &#x3D; evdev_ioctl,  </span><br><span class="line">10 #ifdef CONFIG_COMPAT  </span><br><span class="line">11        .compat_ioctl &#x3D;      evdev_ioctl_compat,  </span><br><span class="line">12 #endif  </span><br><span class="line">13        .fasync &#x3D; evdev_fasync,  </span><br><span class="line">14        .flush &#x3D;   evdev_flush  </span><br><span class="line">15 &#125;;  </span><br><span class="line">16 &#x2F;*evdev设备open函数的实现过程 *&#x2F;  </span><br><span class="line">17 static int evdev_open(struct inode *inode, struct file *file)  </span><br><span class="line">18 &#123;  </span><br><span class="line">19        struct evdev_client *client;  </span><br><span class="line">20        struct evdev *evdev;  </span><br><span class="line">21        &#x2F;* 如果是event0，对于evdev设备来说，次设备号当然是0 *&#x2F;  </span><br><span class="line">22        int i &#x3D; iminor(inode) - EVDEV_MINOR_BASE;  </span><br><span class="line">23        int error;  </span><br><span class="line">24        &#x2F;* 如果大于32，说明超出了evdev能够容纳的最大输入设备个数 *&#x2F;  </span><br><span class="line">25        if (i &gt;&#x3D; EVDEV_MINORS)  </span><br><span class="line">26               return -ENODEV;  </span><br><span class="line">27        &#x2F;* 由于evdev中能容纳32个输入设备，因此通过设备号event0中的0定位到是要处理的是哪一个输入设备，evdev_table中的内容在输入设备驱动注册时通过evdev_connect填充 *&#x2F;  </span><br><span class="line">28        evdev &#x3D; evdev_table[i];  </span><br><span class="line">29        &#x2F;* 判断是否设备接口存在，evdev_exist也是在evdev_connect填充为1 *&#x2F;  </span><br><span class="line">30        if (!evdev || !evdev-&gt;exist)  </span><br><span class="line">31               return -ENODEV;  </span><br><span class="line">32        &#x2F;* 存在则分配evdev中的client来处理event* *&#x2F;  </span><br><span class="line">33        client &#x3D; kzalloc(sizeof(struct evdev_client),GFP_KERNEL);  </span><br><span class="line">34        if (!client)  </span><br><span class="line">35               return -ENOMEM;  </span><br><span class="line">36    </span><br><span class="line">37        &#x2F;* 把event*中的接口指向evdev_table中对应项 *&#x2F;  </span><br><span class="line">38        client-&gt;evdev &#x3D; evdev;  </span><br><span class="line">39        &#x2F;* 把client-&gt;node链接到evdev子集中 *&#x2F;  </span><br><span class="line">40        list_add_tail(&amp;client-&gt;node,&amp;evdev-&gt;client_list);  </span><br><span class="line">41        &#x2F;* 如果open是第一个打开，则会执行input_open_device*&#x2F;  </span><br><span class="line">42        if (!evdev-&gt;open++ &amp;&amp;evdev-&gt;exist) &#123;  </span><br><span class="line">43               error &#x3D;input_open_device(&amp;evdev-&gt;handle);  </span><br><span class="line">44               if (error) &#123;  </span><br><span class="line">45                      list_del(&amp;client-&gt;node);  </span><br><span class="line">46                      kfree(client);  </span><br><span class="line">47                      return error;  </span><br><span class="line">48               &#125;  </span><br><span class="line">49        &#125;  </span><br><span class="line">50        &#x2F;* 将file私有指针指向client*&#x2F;  </span><br><span class="line">51        file-&gt;private_data &#x3D; client;  </span><br><span class="line">52        return 0;  </span><br><span class="line">53 &#125;  </span><br><span class="line">54 &#x2F;&#x2F;由上的代码可以看出，最终是要执行input_open_device去执行设备驱动程序中的代码，然而我们在定义设备驱动的时候并没有给input_dev中的open字段填充内容，因此可以看到input_open_device函数的执行过程：  </span><br><span class="line">55 if(!dev-&gt;users++ &amp;&amp; dev-&gt;open)  </span><br><span class="line">56               err &#x3D; dev-&gt;open(dev);  </span><br><span class="line">57    </span><br><span class="line">58        if (err)  </span><br><span class="line">59               handle-&gt;open--;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上面截取了片段，并没有执行到open函数，open进行自减操作，表示没有调用过open，这个值主要是为了close中判断open为0时释放资源使用。</p>
<p>　　不仅如此，我们在触摸屏驱动中也没有定义read、write，那当触摸屏上报事件时，是如何处理的呢？</p>
<p>　　我们需要先到触摸屏驱动程序中找到上报事件的函数再做进一步分析。</p>
<hr>
<h2 id="输入设备上报事件的处理过程"><a href="#输入设备上报事件的处理过程" class="headerlink" title="输入设备上报事件的处理过程"></a>输入设备上报事件的处理过程</h2><p>　　触摸屏驱动程序<strong>上报事件的函数</strong>为：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 input_report_abs(dev,ABS_X, s3c2440_ts-&gt;tc.xp);  </span><br><span class="line">2 input_report_abs(dev,ABS_Y, s3c2440_ts-&gt;tc.yp);  </span><br><span class="line">3 input_report_abs(dev,ABS_PRESSURE, s3c2440_ts-&gt;tc.pressure);  </span><br><span class="line">4 input_report_key(dev,BTN_TOUCH, s3c2440_ts-&gt;pendown);  </span><br><span class="line">5 input_sync(dev);</span><br></pre></td></tr></table></figure>





<p>　　然而他们其实是<strong>input_event</strong>函数的封装，调用的都是input_event函数，这一函数在input.c中实现如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> 1 void input_event(struct input_dev *dev, unsigned int type, unsigned int code, intvalue)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct input_handle *handle;  </span><br><span class="line"> 4    </span><br><span class="line"> 5        if (type &gt; EV_MAX || !test_bit(type,dev-&gt;evbit))  </span><br><span class="line"> 6               return;  </span><br><span class="line"> 7        switch (type) &#123;  </span><br><span class="line"> 8               case EV_SYN:  </span><br><span class="line"> 9                      switch (code) &#123;  </span><br><span class="line">10                             case SYN_CONFIG:  </span><br><span class="line">11                                    if(dev-&gt;event)  </span><br><span class="line">12                                           dev-&gt;event(dev,type, code, value);  </span><br><span class="line">13                                    break;  </span><br><span class="line">14                             case SYN_REPORT:  </span><br><span class="line">15                                    if(dev-&gt;sync)  </span><br><span class="line">16                                           return;  </span><br><span class="line">17                                    dev-&gt;sync&#x3D; 1;  </span><br><span class="line">18                                    break;  </span><br><span class="line">19                      &#125;  </span><br><span class="line">20                      break;  </span><br><span class="line">21               case EV_KEY:  </span><br><span class="line">22               case EV_SW:  </span><br><span class="line">23               case EV_ABS:  </span><br><span class="line">24               case EV_REL:  </span><br><span class="line">25               case EV_MSC:  </span><br><span class="line">26               case EV_LED:  </span><br><span class="line">27               case EV_SND:  </span><br><span class="line">28               case EV_REP:  </span><br><span class="line">29               case EV_FF:  </span><br><span class="line">30        &#125;  </span><br><span class="line">31    </span><br><span class="line">32        if (type !&#x3D; EV_SYN)  </span><br><span class="line">33               dev-&gt;sync &#x3D; 0;  </span><br><span class="line">34    </span><br><span class="line">35        if (dev-&gt;grab)  </span><br><span class="line">36               dev-&gt;grab-&gt;handler-&gt;event(dev-&gt;grab,type, code, value);  </span><br><span class="line">37        else  </span><br><span class="line">38               list_for_each_entry(handle,&amp;dev-&gt;h_list, d_node)  </span><br><span class="line">39                      if (handle-&gt;open)  </span><br><span class="line">40                             handle-&gt;handler-&gt;event(handle,type, code, value);  </span><br><span class="line">41 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　代码被做了精简，其中就是在匹配上报的事件，并根据事件的类型调用驱动程序中相应的函数来完成，但是由于我们并没有定义过这些函数，因此执行最后的<strong>handle_handler_event</strong>函数，由事件处理层evdev_event函数来完成事件的保存工作，具体过程如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 list_for_each_entry(client,&amp;evdev-&gt;client_list, node) &#123;  </span><br><span class="line">2     client-&gt;buffer[client-&gt;head].type&#x3D; type;  </span><br><span class="line">3     client-&gt;buffer[client-&gt;head].code&#x3D; code;  </span><br><span class="line">4     client-&gt;buffer[client-&gt;head].value&#x3D; value;  </span><br><span class="line">5     client-&gt;head&#x3D; (client-&gt;head + 1) &amp; (EVDEV_BUFFER_SIZE - 1);  </span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这里列举了关键代码，即上报的事件被保存到了client_buffer中，其中client_buffer是一个循环缓冲区，client-&gt;head表示当前数据的位置，因此每次都写到client-&gt;head的位置，而读数据时需要到client_tail中读取。因为在open的时候，client已经被链入到了evdev-&gt;client_list中，因此通过可以通过list_for_each_entry重evdev-&gt;client_list中找到对应的client。</p>
<p>　　事件的上报都会把数据保存到client-&gt;buffer中，以便上层通过read和write进行读去和写入。</p>
<hr>
<h2 id="通过设备节点读取输入事件"><a href="#通过设备节点读取输入事件" class="headerlink" title="通过设备节点读取输入事件"></a>通过设备节点读取输入事件</h2><p>　　还是以触摸屏驱动程序和evdev事件处理层驱动来分析：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 1 static ssize_t evdev_read(struct file *file, char __user *buffer, size_t count, loff_t*ppos)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct evdev_client *client &#x3D;file-&gt;private_data;  </span><br><span class="line"> 4        struct evdev *evdev &#x3D; client-&gt;evdev;  </span><br><span class="line"> 5        int retval;  </span><br><span class="line"> 6    </span><br><span class="line"> 7        &#x2F;* 判断用户给的count是否能够容纳事件数据的大小*&#x2F;  </span><br><span class="line"> 8        if (count &lt; evdev_event_size())  </span><br><span class="line"> 9               return -EINVAL;  </span><br><span class="line">10    </span><br><span class="line">11        &#x2F;* 如果数据不为空并且设备存在并且是阻塞访问方式才能继续执行 *&#x2F;  </span><br><span class="line">12        if (client-&gt;head &#x3D;&#x3D; client-&gt;tail&amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))  </span><br><span class="line">13               return -EAGAIN;  </span><br><span class="line">14    </span><br><span class="line">15        &#x2F;* 如果数据为空，设置进程等待底层驱动层上报事件到client-&gt;buffer中 *&#x2F;  </span><br><span class="line">16        retval &#x3D;wait_event_interruptible(evdev-&gt;wait,  </span><br><span class="line">17               client-&gt;head !&#x3D; client-&gt;tail|| !evdev-&gt;exist);  </span><br><span class="line">18        if (retval)  </span><br><span class="line">19               return retval;  </span><br><span class="line">20    </span><br><span class="line">21        if (!evdev-&gt;exist)  </span><br><span class="line">22               return -ENODEV;  </span><br><span class="line">23    </span><br><span class="line">24        &#x2F;* 循环读取数据 *&#x2F;  </span><br><span class="line">25        while (client-&gt;head !&#x3D; client-&gt;tail&amp;&amp; retval + evdev_event_size() &lt;&#x3D; count) &#123;  </span><br><span class="line">26    </span><br><span class="line">27               struct input_event *event &#x3D;(struct input_event *) client-&gt;buffer + client-&gt;tail;  </span><br><span class="line">28    </span><br><span class="line">29               if (evdev_event_to_user(buffer +retval, event))  </span><br><span class="line">30                      return -EFAULT;  </span><br><span class="line">31    </span><br><span class="line">32               client-&gt;tail &#x3D; (client-&gt;tail+ 1) &amp; (EVDEV_BUFFER_SIZE - 1);  </span><br><span class="line">33               retval +&#x3D; evdev_event_size();  </span><br><span class="line">34        &#125;  </span><br><span class="line">35    </span><br><span class="line">36        return retval;  </span><br><span class="line">37 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这里如果没有数据，进程会睡眠，那由谁来唤醒呢？细心的话可以发现，当设备驱动层调用input_event上报事件调用相应的event函数进行事件写入时，是会唤醒阻塞等待的进程的。</p>
<hr>
<h2 id="通过设备节点写入输入事件"><a href="#通过设备节点写入输入事件" class="headerlink" title="通过设备节点写入输入事件"></a>通过设备节点写入输入事件</h2><p>　　写入过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1 static ssize_t evdev_write(struct file *file, const char __user *buffer, size_t count,loff_t *ppos)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        &#x2F;* 循环写入，调用input_inject_event函数 *&#x2F;  </span><br><span class="line"> 4        while (retval &lt; count) &#123;  </span><br><span class="line"> 5    </span><br><span class="line"> 6               if (evdev_event_from_user(buffer +retval, &amp;event))  </span><br><span class="line"> 7                      return -EFAULT;  </span><br><span class="line"> 8               input_inject_event(&amp;evdev-&gt;handle,event.type, event.code, event.value);  </span><br><span class="line"> 9               retval +&#x3D; evdev_event_size();  </span><br><span class="line">10        &#125;  </span><br><span class="line">11    </span><br><span class="line">12        return retval;  </span><br><span class="line">13 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上述代码中的event是input_event数组，包含了事件的类型、键值，通过input_inject_event把数据写入循环数组client-&gt;buffer中，input_inject_event调用的是input_event函数。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　对input子系统的整个过程做了分析，并从两个角度进行考虑.</p>
<p>　　对于写输入设备驱动程序的来说，需要掌握的是设备应该上报事件的类型，这样才能匹配到对应的事件层驱动帮助你保存对应的数据.</p>
<p>　　而对于设备上层开发者来说，应该先使用cat /proc/bus/input/devices查看你操作的设备类型和处理接口，以帮助你更好的对设备操作。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/ielife" target="_blank" rel="noopener">http://blog.csdn.net/ielife</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/06/Linux/Driver/Input/input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/Linux/Driver/Input/input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">input子系统应用程序开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-06 14:53:11 / Modified: 16:58:24" itemprop="dateCreated datePublished" datetime="2021-01-06T14:53:11+08:00">2021-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应用层如何使用内核提供的接口访问input 子系统上报的数据呢？设备的信息，存放在/dev 、/sys 和/proc三个目录中。其中，/dev存放的设备文件，用来跟应用层交互数据，比如/dev/input/event0文件，应用层调用open打开event0，接下来就是使用read和write与输入设备交互数据了。</p>
<h2 id="查看event设备信息"><a href="#查看event设备信息" class="headerlink" title="查看event设备信息"></a>查看event设备信息</h2><p>1、/dev/input</p>
<p>该目录下存放在驱动中调用input_register_device(struct input_dev *dev)产生的输入设备事件，比如鼠标，键盘、触摸屏。</p>
<p>查看/dev/input下的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;input # ls</span><br><span class="line">event0  event1  event2  mice    mouse0</span><br></pre></td></tr></table></figure>

<p>那么如何知道输入设备属于哪个事件呢？</p>
<p>2、/proc/bus/input</p>
<p>与event对应的相关设备信息位于/proc/bus/input/devices. 查看设备信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">~ # cat &#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices </span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0001 Version&#x3D;0001</span><br><span class="line">N: Name&#x3D;&quot;rk29_ir_gpio&quot;</span><br><span class="line">P: Phys&#x3D;irm_kbd_gpio</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;kbd event0 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;7</span><br><span class="line">B: KEY&#x3D;1ff 0 0 0 0 0 0 0 0 10000 0 0 0 0 0 0 0</span><br><span class="line">B: REL&#x3D;3</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0018 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;Atmel_maXTouch_Touchscreen&quot;</span><br><span class="line">P: Phys&#x3D;i2c-1-004a&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;omap&#x2F;omap_i2c.1&#x2F;i2c-1&#x2F;1-004a&#x2F;input&#x2F;input1</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;mouse0 event1 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;b</span><br><span class="line">B: KEY&#x3D;400 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">B: ABS&#x3D;1000003</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0001 Product&#x3D;0001 Version&#x3D;0100</span><br><span class="line">N: Name&#x3D;&quot;gpio-keys&quot;</span><br><span class="line">P: Phys&#x3D;gpio-keys&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;gpio-keys&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event2 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;1 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>通过看Name就知道是哪个设备。比如触摸屏设备Name=”Atmel_maXTouch_Touchscreen”，它的event是event1</p>
<p>/proc/bus/input/devices信息解释来自：</p>
<p><a href="https://qastack.cn/unix/74903/explain-ev-in-proc-bus-input-devices-data" target="_blank" rel="noopener">https://qastack.cn/unix/74903/explain-ev-in-proc-bus-input-devices-data</a></p>
<blockquote>
<p><code>devices</code>AT键盘输入示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">I: Bus&#x3D;0011 Vendor&#x3D;0001 Product&#x3D;0001 Version&#x3D;ab41</span><br><span class="line">N: Name&#x3D;&quot;AT Translated Set 2 keyboard&quot;</span><br><span class="line">P: Phys&#x3D;isa0060&#x2F;serio0&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;i8042&#x2F;serio0&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;sysrq kbd event2 </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;120013</span><br><span class="line">B: KEY&#x3D;20000 200 20 0 0 0 0 500f 2100002 3803078 f900d401 feffffdf ffefffff ffffffff fffffffe</span><br><span class="line">B: MSC&#x3D;10</span><br><span class="line">B: LED&#x3D;7</span><br></pre></td></tr></table></figure>

<p>在<code>B</code>前面的代表<code>bitmap</code>，<code>N</code>，<code>P</code>，<code>S</code>，<code>U</code>，<code>H</code>在相应的名字值只是第一个字母，<code>I</code>是<code>ID</code>。<a href="http://lxr.free-electrons.com/source/include/linux/input.h#L40" target="_blank" rel="noopener">以有序方式：</a></p>
<ul>
<li><pre><code>I =&gt; @id: id of the device 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &#96;(struct input_id)&#96;</span><br><span class="line"></span><br><span class="line">  - &#96;Bus   &#x3D;&gt; id.bustype&#96;</span><br><span class="line">  - &#96;Vendor &#x3D;&gt; id.vendor&#96;</span><br><span class="line">  - &#96;Product &#x3D;&gt; id.product&#96;</span><br><span class="line">  - &#96;Version &#x3D;&gt; id.version&#96;</span><br><span class="line"></span><br><span class="line">- &#96;N &#x3D;&gt; name of the device.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;P &#x3D;&gt; physical path to the device in the system hierarchy.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;S &#x3D;&gt; sysfs path.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;U &#x3D;&gt; unique identification code for the device (if device has it).&#96;</span><br><span class="line"></span><br><span class="line">- &#96;H &#x3D;&gt; list of input handles associated with the device.&#96;</span><br><span class="line"></span><br><span class="line">- </span><br></pre></td></tr></table></figure>
B =&gt; bitmaps
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - &#96;PROP &#x3D;&gt; device properties and quirks.&#96;</span><br><span class="line">  - **&#96;EV  &#x3D;&gt; types of events supported by the device.&#96;**</span><br><span class="line">  - &#96;KEY &#x3D;&gt; keys&#x2F;buttons this device has.&#96;</span><br><span class="line">  - &#96;MSC &#x3D;&gt; miscellaneous events supported by the device.&#96;</span><br><span class="line">  - &#96;LED &#x3D;&gt; leds present on the device.&#96;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">## 位掩码</span><br><span class="line"></span><br><span class="line">如您所知，计算机以二进制形式处理，因此：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
...
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因此，如果我有一个位图，其值&#96;5&#96;可以容纳换句话说的0和2位，则可以给每个数字起一个名称，并检查它们是否对应于一个值。</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br></pre></td></tr></table></figure>
A = 1,  001
B = 2,  010
C = 4,  100
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么，如果我&#96;MYVAR &#x3D; 5&#96;是&#96;101&#96;二进制，这将检查：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
MYVAR &amp; A == TRUE   (101 &amp; 001 =&gt; 001)
MYVAR &amp; B == FALSE  (101 &amp; 010 =&gt; 000)
MYVAR &amp; C == TRUE   (101 &amp; 100 =&gt; 100 )
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因此我的变量*有* A和C。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">内核使用更复杂的方式，并通过偏移量设置位。原因之一是使用了一台计算机（CPU）整数中的更多位数。例如看&#96;KEY&#96;位图。</span><br><span class="line"></span><br><span class="line">因此，如果我们说：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
A = 0
B = 1
C = 6
...
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接着</span><br><span class="line"></span><br></pre></td></tr></table></figure>
target = 0;
set_bit(A, target);  =&gt; target ==      0001
set_bit(C, target);  =&gt; target == 0100 0001
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">## 解码 &#96;120013&#96;</span><br><span class="line"></span><br><span class="line">取值&#96;120013&#96;为十六进制。作为二进制，它给我们：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
0x120013 == 0001 0010 0000 0000 0001 0011 binary
             1    2    0    0    1    3
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从右到右编号为：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 2            1               &lt;= offset (10&apos;s)
3210 9876 5432 1098 7654 3210   &lt;= offset (counted from right)
0001 0010 0000 0000 0001 0011   &lt;= binary
</code></pre></li>
</ul>
<p>Set bits are:<br>   0, 1, 4, 17, 20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后检查[&#96;input.h&#96;](http:&#x2F;&#x2F;www.cs.fsu.edu&#x2F;~baker&#x2F;devices&#x2F;lxr&#x2F;http&#x2F;source&#x2F;linux&#x2F;include&#x2F;linux&#x2F;input.h?v&#x3D;2.6.11.8#L80)您是否发现它们对应于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   0  EV_SYN (0x00)<br>   1  EV_KEY (0x01)<br>   4  EV_MSC (0x04)<br>  17  EV_LED (0x11)<br>  20  EV_REP (0x14)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要检查它们的含义，[内核文档](https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;input&#x2F;event-codes.txt)提供了快速介绍。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>EV_SYN:</p>
<ul>
<li>Used as markers to separate events. Events may be separated in time or in<br>space, such as with the multitouch protocol.</li>
</ul>
</li>
<li><p>EV_KEY:</p>
<ul>
<li>Used to describe state changes of keyboards, buttons, or other key-like<br>devices.</li>
</ul>
</li>
<li><p>EV_MSC:</p>
<ul>
<li>Used to describe miscellaneous input data that do not fit into other types.</li>
</ul>
</li>
<li><p>EV_LED:</p>
<ul>
<li>Used to turn LEDs on devices on and off.</li>
</ul>
</li>
<li><p>EV_REP:</p>
<ul>
<li>Used for autorepeating devices.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 编写应用程序</span><br><span class="line"></span><br><span class="line">这是一个Atmel_maXTouch_Touchscreen应用测试程序 </span><br></pre></td></tr></table></figure>
#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;sys/time.h&gt;<br>#include &lt;linux/input.h&gt;<br>#include &lt;sys/time.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;</li>
</ul>
</li>
</ul>
</blockquote>
<p>#define DEV  “/dev/input/event1”<br>#define SIZE 16</p>
<p>int main()<br>{<br>    int fd = -1;<br>    int Size = 0;<br>    unsigned int i;<br>    int retval;<br>    fd_set rfds;<br>    struct input_event event_stack[SIZE];</p>
<pre><code>fd = open(DEV, O_RDONLY | O_NONBLOCK);
if(fd &lt; 0)
{
    printf(&quot;open fail\n&quot;);
    return -1;
}
while(1)
{
    FD_ZERO(&amp;rfds);
    FD_SET(fd, &amp;rfds);
    retval = select(fd + 1, &amp;rfds, NULL, NULL, NULL);

    if (retval == -1){
        continue;
    }else if (retval){

    }else
        continue;
    Size = read(fd, event_stack, sizeof(event_stack));
    if(Size &gt;= 0)
    {
        for(i = 0; i &lt; Size/sizeof(event_stack[0]); i++)
            printf(&quot;type = %d\n  code = %d\n  value = %d\n&quot;,
             event_stack[i].type,
             event_stack[i].code,
             event_stack[i].value);
    }
    else
    {
        printf(&quot;Size %d\n&quot;,Size);
    }
}
close(fd);
return 0;</code></pre><p>}</p>
<pre><code></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/05/Linux/Driver/Input/Atmel%E7%9A%84mXT2952T2%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/Linux/Driver/Input/Atmel%E7%9A%84mXT2952T2%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">Atmel的mXT2952T2触摸屏驱动开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-05 13:55:44" itemprop="dateCreated datePublished" datetime="2021-01-05T13:55:44+08:00">2021-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 15:05:04" itemprop="dateModified" datetime="2021-01-06T15:05:04+08:00">2021-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文总结使用input core 编写mxt2952t2触摸屏芯片驱动。先提几个问题如下：</p>
<p>1、mxt2952驱动，如何上报坐标轴的数据给event handlers？</p>
<p>2、输入设备产生的数据，用什么来描述？</p>
<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><p>配置Linux内核支持input子系统，event handlers和设备驱动。</p>
<p>1、配置input 支持的event handlers </p>
<p>配置支持event handlers 如下图所示</p>
<p><img src="http://jiali.clouddn.com/20210105_002.png" alt=""></p>
<p>​                                                                                                                  图 input支持的event handlers</p>
<p>2、配置触摸屏驱动</p>
<p>配置支持 Atmel mxt 驱动如下图所示</p>
<p><img src="http://jiali.clouddn.com/20210105_003.png" alt=""></p>
<p>​                                                                                                                         图配置Atmel mxt驱动</p>
<h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><p>描述一个设备对象的结构体定义在include/linux/input.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_dev - represents an input device</span><br><span class="line"> * @name: name of the device</span><br><span class="line"> * @phys: physical path to the device in the system hierarchy</span><br><span class="line"> * @uniq: unique identification code for the device (if device has it)</span><br><span class="line"> * @id: id of the device (struct input_id)</span><br><span class="line"> * @propbit: bitmap of device properties and quirks</span><br><span class="line"> * @evbit: bitmap of types of events supported by the device (EV_KEY,</span><br><span class="line"> *	EV_REL, etc.)</span><br><span class="line"> * @keybit: bitmap of keys&#x2F;buttons this device has</span><br><span class="line"> * @relbit: bitmap of relative axes for the device</span><br><span class="line"> * @absbit: bitmap of absolute axes for the device</span><br><span class="line"> * @mscbit: bitmap of miscellaneous events supported by the device</span><br><span class="line"> * @ledbit: bitmap of leds present on the device</span><br><span class="line"> * @sndbit: bitmap of sound effects supported by the device</span><br><span class="line"> * @ffbit: bitmap of force feedback effects supported by the device</span><br><span class="line"> * @swbit: bitmap of switches present on the device</span><br><span class="line"> * @hint_events_per_packet: average number of events generated by the</span><br><span class="line"> *	device in a packet (between EV_SYN&#x2F;SYN_REPORT events). Used by</span><br><span class="line"> *	event handlers to estimate size of the buffer needed to hold</span><br><span class="line"> *	events.</span><br><span class="line"> * @keycodemax: size of keycode table</span><br><span class="line"> * @keycodesize: size of elements in keycode table</span><br><span class="line"> * @keycode: map of scancodes to keycodes for this device</span><br><span class="line"> * @getkeycode: optional legacy method to retrieve current keymap.</span><br><span class="line"> * @setkeycode: optional method to alter current keymap, used to implement</span><br><span class="line"> *	sparse keymaps. If not supplied default mechanism will be used.</span><br><span class="line"> *	The method is being called while holding event_lock and thus must</span><br><span class="line"> *	not sleep</span><br><span class="line"> * @ff: force feedback structure associated with the device if device</span><br><span class="line"> *	supports force feedback effects</span><br><span class="line"> * @repeat_key: stores key code of the last key pressed; used to implement</span><br><span class="line"> *	software autorepeat</span><br><span class="line"> * @timer: timer for software autorepeat</span><br><span class="line"> * @rep: current values for autorepeat parameters (delay, rate)</span><br><span class="line"> * @mt: pointer to array of struct input_mt_slot holding current values</span><br><span class="line"> *	of tracked contacts</span><br><span class="line"> * @mtsize: number of MT slots the device uses</span><br><span class="line"> * @slot: MT slot currently being transmitted</span><br><span class="line"> * @trkid: stores MT tracking ID for the current contact</span><br><span class="line"> * @absinfo: array of &amp;struct input_absinfo elements holding information</span><br><span class="line"> *	about absolute axes (current value, min, max, flat, fuzz,</span><br><span class="line"> *	resolution)</span><br><span class="line"> * @key: reflects current state of device&#39;s keys&#x2F;buttons</span><br><span class="line"> * @led: reflects current state of device&#39;s LEDs</span><br><span class="line"> * @snd: reflects current state of sound effects</span><br><span class="line"> * @sw: reflects current state of device&#39;s switches</span><br><span class="line"> * @open: this method is called when the very first user calls</span><br><span class="line"> *	input_open_device(). The driver must prepare the device</span><br><span class="line"> *	to start generating events (start polling thread,</span><br><span class="line"> *	request an IRQ, submit URB, etc.)</span><br><span class="line"> * @close: this method is called when the very last user calls</span><br><span class="line"> *	input_close_device().</span><br><span class="line"> * @flush: purges the device. Most commonly used to get rid of force</span><br><span class="line"> *	feedback effects loaded into the device when disconnecting</span><br><span class="line"> *	from it</span><br><span class="line"> * @event: event handler for events sent _to_ the device, like EV_LED</span><br><span class="line"> *	or EV_SND. The device is expected to carry out the requested</span><br><span class="line"> *	action (turn on a LED, play sound, etc.) The call is protected</span><br><span class="line"> *	by @event_lock and must not sleep</span><br><span class="line"> * @grab: input handle that currently has the device grabbed (via</span><br><span class="line"> *	EVIOCGRAB ioctl). When a handle grabs a device it becomes sole</span><br><span class="line"> *	recipient for all input events coming from the device</span><br><span class="line"> * @event_lock: this spinlock is is taken when input core receives</span><br><span class="line"> *	and processes a new event for the device (in input_event()).</span><br><span class="line"> *	Code that accesses and&#x2F;or modifies parameters of a device</span><br><span class="line"> *	(such as keymap or absmin, absmax, absfuzz, etc.) after device</span><br><span class="line"> *	has been registered with input core must take this lock.</span><br><span class="line"> * @mutex: serializes calls to open(), close() and flush() methods</span><br><span class="line"> * @users: stores number of users (input handlers) that opened this</span><br><span class="line"> *	device. It is used by input_open_device() and input_close_device()</span><br><span class="line"> *	to make sure that dev-&gt;open() is only called when the first</span><br><span class="line"> *	user opens device and dev-&gt;close() is called when the very</span><br><span class="line"> *	last user closes the device</span><br><span class="line"> * @going_away: marks devices that are in a middle of unregistering and</span><br><span class="line"> *	causes input_open_device*() fail with -ENODEV.</span><br><span class="line"> * @sync: set to %true when there were no new events since last EV_SYN</span><br><span class="line"> * @dev: driver model&#39;s view of this device</span><br><span class="line"> * @h_list: list of input handles associated with the device. When</span><br><span class="line"> *	accessing the list dev-&gt;mutex must be held</span><br><span class="line"> * @node: used to place the device onto input_dev_list</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_dev &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *phys;</span><br><span class="line">	const char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line"></span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">       &#x2F;&#x2F;EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件</span><br><span class="line">       &#x2F;&#x2F;EV_KEY       键盘事件</span><br><span class="line">       &#x2F;&#x2F;EV_REL       (relative)相对坐标事件，比如鼠标</span><br><span class="line">       &#x2F;&#x2F;EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应</span><br><span class="line">       &#x2F;&#x2F;EV_MSC      其他事件,功能</span><br><span class="line">       &#x2F;&#x2F;EV_LED       LED灯事件</span><br><span class="line">       &#x2F;&#x2F;EV_SND      (sound)声音事件</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_REP       重复键盘按键事件</span><br><span class="line">       &#x2F;&#x2F;(内部会定义一个定时器,若有键盘按键事件一直按下&#x2F;松开,就重复定时,时间一到就上报事件)   </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_FF         受力事件</span><br><span class="line">       &#x2F;&#x2F;EV_PWR      电源事件</span><br><span class="line">       &#x2F;&#x2F;EV_FF_STATUS  受力状态事件</span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];   &#x2F;&#x2F;输入事件类型</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F;定义按键类型中的code,比如L、H键</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;&#x2F;存放支持的相对坐标值</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; &#x2F;&#x2F;存放支持的绝对坐标值</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; &#x2F;&#x2F;存放支持的其它事件,也就是功能</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; &#x2F;&#x2F;存放支持的各种状态LED</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; &#x2F;&#x2F;存放支持的各种声音</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];   &#x2F;&#x2F;存放支持的受力设备</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];  &#x2F;&#x2F;存放支持的开关功能</span><br><span class="line"></span><br><span class="line">	unsigned int hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">	unsigned int keycodemax;</span><br><span class="line">	unsigned int keycodesize;</span><br><span class="line">	void *keycode;</span><br><span class="line"></span><br><span class="line">	int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  const struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned int *old_keycode);</span><br><span class="line">	int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line"></span><br><span class="line">	struct ff_device *ff;</span><br><span class="line"></span><br><span class="line">	unsigned int repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line"></span><br><span class="line">	int rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">	struct input_mt_slot *mt;</span><br><span class="line">	int mtsize;</span><br><span class="line">	int slot;</span><br><span class="line">	int trkid;</span><br><span class="line"></span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line"></span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F;映射设备当前按键的状态</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	int (*open)(struct input_dev *dev);</span><br><span class="line">	void (*close)(struct input_dev *dev);</span><br><span class="line">	int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br><span class="line"></span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line"></span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	unsigned int users;</span><br><span class="line">	bool going_away;</span><br><span class="line"></span><br><span class="line">	bool sync;</span><br><span class="line"></span><br><span class="line">	struct device dev;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><blockquote>
<p>1、给struct input_dev对象分配一块内存</p>
<p>​      struct input_dev *input_allocate_device(void)</p>
<p>2、填充struct input_dev对象</p>
<p>比如，设置事件类型、事件类型的code</p>
<pre><code>set_bit(EV_ABS, input_dev-&gt;evbit);
input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
/* For single touch */
input_set_abs_params(input_dev, ABS_X, 0, data-&gt;max_x, 0, 0);
input_set_abs_params(input_dev, ABS_Y, 0, data-&gt;max_y, 0, 0);
input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);</code></pre><p>3、注册input_dev设备</p>
<p>int input_register_device(struct input_dev *dev)</p>
<p>4、配置中断，定义中断处理函数</p>
<p>5、上报事件并同步</p>
<p>void input_report_abs(struct input_dev *dev, unsigned int code, int value)</p>
<p>void input_sync(struct input_dev *dev)</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>mXT2952T2驱动位于drivers/input/touchscreen/atmel_mxt_ts.c</p>
<p>1、注册i2c 总线驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);</span><br><span class="line"></span><br><span class="line">static const struct of_device_id mxt_of_match[] &#x3D; &#123;</span><br><span class="line">	&#123; .compatible &#x3D; &quot;atmel,maxtouch&quot;, &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, mxt_of_match);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ACPI</span><br><span class="line">static const struct acpi_device_id mxt_acpi_id[] &#x3D; &#123;</span><br><span class="line">	&#123; &quot;ATML0000&quot;, 0 &#125;,	&#x2F;* Touchpad *&#x2F;</span><br><span class="line">	&#123; &quot;ATML0001&quot;, 0 &#125;,	&#x2F;* Touchscreen *&#x2F;</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(acpi, mxt_acpi_id);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const struct i2c_device_id mxt_id[] &#x3D; &#123;</span><br><span class="line">	&#123; &quot;qt602240_ts&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;atmel_mxt_ts&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;atmel_mxt_tp&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;maxtouch&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;mXT224&quot;, 0 &#125;,</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(i2c, mxt_id);</span><br><span class="line"></span><br><span class="line">static struct i2c_driver mxt_driver &#x3D; &#123;</span><br><span class="line">	.driver &#x3D; &#123;</span><br><span class="line">		.name	&#x3D; &quot;atmel_mxt_ts&quot;,</span><br><span class="line">		.owner	&#x3D; THIS_MODULE,</span><br><span class="line">&#x2F;&#x2F;		.of_match_table &#x3D; of_match_ptr(mxt_of_match),</span><br><span class="line">&#x2F;&#x2F;		.acpi_match_table &#x3D; ACPI_PTR(mxt_acpi_id),</span><br><span class="line">		.pm	&#x3D; &amp;mxt_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe		&#x3D; mxt_probe,</span><br><span class="line">	.remove		&#x3D; mxt_remove,</span><br><span class="line">	.id_table	&#x3D; mxt_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init mxt_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return i2c_add_driver(&amp;mxt_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mxt_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_del_driver(&amp;mxt_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mxt_init);</span><br><span class="line">module_exit(mxt_exit);</span><br><span class="line">&#x2F;* Module information *&#x2F;</span><br><span class="line">MODULE_AUTHOR(&quot;Joonyoung Shim &lt;jy0922.shim@samsung.com&gt;&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Atmel maXTouch Touchscreen driver&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p>2、编写probe函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mxt_data *data;</span><br><span class="line">	const struct mxt_platform_data *pdata;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	pdata &#x3D; mxt_get_platform_data(client);</span><br><span class="line">	if (IS_ERR(pdata))</span><br><span class="line">		return PTR_ERR(pdata);</span><br><span class="line"></span><br><span class="line">	data &#x3D; kzalloc(sizeof(struct mxt_data), GFP_KERNEL);</span><br><span class="line">	if (!data)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	snprintf(data-&gt;phys, sizeof(data-&gt;phys), &quot;i2c-%u-%04x&#x2F;input0&quot;,</span><br><span class="line">		 client-&gt;adapter-&gt;nr, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	data-&gt;client &#x3D; client;</span><br><span class="line"></span><br><span class="line">	data-&gt;pdata &#x3D; pdata;</span><br><span class="line">	i2c_set_clientdata(client, data);</span><br><span class="line"></span><br><span class="line">	if (data-&gt;pdata-&gt;cfg_name)</span><br><span class="line">		mxt_update_file_name(&amp;data-&gt;client-&gt;dev,</span><br><span class="line">				     &amp;data-&gt;cfg_name,</span><br><span class="line">				     data-&gt;pdata-&gt;cfg_name,</span><br><span class="line">				     strlen(data-&gt;pdata-&gt;cfg_name));</span><br><span class="line"></span><br><span class="line">	init_completion(&amp;data-&gt;chg_completion);</span><br><span class="line">	init_completion(&amp;data-&gt;reset_completion);</span><br><span class="line">	init_completion(&amp;data-&gt;crc_completion);</span><br><span class="line">	mutex_init(&amp;data-&gt;debug_msg_lock);</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;suspend_mode &#x3D;&#x3D; MXT_SUSPEND_REGULATOR) &#123;</span><br><span class="line">		error &#x3D; mxt_acquire_irq(data);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_mem;</span><br><span class="line"></span><br><span class="line">		error &#x3D; mxt_probe_regulators(data);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_irq;</span><br><span class="line"></span><br><span class="line">		disable_irq(data-&gt;irq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; sysfs_create_group(&amp;client-&gt;dev.kobj, &amp;mxt_fw_attr_group);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		dev_err(&amp;client-&gt;dev, &quot;Failure %d creating fw sysfs group\n&quot;,</span><br><span class="line">			error);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_initialize(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_irq;</span><br><span class="line"></span><br><span class="line">	setup_timer(&amp;data-&gt;timer, mxt_heartbeat_timer, (unsigned long)data);</span><br><span class="line">	data-&gt;timer.expires &#x3D; jiffies + msecs_to_jiffies(3 * 1000);</span><br><span class="line">	add_timer(&amp;data-&gt;timer);</span><br><span class="line"></span><br><span class="line">	INIT_WORK(&amp;data-&gt;reset_task, mxt_heartbeat_reset_task);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_irq:</span><br><span class="line">	if (data-&gt;irq)</span><br><span class="line">		free_irq(data-&gt;irq, data);</span><br><span class="line">err_free_mem:</span><br><span class="line">	kfree(data);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mxt_initialize函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">static int mxt_initialize(struct mxt_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client *client &#x3D; data-&gt;client;</span><br><span class="line">	int recovery_attempts &#x3D; 0;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		error &#x3D; mxt_read_info_block(data);</span><br><span class="line">		if (!error)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Check bootloader state *&#x2F;</span><br><span class="line">		error &#x3D; mxt_probe_bootloader(data, false);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			dev_info(&amp;client-&gt;dev, &quot;Trying alternate bootloader address\n&quot;);</span><br><span class="line">			error &#x3D; mxt_probe_bootloader(data, true);</span><br><span class="line">			if (error) &#123;</span><br><span class="line">				&#x2F;* Chip is not in appmode or bootloader mode *&#x2F;</span><br><span class="line">				return error;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;* OK, we are in bootloader, see if we can recover *&#x2F;</span><br><span class="line">		if (++recovery_attempts &gt; 1) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev, &quot;Could not recover from bootloader mode\n&quot;);</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * We can reflash from this state, so do not</span><br><span class="line">			 * abort initialization.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			data-&gt;in_bootloader &#x3D; true;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Attempt to exit bootloader into app mode *&#x2F;</span><br><span class="line">		mxt_send_bootloader_cmd(data, false);</span><br><span class="line">		msleep(MXT_FW_RESET_TIME);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_check_retrigen(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_acquire_irq(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_sysfs_init(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_debug_msg_init(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;cfg_name) &#123;</span><br><span class="line">		error &#x3D; request_firmware_nowait(THIS_MODULE, true,</span><br><span class="line">					data-&gt;cfg_name, &amp;data-&gt;client-&gt;dev,</span><br><span class="line">					GFP_KERNEL, data, mxt_config_cb);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev, &quot;Failed to invoke firmware loader: %d\n&quot;,</span><br><span class="line">				error);</span><br><span class="line">			goto err_free_object_table;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		error &#x3D; mxt_configure_objects(data, NULL);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_object_table;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_object_table:</span><br><span class="line">	mxt_free_object_table(data);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mxt_configure_objects(data, NULL)</p>
<p>  –mxt_initialize_input_device（）//注册input_dev</p>
<p>-mxt_initialize_input_device函数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">static int mxt_initialize_input_device(struct mxt_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	const struct mxt_platform_data *pdata &#x3D; data-&gt;pdata;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	struct input_dev *input_dev;</span><br><span class="line">	int error;</span><br><span class="line">	unsigned int num_mt_slots;</span><br><span class="line">	unsigned int mt_flags &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	switch (data-&gt;multitouch) &#123;</span><br><span class="line">	case MXT_TOUCH_MULTI_T9:</span><br><span class="line">		num_mt_slots &#x3D; data-&gt;T9_reportid_max - data-&gt;T9_reportid_min + 1;</span><br><span class="line">		error &#x3D; mxt_read_t9_resolution(data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to initialize T9 resolution\n&quot;);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case MXT_TOUCH_MULTITOUCHSCREEN_T100:</span><br><span class="line">		num_mt_slots &#x3D; data-&gt;num_touchids;</span><br><span class="line">		error &#x3D; mxt_read_t100_config(data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to read T100 config\n&quot;);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		dev_err(dev, &quot;Invalid multitouch object\n&quot;);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Handle default values and orientation switch *&#x2F;</span><br><span class="line">	if (data-&gt;max_x &#x3D;&#x3D; 0)</span><br><span class="line">		data-&gt;max_x &#x3D; 1023;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;max_y &#x3D;&#x3D; 0)</span><br><span class="line">		data-&gt;max_y &#x3D; 1023;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;xy_switch)</span><br><span class="line">		swap(data-&gt;max_x, data-&gt;max_y);</span><br><span class="line"></span><br><span class="line">	printk( &quot;Touchscreen size X%uY%u\n&quot;, data-&gt;max_x, data-&gt;max_y);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Register input device *&#x2F;</span><br><span class="line">	input_dev &#x3D; input_allocate_device();</span><br><span class="line">	if (!input_dev)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;pdata-&gt;input_name)</span><br><span class="line">		input_dev-&gt;name &#x3D; data-&gt;pdata-&gt;input_name;</span><br><span class="line">	else</span><br><span class="line">		input_dev-&gt;name &#x3D; &quot;Atmel_maXTouch_Touchscreen&quot;;</span><br><span class="line"></span><br><span class="line">	input_dev-&gt;phys &#x3D; data-&gt;phys;</span><br><span class="line">	input_dev-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">	input_dev-&gt;dev.parent &#x3D; dev;</span><br><span class="line">	input_dev-&gt;open &#x3D; mxt_input_open;</span><br><span class="line">	input_dev-&gt;close &#x3D; mxt_input_close;</span><br><span class="line"></span><br><span class="line">	set_bit(EV_ABS, input_dev-&gt;evbit);</span><br><span class="line">	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);</span><br><span class="line"></span><br><span class="line">	&#x2F;* For single touch *&#x2F;</span><br><span class="line">	input_set_abs_params(input_dev, ABS_X, 0, data-&gt;max_x, 0, 0);</span><br><span class="line">	input_set_abs_params(input_dev, ABS_Y, 0, data-&gt;max_y, 0, 0);</span><br><span class="line">	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* For T107 Active Stylus *&#x2F;</span><br><span class="line">	if (data-&gt;multitouch &#x3D;&#x3D; MXT_TOUCH_MULTITOUCHSCREEN_T100 &amp;&amp;</span><br><span class="line">	    data-&gt;T107_address) &#123;</span><br><span class="line">		error &#x3D; mxt_set_up_active_stylus(input_dev, data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to read T107 config\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* For T15 Key Array *&#x2F;</span><br><span class="line">	if (data-&gt;T15_reportid_min) &#123;</span><br><span class="line">		data-&gt;t15_keystatus &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (i &#x3D; 0; i &lt; data-&gt;pdata-&gt;t15_num_keys; i++)</span><br><span class="line">			input_set_capability(input_dev, EV_KEY,</span><br><span class="line">					data-&gt;pdata-&gt;t15_keymap[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_set_drvdata(input_dev, data);</span><br><span class="line"></span><br><span class="line">	error &#x3D; input_register_device(input_dev);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		dev_err(dev, &quot;Error %d registering input device\n&quot;, error);</span><br><span class="line">		goto err_free_mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;input_dev &#x3D; input_dev;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_mem:</span><br><span class="line">	input_free_device(input_dev);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写中断函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t mxt_interrupt(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mxt_data *data &#x3D; dev_id;</span><br><span class="line"></span><br><span class="line">	complete(&amp;data-&gt;chg_completion);</span><br><span class="line"></span><br><span class="line">	if (data-&gt;in_bootloader) &#123;</span><br><span class="line">		if (data-&gt;flash &amp;&amp; &amp;data-&gt;flash-&gt;work)</span><br><span class="line">			cancel_delayed_work_sync(&amp;data-&gt;flash-&gt;work);</span><br><span class="line"></span><br><span class="line">		return IRQ_RETVAL(mxt_check_bootloader(data));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!data-&gt;object_table)</span><br><span class="line">		return IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;T44_address) &#123;</span><br><span class="line">		return mxt_process_messages_t44(data);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return mxt_process_messages(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断函数处理过程</p>
<p> mxt_process_messages_t44</p>
<p>   –&gt;mxt_proc_message</p>
<p>​          –&gt;mxt_proc_t100_message //上报事件</p>
<p>看看mxt_proc_t100_message实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	struct input_dev *input_dev &#x3D; data-&gt;input_dev;</span><br><span class="line">	int id;</span><br><span class="line">	u8 status;</span><br><span class="line">	u8 type &#x3D; 0;</span><br><span class="line">	u16 x;</span><br><span class="line">	u16 y;</span><br><span class="line">	int distance &#x3D; 0;</span><br><span class="line">	int tool &#x3D; 0;</span><br><span class="line">	u8 major &#x3D; 0;</span><br><span class="line">	u8 pressure &#x3D; 0;</span><br><span class="line">	u8 orientation &#x3D; 0;</span><br><span class="line">	bool active &#x3D; false;</span><br><span class="line">	bool hover &#x3D; false;</span><br><span class="line"></span><br><span class="line">	id &#x3D; message[0] - data-&gt;T100_reportid_min - 2;</span><br><span class="line"></span><br><span class="line">	&#x2F;* ignore SCRSTATUS events *&#x2F;</span><br><span class="line">	if (id &lt; 0)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	status &#x3D; message[1];</span><br><span class="line">	x &#x3D; get_unaligned_le16(&amp;message[2]);</span><br><span class="line">	y &#x3D; get_unaligned_le16(&amp;message[4]);</span><br><span class="line"></span><br><span class="line">	if (status &amp; MXT_T100_DETECT) &#123;</span><br><span class="line">		type &#x3D; (status &amp; MXT_T100_TYPE_MASK) &gt;&gt; 4;</span><br><span class="line"></span><br><span class="line">		switch (type) &#123;</span><br><span class="line">		case MXT_T100_TYPE_HOVERING_FINGER:</span><br><span class="line">			tool &#x3D; MT_TOOL_FINGER;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_HOVERING;</span><br><span class="line">			hover &#x3D; true;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_FINGER:</span><br><span class="line">		case MXT_T100_TYPE_GLOVE:</span><br><span class="line">			tool &#x3D; MT_TOOL_FINGER;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			hover &#x3D; false;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_area)</span><br><span class="line">				major &#x3D; message[data-&gt;t100_aux_area];</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_ampl)</span><br><span class="line">				pressure &#x3D; message[data-&gt;t100_aux_ampl];</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_vect)</span><br><span class="line">				orientation &#x3D; message[data-&gt;t100_aux_vect];</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_PASSIVE_STYLUS:</span><br><span class="line">			tool &#x3D; MT_TOOL_PEN;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			hover &#x3D; false;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line"></span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * Passive stylus is reported with size zero so</span><br><span class="line">			 * hardcode.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			major &#x3D; MXT_TOUCH_MAJOR_DEFAULT;</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_ampl)</span><br><span class="line">				pressure &#x3D; message[data-&gt;t100_aux_ampl];</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_ACTIVE_STYLUS:</span><br><span class="line">			&#x2F;* Report input buttons *&#x2F;</span><br><span class="line">			input_report_key(input_dev, BTN_STYLUS,</span><br><span class="line">					 message[6] &amp; MXT_T107_STYLUS_BUTTON0);</span><br><span class="line">			input_report_key(input_dev, BTN_STYLUS2,</span><br><span class="line">					 message[6] &amp; MXT_T107_STYLUS_BUTTON1);</span><br><span class="line"></span><br><span class="line">			&#x2F;* stylus in range, but position unavailable *&#x2F;</span><br><span class="line">			if (!(message[6] &amp; MXT_T107_STYLUS_HOVER))</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			tool &#x3D; MT_TOOL_PEN;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line">			major &#x3D; MXT_TOUCH_MAJOR_DEFAULT;</span><br><span class="line"></span><br><span class="line">			if (!(message[6] &amp; MXT_T107_STYLUS_TIPSWITCH)) &#123;</span><br><span class="line">				hover &#x3D; true;</span><br><span class="line">				distance &#x3D; MXT_DISTANCE_HOVERING;</span><br><span class="line">			&#125; else if (data-&gt;stylus_aux_pressure) &#123;</span><br><span class="line">				pressure &#x3D; message[data-&gt;stylus_aux_pressure];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_LARGE_TOUCH:</span><br><span class="line">			&#x2F;* Ignore suppressed touch *&#x2F;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		default:</span><br><span class="line">			dev_dbg(dev, &quot;Unexpected T100 type\n&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Values reported should be non-zero if tool is touching the</span><br><span class="line">	 * device</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!pressure &amp;&amp; !hover)</span><br><span class="line">		pressure &#x3D; MXT_PRESSURE_DEFAULT;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;input_mt_slot(input_dev, id);</span><br><span class="line"></span><br><span class="line">	if (active) &#123;</span><br><span class="line">&#x2F;&#x2F;		printk( &quot;[%u] type:%u x:%u y:%u a:%02X p:%02X v:%02X\n&quot;,</span><br><span class="line">&#x2F;&#x2F;			id, type, x, y, major, pressure, orientation);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;		input_mt_report_slot_state(input_dev, tool, 1);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_POSITION_X, x);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_POSITION_Y, y);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, major);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_PRESSURE, pressure);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_DISTANCE, distance);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_ORIENTATION, orientation);</span><br><span class="line"></span><br><span class="line">		input_report_abs(input_dev, ABS_X, x);</span><br><span class="line">		input_report_abs(input_dev, ABS_Y, y);</span><br><span class="line">		input_report_key(input_dev, BTN_TOUCH, 1);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_PRESSURE, 1);</span><br><span class="line">		input_sync(input_dev);</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;		printk( &quot;[%u] release\n&quot;, id);</span><br><span class="line"></span><br><span class="line">		&#x2F;* close out slot *&#x2F;</span><br><span class="line">&#x2F;&#x2F;		input_mt_report_slot_state(input_dev, 0, 0);</span><br><span class="line">		input_report_key(input_dev, BTN_TOUCH, 0);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_PRESSURE, 0);</span><br><span class="line">		input_sync(input_dev);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;update_input &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ # hexdump &#x2F;dev&#x2F;input&#x2F;event1</span><br><span class="line">0000000 45b4 386d 6bb2 000d 0003 0000 02e6 0000</span><br><span class="line">0000010 45b4 386d 6bb6 000d 0003 0001 01a5 0000</span><br><span class="line">0000020 45b4 386d 6bb9 000d 0001 014a 0001 0000</span><br><span class="line">0000030 45b4 386d 6bbb 000d 0000 0000 0000 0000</span><br><span class="line">0000040 45b4 386d 41ff 000e 0001 014a 0000 0000</span><br><span class="line">0000050 45b4 386d 4202 000e 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexdump &#x2F;dev&#x2F;event1</span><br><span class="line"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     # input_report_abs(ts.dev, ABS_X, ts.xp);</span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     # input_report_abs(ts.dev, ABS_Y, ts.yp);</span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     # input_report_abs(ts.dev, ABS_PRESSURE, 1);</span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     # input_report_key(ts.dev, BTN_TOUCH, 1);</span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     # input_sync(ts.dev);</span><br></pre></td></tr></table></figure>

<h2 id="q-amp-s"><a href="#q-amp-s" class="headerlink" title="q&amp;s"></a>q&amp;s</h2><p>1、mxt2952驱动，如何上报坐标轴的数据给event handlers？</p>
<p>驱动初始化中先设置设备的事件类型和code，触摸屏要设置坐标范围，然后就可以通过void input_report_abs(struct input_dev *dev, unsigned int code, int value)函数上报数据</p>
<p>2、输入设备产生的数据，用什么来描述？</p>
<p>设备产生的数据，经过event handlers 封装成struct input_event对象，然后递交给应用层。struct input_event结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct input_event &#123;</span><br><span class="line">	struct timeval time;</span><br><span class="line">	__u16 type;</span><br><span class="line">	__u16 code;</span><br><span class="line">	__s32 value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、如何事件类型、code和value关系</p>
<p>事件类型就是指各种输入设备，比如鼠标，键盘，触摸屏等</p>
<p>code就是对事件类型在划分一个层次，比如键盘事件类型，键盘有很多按键，比如H、L 、U,这些按键就是code。</p>
<p>value就是code的值</p>
<p>4、如何理解设置事件类型的函数</p>
<p>先看一下内核关于bit操作的宏定义在include/linux/bitops.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define BIT(nr)			(1UL &lt;&lt; (nr)) &#x2F;&#x2F;UL中的第几bit</span><br><span class="line">#define BIT_MASK(nr)		(1UL &lt;&lt; ((nr) % BITS_PER_LONG))</span><br><span class="line">#define BIT_WORD(nr)		((nr) &#x2F; BITS_PER_LONG) 表示bit在第几个long</span><br><span class="line">#define BITS_PER_BYTE		8</span><br><span class="line">#define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long)) &#x2F;&#x2F;根据占用long的bit的数量，计算数组的长度</span><br></pre></td></tr></table></figure>

<p>在include/linux/kernel.h定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) &#x2F; (d))</span><br></pre></td></tr></table></figure>

<p>在看input_dev结构体中如何表示一组事件类型和code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br></pre></td></tr></table></figure>

<p>从上面看出，用一个unsigned long 中的bit表示事件类型和code,用数组存储事件类型和code，数组的大小根据占用了多少bit来计算。</p>
<p>因此，设置事件类型可以使用下面的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev-&gt;keybit[BIT_WORD(BTN_TOUCH)] &#x3D; BIT(BTN_TOUCH);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_bit(EV_ABS, input_dev-&gt;evbit);</span><br></pre></td></tr></table></figure>

<p>5、为什么要设置事件类型和code？</p>
<p>首先，上报事件函数根据具体的事件类型和code,判断input core 是否支持该类型和code，如果支持，才做下一步上报数据的操作。看一个按键上报函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有上报事件函数，都会直接调用input_event()函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void input_event(struct input_dev *dev,</span><br><span class="line">		 unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">		add_input_randomness(type, code, value);</span><br><span class="line">		input_handle_event(dev, type, code, value);</span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">static void input_handle_event(struct input_dev *dev,</span><br><span class="line">			       unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	int disposition &#x3D; INPUT_IGNORE_EVENT;</span><br><span class="line"></span><br><span class="line">	switch (type) &#123;</span><br><span class="line"></span><br><span class="line">	case EV_SYN:</span><br><span class="line">		switch (code) &#123;</span><br><span class="line">		case SYN_CONFIG:</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case SYN_REPORT:</span><br><span class="line">			if (!dev-&gt;sync) &#123;</span><br><span class="line">				dev-&gt;sync &#x3D; true;</span><br><span class="line">				disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		case SYN_MT_REPORT:</span><br><span class="line">			dev-&gt;sync &#x3D; false;</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_KEY:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;keybit, KEY_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;key) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			if (value !&#x3D; 2) &#123;</span><br><span class="line">				__change_bit(code, dev-&gt;key);</span><br><span class="line">				if (value)</span><br><span class="line">					input_start_autorepeat(dev, code);</span><br><span class="line">				else</span><br><span class="line">					input_stop_autorepeat(dev);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_SW:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;sw) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;sw);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_ABS:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;absbit, ABS_MAX))</span><br><span class="line">			disposition &#x3D; input_handle_abs_event(dev, code, &amp;value);</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_REL:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_MSC:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_LED:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;led) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;led);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_SND:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">			if (!!test_bit(code, dev-&gt;snd) !&#x3D; !!value)</span><br><span class="line">				__change_bit(code, dev-&gt;snd);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_REP:</span><br><span class="line">		if (code &lt;&#x3D; REP_MAX &amp;&amp; value &gt;&#x3D; 0 &amp;&amp; dev-&gt;rep[code] !&#x3D; value) &#123;</span><br><span class="line">			dev-&gt;rep[code] &#x3D; value;</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_FF:</span><br><span class="line">		if (value &gt;&#x3D; 0)</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_PWR:</span><br><span class="line">		disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (disposition !&#x3D; INPUT_IGNORE_EVENT &amp;&amp; type !&#x3D; EV_SYN)</span><br><span class="line">		dev-&gt;sync &#x3D; false;</span><br><span class="line"></span><br><span class="line">	if ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">		dev-&gt;event(dev, type, code, value);</span><br><span class="line"></span><br><span class="line">	if (disposition &amp; INPUT_PASS_TO_HANDLERS)</span><br><span class="line">		input_pass_event(dev, type, code, value); &#x2F;&#x2F;类型和code符合，上报事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Pass event first through all filters and then, if event has not been</span><br><span class="line"> * filtered out, through all open handles. This function is called with</span><br><span class="line"> * dev-&gt;event_lock held and interrupts disabled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void input_pass_event(struct input_dev *dev,</span><br><span class="line">			     unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	struct input_handle *handle;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	handle &#x3D; rcu_dereference(dev-&gt;grab);</span><br><span class="line">	if (handle)</span><br><span class="line">		handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用event handler的event函数</span><br><span class="line">	else &#123;</span><br><span class="line">		bool filtered &#x3D; false;</span><br><span class="line"></span><br><span class="line">		list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) &#123;</span><br><span class="line">			if (!handle-&gt;open)</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			handler &#x3D; handle-&gt;handler;</span><br><span class="line">			if (!handler-&gt;filter) &#123;</span><br><span class="line">				if (filtered)</span><br><span class="line">					break;</span><br><span class="line"></span><br><span class="line">				handler-&gt;event(handle, type, code, value);</span><br><span class="line"></span><br><span class="line">			&#125; else if (handler-&gt;filter(handle, type, code, value))</span><br><span class="line">				filtered &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、为什么上报事件后，一定需要同步？</p>
<p>上报事件，实际上驱动把数据递交给event handlers ,然后event handlers 存在一个Buffer,需要同步，才把Buffer的数据递交给应用层。</p>
<p>驱动程序上报事件，本质是调用handlers的event事件处理函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Pass incoming event to all connected clients.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void evdev_event(struct input_handle *handle,</span><br><span class="line">			unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev *evdev &#x3D; handle-&gt;private;</span><br><span class="line">	struct evdev_client *client;</span><br><span class="line">	struct input_event event;</span><br><span class="line"></span><br><span class="line">	do_gettimeofday(&amp;event.time);</span><br><span class="line">	event.type &#x3D; type;</span><br><span class="line">	event.code &#x3D; code;</span><br><span class="line">	event.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	client &#x3D; rcu_dereference(evdev-&gt;grab);</span><br><span class="line">	if (client)</span><br><span class="line">		evdev_pass_event(client, &amp;event);</span><br><span class="line">	else</span><br><span class="line">		list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">			evdev_pass_event(client, &amp;event); &#x2F;&#x2F;把event事件存储起来</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	if (type &#x3D;&#x3D; EV_SYN &amp;&amp; code &#x3D;&#x3D; SYN_REPORT) &#x2F;&#x2F;收到同步信号，就唤醒read去去读buffer</span><br><span class="line">		wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>evdev_pass_event()函数把event事件存储在buffer里面，函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void evdev_pass_event(struct evdev_client *client,</span><br><span class="line">			     struct input_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Interrupts are disabled, just acquire the lock. *&#x2F;</span><br><span class="line">	spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">	client-&gt;buffer[client-&gt;head++] &#x3D; *event;</span><br><span class="line">	client-&gt;head &amp;&#x3D; client-&gt;bufsize - 1;</span><br><span class="line"></span><br><span class="line">	if (unlikely(client-&gt;head &#x3D;&#x3D; client-&gt;tail)) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * This effectively &quot;drops&quot; all unconsumed events, leaving</span><br><span class="line">		 * EV_SYN&#x2F;SYN_DROPPED plus the newest event in the queue.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		client-&gt;tail &#x3D; (client-&gt;head - 2) &amp; (client-&gt;bufsize - 1);</span><br><span class="line"></span><br><span class="line">		client-&gt;buffer[client-&gt;tail].time &#x3D; event-&gt;time;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].type &#x3D; EV_SYN;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].code &#x3D; SYN_DROPPED;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		client-&gt;packet_head &#x3D; client-&gt;tail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (event-&gt;type &#x3D;&#x3D; EV_SYN &amp;&amp; event-&gt;code &#x3D;&#x3D; SYN_REPORT) &#123;</span><br><span class="line">		client-&gt;packet_head &#x3D; client-&gt;head;</span><br><span class="line">		kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Meng">
      <meta itemprop="description" content="冒险，创新，永不放弃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">linux input子系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-04 15:35:27" itemprop="dateCreated datePublished" datetime="2021-01-04T15:35:27+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-07 14:01:17" itemprop="dateModified" datetime="2021-01-07T14:01:17+08:00">2021-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/" itemprop="url" rel="index"><span itemprop="name">Driver</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/Driver/Input%E5%AD%90%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Input子系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>输入子系统，用于管理各种输入设备，采用软件分层的思想，把一些通用的操作和经常需要更改的操作分开。通用的部分就是纯软件逻辑，不涉及硬件操作，而经常需要更改的部分就是配置硬件。因此通过输入子系统，让各种输入设备开发比较简单，不需重复编写通用的代码，只需要专注硬件的配置就可以了。那么，什么是输入设备？从IO角度看，与cpu的输入IO引脚连接的设备就是输入设备，比如按键；从广义角度，人机交互的设备就是输入设备，比如鼠标，键盘，触摸屏。关于Input Subsystem定义：</p>
<p>The input subsystem is the part of the Linux kernel that manages the various input devices (such as keyboards, mice, joysticks, tablets and a wide range of other devices) that a user uses to interact with the kernel, command line and graphical user interface. This subsystem is included in the kernel because these devices usually are accessed through special hardware interfaces (such as serial ports, PS/2 ports, Apple Desktop Bus and the Universal Serial Bus), which are protected and managed by the kernel. The kernel then exposes the user input in a consistent, device-independent way to user space through a range of defined APIs</p>
<p>Linux 输入子系统全景图如下：</p>
<p><img src="http://jiali.clouddn.com/20210104_002.png" alt=""></p>
<p>​                                                                                                                       Linux 输入子系统全景图</p>
<p>input core 为event handlers和drivers层提供实现的接口；event handlers 为用户空间与内核空间交互提供接口；drivers,实现各种输入设备的操作。</p>
<h2 id="Input-Subsystem软件层次分析"><a href="#Input-Subsystem软件层次分析" class="headerlink" title="Input Subsystem软件层次分析"></a>Input Subsystem软件层次分析</h2><p> input subsystem 软件层次分为 input core层、drivers层 和 event handlers层。它们之间的关系如下图。</p>
<p><img src="http://jiali.clouddn.com/20210104_001.png" alt=""></p>
<p>​                                                                                                   input subsystem 软件层次图</p>
<ul>
<li>input core：提供input subsystem所有的核心操作，由drivers/input/input.c文件定义。</li>
<li>drivers:操作各种输入设备，与设备交互，把设备数据传给event handlers。</li>
<li>event handlers:定义应用层与内核交互的接口，并把收到的设备数据传给应用层。</li>
</ul>
<h2 id="Input-Subsystem设计"><a href="#Input-Subsystem设计" class="headerlink" title="Input Subsystem设计"></a>Input Subsystem设计</h2><p>1、主要数据结构</p>
<p><img src="http://jiali.clouddn.com/20210104_003.png" alt=""></p>
<p>​                                                                                                             表 输入子系统主要数据结构</p>
<p>数据链表如下：</p>
<p><img src="http://jiali.clouddn.com/20210107_001.png" alt=""></p>
<p>​                                                                                                      图 数据链表关系</p>
<p>2、软件设计</p>
<p>软件方案设计如下图</p>
<p><img src="http://jiali.clouddn.com/20210104_004.png" alt=""></p>
<p>​                                                                                                         图 软件方案设计</p>
<p>3、intput 子系统实现</p>
<p>input子系统实现如下图</p>
<p><img src="http://jiali.clouddn.com/20210105_001.png" alt=""></p>
<p>​                                                                                                              图 input 子系统实现</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>主要分析input.c 、evdev.c、触摸屏驱动atmel_mxt_ts.c这三个代表文件，理解input子系统如何工作。</p>
<h3 id="1、Linux-input-子系统目录层次"><a href="#1、Linux-input-子系统目录层次" class="headerlink" title="1、Linux input 子系统目录层次"></a>1、Linux input 子系统目录层次</h3><p>Linux input 子系统目录如下：</p>
<p><img src="http://jiali.clouddn.com/20210106_001.png" alt=""></p>
<p>input顶层目录包含各种event handlers(比如mousedev.c \evdev.c\joydev.c)和input core（input.c）,子目录就是输入设备驱动文件。</p>
<h3 id="2、主要数据结构关系"><a href="#2、主要数据结构关系" class="headerlink" title="2、主要数据结构关系"></a>2、主要数据结构关系</h3><p>（1）表示输入设备的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *phys;</span><br><span class="line">	const char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line"></span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned int hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">	unsigned int keycodemax;</span><br><span class="line">	unsigned int keycodesize;</span><br><span class="line">	void *keycode;</span><br><span class="line"></span><br><span class="line">	int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  const struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned int *old_keycode);</span><br><span class="line">	int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line"></span><br><span class="line">	struct ff_device *ff;</span><br><span class="line"></span><br><span class="line">	unsigned int repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line"></span><br><span class="line">	int rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">	struct input_mt_slot *mt;</span><br><span class="line">	int mtsize;</span><br><span class="line">	int slot;</span><br><span class="line">	int trkid;</span><br><span class="line"></span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line"></span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	int (*open)(struct input_dev *dev);</span><br><span class="line">	void (*close)(struct input_dev *dev);</span><br><span class="line">	int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br><span class="line"></span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line"></span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	unsigned int users;</span><br><span class="line">	bool going_away;</span><br><span class="line"></span><br><span class="line">	bool sync;</span><br><span class="line"></span><br><span class="line">	struct device dev;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）、表示evdev事件处理的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handler - implements one of interfaces for input devices</span><br><span class="line"> * @private: driver-specific data</span><br><span class="line"> * @event: event handler. This method is being called by input core with</span><br><span class="line"> *	interrupts disabled and dev-&gt;event_lock spinlock held and so</span><br><span class="line"> *	it may not sleep</span><br><span class="line"> * @filter: similar to @event; separates normal event handlers from</span><br><span class="line"> *	&quot;filters&quot;.</span><br><span class="line"> * @match: called after comparing device&#39;s id with handler&#39;s id_table</span><br><span class="line"> *	to perform fine-grained matching between device and handler</span><br><span class="line"> * @connect: called when attaching a handler to an input device</span><br><span class="line"> * @disconnect: disconnects a handler from input device</span><br><span class="line"> * @start: starts handler for given handle. This function is called by</span><br><span class="line"> *	input core right after connect() method and also when a process</span><br><span class="line"> *	that &quot;grabbed&quot; a device releases it</span><br><span class="line"> * @fops: file operations this driver implements</span><br><span class="line"> * @minor: beginning of range of 32 minors for devices this driver</span><br><span class="line"> *	can provide</span><br><span class="line"> * @name: name of the handler, to be shown in &#x2F;proc&#x2F;bus&#x2F;input&#x2F;handlers</span><br><span class="line"> * @id_table: pointer to a table of input_device_ids this driver can</span><br><span class="line"> *	handle</span><br><span class="line"> * @h_list: list of input handles associated with the handler</span><br><span class="line"> * @node: for placing the driver onto input_handler_list</span><br><span class="line"> *</span><br><span class="line"> * Input handlers attach to input devices and create input handles. There</span><br><span class="line"> * are likely several handlers attached to any given input device at the</span><br><span class="line"> * same time. All of them will get their copy of input event generated by</span><br><span class="line"> * the device.</span><br><span class="line"> *</span><br><span class="line"> * The very same structure is used to implement input filters. Input core</span><br><span class="line"> * allows filters to run first and will not pass event to regular handlers</span><br><span class="line"> * if any of the filters indicate that the event should be filtered (by</span><br><span class="line"> * returning %true from their filter() method).</span><br><span class="line"> *</span><br><span class="line"> * Note that input core serializes calls to connect() and disconnect()</span><br><span class="line"> * methods.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">	int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">	void (*disconnect)(struct input_handle *handle);</span><br><span class="line">	void (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">	const struct file_operations *fops;</span><br><span class="line">	int minor;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	const struct input_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）连接输入设备和event handler对象的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handle - links input device with an input handler</span><br><span class="line"> * @private: handler-specific data</span><br><span class="line"> * @open: counter showing whether the handle is &#39;open&#39;, i.e. should deliver</span><br><span class="line"> *	events from its device</span><br><span class="line"> * @name: name given to the handle by handler that created it</span><br><span class="line"> * @dev: input device the handle is attached to</span><br><span class="line"> * @handler: handler that works with the device through this handle</span><br><span class="line"> * @d_node: used to put the handle on device&#39;s list of attached handles</span><br><span class="line"> * @h_node: used to put the handle on handler&#39;s list of handles from which</span><br><span class="line"> *	it gets events</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	int open;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	struct input_dev *dev;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line"></span><br><span class="line">	struct list_head	d_node;</span><br><span class="line">	struct list_head	h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、input子系统的类"><a href="#3、input子系统的类" class="headerlink" title="3、input子系统的类"></a>3、input子系统的类</h3><p>根据数据结构的关系，总结出input子系统的类，如下</p>
<p><img src="http://jiali.clouddn.com/20210107_002.png" alt=""></p>
<p>​                                                                                                                   图 input子系统的类</p>
<h3 id="4、主要函数分析"><a href="#4、主要函数分析" class="headerlink" title="4、主要函数分析"></a>4、主要函数分析</h3><p>结合触摸屏、evdev  handler和input core 分析input 代码流程</p>
<p>首先初始化input 子系统,文件为drivers/input/input.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	err &#x3D; class_register(&amp;input_class);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register input_dev class\n&quot;);</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err &#x3D; input_proc_init();</span><br><span class="line">	if (err)</span><br><span class="line">		goto fail1;</span><br><span class="line"></span><br><span class="line">	err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">		goto fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit input_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_proc_exit();</span><br><span class="line">	unregister_chrdev(INPUT_MAJOR, &quot;input&quot;);</span><br><span class="line">	class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);</span><br><span class="line">module_exit(input_exit);</span><br></pre></td></tr></table></figure>

<p>其次，注册evdev handler</p>
<p>文件在drivers/input/evdev.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit evdev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，注册dev 驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_device - register device with input core</span><br><span class="line"> * @dev: device to be registered</span><br><span class="line"> *</span><br><span class="line"> * This function registers device with input core. The device must be</span><br><span class="line"> * allocated with input_allocate_device() and all it&#39;s capabilities</span><br><span class="line"> * set up before registering.</span><br><span class="line"> * If function fails the device must be freed with input_free_device().</span><br><span class="line"> * Once device has been successfully registered it can be unregistered</span><br><span class="line"> * with input_unregister_device(); input_free_device() should not be</span><br><span class="line"> * called in this case.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	static atomic_t input_no &#x3D; ATOMIC_INIT(0);</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	const char *path;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Every input device generates EV_SYN&#x2F;SYN_REPORT events. *&#x2F;</span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* KEY_RESERVED is not supposed to be transmitted to userspace. *&#x2F;</span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. *&#x2F;</span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;hint_events_per_packet)</span><br><span class="line">		dev-&gt;hint_events_per_packet &#x3D;</span><br><span class="line">				input_estimate_events_per_packet(dev);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If delay and period are pre-set by the driver, then autorepeating</span><br><span class="line">	 * is handled by the driver itself and we don&#39;t do it in input.c.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	init_timer(&amp;dev-&gt;timer);</span><br><span class="line">	if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">		dev-&gt;timer.data &#x3D; (long) dev;</span><br><span class="line">		dev-&gt;timer.function &#x3D; input_repeat_key;</span><br><span class="line">		dev-&gt;rep[REP_DELAY] &#x3D; 250;</span><br><span class="line">		dev-&gt;rep[REP_PERIOD] &#x3D; 33;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode &#x3D; input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode &#x3D; input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,</span><br><span class="line">		     (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;dev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(&quot;%s as %s\n&quot;,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;,</span><br><span class="line">		path ? path : &quot;N&#x2F;A&quot;);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		device_del(&amp;dev-&gt;dev);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>evdev handler 和dev注册都会判断evdev handler和dev 匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">	const struct input_device_id *id;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	id &#x3D; input_match_device(handler, dev);</span><br><span class="line">	if (!id)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	error &#x3D; handler-&gt;connect(handler, dev, id);</span><br><span class="line">	if (error &amp;&amp; error !&#x3D; -ENODEV)</span><br><span class="line">		pr_err(&quot;failed to attach handler %s to device %s, error: %d\n&quot;,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配成功后，调用 evdev handler 的connect函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Create new evdev device. Note that input core serializes calls</span><br><span class="line"> * to connect and disconnect so we don&#39;t need to lock evdev_table here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line">			 const struct input_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev *evdev;</span><br><span class="line">	int minor;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)</span><br><span class="line">		if (!evdev_table[minor])</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">	if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;</span><br><span class="line">		pr_err(&quot;no more free evdev devices\n&quot;);</span><br><span class="line">		return -ENFILE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);</span><br><span class="line">	if (!evdev)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">	spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">	mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">	init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);</span><br><span class="line">	evdev-&gt;exist &#x3D; true;</span><br><span class="line">	evdev-&gt;minor &#x3D; minor;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">	evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">	evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">	evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);</span><br><span class="line">	evdev-&gt;dev.class &#x3D; &amp;input_class;</span><br><span class="line">	evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;</span><br><span class="line">	evdev-&gt;dev.release &#x3D; evdev_free;</span><br><span class="line">	device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_evdev;</span><br><span class="line"></span><br><span class="line">	error &#x3D; evdev_install_chrdev(evdev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_unregister_handle;</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;evdev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">	evdev_cleanup(evdev);</span><br><span class="line"> err_unregister_handle:</span><br><span class="line">	input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line"> err_free_evdev:</span><br><span class="line">	put_device(&amp;evdev-&gt;dev);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在connect函数调用input_register_handle函数注册handle。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_handle - register a new input handle</span><br><span class="line"> * @handle: handle to register</span><br><span class="line"> *</span><br><span class="line"> * This function puts a new input handle onto device&#39;s</span><br><span class="line"> * and handler&#39;s lists so that events can flow through</span><br><span class="line"> * it once it is opened using input_open_device().</span><br><span class="line"> *</span><br><span class="line"> * This function is supposed to be called from handler&#39;s</span><br><span class="line"> * connect() method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_handle(struct input_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_handler *handler &#x3D; handle-&gt;handler;</span><br><span class="line">	struct input_dev *dev &#x3D; handle-&gt;dev;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * We take dev-&gt;mutex here to prevent race with</span><br><span class="line">	 * input_release_device().</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Filters go to the head of the list, normal handlers</span><br><span class="line">	 * to the tail.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (handler-&gt;filter)</span><br><span class="line">		list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">	else</span><br><span class="line">		list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Since we are supposed to be called from -&gt;connect()</span><br><span class="line">	 * which is mutually exclusive with -&gt;disconnect()</span><br><span class="line">	 * we can&#39;t be racing with input_unregister_handle()</span><br><span class="line">	 * and so separate lock is not needed here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	if (handler-&gt;start)</span><br><span class="line">		handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码分析完毕，后面看看应用层如何与input 子系统交互。</p>
<h2 id="应用层与内核input子系统交互"><a href="#应用层与内核input子系统交互" class="headerlink" title="应用层与内核input子系统交互"></a>应用层与内核input子系统交互</h2><p>应用层与设备交互，通过 Linux一套接口实现，就是open 、read 、write函数。这些函数最终会调用input 子系统的evdev handler 的fops的open、read和write。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>evdev_fops定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations evdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.read		&#x3D; evdev_read,</span><br><span class="line">	.write		&#x3D; evdev_write,</span><br><span class="line">	.poll		&#x3D; evdev_poll,</span><br><span class="line">	.open		&#x3D; evdev_open,</span><br><span class="line">	.release	&#x3D; evdev_release,</span><br><span class="line">	.unlocked_ioctl	&#x3D; evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl	&#x3D; evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">	.fasync		&#x3D; evdev_fasync,</span><br><span class="line">	.flush		&#x3D; evdev_flush,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看一下evdev_read</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *buffer,</span><br><span class="line">			  size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev_client *client &#x3D; file-&gt;private_data;</span><br><span class="line">	struct evdev *evdev &#x3D; client-&gt;evdev;</span><br><span class="line">	struct input_event event;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	if (count &lt; input_event_size())</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (client-&gt;packet_head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp;</span><br><span class="line">	    (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">		client-&gt;packet_head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line"></span><br><span class="line">	if (!evdev-&gt;exist)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	while (retval + input_event_size() &lt;&#x3D; count &amp;&amp;</span><br><span class="line">	       evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">		if (input_event_to_user(buffer + retval, &amp;event))</span><br><span class="line">			return -EFAULT;</span><br><span class="line"></span><br><span class="line">		retval +&#x3D; input_event_size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，可以看出input 子系统简化了输入设备的驱动程序开发。这边设备驱动专注设备的配置和交互，不用重新编写与应用层交互的代码。设备驱动遵循下面的流程：</p>
<blockquote>
<p>1、input_allocate_device() 给input_dev分配空间</p>
<p>2、设置input_dev对象，设置事件类型、code</p>
<p>3、硬件初始化，中断初始化，定义中断处理程序</p>
<p>4、通过 input_register_device() 注册 </p>
<p>5、定义中断处理程序，上报事件并同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、上报事件</span><br><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_switch(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">2、同步</span><br><span class="line">void input_sync(struct input_dev *dev)</span><br></pre></td></tr></table></figure>


</blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/lcw/p/3293302.html" target="_blank" rel="noopener">input子系统全面分析</a></p>
<p><a href="https://www.linuxjournal.com/article/6396" target="_blank" rel="noopener">The Linux USB Input Subsystem, Part I</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Meng"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Meng</p>
  <div class="site-description" itemprop="description">冒险，创新，永不放弃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jialimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jialimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiali201209@163.com" title="E-Mail → mailto:jiali201209@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ilinuxkernel.com/" title="http:&#x2F;&#x2F;ilinuxkernel.com" rel="noopener" target="_blank">Linux Kernel Exploration</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.wowotech.net/" title="http:&#x2F;&#x2F;www.wowotech.net" rel="noopener" target="_blank">蜗窝科技</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tinylab.org/" title="http:&#x2F;&#x2F;tinylab.org" rel="noopener" target="_blank">泰晓科技</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
