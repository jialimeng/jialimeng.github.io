<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>写得好得Linux博客</title>
    <url>/2021/01/18/Linux/%E5%86%99%E5%BE%97%E5%A5%BD%E7%9A%84Linux%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="底层驱动"><a href="#底层驱动" class="headerlink" title="底层驱动"></a>底层驱动</h2><p>1、来自CSDN博主：<a href="https://blog.csdn.net/lickylin" target="_blank" rel="noopener">jerry_chg</a>【<a href="https://blog.csdn.net/lickylin】" target="_blank" rel="noopener">https://blog.csdn.net/lickylin】</a></p>
<p>推荐理由：</p>
<p>Linux内容比较全面，基本覆盖了Linux驱动开发；Linux讲解深入；Linux内容新而且丰富，比如对pinctrl子系统。</p>
<p>2、来自博客园博主：<a href="https://home.cnblogs.com/u/lcw/" target="_blank" rel="noopener">Leo.cheng </a>【<a href="https://home.cnblogs.com/u/lcw/】" target="_blank" rel="noopener">https://home.cnblogs.com/u/lcw/】</a></p>
<p>推荐理由：</p>
<p>常见的Linux驱动，总结比较全面，简单容易理解，嵌入式知识丰富,比如LCD、RTC 、input。</p>
<p>3、来自博客园博主：<a href="https://home.cnblogs.com/u/Lioker/" target="_blank" rel="noopener">Lioker</a>【<a href="https://home.cnblogs.com/u/Lioker/】" target="_blank" rel="noopener">https://home.cnblogs.com/u/Lioker/】</a></p>
<p>推荐理由：</p>
<p>常见驱动总结得很好，逻辑清晰，比如DMA、RTC、EMMC、I2C。</p>
<p>4、来自博客园博主：<a href="https://home.cnblogs.com/u/lifexy/" target="_blank" rel="noopener">诺谦</a>【<a href="https://home.cnblogs.com/u/lifexy/】" target="_blank" rel="noopener">https://home.cnblogs.com/u/lifexy/】</a></p>
<p>推荐理由：</p>
<p>调试经验丰富，有电源管理系统讲解</p>
<p>5、来自CSDN :  <a href="https://xingxingzhihuo.blog.csdn.net/" target="_blank" rel="noopener">星星之火</a>【<a href="https://xingxingzhihuo.blog.csdn.net/】" target="_blank" rel="noopener">https://xingxingzhihuo.blog.csdn.net/】</a></p>
<p>推荐理由：</p>
<p>比较全面总结韦东山的教程视频</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h2 id="来自githubpage博客"><a href="#来自githubpage博客" class="headerlink" title="来自githubpage博客"></a>来自githubpage博客</h2><p>1、<a href="https://draapho.github.io/archives/" target="_blank" rel="noopener">https://draapho.github.io/archives/</a></p>
<p>推荐理由：</p>
<p>总结韦东山的视频教程资料，比较全</p>
<p>2、<a href="http://kcmetercec.top/" target="_blank" rel="noopener">http://kcmetercec.top/</a></p>
<p>推荐理由：</p>
<p>内容丰富，先保存</p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu中QT无法切换中文输入法</title>
    <url>/2020/07/28/ubuntu/ubuntu%E4%B8%ADQT%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在ubuntu下，系统自带的输入法为fcitx+Sunpinyin,然而QtCreator无法使用系统自带的中文输入法。原因是前下载的QtCreator中没有适配当前输入法框架（ibus、fcitx）的libfcitxplatforminputcontextplugin.so动态库。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>已经安装好的qt，且配置好环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QT_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake&#x2F;bin:$QT_PATH&#x2F;5.4&#x2F;gcc_64&#x2F;bin:$QT_PATH&#x2F;Tools&#x2F;QtCreator&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>1、下载fcitx-libs 源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fcitx&#x2F;fcitx-qt5.git</span><br></pre></td></tr></table></figure>

<p>2、编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd fcitx-qt5</span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>3、编译产生的 libfcitxplatforminputcontextplugin.so在fcitx-qt5/platforminputcontext下，拷贝这个so文件到 Qt5.5安装目录（非必须，因为安装后，会自动拷贝这个so文件到qt的安装目录）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd fcitx-qt5&#x2F;platforminputcontext </span><br><span class="line">cp libfcitxplatforminputcontextplugin.so &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;plugins&#x2F;platforminputcontexts -a</span><br><span class="line">cp libfcitxplatforminputcontextplugin.so &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;Tools&#x2F;QtCreator&#x2F;bin&#x2F;plugins&#x2F;platforminputcontexts -a</span><br></pre></td></tr></table></figure>

<p>4、重启QtCreator就可以使用系统自带的fcitx输入法了。</p>
<p><strong>编译fcitx-qt5库遇到缺失依赖库的问题：</strong></p>
<p>问题1：第一次编译 fcitx-qt5，会遇到的问题如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# cmake .</span><br><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++</span><br><span class="line">-- Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">CMake Error at CMakeLists.txt:8 (find_package):</span><br><span class="line">  Could not find a package configuration file provided by &quot;ECM&quot; (requested</span><br><span class="line">  version 1.4.0) with any of the following names:</span><br><span class="line"></span><br><span class="line">    ECMConfig.cmake</span><br><span class="line">    ecm-config.cmake</span><br><span class="line"></span><br><span class="line">  Add the installation prefix of &quot;ECM&quot; to CMAKE_PREFIX_PATH or set &quot;ECM_DIR&quot;</span><br><span class="line">  to a directory containing one of the above files.  If &quot;ECM&quot; provides a</span><br><span class="line">  separate development package or SDK, be sure it has been installed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;CMakeFiles&#x2F;CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>下载extra-cmake-modules</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# git clone https:&#x2F;&#x2F;github.com&#x2F;KDE&#x2F;extra-cmake-modules.git</span><br><span class="line">root@ubuntu:~# cd extra-cmake-modules&#x2F;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;extra-cmake-modules# cmake .</span><br><span class="line">-- Could NOT find Sphinx (missing:  Sphinx_BUILD_EXECUTABLE) (Required is at least version &quot;1.2&quot;)</span><br><span class="line">-- Found QCollectionGenerator: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;bin&#x2F;qcollectiongenerator (found version &quot;1.0&quot;) </span><br><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- WARNING: skipping tests that require PyQt</span><br><span class="line">-- </span><br><span class="line">-- The following features have been enabled:</span><br><span class="line"></span><br><span class="line"> * BUILD_TESTING , Build automated tests.</span><br><span class="line"></span><br><span class="line">-- The following OPTIONAL packages have been found:</span><br><span class="line"></span><br><span class="line"> * QCollectionGenerator , Qt help collection generator. , &lt;https:&#x2F;&#x2F;www.qt.io&#x2F;&gt;</span><br><span class="line">   Required to build Extra CMake Modules documentation in Qt Help format.</span><br><span class="line"> * Qt5LinguistTools , Qt5 linguist tools. , &lt;https:&#x2F;&#x2F;www.qt.io&#x2F;&gt;</span><br><span class="line">   Required to run tests for the ECMPoQmTools module.</span><br><span class="line"> * Qt5Core , Qt5 core library. , &lt;https:&#x2F;&#x2F;www.qt.io&#x2F;&gt;</span><br><span class="line">   Required to run tests for the ECMQtDeclareLoggingCategory module, and for some tests of the KDEInstallDirs module.</span><br><span class="line"> * Qt5Gui (required version &gt;&#x3D; 5.4.1)</span><br><span class="line"> * Qt5Network (required version &gt;&#x3D; 5.4.1)</span><br><span class="line"> * Qt5Qml (required version &gt;&#x3D; 5.4.1)</span><br><span class="line"> * Qt5Quick , Qt5 Quick library. , &lt;https:&#x2F;&#x2F;www.qt.io&#x2F;&gt;</span><br><span class="line">   Required to run tests for the ECMQMLModules module.</span><br><span class="line"></span><br><span class="line">-- The following features have been disabled:</span><br><span class="line"></span><br><span class="line"> * BUILD_HTML_DOCS , Generate HTML documentation for installed modules.</span><br><span class="line"> * BUILD_MAN_DOCS , Generate man page documentation for installed modules.</span><br><span class="line"> * BUILD_QTHELP_DOCS , Generate QtHelp documentation for installed modules.</span><br><span class="line"></span><br><span class="line">-- The following OPTIONAL packages have not been found:</span><br><span class="line"></span><br><span class="line"> * Sphinx (required version &gt;&#x3D; 1.2) , Tool to generate documentation. , &lt;https:&#x2F;&#x2F;www.sphinx-doc.org&#x2F;&gt;</span><br><span class="line">   Required to build documentation for Extra CMake Modules.</span><br><span class="line"></span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: &#x2F;root&#x2F;extra-cmake-modules</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;extra-cmake-modules# make install</span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMSetupQtPluginMacroNames.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMAddAppIcon.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMFindQMLModule.cmake.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMAddQtDesignerPlugin.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQtDeclareLoggingCategory.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQmLoader.cpp.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMWinResolveSymlinks.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMUninstallTarget.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMMarkAsTest.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQueryQmake.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGenerateExportHeader.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMEnableSanitizers.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMOptionalAddSubdirectory.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMCoverageOption.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQtDeclareLoggingCategory.cpp.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMConfiguredInstall.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQMLModules.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMFindModuleHelpers.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMMarkNonGuiExecutable.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMPoQmTools.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMCreateQmFromPoFiles.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGenerateDBusServiceFile.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGenerateHeaders.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMPackageConfigHelpers.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMInstallIcons.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQtDeclareLoggingCategory.h.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ecm_uninstall.cmake.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGenerateQmlTypes.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGeneratePriFile.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMSetupVersion.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQchDoxygenLayout.xml</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMQchDoxygen.config.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMAddQch.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMAddTests.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMSourceVersionControl.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMVersionHeader.h.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMUseFindModules.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;modules&#x2F;ECMGeneratePkgConfigFile.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;test-modules&#x2F;test_execute_and_compare.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;prefix.sh.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;appstreamtest.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDEClangFormat.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDECompilerSettings.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDEPackageAppTemplates.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;clang-format.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDECMakeSettings.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDEFrameworkCompilerSettings.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;kde-modules&#x2F;KDEInstallDirs.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindXCB.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindWaylandScanner.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindX11_XCB.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindPythonModuleGeneration.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindOpenEXR.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindKF5.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindQtWaylandScanner.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindLibGit2.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindInotify.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindGperf.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindSeccomp.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindPhoneNumber.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindUDev.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindTaglib.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindSharedMimeInfo.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindQHelpGenerator.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindGLIB2.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindCanberra.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindSasl2.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;GeneratePythonBindingUmbrellaModule.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindEGL.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindPoppler.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindWayland.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindFontconfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindLibExiv2.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;ECMFindModuleHelpersStub.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindIcoTool.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;FindPulseAudio.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;rules_engine.py</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;run-sip.py</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;sip_generator.py</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;find-modules&#x2F;Qt5Ruleset.py</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;hasMainSymbol.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;deployment-file-qt514.json.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;ECMAndroidDeployQt.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;deployment-file.json.in</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;specifydependencies.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;toolchain&#x2F;Android.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;cmake&#x2F;ECMConfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;ECM&#x2F;cmake&#x2F;ECMConfigVersion.cmake</span><br></pre></td></tr></table></figure>

<p>问题2：再次编译fcitx-qt5，会遇到问题如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# cmake .</span><br><span class="line">-- Performing Test SUPPORT_CXX11</span><br><span class="line">-- Performing Test SUPPORT_CXX11 - Success</span><br><span class="line">-- Found PkgConfig: &#x2F;usr&#x2F;bin&#x2F;pkg-config (found version &quot;0.29.1&quot;) </span><br><span class="line">-- Could NOT find XKBCommon_XKBCommon (missing:  XKBCommon_XKBCommon_LIBRARY XKBCommon_XKBCommon_INCLUDE_DIR) </span><br><span class="line">CMake Error at &#x2F;usr&#x2F;share&#x2F;cmake-3.5&#x2F;Modules&#x2F;FindPackageHandleStandardArgs.cmake:148 (message):</span><br><span class="line">  Could NOT find XKBCommon (missing: XKBCommon_LIBRARIES XKBCommon) (Required</span><br><span class="line">  is at least version &quot;0.5.0&quot;)</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  &#x2F;usr&#x2F;share&#x2F;cmake-3.5&#x2F;Modules&#x2F;FindPackageHandleStandardArgs.cmake:388 (_FPHSA_FAILURE_MESSAGE)</span><br><span class="line">  cmake&#x2F;FindXKBCommon.cmake:30 (find_package_handle_standard_args)</span><br><span class="line">  CMakeLists.txt:33 (find_package)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;CMakeFiles&#x2F;CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p><a href="http://xkbcommon.org/" target="_blank" rel="noopener">http://xkbcommon.org/</a> 下载xkbcommon（本文下次0.8.4）</p>
<p>进入xkbcommon配置并编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;libxkbcommon-0.8.4# .&#x2F;configure --disable-x11</span><br><span class="line">checking for a BSD-compatible install... &#x2F;usr&#x2F;bin&#x2F;install -c</span><br><span class="line">checking whether build environment is sane... yes</span><br><span class="line">checking for a thread-safe mkdir -p... &#x2F;bin&#x2F;mkdir -p</span><br><span class="line">checking for gawk... no</span><br><span class="line">checking for mawk... mawk</span><br><span class="line">checking whether make sets $(MAKE)... yes</span><br><span class="line">checking whether make supports nested variables... yes</span><br><span class="line">checking whether to enable maintainer-specific portions of Makefiles... yes</span><br><span class="line">checking whether make supports the include directive... yes (GNU style)</span><br><span class="line">checking for gcc... gcc</span><br><span class="line">checking whether the C compiler works... yes</span><br><span class="line">checking for C compiler default output file name... a.out</span><br><span class="line">checking for suffix of executables... </span><br><span class="line">checking whether we are cross compiling... no</span><br><span class="line">checking for suffix of object files... o</span><br><span class="line">checking whether we are using the GNU C compiler... yes</span><br><span class="line">checking whether gcc accepts -g... yes</span><br><span class="line">checking for gcc option to accept ISO C89... none needed</span><br><span class="line">checking whether gcc understands -c and -o together... yes</span><br><span class="line">checking dependency style of gcc... gcc3</span><br><span class="line">checking how to run the C preprocessor... gcc -E</span><br><span class="line">checking for grep that handles long lines and -e... &#x2F;bin&#x2F;grep</span><br><span class="line">checking for egrep... &#x2F;bin&#x2F;grep -E</span><br><span class="line">checking for ANSI C header files... yes</span><br><span class="line">checking for sys&#x2F;types.h... yes</span><br><span class="line">checking for sys&#x2F;stat.h... yes</span><br><span class="line">checking for stdlib.h... yes</span><br><span class="line">checking for string.h... yes</span><br><span class="line">checking for memory.h... yes</span><br><span class="line">checking for strings.h... yes</span><br><span class="line">checking for inttypes.h... yes</span><br><span class="line">checking for stdint.h... yes</span><br><span class="line">checking for unistd.h... yes</span><br><span class="line">checking minix&#x2F;config.h usability... no</span><br><span class="line">checking minix&#x2F;config.h presence... no</span><br><span class="line">checking for minix&#x2F;config.h... no</span><br><span class="line">checking whether it is safe to define __EXTENSIONS__... yes</span><br><span class="line">checking build system type... x86_64-pc-linux-gnu</span><br><span class="line">checking host system type... x86_64-pc-linux-gnu</span><br><span class="line">checking how to print strings... printf</span><br><span class="line">checking for a sed that does not truncate output... &#x2F;bin&#x2F;sed</span><br><span class="line">checking for fgrep... &#x2F;bin&#x2F;grep -F</span><br><span class="line">checking for ld used by gcc... &#x2F;usr&#x2F;bin&#x2F;ld</span><br><span class="line">checking if the linker (&#x2F;usr&#x2F;bin&#x2F;ld) is GNU ld... yes</span><br><span class="line">checking for BSD- or MS-compatible name lister (nm)... &#x2F;usr&#x2F;bin&#x2F;nm -B</span><br><span class="line">checking the name lister (&#x2F;usr&#x2F;bin&#x2F;nm -B) interface... BSD nm</span><br><span class="line">checking whether ln -s works... yes</span><br><span class="line">checking the maximum length of command line arguments... 1572864</span><br><span class="line">checking how to convert x86_64-pc-linux-gnu file names to x86_64-pc-linux-gnu format... func_convert_file_noop</span><br><span class="line">checking how to convert x86_64-pc-linux-gnu file names to toolchain format... func_convert_file_noop</span><br><span class="line">checking for &#x2F;usr&#x2F;bin&#x2F;ld option to reload object files... -r</span><br><span class="line">checking for objdump... objdump</span><br><span class="line">checking how to recognize dependent libraries... pass_all</span><br><span class="line">checking for dlltool... no</span><br><span class="line">checking how to associate runtime and link libraries... printf %s\n</span><br><span class="line">checking for ar... ar</span><br><span class="line">checking for archiver @FILE support... @</span><br><span class="line">checking for strip... strip</span><br><span class="line">checking for ranlib... ranlib</span><br><span class="line">checking command to parse &#x2F;usr&#x2F;bin&#x2F;nm -B output from gcc object... ok</span><br><span class="line">checking for sysroot... no</span><br><span class="line">checking for a working dd... &#x2F;bin&#x2F;dd</span><br><span class="line">checking how to truncate binary pipes... &#x2F;bin&#x2F;dd bs&#x3D;4096 count&#x3D;1</span><br><span class="line">checking for mt... mt</span><br><span class="line">checking if mt is a manifest tool... no</span><br><span class="line">checking for dlfcn.h... yes</span><br><span class="line">checking for objdir... .libs</span><br><span class="line">checking if gcc supports -fno-rtti -fno-exceptions... no</span><br><span class="line">checking for gcc option to produce PIC... -fPIC -DPIC</span><br><span class="line">checking if gcc PIC flag -fPIC -DPIC works... yes</span><br><span class="line">checking if gcc static flag -static works... yes</span><br><span class="line">checking if gcc supports -c -o file.o... yes</span><br><span class="line">checking if gcc supports -c -o file.o... (cached) yes</span><br><span class="line">checking whether the gcc linker (&#x2F;usr&#x2F;bin&#x2F;ld -m elf_x86_64) supports shared libraries... yes</span><br><span class="line">checking whether -lc should be explicitly linked in... no</span><br><span class="line">checking dynamic linker characteristics... GNU&#x2F;Linux ld.so</span><br><span class="line">checking how to hardcode library paths into programs... immediate</span><br><span class="line">checking whether stripping libraries is possible... yes</span><br><span class="line">checking if libtool supports shared libraries... yes</span><br><span class="line">checking whether to build shared libraries... yes</span><br><span class="line">checking whether to build static libraries... yes</span><br><span class="line">checking for gcc option to accept ISO C99... none needed</span><br><span class="line">checking whether __clang__ is declared... no</span><br><span class="line">checking whether __INTEL_COMPILER is declared... no</span><br><span class="line">checking whether __SUNPRO_C is declared... no</span><br><span class="line">checking for pkg-config... &#x2F;usr&#x2F;bin&#x2F;pkg-config</span><br><span class="line">checking pkg-config is at least version 0.9.0... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;unknown-warning-option... no</span><br><span class="line">checking if gcc supports -Werror&#x3D;unused-command-line-argument... no</span><br><span class="line">checking if gcc supports -Wall... yes</span><br><span class="line">checking if gcc supports -Wpointer-arith... yes</span><br><span class="line">checking if gcc supports -Wmissing-declarations... yes</span><br><span class="line">checking if gcc supports -Wformat&#x3D;2... yes</span><br><span class="line">checking if gcc supports -Wstrict-prototypes... yes</span><br><span class="line">checking if gcc supports -Wmissing-prototypes... yes</span><br><span class="line">checking if gcc supports -Wnested-externs... yes</span><br><span class="line">checking if gcc supports -Wbad-function-cast... yes</span><br><span class="line">checking if gcc supports -Wold-style-definition... yes</span><br><span class="line">checking if gcc supports -Wdeclaration-after-statement... yes</span><br><span class="line">checking if gcc supports -Wunused... yes</span><br><span class="line">checking if gcc supports -Wuninitialized... yes</span><br><span class="line">checking if gcc supports -Wshadow... yes</span><br><span class="line">checking if gcc supports -Wmissing-noreturn... yes</span><br><span class="line">checking if gcc supports -Wmissing-format-attribute... yes</span><br><span class="line">checking if gcc supports -Wredundant-decls... yes</span><br><span class="line">checking if gcc supports -Wlogical-op... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;implicit... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;nonnull... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;init-self... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;main... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;missing-braces... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;sequence-point... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;return-type... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;trigraphs... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;array-bounds... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;write-strings... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;address... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;int-to-pointer-cast... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;pointer-to-int-cast... yes</span><br><span class="line">checking if gcc supports -pedantic... yes</span><br><span class="line">checking if gcc supports -Werror... yes</span><br><span class="line">checking if gcc supports -Werror&#x3D;attributes... yes</span><br><span class="line">Package xorg-macros was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing &#96;xorg-macros.pc&#39;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package &#39;xorg-macros&#39; found</span><br><span class="line">checking whether make supports nested variables... (cached) yes</span><br><span class="line">checking whether to build documentation... yes</span><br><span class="line">checking for doxygen... no</span><br><span class="line">configure: WARNING: doxygen not found - documentation targets will be skipped</span><br><span class="line">checking for inline... inline</span><br><span class="line">checking for pkg-config... (cached) &#x2F;usr&#x2F;bin&#x2F;pkg-config</span><br><span class="line">checking pkg-config is at least version 0.9.0... yes</span><br><span class="line">checking for bison... no</span><br><span class="line">checking for byacc... no</span><br><span class="line">checking for yacc... no</span><br><span class="line">checking for eaccess... yes</span><br><span class="line">checking for euidaccess... yes</span><br><span class="line">checking for mmap... yes</span><br><span class="line">checking for mkostemp... yes</span><br><span class="line">checking for posix_fallocate... yes</span><br><span class="line">checking for secure_getenv... yes</span><br><span class="line">checking for __secure_getenv... no</span><br><span class="line">checking for __builtin_expect... yes</span><br><span class="line">checking for __builtin_popcount... yes</span><br><span class="line">checking linux&#x2F;input.h usability... yes</span><br><span class="line">checking linux&#x2F;input.h presence... yes</span><br><span class="line">checking for linux&#x2F;input.h... yes</span><br><span class="line">checking if gcc supports -fvisibility&#x3D;hidden -fno-strict-aliasing -fsanitize-undefined-trap-on-error... yes</span><br><span class="line">checking if gcc supports -Wextra -Wno-unused-parameter -Wno-missing-field-initializers... yes</span><br><span class="line">checking if gcc supports -Wdocumentation -Wno-documentation-deprecated-sync... no</span><br><span class="line">checking whether the linker accepts -Wl,--no-undefined... yes</span><br><span class="line">checking whether the linker accepts -Wl,--version-script&#x3D;&quot;.&#x2F;xkbcommon.map&quot;... yes</span><br><span class="line">checking that generated files are newer than configure... done</span><br><span class="line">configure: creating .&#x2F;config.status</span><br><span class="line">config.status: creating Makefile</span><br><span class="line">config.status: creating xkbcommon.pc</span><br><span class="line">config.status: creating xkbcommon-x11.pc</span><br><span class="line">config.status: creating doc&#x2F;Doxyfile</span><br><span class="line">config.status: creating src&#x2F;config.h</span><br><span class="line">config.status: executing depfiles commands</span><br><span class="line">config.status: executing libtool commands</span><br><span class="line"></span><br><span class="line">        libxkbcommon 0.8.4</span><br><span class="line"></span><br><span class="line">        libxkbcommon:            yes</span><br><span class="line">        libxkbcommon-x11:        no</span><br><span class="line">        Wayland utilities:       no</span><br><span class="line">        documentation:           yes</span><br><span class="line"></span><br><span class="line">        default XKB rules:       evdev</span><br><span class="line">        default XKB model:       pc105</span><br><span class="line">        default XKB layout:      us</span><br><span class="line">        default XKB variant:     </span><br><span class="line">        default XKB options:     </span><br><span class="line"></span><br><span class="line">        prefix:                  &#x2F;usr&#x2F;local</span><br><span class="line">        includedir:              $&#123;prefix&#125;&#x2F;include</span><br><span class="line">        lib dir:                 $&#123;exec_prefix&#125;&#x2F;lib</span><br><span class="line">        datarootdir:             $&#123;prefix&#125;&#x2F;share</span><br><span class="line">        XKB config root:         &#x2F;usr&#x2F;share&#x2F;X11&#x2F;xkb</span><br><span class="line">        X11 locale root:         $&#123;datarootdir&#125;&#x2F;X11&#x2F;locale</span><br></pre></td></tr></table></figure>

<p>编译会出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;libxkbcommon-0.8.4# make</span><br><span class="line">  YACC     src&#x2F;xkbcomp&#x2F;parser.c</span><br><span class="line">.&#x2F;build-aux&#x2F;ylwrap: 行 176: yacc: 未找到命令</span><br><span class="line">Makefile:1705: recipe for target &#39;src&#x2F;xkbcomp&#x2F;parser.c&#39; failed</span><br><span class="line">make: *** [src&#x2F;xkbcomp&#x2F;parser.c] Error 127</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;libxkbcommon-0.8.4# apt-get install bison</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  cpp-5 libisl15 libmpfr4</span><br><span class="line">使用&#39;apt autoremove&#39;来卸载它(它们)。</span><br><span class="line">将会同时安装下列软件：</span><br><span class="line">  libbison-dev</span><br><span class="line">建议安装：</span><br><span class="line">  bison-doc</span><br><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  bison libbison-dev</span><br><span class="line">升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 1000 个软件包未被升级。</span><br><span class="line">需要下载 605 kB 的归档。</span><br><span class="line">解压缩后会消耗 1,811 kB 的额外空间。</span><br><span class="line">您希望继续执行吗？ [Y&#x2F;n] y</span><br><span class="line">获取:1 http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu bionic&#x2F;main amd64 libbison-dev amd64 2:3.0.4.dfsg-1build1 [339 kB]</span><br><span class="line">获取:2 http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu bionic&#x2F;main amd64 bison amd64 2:3.0.4.dfsg-1build1 [266 kB]</span><br><span class="line">已下载 605 kB，耗时 0秒 (1,369 kB&#x2F;s)</span><br><span class="line">正在选中未选择的软件包 libbison-dev:amd64。</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 129703 个文件和目录。)</span><br><span class="line">正准备解包 ...&#x2F;libbison-dev_2%3a3.0.4.dfsg-1build1_amd64.deb  ...</span><br><span class="line">正在解包 libbison-dev:amd64 (2:3.0.4.dfsg-1build1) ...</span><br><span class="line">正在选中未选择的软件包 bison。</span><br><span class="line">正准备解包 ...&#x2F;bison_2%3a3.0.4.dfsg-1build1_amd64.deb  ...</span><br><span class="line">正在解包 bison (2:3.0.4.dfsg-1build1) ...</span><br><span class="line">正在设置 libbison-dev:amd64 (2:3.0.4.dfsg-1build1) ...</span><br><span class="line">正在设置 bison (2:3.0.4.dfsg-1build1) ...</span><br><span class="line">update-alternatives: 使用 &#x2F;usr&#x2F;bin&#x2F;bison.yacc 来在自动模式中提供 &#x2F;usr&#x2F;bin&#x2F;yacc (yacc)</span><br><span class="line">正在处理用于 man-db (2.7.5-1) 的触发器 ...</span><br></pre></td></tr></table></figure>

<p>再次编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;libxkbcommon-0.8.4# make</span><br><span class="line">  YACC     src&#x2F;xkbcomp&#x2F;parser.c</span><br><span class="line">updating src&#x2F;xkbcomp&#x2F;parser.h</span><br><span class="line">make  all-am</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br><span class="line">  CC       src&#x2F;compose&#x2F;parser.lo</span><br><span class="line">  CC       src&#x2F;compose&#x2F;paths.lo</span><br><span class="line">  CC       src&#x2F;compose&#x2F;state.lo</span><br><span class="line">  CC       src&#x2F;compose&#x2F;table.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;action.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;ast-build.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;compat.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;expr.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;include.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;keycodes.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;keymap.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;keymap-dump.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;keywords.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;parser.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;rules.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;scanner.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;symbols.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;types.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;vmod.lo</span><br><span class="line">  CC       src&#x2F;xkbcomp&#x2F;xkbcomp.lo</span><br><span class="line">  CC       src&#x2F;atom.lo</span><br><span class="line">  CC       src&#x2F;context.lo</span><br><span class="line">  CC       src&#x2F;context-priv.lo</span><br><span class="line">  CC       src&#x2F;keysym.lo</span><br><span class="line">  CC       src&#x2F;keysym-utf.lo</span><br><span class="line">  CC       src&#x2F;keymap.lo</span><br><span class="line">  CC       src&#x2F;keymap-priv.lo</span><br><span class="line">  CC       src&#x2F;state.lo</span><br><span class="line">  CC       src&#x2F;text.lo</span><br><span class="line">  CC       src&#x2F;utf8.lo</span><br><span class="line">  CC       src&#x2F;utils.lo</span><br><span class="line">  CCLD     libxkbcommon.la</span><br><span class="line">copying selected object files to avoid basename conflicts...</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;libxkbcommon-0.8.4# make install</span><br><span class="line">make  install-am</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br><span class="line">make[2]: Entering directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br><span class="line"> &#x2F;bin&#x2F;mkdir -p &#39;&#x2F;usr&#x2F;local&#x2F;lib&#39;</span><br><span class="line"> &#x2F;bin&#x2F;bash .&#x2F;libtool   --mode&#x3D;install &#x2F;usr&#x2F;bin&#x2F;install -c   libxkbcommon.la &#39;&#x2F;usr&#x2F;local&#x2F;lib&#39;</span><br><span class="line">libtool: install: &#x2F;usr&#x2F;bin&#x2F;install -c .libs&#x2F;libxkbcommon.so.0.0.0 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.so.0.0.0</span><br><span class="line">libtool: install: (cd &#x2F;usr&#x2F;local&#x2F;lib &amp;&amp; &#123; ln -s -f libxkbcommon.so.0.0.0 libxkbcommon.so.0 || &#123; rm -f libxkbcommon.so.0 &amp;&amp; ln -s libxkbcommon.so.0.0.0 libxkbcommon.so.0; &#125;; &#125;)</span><br><span class="line">libtool: install: (cd &#x2F;usr&#x2F;local&#x2F;lib &amp;&amp; &#123; ln -s -f libxkbcommon.so.0.0.0 libxkbcommon.so || &#123; rm -f libxkbcommon.so &amp;&amp; ln -s libxkbcommon.so.0.0.0 libxkbcommon.so; &#125;; &#125;)</span><br><span class="line">libtool: install: &#x2F;usr&#x2F;bin&#x2F;install -c .libs&#x2F;libxkbcommon.lai &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.la</span><br><span class="line">libtool: install: &#x2F;usr&#x2F;bin&#x2F;install -c .libs&#x2F;libxkbcommon.a &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.a</span><br><span class="line">libtool: install: chmod 644 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.a</span><br><span class="line">libtool: install: ranlib &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.a</span><br><span class="line">libtool: finish: PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;Tools&#x2F;QtCreator&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;sbin&quot; ldconfig -n &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Libraries have been installed in:</span><br><span class="line">   &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line"></span><br><span class="line">If you ever happen to want to link against installed libraries</span><br><span class="line">in a given directory, LIBDIR, you must either use libtool, and</span><br><span class="line">specify the full pathname of the library, or use the &#39;-LLIBDIR&#39;</span><br><span class="line">flag during linking and do at least one of the following:</span><br><span class="line">   - add LIBDIR to the &#39;LD_LIBRARY_PATH&#39; environment variable</span><br><span class="line">     during execution</span><br><span class="line">   - add LIBDIR to the &#39;LD_RUN_PATH&#39; environment variable</span><br><span class="line">     during linking</span><br><span class="line">   - use the &#39;-Wl,-rpath -Wl,LIBDIR&#39; linker flag</span><br><span class="line">   - have your system administrator add LIBDIR to &#39;&#x2F;etc&#x2F;ld.so.conf&#39;</span><br><span class="line"></span><br><span class="line">See any operating system documentation about shared libraries for</span><br><span class="line">more information, such as the ld(1) and ld.so(8) manual pages.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> &#x2F;bin&#x2F;mkdir -p &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig&#39;</span><br><span class="line"> &#x2F;usr&#x2F;bin&#x2F;install -c -m 644 xkbcommon.pc &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig&#39;</span><br><span class="line"> &#x2F;bin&#x2F;mkdir -p &#39;&#x2F;usr&#x2F;local&#x2F;include&#x2F;xkbcommon&#39;</span><br><span class="line"> &#x2F;usr&#x2F;bin&#x2F;install -c -m 644 xkbcommon&#x2F;xkbcommon.h xkbcommon&#x2F;xkbcommon-compat.h xkbcommon&#x2F;xkbcommon-compose.h xkbcommon&#x2F;xkbcommon-keysyms.h xkbcommon&#x2F;xkbcommon-names.h &#39;&#x2F;usr&#x2F;local&#x2F;include&#x2F;xkbcommon&#39;</span><br><span class="line">make[2]: Leaving directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;root&#x2F;libxkbcommon-0.8.4&#39;</span><br></pre></td></tr></table></figure>

<p>问题3：再次编译，发现没安装cmake</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# cmake .</span><br><span class="line">-- Found XKBCommon_XKBCommon: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.so (found version &quot;0.8.4&quot;) </span><br><span class="line">-- Found XKBCommon: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libxkbcommon.so (found suitable version &quot;0.8.4&quot;, minimum required is &quot;0.5.0&quot;) found components:  XKBCommon </span><br><span class="line">CMake Error at CMakeLists.txt:36 (find_package):</span><br><span class="line">  By not providing &quot;FindFcitx.cmake&quot; in CMAKE_MODULE_PATH this project has</span><br><span class="line">  asked CMake to find a package configuration file provided by &quot;Fcitx&quot;, but</span><br><span class="line">  CMake did not find one.</span><br><span class="line"></span><br><span class="line">  Could not find a package configuration file provided by &quot;Fcitx&quot; (requested</span><br><span class="line">  version 4.2.8) with any of the following names:</span><br><span class="line"></span><br><span class="line">    FcitxConfig.cmake</span><br><span class="line">    fcitx-config.cmake</span><br><span class="line"></span><br><span class="line">  Add the installation prefix of &quot;Fcitx&quot; to CMAKE_PREFIX_PATH or set</span><br><span class="line">  &quot;Fcitx_DIR&quot; to a directory containing one of the above files.  If &quot;Fcitx&quot;</span><br><span class="line">  provides a separate development package or SDK, be sure it has been</span><br><span class="line">  installed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;CMakeFiles&#x2F;CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>

<p>安装cmake</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# apt-get install cmake</span><br></pre></td></tr></table></figure>

<p>重新编译，还是有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# cmake .</span><br><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc</span><br><span class="line">-- Check for working C compiler: &#x2F;usr&#x2F;bin&#x2F;cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++</span><br><span class="line">-- Check for working CXX compiler: &#x2F;usr&#x2F;bin&#x2F;c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">CMake Error at CMakeLists.txt:36 (find_package):</span><br><span class="line">  By not providing &quot;FindFcitx.cmake&quot; in CMAKE_MODULE_PATH this project has</span><br><span class="line">  asked CMake to find a package configuration file provided by &quot;Fcitx&quot;, but</span><br><span class="line">  CMake did not find one.</span><br><span class="line"></span><br><span class="line">  Could not find a package configuration file provided by &quot;Fcitx&quot; (requested</span><br><span class="line">  version 4.2.8) with any of the following names:</span><br><span class="line"></span><br><span class="line">    FcitxConfig.cmake</span><br><span class="line">    fcitx-config.cmake</span><br><span class="line"></span><br><span class="line">  Add the installation prefix of &quot;Fcitx&quot; to CMAKE_PREFIX_PATH or set</span><br><span class="line">  &quot;Fcitx_DIR&quot; to a directory containing one of the above files.  If &quot;Fcitx&quot;</span><br><span class="line">  provides a separate development package or SDK, be sure it has been</span><br><span class="line">  installed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;CMakeFiles&#x2F;CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# apt-get install fcitx-libs-dev</span><br></pre></td></tr></table></figure>

<p>最后编译，成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# cmake .</span><br><span class="line">-- Checking for module &#39;fcitx&#39;</span><br><span class="line">--   Found fcitx, version 4.2.9.6</span><br><span class="line">-- Checking for module &#39;fcitx-config&#39;</span><br><span class="line">--   Found fcitx-config, version 4.2.9.6</span><br><span class="line">-- Checking for module &#39;fcitx-utils&#39;</span><br><span class="line">--   Found fcitx-utils, version 4.2.9.6</span><br><span class="line">-- fcitx4-config found &#x2F;usr&#x2F;bin&#x2F;fcitx4-config</span><br><span class="line">-- Found Fcitx: 4.2.9.6 (Required is at least version &quot;4.2.8&quot;) </span><br><span class="line">-- Looking for dgettext</span><br><span class="line">-- Looking for dgettext - found</span><br><span class="line">-- Found LIBINTL: &#x2F;usr&#x2F;include  </span><br><span class="line">-- Performing Test COMPILER_HAS_HIDDEN_VISIBILITY</span><br><span class="line">-- Performing Test COMPILER_HAS_HIDDEN_VISIBILITY - Success</span><br><span class="line">-- Performing Test COMPILER_HAS_HIDDEN_INLINE_VISIBILITY</span><br><span class="line">-- Performing Test COMPILER_HAS_HIDDEN_INLINE_VISIBILITY - Success</span><br><span class="line">-- Performing Test COMPILER_HAS_DEPRECATED_ATTR</span><br><span class="line">-- Performing Test COMPILER_HAS_DEPRECATED_ATTR - Success</span><br><span class="line">-- The following OPTIONAL packages have been found:</span><br><span class="line"></span><br><span class="line"> * PkgConfig</span><br><span class="line"></span><br><span class="line">-- The following REQUIRED packages have been found:</span><br><span class="line"></span><br><span class="line"> * ECM (required version &gt;&#x3D; 1.4.0)</span><br><span class="line"> * Qt5DBus</span><br><span class="line"> * Qt5Widgets</span><br><span class="line"> * Qt5Concurrent</span><br><span class="line"> * Qt5 (required version &gt;&#x3D; 5.1.0)</span><br><span class="line"> * Qt5Gui (required version &gt;&#x3D; 5.1.0)</span><br><span class="line"> * XKBCommon (required version &gt;&#x3D; 0.5.0), Keyboard handling library using XKB data, &lt;http:&#x2F;&#x2F;xkbcommon.org&gt;</span><br><span class="line"> * Fcitx (required version &gt;&#x3D; 4.2.8)</span><br><span class="line"> * LibIntl</span><br><span class="line"> * Qt5Core</span><br><span class="line"></span><br><span class="line">-- Configuring done</span><br><span class="line">CMake Warning (dev) in guiwrapper&#x2F;CMakeLists.txt:</span><br><span class="line">  Policy CMP0071 is not set: Let AUTOMOC and AUTOUIC process GENERATED files.</span><br><span class="line">  Run &quot;cmake --help-policy CMP0071&quot; for policy details.  Use the cmake_policy</span><br><span class="line">  command to set the policy and suppress this warning.</span><br><span class="line"></span><br><span class="line">  For compatibility, CMake is excluding the GENERATED source file(s):</span><br><span class="line"></span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;guiwrapper&#x2F;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">  from processing by AUTOMOC.  If any of the files should be processed, set</span><br><span class="line">  CMP0071 to NEW.  If any of the files should not be processed, explicitly</span><br><span class="line">  exclude them by setting the source file property SKIP_AUTOMOC:</span><br><span class="line"></span><br><span class="line">    set_property(SOURCE file.h PROPERTY SKIP_AUTOMOC ON)</span><br><span class="line"></span><br><span class="line">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br><span class="line"></span><br><span class="line">CMake Warning (dev) in quickphrase-editor&#x2F;CMakeLists.txt:</span><br><span class="line">  Policy CMP0071 is not set: Let AUTOMOC and AUTOUIC process GENERATED files.</span><br><span class="line">  Run &quot;cmake --help-policy CMP0071&quot; for policy details.  Use the cmake_policy</span><br><span class="line">  command to set the policy and suppress this warning.</span><br><span class="line"></span><br><span class="line">  For compatibility, CMake is excluding the GENERATED source file(s):</span><br><span class="line"></span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;quickphrase-editor&#x2F;ui_editordialog.h&quot;</span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;quickphrase-editor&#x2F;ui_batchdialog.h&quot;</span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;quickphrase-editor&#x2F;ui_editor.h&quot;</span><br><span class="line"></span><br><span class="line">  from processing by AUTOMOC.  If any of the files should be processed, set</span><br><span class="line">  CMP0071 to NEW.  If any of the files should not be processed, explicitly</span><br><span class="line">  exclude them by setting the source file property SKIP_AUTOMOC:</span><br><span class="line"></span><br><span class="line">    set_property(SOURCE file.h PROPERTY SKIP_AUTOMOC ON)</span><br><span class="line"></span><br><span class="line">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br><span class="line"></span><br><span class="line">CMake Warning (dev) in platforminputcontext&#x2F;CMakeLists.txt:</span><br><span class="line">  Policy CMP0071 is not set: Let AUTOMOC and AUTOUIC process GENERATED files.</span><br><span class="line">  Run &quot;cmake --help-policy CMP0071&quot; for policy details.  Use the cmake_policy</span><br><span class="line">  command to set the policy and suppress this warning.</span><br><span class="line"></span><br><span class="line">  For compatibility, CMake is excluding the GENERATED source file(s):</span><br><span class="line"></span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;platforminputcontext&#x2F;inputcontextproxy.h&quot;</span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;platforminputcontext&#x2F;inputcontext1proxy.h&quot;</span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;platforminputcontext&#x2F;inputmethodproxy.h&quot;</span><br><span class="line">    &quot;&#x2F;root&#x2F;fcitx-qt5&#x2F;platforminputcontext&#x2F;inputmethod1proxy.h&quot;</span><br><span class="line"></span><br><span class="line">  from processing by AUTOMOC.  If any of the files should be processed, set</span><br><span class="line">  CMP0071 to NEW.  If any of the files should not be processed, explicitly</span><br><span class="line">  exclude them by setting the source file property SKIP_AUTOMOC:</span><br><span class="line"></span><br><span class="line">    set_property(SOURCE file.h PROPERTY SKIP_AUTOMOC ON)</span><br><span class="line"></span><br><span class="line">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br><span class="line"></span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: &#x2F;root&#x2F;fcitx-qt5</span><br></pre></td></tr></table></figure>

<p>执行make</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# make</span><br><span class="line">Scanning dependencies of target fcitx-scan-addons.target</span><br><span class="line">[  0%] Built target fcitx-scan-addons.target</span><br><span class="line">Scanning dependencies of target fcitx-modules.target</span><br><span class="line">[  0%] Built target fcitx-modules.target</span><br><span class="line">Scanning dependencies of target FcitxQt5DBusAddons_autogen</span><br><span class="line">[  1%] Automatic MOC for target FcitxQt5DBusAddons</span><br><span class="line">[  1%] Built target FcitxQt5DBusAddons_autogen</span><br><span class="line">Scanning dependencies of target FcitxQt5DBusAddons</span><br><span class="line">[  2%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtconnection.cpp.o</span><br><span class="line">[  4%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtformattedpreedit.cpp.o</span><br><span class="line">[  5%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtinputcontextproxy.cpp.o</span><br><span class="line">[  7%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtinputmethodproxy.cpp.o</span><br><span class="line">[  8%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtkeyboardlayout.cpp.o</span><br><span class="line">[ 10%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtkeyboardproxy.cpp.o</span><br><span class="line">[ 11%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;fcitxqtinputmethoditem.cpp.o</span><br><span class="line">[ 13%] Building CXX object dbusaddons&#x2F;CMakeFiles&#x2F;FcitxQt5DBusAddons.dir&#x2F;FcitxQt5DBusAddons_autogen&#x2F;mocs_compilation.cpp.o</span><br><span class="line">[ 14%] Linking CXX shared library libFcitxQt5DBusAddons.so</span><br><span class="line">[ 14%] Built target FcitxQt5DBusAddons</span><br><span class="line">Scanning dependencies of target FcitxQt5WidgetsAddons_autogen</span><br><span class="line">[ 16%] Automatic MOC for target FcitxQt5WidgetsAddons</span><br><span class="line">[ 16%] Built target FcitxQt5WidgetsAddons_autogen</span><br><span class="line">Scanning dependencies of target FcitxQt5WidgetsAddons</span><br><span class="line">[ 17%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;fcitxqtconfiguifactory.cpp.o</span><br><span class="line">[ 19%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;fcitxqtconfiguiplugin.cpp.o</span><br><span class="line">[ 20%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;fcitxqtconfiguiwidget.cpp.o</span><br><span class="line">[ 22%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;fcitxqtkeysequencewidget.cpp.o</span><br><span class="line">[ 23%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;qtkeytrans.cpp.o</span><br><span class="line">[ 25%] Building CXX object widgetsaddons&#x2F;CMakeFiles&#x2F;FcitxQt5WidgetsAddons.dir&#x2F;FcitxQt5WidgetsAddons_autogen&#x2F;mocs_compilation.cpp.o</span><br><span class="line">[ 26%] Linking CXX shared library libFcitxQt5WidgetsAddons.so</span><br><span class="line">[ 26%] Built target FcitxQt5WidgetsAddons</span><br><span class="line">Scanning dependencies of target fcitx-qt5-gui-wrapper_autogen</span><br><span class="line">[ 27%] Automatic MOC for target fcitx-qt5-gui-wrapper</span><br><span class="line">[ 27%] Built target fcitx-qt5-gui-wrapper_autogen</span><br><span class="line">[ 29%] Generating ui_mainwindow.h</span><br><span class="line">Scanning dependencies of target fcitx-qt5-gui-wrapper</span><br><span class="line">[ 30%] Building CXX object guiwrapper&#x2F;CMakeFiles&#x2F;fcitx-qt5-gui-wrapper.dir&#x2F;main.cpp.o</span><br><span class="line">[ 32%] Building CXX object guiwrapper&#x2F;CMakeFiles&#x2F;fcitx-qt5-gui-wrapper.dir&#x2F;wrapperapp.cpp.o</span><br><span class="line">[ 33%] Building CXX object guiwrapper&#x2F;CMakeFiles&#x2F;fcitx-qt5-gui-wrapper.dir&#x2F;mainwindow.cpp.o</span><br><span class="line">[ 35%] Building CXX object guiwrapper&#x2F;CMakeFiles&#x2F;fcitx-qt5-gui-wrapper.dir&#x2F;fcitx-qt5-gui-wrapper_autogen&#x2F;mocs_compilation.cpp.o</span><br><span class="line">[ 36%] Linking CXX executable fcitx-qt5-gui-wrapper</span><br><span class="line">[ 36%] Built target fcitx-qt5-gui-wrapper</span><br><span class="line">Scanning dependencies of target fcitx-quickphrase-editor5_autogen</span><br><span class="line">[ 38%] Automatic MOC for target fcitx-quickphrase-editor5</span><br><span class="line">[ 38%] Built target fcitx-quickphrase-editor5_autogen</span><br><span class="line">[ 39%] Generating ui_editor.h</span><br><span class="line">[ 41%] Generating ui_editordialog.h</span><br><span class="line">[ 42%] Generating ui_batchdialog.h</span><br><span class="line">Scanning dependencies of target fcitx-quickphrase-editor5</span><br><span class="line">[ 44%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;main.cpp.o</span><br><span class="line">[ 45%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;model.cpp.o</span><br><span class="line">[ 47%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;editor.cpp.o</span><br><span class="line">[ 48%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;editordialog.cpp.o</span><br><span class="line">[ 50%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;batchdialog.cpp.o</span><br><span class="line">[ 51%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;filelistmodel.cpp.o</span><br><span class="line">[ 52%] Building CXX object quickphrase-editor&#x2F;CMakeFiles&#x2F;fcitx-quickphrase-editor5.dir&#x2F;fcitx-quickphrase-editor5_autogen&#x2F;mocs_compilation.cpp.o</span><br><span class="line">[ 54%] Linking CXX shared module libfcitx-quickphrase-editor5.so</span><br><span class="line">[ 54%] Built target fcitx-quickphrase-editor5</span><br><span class="line">Scanning dependencies of target fcitx-compile-mo.target</span><br><span class="line">[ 55%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;ca&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 57%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;da&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 58%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;de&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 60%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;es&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 61%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;fr&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 63%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;ja&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 64%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;ko&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 66%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;ru&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 67%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;zh_CN&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 69%] Generating ..&#x2F;fcitx_cmake_cache&#x2F;mo&#x2F;zh_TW&#x2F;fcitx-qt5.mo</span><br><span class="line">[ 69%] Built target fcitx-compile-mo.target</span><br><span class="line">Scanning dependencies of target fcitxplatforminputcontextplugin_autogen</span><br><span class="line">[ 70%] Automatic MOC for target fcitxplatforminputcontextplugin</span><br><span class="line">[ 70%] Built target fcitxplatforminputcontextplugin_autogen</span><br><span class="line">[ 72%] Generating inputmethod1proxy.cpp, inputmethod1proxy.h</span><br><span class="line">[ 73%] Generating inputcontextproxy.cpp, inputcontextproxy.h</span><br><span class="line">Warning: deprecated annotation &#39;com.trolltech.QtDBus.QtTypeName.In0&#39; found; suggest updating to &#39;org.qtproject.QtDBus.QtTypeName.In0&#39;</span><br><span class="line">[ 75%] Generating inputcontextproxy.moc</span><br><span class="line">[ 76%] Generating inputcontext1proxy.cpp, inputcontext1proxy.h</span><br><span class="line">Warning: deprecated annotation &#39;com.trolltech.QtDBus.QtTypeName.In0&#39; found; suggest updating to &#39;org.qtproject.QtDBus.QtTypeName.In0&#39;</span><br><span class="line">[ 77%] Generating inputcontext1proxy.moc</span><br><span class="line">[ 79%] Generating inputmethodproxy.cpp, inputmethodproxy.h</span><br><span class="line">[ 80%] Generating inputmethodproxy.moc</span><br><span class="line">[ 82%] Generating inputmethod1proxy.moc</span><br><span class="line">Scanning dependencies of target fcitxplatforminputcontextplugin</span><br><span class="line">[ 83%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;fcitxinputcontextproxy.cpp.o</span><br><span class="line">[ 85%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;fcitxqtdbustypes.cpp.o</span><br><span class="line">[ 86%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;fcitxwatcher.cpp.o</span><br><span class="line">[ 88%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;qfcitxplatforminputcontext.cpp.o</span><br><span class="line">[ 89%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;main.cpp.o</span><br><span class="line">[ 91%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;qtkey.cpp.o</span><br><span class="line">[ 92%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;inputcontextproxy.cpp.o</span><br><span class="line">[ 94%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;inputcontext1proxy.cpp.o</span><br><span class="line">[ 95%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;inputmethodproxy.cpp.o</span><br><span class="line">[ 97%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;inputmethod1proxy.cpp.o</span><br><span class="line">[ 98%] Building CXX object platforminputcontext&#x2F;CMakeFiles&#x2F;fcitxplatforminputcontextplugin.dir&#x2F;fcitxplatforminputcontextplugin_autogen&#x2F;mocs_compilation.cpp.o</span><br><span class="line">[100%] Linking CXX shared module libfcitxplatforminputcontextplugin.so</span><br><span class="line">[100%] Built target fcitxplatforminputcontextplugin</span><br></pre></td></tr></table></figure>

<p>执行make install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# make install </span><br><span class="line">[  0%] Built target fcitx-scan-addons.target</span><br><span class="line">[  0%] Built target fcitx-modules.target</span><br><span class="line">[  1%] Automatic MOC for target FcitxQt5DBusAddons</span><br><span class="line">[  1%] Built target FcitxQt5DBusAddons_autogen</span><br><span class="line">[ 14%] Built target FcitxQt5DBusAddons</span><br><span class="line">[ 16%] Automatic MOC for target FcitxQt5WidgetsAddons</span><br><span class="line">[ 16%] Built target FcitxQt5WidgetsAddons_autogen</span><br><span class="line">[ 26%] Built target FcitxQt5WidgetsAddons</span><br><span class="line">[ 27%] Automatic MOC for target fcitx-qt5-gui-wrapper</span><br><span class="line">[ 27%] Built target fcitx-qt5-gui-wrapper_autogen</span><br><span class="line">[ 36%] Built target fcitx-qt5-gui-wrapper</span><br><span class="line">[ 38%] Automatic MOC for target fcitx-quickphrase-editor5</span><br><span class="line">[ 38%] Built target fcitx-quickphrase-editor5_autogen</span><br><span class="line">[ 54%] Built target fcitx-quickphrase-editor5</span><br><span class="line">[ 69%] Built target fcitx-compile-mo.target</span><br><span class="line">[ 70%] Automatic MOC for target fcitxplatforminputcontextplugin</span><br><span class="line">[ 70%] Built target fcitxplatforminputcontextplugin_autogen</span><br><span class="line">[100%] Built target fcitxplatforminputcontextplugin</span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5DBusAddons&#x2F;FcitxQt5DBusAddonsConfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5DBusAddons&#x2F;FcitxQt5DBusAddonsConfigVersion.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5DBusAddons&#x2F;FcitxQt5DBusAddonsTargets.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5DBusAddons&#x2F;FcitxQt5DBusAddonsTargets-noconfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;fcitxqtdbusaddons_version.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5DBusAddons.so.1.0</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5DBusAddons.so.1</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5DBusAddons.so</span><br><span class="line">-- Set runtime path of &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5DBusAddons.so.1.0&quot; to &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtconnection.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtformattedpreedit.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtinputcontextproxy.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtinputmethodproxy.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtkeyboardlayout.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtkeyboardproxy.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtinputmethoditem.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtDBusAddons&#x2F;fcitxqtdbusaddons_export.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5WidgetsAddons&#x2F;FcitxQt5WidgetsAddonsConfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5WidgetsAddons&#x2F;FcitxQt5WidgetsAddonsConfigVersion.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5WidgetsAddons&#x2F;FcitxQt5WidgetsAddonsTargets.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;FcitxQt5WidgetsAddons&#x2F;FcitxQt5WidgetsAddonsTargets-noconfig.cmake</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;fcitxqtwidgetsaddons_version.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5WidgetsAddons.so.1.0</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5WidgetsAddons.so.1</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5WidgetsAddons.so</span><br><span class="line">-- Set runtime path of &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libFcitxQt5WidgetsAddons.so.1.0&quot; to &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtWidgetsAddons&#x2F;fcitxqtconfiguifactory.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtWidgetsAddons&#x2F;fcitxqtconfiguiplugin.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtWidgetsAddons&#x2F;fcitxqtconfiguiwidget.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtWidgetsAddons&#x2F;fcitxqtkeysequencewidget.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;FcitxQt5&#x2F;FcitxQtWidgetsAddons&#x2F;fcitxqtwidgetsaddons_export.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;fcitx&#x2F;libexec&#x2F;fcitx-qt5-gui-wrapper</span><br><span class="line">-- Set runtime path of &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;fcitx&#x2F;libexec&#x2F;fcitx-qt5-gui-wrapper&quot; to &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;fcitx&#x2F;qt&#x2F;libfcitx-quickphrase-editor5.so</span><br><span class="line">-- Set runtime path of &quot;&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;fcitx&#x2F;qt&#x2F;libfcitx-quickphrase-editor5.so&quot; to &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;ca&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;da&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;de&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;es&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;fr&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;ja&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;ko&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;ru&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;zh_CN&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;share&#x2F;locale&#x2F;zh_TW&#x2F;LC_MESSAGES&#x2F;fcitx-qt5.mo</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;plugins&#x2F;platforminputcontexts&#x2F;libfcitxplatforminputcontextplugin.so</span><br><span class="line">-- Set runtime path of &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;plugins&#x2F;platforminputcontexts&#x2F;libfcitxplatforminputcontextplugin.so&quot; to &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>查看发现QT的安装目录已经有libfcitxplatforminputcontextplugin.so</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;fcitx-qt5# ls &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qt&#x2F;5.4&#x2F;gcc_64&#x2F;plugins&#x2F;platforminputcontexts</span><br><span class="line">libcomposeplatforminputcontextplugin.so  libfcitxplatforminputcontextplugin.so  libibusplatforminputcontextplugin.so</span><br></pre></td></tr></table></figure>

<p>最后，打开qt程序，发现已经可以使用中文输入法</p>
<p><img src="http://jiali.clouddn.com/20200729_001.png" alt=""></p>
<p>参考：</p>
<p><a href="https://my.oschina.net/lieefu/blog/505363?fromerr=NNm21wBS" target="_blank" rel="noopener">解决Qt5 Creator无法切换输入法（fcitx），Ubuntu中不能使用搜狗输入法录入汉字问题</a></p>
<p><a href="https://blog.csdn.net/tianminggenie/article/details/82909224" target="_blank" rel="noopener">Linux 下 Qt 5 无法切换中文输入法</a></p>
<p><a href="https://www.cnblogs.com/cposture/p/5397694.html" target="_blank" rel="noopener">Ubuntu 16.04 下 Qt 5.6 无法输入中文的问题</a></p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>smartctl使用介绍</title>
    <url>/2020/09/03/ubuntu/smartctl%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://zh.wikipedia.org/wiki/S.M.A.R.T." target="_blank" rel="noopener">S.M.A.R.T.</a> 是个用来检测硬盘健康状况的指标。SMART是一种磁盘自我分析检测技术，早在90年代末就基本得到了普及每一块硬盘（包括IDE、SCSI），在运行的时候都会将自身的若干参数记录下来，这些参数包括型号、容量、温度、密度、扇区、寻道时间、传输、误码率等。硬盘运行了几千小时后，很多内在的物理参数都会发生变化，某一参数超过报警阈值，则说明硬盘接近损坏，此时硬盘依然在工作，如果用户不理睬这个报警继续使用，那么硬盘将变得非常不可靠，随时可能故障。</p>
<h2 id="smart-安装"><a href="#smart-安装" class="headerlink" title="smart 安装"></a>smart 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install smartmontools</span><br></pre></td></tr></table></figure>



<h2 id="smart使用方法"><a href="#smart使用方法" class="headerlink" title="smart使用方法"></a>smart使用方法</h2><p>smartctl -a <device> 检查该设备是否已经打开SMART技术。 smartctl -s on <device> 如果没有打开SMART技术，使用该命令打开SMART技术。 smartctl -t short <device> 后台检测硬盘，消耗时间短； smartctl -t long <device> 后台检测硬盘，消耗时间长； smartctl -C -t short <device> 前台检测硬盘，消耗时间短； smartctl -C -t long <device> 前台检测硬盘，消耗时间长。其实就是利用硬盘SMART的自检程序。 smartctl -X <device> 中断后台检测硬盘。 smartctl -l selftest <device> 显示硬盘检测日志。 smartctl -l error <device> 显示硬盘错误汇总。<br>首先通过dmesg工具，确认一下硬盘的设备符号。例如一个IDE硬盘连接到Primary IDE 总线上的Slave位置，硬盘设备符号是/dev/hdb，hdb中的h代表IDE，如果显示为sdb，则代表SATA和SCSI，最后一个字幕b代表Primary总线，第二块硬盘即Slave位置，确认硬盘是否打开了SMART支持：</p>
<p>1.查询硬盘是否开启smart支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># smartctl -i &#x2F;dev&#x2F;sda</span><br><span class="line">smartctl 5.40 2010-10-16 r3189 [i386-redhat-linux-gnu] (local build)</span><br><span class="line">Copyright (C) 2002-10 by Bruce Allen, http:&#x2F;&#x2F;smartmontools.sourceforge.net</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF INFORMATION SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">Device Model:     HITACHI HTS543225L9SA00</span><br><span class="line">Serial Number:    090131FB2F32YLG28JEA</span><br><span class="line">Firmware Version: FBEZC48C</span><br><span class="line">User Capacity:    250,059,350,016 bytes</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   8</span><br><span class="line">ATA Standard is:  ATA-8-ACS revision 3f</span><br><span class="line">Local Time is:    Wed May 25 10:10:39 2011 CST</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled                          &#x2F;&#x2F;表示启用了smart支持</span><br></pre></td></tr></table></figure>

<p>2.如果看到SMART support is: Disabled表示SMART未启用，执行如下命令，启动SMART</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo smartctl -s on &#x2F;dev&#x2F;sda</span><br><span class="line">smartctl 5.41 2011-06-09 r3365 [x86_64-linux-3.8.0-31-generic] (local build)</span><br><span class="line">Copyright (C) 2002-11 by Bruce Allen, http:&#x2F;&#x2F;smartmontools.sourceforge.net</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF ENABLE&#x2F;DISABLE COMMANDS SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">SMART Enabled.</span><br></pre></td></tr></table></figure>

<p>3.支持 SMART 后我们可以使用 <em>-H</em> 参数来手动检查硬盘、随身硬盘的建康状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># - 通过 (passed)。</span><br><span class="line">$ sudo smartctl -H &#x2F;dev&#x2F;sda</span><br><span class="line">smartctl 5.41 2011-06-09 r3365 [x86_64-linux-3.8.0-31-generic] (local build)</span><br><span class="line">Copyright (C) 2002-11 by Bruce Allen, http:&#x2F;&#x2F;smartmontools.sourceforge.net</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF READ SMART DATA SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br><span class="line"></span><br><span class="line"># - 失败 (failed)。</span><br><span class="line">$ sudo smartctl -H &#x2F;dev&#x2F;sda</span><br><span class="line">smartctl 5.41 2011-06-09 r3365 [x86_64-linux-3.8.0-31-generic] (local build)</span><br><span class="line">Copyright (C) 2002-11 by Bruce Allen, http:&#x2F;&#x2F;smartmontools.sourceforge.net</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D; START OF READ SMART DATA SECTION &#x3D;&#x3D;&#x3D;</span><br><span class="line">SMART overall-health self-assessment test result: FAILED!</span><br><span class="line">Drive failure expected in less than 24 hours. SAVE ALL DATA.</span><br><span class="line">Failed Attributes:</span><br><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</span><br><span class="line">5 Reallocated_Sector_Ct   0x0033   004   004   005    Pre-fail  Always   FAILING_NOW 1887</span><br></pre></td></tr></table></figure>







<p>参考：</p>
<p><a href="https://www.w3cschool.cn/working_on_gnu_linux/working_on_gnu_linux-wqdu27ol.html" target="_blank" rel="noopener">GNU/Linux 检测硬盘健康状态：S.M.A.R.T.</a></p>
<p><a href="https://www.cnblogs.com/fiberhome/p/8275961.html" target="_blank" rel="noopener">Linux硬盘的检测–smartctl详细介绍</a></p>
<p><a href="https://www.cnblogs.com/xqzt/p/5512075.html" target="_blank" rel="noopener">硬盘SMART检测参数详解</a></p>
<p><a href="https://blog.csdn.net/watermelonbig/article/details/72871990" target="_blank" rel="noopener">smartctl检测物理磁盘健康度的测试结果解读</a></p>
]]></content>
  </entry>
  <entry>
    <title>硬盘测试</title>
    <url>/2020/09/03/ubuntu/%E7%A1%AC%E7%9B%98%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿到一块硬盘，需要了解硬盘的性能和坏块，下面总结如何检测坏块和性能测试做些什么事情。</p>
<h2 id="检测坏块"><a href="#检测坏块" class="headerlink" title="检测坏块"></a>检测坏块</h2><p>使用 badblocks检测硬盘坏块</p>
<p>badblocks -s//显示进度  -v//显示执行详细情况   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># badblocks -s -v &#x2F;dev&#x2F;sda</span><br><span class="line">正在检查从 0 到 244198583的块</span><br><span class="line">Checking for bad blocks (read-only test): ^C0.10% done, 0:04 elapsed</span><br><span class="line">Interrupted at block 272896</span><br></pre></td></tr></table></figure>

<p>$badblocks -s//显示进度 -w//以写去检测 -v//显示执行详细情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># badblocks -w -s -v &#x2F;dev&#x2F;sda1</span><br><span class="line">Checking for bad blocks in read-write mode</span><br><span class="line">From block 0 to 25607577</span><br><span class="line">Testing with pattern 0xaa: ^C0.73% done, 0:03 elapsed</span><br><span class="line"></span><br><span class="line">注意，不能以写的方式检测已经挂载的硬盘</span><br></pre></td></tr></table></figure>

<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>1.测试磁盘读写速度使用hdparm或者dd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hdparm -Tt &#x2F;dev&#x2F;sda</span><br><span class="line">&#x2F;dev&#x2F;sda:</span><br><span class="line">Timing cached reads:   </span><br><span class="line">1918 MB in  2.00 seconds &#x3D; 959.62 MB&#x2F;sec</span><br><span class="line">Timing buffered disk reads:  184 MB in  3.00 seconds &#x3D;  61.26 MB&#x2F;sec</span><br></pre></td></tr></table></figure>

<p>hdparm可检测，显示与设定IDE或SCSI硬盘的参数。</p>
<p>语法：</p>
<p>hdparm [-CfghiIqtTvyYZ][-a &lt;快取分区&gt;][-A &lt;0或1&gt;][-c ][-d &lt;0或1&gt;][-k &lt;0或1&gt;][-K &lt;0或1&gt;][-m &lt;分区数&gt;][-n &lt;0或1&gt;][-p ][-P &lt;分区数&gt;][-r &lt;0或1&gt;][-S &lt;时间&gt;][-u &lt;0或1&gt;][-W &lt;0或1&gt;][-X &lt;传输模式&gt;] [设备]<br>-a&lt;快取分区&gt; 设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定。 -A&lt;0或1&gt; 启动或关闭读取文件时的快取功能。-c&lt;I/O模式&gt; 设定IDE32位I/O模式。 -C 检测IDE硬盘的电源管理模式。-d&lt;0或1&gt; 设定磁盘的DMA模式。-f 将内存缓冲区的数据写入硬盘，并清楚缓冲区。 -g 显示硬盘的磁轨，磁头，磁区等参数。-h 显示帮助。-i 显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。 -I 直接读取硬盘所提供的硬件规格信息。-k&lt;0或1&gt; 重设硬盘时，保留-dmu参数的设定。 -K&lt;0或1&gt; 重设硬盘时，保留-APSWXZ参数的设定。-m&lt;磁区数&gt; 设定硬盘多重分区存取的分区数。 -n&lt;0或1&gt; 忽略硬盘写入时所发生的错误。-p&lt;PIO模式&gt; 设定硬盘的PIO模式。 -P&lt;磁区数&gt; 设定硬盘内部快取的分区数。-q 在执行后续的参数时，不在屏幕上显示任何信息。 -r&lt;0或1&gt; 设定硬盘的读写模式。-S&lt;时间&gt; 设定硬盘进入省电模式前的等待时间。-t 评估硬盘的读取效率。 -T 评估硬盘快取的读取效率。-u&lt;0或1&gt; 在硬盘存取时，允许其他中断要求同时执行。-v 显示硬盘的相关设定。 -W&lt;0或1&gt; 设定硬盘的写入快取。-X&lt;传输模式&gt;  设定硬盘的传输模式。-y 使IDE硬盘进入省电模式。 -Y 使IDE硬盘进入睡眠模式。-Z 关闭某些Seagate硬盘的自动省电功能。</p>
<p>2.iostat测试IO瓶颈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat -x 1</span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s   rsec&#x2F;s   wsec&#x2F;s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class="line">sda               0.00     0.00 2752.00    1.00 1409024.00     8.00   511.82     4.64    1.69   0.35  96.10</span><br></pre></td></tr></table></figure>

<p>3.fio测试随机读写性能</p>
<p>下载并安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;brick.kernel.dk&#x2F;snaps&#x2F;fio-2.2.5.tar.gz</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">yum install libaio-devel gcc  -y</span><br><span class="line">tar -zxvf fio-2.2.5.tar.gz</span><br><span class="line">cd fio-2.2.5</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>使用方法参考<a href="http://www.dbhelp.net/2018/01/09/linux%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98io%E6%80%A7%E8%83%BD%EF%BC%88%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%EF%BC%89.html" target="_blank" rel="noopener">http://www.dbhelp.net/2018/01/09/linux%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98io%E6%80%A7%E8%83%BD%EF%BC%88%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%EF%BC%89.html</a></p>
<h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><p>1.磁盘性能指标–IOPS</p>
<p>IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求</p>
<p> 随机读写频繁的应用，如小文件存储(图片)、OLTP数据库、邮件服务器，关注随机读写性能，IOPS是关键衡量指标。<br> 顺序读写频繁的应用，传输大量连续数据，如电视台的视频编辑，视频点播VOD(Video On Demand)，关注连续读写性能。数据吞吐量是关键衡量指标。</p>
<p>IOPS和数据吞吐量适用于不同的场合：<br>读取10000个1KB文件，用时10秒  Throught(吞吐量)=1MB/s ，IOPS=1000  追求IOPS<br>读取1个10MB文件，用时0.2秒  Throught(吞吐量)=50MB/s, IOPS=5  追求吞吐量</p>
<p>2.磁盘服务时间</p>
<p>传统磁盘本质上一种机械装置，如FC, SAS, SATA磁盘，转速通常为5400/7200/10K/15K rpm不等。影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I/O请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。</p>
<p>寻道时间 Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms。<br>旋转延迟 Trotation是指盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间。旋转延迟取决于磁盘转速，通常使用磁盘旋转一周所需时间的1/2表示。比如，7200 rpm的磁盘平均旋转延迟大约为60*1000/7200/2 = 4.17ms，而转速为15000 rpm的磁盘其平均旋转延迟为2ms。<br>数据传输时间 Ttransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间。简单计算时可忽略。</p>
<p>常见磁盘平均物理寻道时间为：<br>7200转/分的STAT硬盘平均物理寻道时间是9ms<br>10000转/分的STAT硬盘平均物理寻道时间是6ms<br>15000转/分的SAS硬盘平均物理寻道时间是4ms</p>
<p>常见硬盘的旋转延迟时间为：</p>
<p>7200  rpm的磁盘平均旋转延迟大约为60*1000/7200/2 = 4.17ms</p>
<p>10000 rpm的磁盘平均旋转延迟大约为60*1000/10000/2 = 3ms，</p>
<p>15000 rpm的磁盘其平均旋转延迟约为60*1000/15000/2 = 2ms</p>
<p>参考：</p>
<p><a href="https://blog.51cto.com/wushank/1708168" target="_blank" rel="noopener">磁盘性能指标–IOPS、吞吐量及测试</a></p>
<p><a href="https://blog.csdn.net/qq_35298894/article/details/79022859" target="_blank" rel="noopener">Linux 测试 IO 性能（磁盘读写速度）</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux内核写时复制机制源代码解读</title>
    <url>/2020/08/31/Linux/Kernel/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>本文转载来自Linux阅码场：<a href="https://mp.weixin.qq.com/s/3YOnF9wQzW5B9cDWoKtTEA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3YOnF9wQzW5B9cDWoKtTEA</a></p>
<p>作者简介</p>
<p>韩传华，就职于国内一家半导体公司，主要从事linux相关系统软件开发工作，负责Soc芯片BringUp及系统软件开发，乐于分享喜欢学习，喜欢专研Linux内核源代码。</p>
<p>写时复制技术（一下简称COW）是linux内核比较重要的一种机制，我们都知道：父进程fork子进程的时候，子进程会和父进程会以只读的方式共享所有私有的可写页，当有一方将要写的时候会发生COW缺页异常。那么究竟COW在linux内核中是如何触发？又是如何处理的呢？我们将在本文中以源代码情景分析的方式来解读神秘的写时COW，从源代码级别的角度彻底理解它。</p>
<p>需要说明的是:本文中所分析的内核源码时linux-5.0版本内核，使用arm64处理器架构，当然此文章发布时linux内核已经是linux-5.8.x，当你查看最新的内核源码的时候会发现变化并不是很大。本文主要会从下面几个方面去分析讨论写时复制：</p>
<p>1.fork子进程时内核为COW做了哪些准备<br>2.COW进程是如何触发的<br>3.内核时怎样处理COW这种缺页异常的<br>4.匿名页的reuse</p>
<h2 id="一，从fork说起"><a href="#一，从fork说起" class="headerlink" title="一，从fork说起"></a>一，从fork说起</h2><p>我们都知道，进程是通过fork进行创建的，fork创建子进程的时候会和父进程共享资源，如fs,file,mm等等，其中内存资源的共享是一下路径：<br>kernel/fork.c<br>_do_fork-&gt;copy_process-&gt;copy_mm</p>
<p>当然本文中讨论的是COW，暂时不详解其他资源共享以及内存资源共享的其他部分（后面的相关文章我们会讨论），copy_mm总体来说所作的工作是：分配mm_struct结构实例mm，拷贝父进程的old_mm到mm,创建自己的pgd页全局目录，然后会遍历父进程的vma链表为子进程建立vma链表（如代码段，数据段等等），然后就是比较关键的页的共享，linux内核为了效率考虑并不是拷贝父进程的所有物理页内容，而是通过复制页表来共享这些页。而在复制页表的时候，内核会判断这个页表条目是完全复制还是修改为只读来为COW缺页做准备。</p>
<p>共享父进程内存资源处理如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byuhcmomXpTGC8jxKCsr8icJ0ibHCQIn6mXIk082ibdUDjLKmgaBBHrLDGIfYiaB2s7R5Z38jia1XgaVtdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>以下我们主要分析copy_one_pte 拷贝页表条目的这一函数：<br>首先会处理一些页表项不为空但物理页不在内存中的情况（!pte_present(pte)分支）如被swap到交换分区中的页，接下来处理物理页在内存中的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   774         |* If it&#39;s a COW mapping, write protect it both</span><br><span class="line">   775         |* in the parent and the child</span><br><span class="line">   776         |*&#x2F;</span><br><span class="line">   777         if (is_cow_mapping(vm_flags) &amp;&amp; pte_write(pte)) &#123;&#x2F;&#x2F;vma为私有可写  而且pte有可写属性</span><br><span class="line">   778                 ptep_set_wrprotect(src_mm, addr, src_pte);&#x2F;&#x2F;设置父进程页表项为只读</span><br><span class="line">   779                 pte &#x3D; pte_wrprotect(pte); &#x2F;&#x2F;为子进程设置只读的页表项值</span><br><span class="line">   780         &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码块是判断当前页所在的vma是否是私有可写的属性而且父进程页表项是可写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">247 static inline bool is_cow_mapping(vm_flags_t flags)</span><br><span class="line">248 &#123;</span><br><span class="line">249         return (flags &amp; (VM_SHARED | VM_MAYWRITE)) &#x3D;&#x3D; VM_MAYWRITE;</span><br><span class="line">250 &#125;</span><br></pre></td></tr></table></figure>

<p>如果判断成立说明是COW的映射，则需要将父子进程页表修改为只读：<br>ptep_set_wrprotect(src_mm, addr, src_pte)将父进程的页表项修改为只读， pte = pte_wrprotect(pte)将子进程的即将写入的页表项值修改为只读（注意：修改之前pte为父进程原来的pte值，修改之后子进程pte还没有写入到对应的页表项条目中！）<br>修改页表项为只读的核心函数为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">152 static inline pte_t pte_wrprotect(pte_t pte)</span><br><span class="line">  153 &#123;</span><br><span class="line">  154         pte &#x3D; clear_pte_bit(pte, __pgprot(PTE_WRITE));&#x2F;&#x2F;清可写位</span><br><span class="line">  155         pte &#x3D; set_pte_bit(pte, __pgprot(PTE_RDONLY));&#x2F;&#x2F;置位只读位</span><br><span class="line">  156         return pte;</span><br><span class="line">  157</span><br></pre></td></tr></table></figure>

<p>再次回到copy_one_pte函数往下分析：<br>上面我们已经修改了父进程的页表项，也获得了子进程即将写入的页表项值pte(注意：现在还没有写入到子进程的页表项中，因为此时子进程的页表项值还没有被完全拼接号好)，接下来我们将要拼接子进程的页表项的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">782         &#x2F;*</span><br><span class="line">   783         |* If it&#39;s a shared mapping, mark it clean in</span><br><span class="line">   784         |* the child</span><br><span class="line">   785         |*&#x2F;</span><br><span class="line">   786         if (vm_flags &amp; VM_SHARED) &#x2F;&#x2F;vma的属性为共享</span><br><span class="line">   787                 pte &#x3D; pte_mkclean(pte);&#x2F;&#x2F;设置页表项值为clean</span><br><span class="line">   788         pte &#x3D; pte_mkold(pte); &#x2F;&#x2F;设置页表项值为未被访问过即是清PTE_AF</span><br><span class="line">   789</span><br><span class="line">   790         page &#x3D; vm_normal_page(vma, addr, pte); &#x2F;&#x2F;获得pte对应的page结构（即是和父进程共享的页描述符）</span><br><span class="line">   791         if (page) &#123;</span><br><span class="line">   792                 get_page(page);&#x2F;&#x2F;增进page结构的引用计数</span><br><span class="line">   793                 page_dup_rmap(page, false);&#x2F;&#x2F;注意：不是拷贝rmap 而是增加page-&gt;_mapcount计数（页被映射计数）</span><br><span class="line">   794                 rss[mm_counter(page)]++;</span><br><span class="line">   795         &#125; else if (pte_devmap(pte)) &#123;</span><br><span class="line">   796                 page &#x3D; pte_page(pte);</span><br><span class="line">   797</span><br><span class="line">   798                 &#x2F;*</span><br><span class="line">   799                 |* Cache coherent device memory behave like regular page and</span><br><span class="line">   800                 |* not like persistent memory page. For more informations see</span><br><span class="line">   801                 |* MEMORY_DEVICE_CACHE_COHERENT in memory_hotplug.h</span><br><span class="line">   802                 |*&#x2F;</span><br><span class="line">   803                 if (is_device_public_page(page)) &#123;</span><br><span class="line">   804                         get_page(page);</span><br><span class="line">   805                         page_dup_rmap(page, false);</span><br><span class="line">   806                         rss[mm_counter(page)]++;</span><br><span class="line">   807                 &#125;</span><br><span class="line">   808         &#125;</span><br><span class="line">   809</span><br><span class="line">   810 out_set_pte:</span><br><span class="line">   811         set_pte_at(dst_mm, addr, dst_pte, pte);&#x2F;&#x2F;将拼接的页表项值写入到子进程的页表项中</span><br><span class="line">   812         return 0;</span><br></pre></td></tr></table></figure>

<p>以上过程就完成了对于需要写时复制的页，将父子进程的页表项改写为只读（这时候vma的属性是可写的），并共享相同的物理页，这为下面的COW缺页异常做好了页表级别的准备工作。</p>
<h2 id="二，COW缺页异常触发条件"><a href="#二，COW缺页异常触发条件" class="headerlink" title="二，COW缺页异常触发条件"></a>二，COW缺页异常触发条件</h2><p>当然如果父子进程仅仅是对COW共享的页面做只读访问，则通过各自的页表就能直接访问到对应的数据，一切都正常，一旦有一方去写，就会发生处理器异常，处理器会判断出是COW缺页异常：</p>
<p>arm64处理器处理过程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byuhcmomXpTGC8jxKCsr8icJ0iaTAddeQdzA06YfwUcnPKjFC5Jksp3L1UzzTV35wTibiaEFlTBUibfP1gA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>我们从handle_pte_fault函数开始分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3800         if (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;&#x2F;&#x2F;vam可写</span><br><span class="line">  3801                 if (!pte_write(entry))&#x2F;&#x2F;页表项属性只读</span><br><span class="line">  3802                         return do_wp_page(vmf);&#x2F;&#x2F;处理cow</span><br><span class="line">  3803                 entry &#x3D; pte_mkdirty(entry);</span><br><span class="line">  3804         &#125;</span><br></pre></td></tr></table></figure>

<p>程序走到上面的判断说明：<strong>页表项存在，物理页存在内存，但是vma是可写，pte页表项是只读属性</strong>（这就是fork的时候所作的准备），这些条件也是COW缺页异常判断的条件。</p>
<h2 id="二-发生COW缺页异常"><a href="#二-发生COW缺页异常" class="headerlink" title="二,发生COW缺页异常"></a>二,发生COW缺页异常</h2><p>当内核判断了这次异常时COW缺页异常，就会调用do_wp_page进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2480 static vm_fault_t do_wp_page(struct vm_fault *vmf)</span><br><span class="line">2481         __releases(vmf-&gt;ptl)</span><br><span class="line">2482 &#123;</span><br><span class="line">2483         struct vm_area_struct *vma &#x3D; vmf-&gt;vma;</span><br><span class="line">2484</span><br><span class="line">2485         vmf-&gt;page &#x3D; vm_normal_page(vma, vmf-&gt;address, vmf-&gt;orig_pte);&#x2F;&#x2F;获得异常地址对应的page实例</span><br><span class="line">2486         if (!vmf-&gt;page) &#123;</span><br><span class="line">2487                 &#x2F;*</span><br><span class="line">2488                 |* VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span><br><span class="line">2489                 |* VM_PFNMAP VMA.</span><br><span class="line">2490                 |*</span><br><span class="line">2491                 |* We should not cow pages in a shared writeable mapping.</span><br><span class="line">2492                 |* Just mark the pages writable and&#x2F;or call ops-&gt;pfn_mkwrite.</span><br><span class="line">2493                 |*&#x2F;</span><br><span class="line">2494                 if ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) &#x3D;&#x3D;</span><br><span class="line">2495                                 |    (VM_WRITE|VM_SHARED))</span><br><span class="line">2496                         return wp_pfn_shared(vmf);&#x2F;&#x2F;处理共享可写映射</span><br><span class="line">2497</span><br><span class="line">2498                 pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">2499                 return wp_page_copy(vmf);&#x2F;&#x2F;处理私有可写映射</span><br><span class="line">2500         &#125;</span><br></pre></td></tr></table></figure>

<p>2485行，获得发生异常时地址所在的page结构，如果没有page结构是使用页帧号的特殊映射，则通过wp_pfn_shared处理共享可写映射，wp_page_copy处理私有可写映射，当然这不是我们分析重点。</p>
<p>我们继续往下分析：<br>我们主要关注2522行，判断是否可以重新使用这个页，这个稍后在分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2544         |* Ok, we need to copy. Oh, well..</span><br><span class="line">2545         |*&#x2F;</span><br><span class="line">2546         get_page(vmf-&gt;page);</span><br><span class="line">2547</span><br><span class="line">2548         pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">2549         return wp_page_copy(vmf);</span><br></pre></td></tr></table></figure>

<p>2546行 增加原来的页的引用计数，防止被释放。<br>2548行 释放页表锁<br>2549行 这是COW处理的核心函数</p>
<p>我们下面将详细分析wp_page_copy函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      * - Allocate a page, copy the content of the old page to the new one.</span><br><span class="line">2234  * - Handle book keeping and accounting - cgroups, mmu-notifiers, etc.</span><br><span class="line">2235  * - Take the PTL. If the pte changed, bail out and release the allocated page</span><br><span class="line">2236  * - If the pte is still the way we remember it, update the page table and all</span><br><span class="line">2237  *   relevant references. This includes dropping the reference the page-table</span><br><span class="line">2238  *   held to the old page, as well as updating the rmap.</span><br><span class="line">2239  * - In any case, unlock the PTL and drop the reference we took to the old page.</span><br><span class="line">2240  *&#x2F;</span><br><span class="line">2241 static vm_fault_t wp_page_copy(struct vm_fault *vmf)</span><br><span class="line">2242 &#123;</span><br><span class="line">2243         struct vm_area_struct *vma &#x3D; vmf-&gt;vma;</span><br><span class="line">2244         struct mm_struct *mm &#x3D; vma-&gt;vm_mm;</span><br><span class="line">2245         struct page *old_page &#x3D; vmf-&gt;page;</span><br><span class="line">2246         struct page *new_page &#x3D; NULL;</span><br><span class="line">2247         pte_t entry;</span><br><span class="line">2248         int page_copied &#x3D; 0;</span><br><span class="line">2249         struct mem_cgroup *memcg;</span><br><span class="line">2250         struct mmu_notifier_range range;</span><br><span class="line">2251</span><br><span class="line">2252         if (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">2253                 goto oom;</span><br><span class="line">2254</span><br><span class="line">2255         if (is_zero_pfn(pte_pfn(vmf-&gt;orig_pte))) &#123;</span><br><span class="line">2256                 new_page &#x3D; alloc_zeroed_user_highpage_movable(vma,</span><br><span class="line">2257                                                         |     vmf-&gt;address);</span><br><span class="line">2258                 if (!new_page)</span><br><span class="line">2259                         goto oom;</span><br><span class="line">2260         &#125; else &#123;</span><br><span class="line">2261                 new_page &#x3D; alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,</span><br><span class="line">2262                                 vmf-&gt;address);</span><br><span class="line">2263                 if (!new_page)</span><br><span class="line">2264                         goto oom;</span><br><span class="line">2265                 cow_user_page(new_page, old_page, vmf-&gt;address, vma);</span><br><span class="line">2266         &#125;</span><br></pre></td></tr></table></figure>

<p>2252行 关联一个anon_vma实例到vma<br>2255行 到 2259行 <strong>判断原来的页表项映射的页是0页，就分配高端可移动的页并用0初始化</strong><br>2261到2265行 <strong>如果不是0页，分配高端可移动的页，然后将原来的页拷贝到新页</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2268         if (mem_cgroup_try_charge_delay(new_page, mm, GFP_KERNEL, &amp;memcg, false))</span><br><span class="line">2269                 goto oom_free_new;</span><br><span class="line">2270</span><br><span class="line">2271         __SetPageUptodate(new_page);</span><br><span class="line">2272</span><br><span class="line">2273         mmu_notifier_range_init(&amp;range, mm, vmf-&gt;address &amp; PAGE_MASK,</span><br><span class="line">2274                                 (vmf-&gt;address &amp; PAGE_MASK) + PAGE_SIZE);</span><br><span class="line">2275         mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">2276</span><br><span class="line">2277         &#x2F;*</span><br><span class="line">2278         |* Re-check the pte - we dropped the lock</span><br><span class="line">2279         |*&#x2F;</span><br><span class="line">2280         vmf-&gt;pte &#x3D; pte_offset_map_lock(mm, vmf-&gt;pmd, vmf-&gt;address, &amp;vmf-&gt;ptl);</span><br><span class="line">2281         if (likely(pte_same(*vmf-&gt;pte, vmf-&gt;orig_pte))) &#123;</span><br><span class="line">2282                 if (old_page) &#123;</span><br><span class="line">2283                         if (!PageAnon(old_page)) &#123;</span><br><span class="line">2284                                 dec_mm_counter_fast(mm,</span><br><span class="line">2285                                                 mm_counter_file(old_page));</span><br><span class="line">2286                                 inc_mm_counter_fast(mm, MM_ANONPAGES);</span><br><span class="line">2287                         &#125;</span><br><span class="line">2288                 &#125; else &#123;</span><br><span class="line">2289                         inc_mm_counter_fast(mm, MM_ANONPAGES);</span><br><span class="line">2290                 &#125;</span><br><span class="line">2291                 flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte));</span><br><span class="line">2292                 entry &#x3D; mk_pte(new_page, vma-&gt;vm_page_prot);</span><br><span class="line">2293                 entry &#x3D; maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">2294                 &#x2F;*</span><br><span class="line">2295                 |* Clear the pte entry and flush it first, before updating the</span><br><span class="line">2296                 |* pte with the new entry. This will avoid a race condition</span><br><span class="line">2297                 |* seen in the presence of one thread doing SMC and another</span><br><span class="line">2298                 |* thread doing COW.</span><br><span class="line">2299                 |*&#x2F;</span><br><span class="line">2300                 ptep_clear_flush_notify(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">2301                 page_add_new_anon_rmap(new_page, vma, vmf-&gt;address, false);</span><br><span class="line">2302                 mem_cgroup_commit_charge(new_page, memcg, false, false);</span><br><span class="line">2303                 lru_cache_add_active_or_unevictable(new_page, vma);</span><br><span class="line">2304                 &#x2F;*</span><br><span class="line">2305                 |* We call the notify macro here because, when using secondary</span><br><span class="line">2306                 |* mmu page tables (such as kvm shadow page tables), we want the</span><br><span class="line">2307                 |* new page to be mapped directly into the secondary page table.</span><br><span class="line">2308                 |*&#x2F;</span><br><span class="line">2309                 set_pte_at_notify(mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">2310                 update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">2311                 if (old_page) &#123;</span><br><span class="line">2312                         &#x2F;*</span><br><span class="line">2313                         |* Only after switching the pte to the new page may</span><br><span class="line">2314                         |* we remove the mapcount here. Otherwise another</span><br><span class="line">2315                         |* process may come and find the rmap count decremented</span><br><span class="line">2316                         |* before the pte is switched to the new page, and</span><br><span class="line">2317                         |* &quot;reuse&quot; the old page writing into it while our pte</span><br><span class="line">2318                         |* here still points into it and can be read by other</span><br><span class="line">2319                         |* threads.</span><br><span class="line">2320                         |*</span><br><span class="line">2321                         |* The critical issue is to order this</span><br><span class="line">2322                         |* page_remove_rmap with the ptp_clear_flush above.</span><br><span class="line">2323                         |* Those stores are ordered by (if nothing else,)</span><br><span class="line">2324                         |* the barrier present in the atomic_add_negative</span><br><span class="line">2325                         |* in page_remove_rmap.</span><br><span class="line">2326                         |*</span><br><span class="line">2327                         |* Then the TLB flush in ptep_clear_flush ensures that</span><br><span class="line">2328                         |* no process can access the old page before the</span><br><span class="line">2329                         |* decremented mapcount is visible. And the old page</span><br><span class="line">2330                         |* cannot be reused until after the decremented</span><br><span class="line">2331                         |* mapcount is visible. So transitively, TLBs to</span><br><span class="line">2332                         |* old page will be flushed before it can be reused.</span><br><span class="line">2333                         |*&#x2F;</span><br><span class="line">2334                         page_remove_rmap(old_page, false);</span><br><span class="line">2335                 &#125;</span><br><span class="line">2336</span><br><span class="line">2337                 &#x2F;* Free the old page.. *&#x2F;</span><br><span class="line">2338                 new_page &#x3D; old_page;</span><br><span class="line">2339                 page_copied &#x3D; 1;</span><br><span class="line">2340         &#125; else &#123;</span><br><span class="line">2341                 mem_cgroup_cancel_charge(new_page, memcg, false);</span><br><span class="line">2342         &#125;</span><br></pre></td></tr></table></figure>

<p>2271行 设置新的页标识位为PageUptodate，表示页中包含有效数据。<br>2280行 锁住页表<br>2281到2339行是发生缺页异常时获得页表项和现在锁住之后获得页表项内容相同的情况<br>2341 时页表项不同的情况<br>主要分析相同的情况：<br>2282到2290 主要时对页计数的统计<br>2291 cache中刷新页<br>2292行 由vma的访问权限和新页的页描述符来构建页表项的值<br>2293行 <strong>设置页表项值属性为脏和可写（如果vma有可写属性，这个时候将页表项修改为了可写，fork的时候修改为只读这个地方修改了回来）</strong><br>2300行 将页表项原有的值清除，然后刷新地址发生缺页地址对应的tlb（这一行操作很重要）<br>2301行 <strong>将新的物理页添加到vma对应的匿名页的反向映射中</strong><br>2303行 <strong>将新物理页添加到活跃或不可回收LRU链表中</strong><br>2309 行<strong>将构建好的页表项值写入到页表项条目中</strong>，这个时候页表项修改才会生效。<br>2334行 删除原来的页到虚拟页的反向映射，然后做了比较重要的一个操作为<strong>atomic_add_negative(-1, &amp;page-&gt;_mapcount)</strong>将页的页表映射计数减一。<br>2344到2347 递减旧页的引用计数 并释放页表锁<br>2353到2364行 如果已经映射了新的物理页，旧页被锁住在内存中，将旧页解锁。<br>到此就完成了写时复制过程。总结下：分配新的物理页，拷贝原来页的内容到新页，然后修改页表项内容指向新页并修改为可写（vma具备可写属性）。<br>前面我们遗留了一个问题没有讨论，那就是do_wp_page函数中处理reuse_swap_page的处理，所谓的单身匿名页面的处理。</p>
<h2 id="四，匿名页的reuse"><a href="#四，匿名页的reuse" class="headerlink" title="四，匿名页的reuse"></a>四，匿名页的reuse</h2><p>假设有如下情形发生：父进程P通过fork创建了子进程A,其中有一<strong>私有可写的匿名页</strong>page1被共享，这个时候内核会此页都映射到各自的虚拟内存页，并修改双方的页表属性为只读，page1的映射计数_mapcount为2， 这个时候假设子进程写page1,则发生COW异常，异常处理程序为子进程A分配了新页page2并和虚拟页建立映射关系，并改写了子进程页表项为可写，这个时候子进程可以随意的写page2而不会影响父进程，当然上面分析我们知道page1的映射计数_mapcount会递减1变为1，也就表面这个页page1被父进程所唯一映射，那么<strong>这个时候父进程再去写page1，会发生什么呢？还会发生COW去分配新的页吗?</strong><br>下面我们在源代码中寻找答案：</p>
<p>do_wp_page函数的2502到2541是我们分析重点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2502         &#x2F;*</span><br><span class="line">2503         |* Take out anonymous pages first, anonymous shared vmas are</span><br><span class="line">2504         |* not dirty accountable.</span><br><span class="line">2505         |*&#x2F;</span><br><span class="line">2506         if (PageAnon(vmf-&gt;page) &amp;&amp; !PageKsm(vmf-&gt;page)) &#123;</span><br><span class="line">2507                 int total_map_swapcount;</span><br><span class="line">2508                 if (!trylock_page(vmf-&gt;page)) &#123;</span><br><span class="line">2509                         get_page(vmf-&gt;page);</span><br><span class="line">2510                         pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">2511                         lock_page(vmf-&gt;page);</span><br><span class="line">2512                         vmf-&gt;pte &#x3D; pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd,</span><br><span class="line">2513                                         vmf-&gt;address, &amp;vmf-&gt;ptl);</span><br><span class="line">2514                         if (!pte_same(*vmf-&gt;pte, vmf-&gt;orig_pte)) &#123;</span><br><span class="line">2515                                 unlock_page(vmf-&gt;page);</span><br><span class="line">2516                                 pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">2517                                 put_page(vmf-&gt;page);</span><br><span class="line">2518                                 return 0;</span><br><span class="line">2519                         &#125;</span><br><span class="line">2520                         put_page(vmf-&gt;page);</span><br><span class="line">2521                 &#125;</span><br><span class="line">2522                 if (reuse_swap_page(vmf-&gt;page, &amp;total_map_swapcount)) &#123;</span><br><span class="line">2523                         if (total_map_swapcount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">2524                                 &#x2F;*</span><br><span class="line">2525                                 |* The page is all ours. Move it to</span><br><span class="line">2526                                 |* our anon_vma so the rmap code will</span><br><span class="line">2527                                 |* not search our parent or siblings.</span><br><span class="line">2528                                 |* Protected against the rmap code by</span><br><span class="line">2529                                 |* the page lock.</span><br><span class="line">2530                                 |*&#x2F;</span><br><span class="line">2524                                 &#x2F;*</span><br><span class="line">2525                                 |* The page is all ours. Move it to</span><br><span class="line">2526                                 |* our anon_vma so the rmap code will</span><br><span class="line">2527                                 |* not search our parent or siblings.</span><br><span class="line">2528                                 |* Protected against the rmap code by</span><br><span class="line">2529                                 |* the page lock.</span><br><span class="line">2530                                 |*&#x2F;</span><br><span class="line">2531                                 page_move_anon_rmap(vmf-&gt;page, vma);</span><br><span class="line">2532                         &#125;</span><br><span class="line">2533                         unlock_page(vmf-&gt;page);</span><br><span class="line">2534                         wp_page_reuse(vmf);</span><br><span class="line">2535                         return VM_FAULT_WRITE;</span><br><span class="line">2536                 &#125;</span><br><span class="line">2537                 unlock_page(vmf-&gt;page);</span><br><span class="line">2538         &#125; else if (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) &#x3D;&#x3D;</span><br><span class="line">2539                                         (VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">2540                 return wp_page_shared(vmf);</span><br><span class="line">2541         &#125;</span><br></pre></td></tr></table></figure>

<p>2506行 对于<strong>匿名页面且非KSM</strong>页<br>2522行 <strong>判断是否这个页面只被我所拥有</strong>（total_map_swapcount &lt;= 0）<br>2534 调用wp_page_reuse处理（这是重点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2195 &#x2F;*</span><br><span class="line">2196  * Handle write page faults for pages that can be reused in the current vma</span><br><span class="line">2197  *</span><br><span class="line">2198  * This can happen either due to the mapping being with the VM_SHARED flag,</span><br><span class="line">2199  * or due to us being the last reference standing to the page. In either</span><br><span class="line">2200  * case, all we need to do here is to mark the page as writable and update</span><br><span class="line">2201  * any related book-keeping.</span><br><span class="line">2202  *&#x2F;</span><br><span class="line">2203 static inline void wp_page_reuse(struct vm_fault *vmf)</span><br><span class="line">2204         __releases(vmf-&gt;ptl)</span><br><span class="line">2205 &#123;</span><br><span class="line">2206         struct vm_area_struct *vma &#x3D; vmf-&gt;vma;</span><br><span class="line">2207         struct page *page &#x3D; vmf-&gt;page;</span><br><span class="line">2208         pte_t entry;</span><br><span class="line">2209         &#x2F;*</span><br><span class="line">2210         |* Clear the pages cpupid information as the existing</span><br><span class="line">2211         |* information potentially belongs to a now completely</span><br><span class="line">2212         |* unrelated process.</span><br><span class="line">2213         |*&#x2F;</span><br><span class="line">2214         if (page)</span><br><span class="line">2215                 page_cpupid_xchg_last(page, (1 &lt;&lt; LAST_CPUPID_SHIFT) - 1);</span><br><span class="line">2216</span><br><span class="line">2217         flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte));</span><br><span class="line">2218         entry &#x3D; pte_mkyoung(vmf-&gt;orig_pte);</span><br><span class="line">2219         entry &#x3D; maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">2220         if (ptep_set_access_flags(vma, vmf-&gt;address, vmf-&gt;pte, entry, 1))</span><br><span class="line">2221                 update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">2222         pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">2223 &#125;</span><br></pre></td></tr></table></figure>

<p>代码中可以清晰看到：<br>2218行 <strong>设置页被访问</strong><br>2219行 <strong>设置页表项为脏，如果页所在的vma是可写属性则设置页表项值为可写</strong><br>2220行 <strong>将设置好的页表项值写入到页表项条目中</strong>（真正设置好了页表项），注意arm64中在ptep_set_access_flags刷新了页对应的tlb。</p>
<p>分析到这里，有关COW的机制已经全部分析完，当然这个过程涉及到了无数的技术细节，在此不再一一赘述，后面有机会会讨论到相关的内容。</p>
<h2 id="五，总结"><a href="#五，总结" class="headerlink" title="五，总结"></a>五，总结</h2><p>我们总结一下写时复制（COW）机制的整个过程：首先发生在父进程fork子进程的时候，父子进程会共享（此共享并不是我们通常所说的共享映射和私有映射，而是通过将页映射到每个进程页表形成共享）所有的私有可写的物理页，并将父子进程对应的页表项修改为只读，当有一方试图写共享的物理页，由于页表项属性是只读的会发生COW缺页异常，缺页异常处理程序会为写操作的一方分配新的物理页，并将原来共享的物理页内容拷贝到新页，然后建立新页的页表映射关系，这样写操作的进程就可以继续执行，不会影响另一方，父子进程对共享的私有页面访问就分道扬镳了，当共享的页面最终只有一个拥有者（即是其他映射页面到自己页表的进程都发生写时复制分配了新的物理页），这个时候如果拥有者进程想要写这个页就会重新使用这个页而不用分配新页。</p>
<p>下面给出实验代码案例：<br>程序中有一全局变量num=10 打印num的值, 然后fork子进程，在子进程中修改全局变量num=100 然后打印num的值,父进程中睡眠1s故意等待子进程先执行完， 然后再次打印num的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 #include &lt;stdio.h&gt;</span><br><span class="line"> 2 #include &lt;unistd.h&gt;</span><br><span class="line"> 3 #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"> 4 </span><br><span class="line"> 5 </span><br><span class="line"> 6 int num &#x3D; 10;</span><br><span class="line"> 7 </span><br><span class="line"> 8 int main(int argc,char **argv)</span><br><span class="line"> 9 &#123;</span><br><span class="line">10 </span><br><span class="line">11         pid_t pid;</span><br><span class="line">12 </span><br><span class="line">13         printf(&quot;###%s:%d  pid&#x3D;%d num&#x3D;%d###\n&quot;, __func__, __LINE__,  getpid(), num);</span><br><span class="line">14 </span><br><span class="line">15 </span><br><span class="line">16         pid &#x3D; fork();</span><br><span class="line">17         if (pid &lt; 0) &#123;</span><br><span class="line">18                 printf(&quot;fail to fork\n&quot;);</span><br><span class="line">19                 return -1;</span><br><span class="line">20         &#125; else if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;child process</span><br><span class="line">21                 num &#x3D; 100;</span><br><span class="line">22                 printf(&quot;### This is child process pid&#x3D;%d  num&#x3D;%d###\n&quot;, getpid(), num);</span><br><span class="line">23                 _exit(0);</span><br><span class="line">24         &#125; else &#123; &#x2F;&#x2F;parent process</span><br><span class="line">25                 sleep(1);</span><br><span class="line">26                 printf(&quot;### This is parent process  pid&#x3D;%d  num&#x3D;%d###\n&quot;, getpid(), num);</span><br><span class="line">27                 _exit(0);</span><br><span class="line">28         &#125;</span><br><span class="line">29 </span><br><span class="line">30         return 0;</span><br><span class="line">31 &#125;</span><br></pre></td></tr></table></figure>

<p>大家可以思考一下：第13，22, 27分别得出的num是多少？<br>我们编译执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hanch@hanch-VirtualBox:~&#x2F;test&#x2F;COW$ gcc fork-cow-test.c -o fork-cow-test</span><br><span class="line">hanch@hanch-VirtualBox:~&#x2F;test&#x2F;COW$ .&#x2F;fork-cow-test </span><br><span class="line">###main:13  pid&#x3D;26844 num&#x3D;10###</span><br><span class="line">### This is child process pid&#x3D;26845  num&#x3D;100###</span><br><span class="line">### This is parent process  pid&#x3D;26844  num&#x3D;10###</span><br></pre></td></tr></table></figure>

<p>可以发现父进程中的全局变量num =10, 当fork子进程后对这个全局变量进行了修改使得num =100,实际上fork的时候已经将父子进程的num这个全局变量所在的页修改为了只读，然后共享这个页，当子进程写这个全局变量的时候发生了COW缺页异常，然而这对于应用程序来说是透明的，内核却在缺页异常处理中做了很多工作：主要是为子进程分配物理页，将父进程的num所在的页内容拷贝到子进程，然后将子进程的va所对应的的页表条目修改为可写和分配的物理页建立了映射关系，然后缺页异常就返回了（从内核空间返回到了用户空间），这个时候处理器会重新执行赋值操作指令，这个时候属于子进程的num才被改写为100，但是要明白这个时候父进程的num变量所在的页的读写属性还是只读，父进程再去写的时候依然会发生COW缺页异常。</p>
<p>最后我们用图说话来理解COW的整个过程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byuhcmomXpTGC8jxKCsr8icJ0iauXplOlgzYu79CWfFziaaElzeXzEDjLPfwzyP1l3oHdLkR0HJfyFxMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h1 id="END"><a href="#END" class="headerlink" title="(END)"></a>(END)</h1>]]></content>
      <categories>
        <category>linux</category>
        <category>Kernel</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>写时复制技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客迁移</title>
    <url>/2020/07/13/%E5%B7%A5%E5%85%B7/hexo/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了很多时间搭建好github+hexo博客，为了方便在另一台电脑使用已经搭建好的博客，那么，如何把Hexo博客迁移到另一台电脑？本文，整理hexo博客迁移过程。</p>
<p>两种方便的备份方法：</p>
<ul>
<li>微软的oneDrive网盘</li>
<li>利用github分支</li>
</ul>
<p>本文，整理如何在Hexo博客系统创建分支，进行备份。</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>1、拷贝博客系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">克隆博客</span><br></pre></td></tr></table></figure>

<p>2、删除除了<strong>.git</strong>文件夹（历史的版本控制记录在.git文件中）的其它所有文件和文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r *</span><br></pre></td></tr></table></figure>

<p>3、把下面文件拷贝到hexo文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br><span class="line">.git</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<ul>
<li>public 文件夹不需要备份，因为执行hexo g 会产生该文件</li>
<li>node_modules和package-lock.json不需要备份，因为npm install hexo-deployer-git –save 会产生这两个文件。</li>
<li>.deploy_git文件夹是 hexo d 时候产生，所以也不需要备份</li>
</ul>
<p>4、还需要删除主题文件中的.git和.github</p>
<ul>
<li>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，否则提交主题文件夹会失败.</li>
<li>c的。可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可</li>
</ul>
<p>5、创建source分支，并提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b source</span><br><span class="line">git add .</span><br><span class="line">git commit -a -m &quot;创建分支&quot;</span><br></pre></td></tr></table></figure>

<p>6、最好，推送分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin source</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>由于package-lock.json没做备份，当重新执行npm install hexo-deployer-git –save，会产生新的node_modules和package-lock.json文件，这时候执行hexo g，会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found in D:\hexo</span><br><span class="line">ERROR Try running:&#39;npm install hexo --save&#39;</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>方法一：</p>
<p>刚开始做备份分支时候，把package-lock.json拷贝进去。</p>
<p>方法二：</p>
<p>执行下面的命令，重新更新文件包，就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="博客系统管理"><a href="#博客系统管理" class="headerlink" title="博客系统管理"></a>博客系统管理</h2><p>现在需要管理源码分支和gitpage博客。那么，如何管理呢？</p>
<p>1、针对原来的源码库管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把source分支中的.git拷贝到原来的源码博客系统myblog目录中</span><br></pre></td></tr></table></figure>

<p><img src="http://jiali.clouddn.com/20200714_001.png" alt="20200714_001"></p>
<p>打开bash，进入myblog,可以看到已经纳入source版本控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MINGW64 &#x2F;e&#x2F;myblog (source)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>接下来就是推送源码到source分支和推送静态博客到master</p>
<p>推送源码到source分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new test</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m &quot;创建test&quot;</span><br><span class="line">$ git push origin source</span><br></pre></td></tr></table></figure>

<p>推送静态博客到master分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>2、拉取source分支到另一台电脑,操作工程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git 12</span><br><span class="line">Cloning into &#39;12&#39;...</span><br><span class="line">remote: Enumerating objects: 523, done.</span><br><span class="line">remote: Counting objects: 100% (523&#x2F;523), done.</span><br><span class="line">remote: Compressing objects: 100% (435&#x2F;435), done.</span><br><span class="line">remote: Total 523 (delta 47), reused 519 (delta 43), pack-reused 0</span><br><span class="line">Receiving objects: 100% (523&#x2F;523), 971.48 KiB | 993.00 KiB&#x2F;s, done.</span><br><span class="line">Resolving deltas: 100% (47&#x2F;47), done.</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e</span><br><span class="line">$ cd 12</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  package.json  scaffolds&#x2F;  source&#x2F;  themes&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls -a</span><br><span class="line">.&#x2F;   .git&#x2F;       _config.yml   scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">..&#x2F;  .gitignore  package.json  source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line">&gt; ejs@2.7.4 postinstall E:\12\node_modules\ejs</span><br><span class="line">&gt; node .&#x2F;postinstall.js</span><br><span class="line"></span><br><span class="line">Thank you for installing EJS: built with the Jake JavaScript build tool (https:&#x2F;&#x2F;jakejs.com&#x2F;)</span><br><span class="line"></span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.3 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">added 254 packages in 40.502s</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.3 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">+ hexo-deployer-git@2.1.0</span><br><span class="line">updated 1 package in 1.458s</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls</span><br><span class="line">_config.yml    package.json       scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">node_modules&#x2F;  package-lock.json  source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git status</span><br><span class="line">On branch source</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;source&#39;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   package.json</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git restore package.json</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git status</span><br><span class="line">On branch source</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;source&#39;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ hexo new test</span><br><span class="line">INFO  Created: E:\12\source\_posts\test.md</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls -a</span><br><span class="line">.&#x2F;   .git&#x2F;       _config.yml    package.json       scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">..&#x2F;  .gitignore  node_modules&#x2F;  package-lock.json  source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ hexo g</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 303 ms</span><br><span class="line">INFO  Generated: search.xml</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  Generated: categories&#x2F;index.html</span><br><span class="line">INFO  Generated: about&#x2F;index.html</span><br><span class="line">INFO  Generated: archives&#x2F;index.html</span><br><span class="line">INFO  Generated: tags&#x2F;index.html</span><br><span class="line">INFO  Generated: images&#x2F;avatar.gif</span><br><span class="line">INFO  Generated: images&#x2F;apple-touch-icon-next.png</span><br><span class="line">INFO  Generated: images&#x2F;algolia_logo.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by-nc.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by-nc-nd.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by-nc-sa.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by-nd.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by-sa.svg</span><br><span class="line">INFO  Generated: images&#x2F;logo.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-by.svg</span><br><span class="line">INFO  Generated: images&#x2F;cc-zero.svg</span><br><span class="line">INFO  Generated: images&#x2F;favicon-16x16-next.png</span><br><span class="line">INFO  Generated: images&#x2F;favicon-32x32-next.png</span><br><span class="line">INFO  Generated: archives&#x2F;2020&#x2F;index.html</span><br><span class="line">INFO  Generated: archives&#x2F;2020&#x2F;07&#x2F;index.html</span><br><span class="line">INFO  Generated: js&#x2F;algolia-search.js</span><br><span class="line">INFO  Generated: js&#x2F;bookmark.js</span><br><span class="line">INFO  Generated: css&#x2F;main.css</span><br><span class="line">INFO  Generated: js&#x2F;next-boot.js</span><br><span class="line">INFO  Generated: lib&#x2F;anime.min.js</span><br><span class="line">INFO  Generated: js&#x2F;motion.js</span><br><span class="line">INFO  Generated: js&#x2F;local-search.js</span><br><span class="line">INFO  Generated: js&#x2F;utils.js</span><br><span class="line">INFO  Generated: lib&#x2F;velocity&#x2F;velocity.ui.min.js</span><br><span class="line">INFO  Generated: js&#x2F;schemes&#x2F;muse.js</span><br><span class="line">INFO  Generated: lib&#x2F;velocity&#x2F;velocity.min.js</span><br><span class="line">INFO  Generated: js&#x2F;schemes&#x2F;pisces.js</span><br><span class="line">INFO  Generated: lib&#x2F;font-awesome&#x2F;css&#x2F;all.min.css</span><br><span class="line">INFO  Generated: 2020&#x2F;07&#x2F;14&#x2F;hello-world&#x2F;index.html</span><br><span class="line">INFO  Generated: 2020&#x2F;07&#x2F;14&#x2F;test&#x2F;index.html</span><br><span class="line">INFO  Generated: lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-regular-400.woff2</span><br><span class="line">INFO  Generated: lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-solid-900.woff2</span><br><span class="line">INFO  Generated: lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-brands-400.woff2</span><br><span class="line">INFO  39 files generated in 689 ms</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  node_modules&#x2F;  package-lock.json  scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">db.json      package.json   public&#x2F;            source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line">INFO  Farewell</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  node_modules&#x2F;  package-lock.json  scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">db.json      package.json   public&#x2F;            source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git status</span><br><span class="line">On branch source</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;source&#39;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        source&#x2F;_posts&#x2F;test.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git add source&#x2F;_posts&#x2F;test.md</span><br><span class="line">warning: LF will be replaced by CRLF in source&#x2F;_posts&#x2F;test.md.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git status</span><br><span class="line">On branch source</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;source&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   source&#x2F;_posts&#x2F;test.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git commit -a -m &quot;提交git 测试文件&quot;</span><br><span class="line">[source 5df4335] 提交git 测试文件</span><br><span class="line"> 1 file changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 source&#x2F;_posts&#x2F;test.md</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git push origin source</span><br><span class="line">Enumerating objects: 8, done.</span><br><span class="line">Counting objects: 100% (8&#x2F;8), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (5&#x2F;5), done.</span><br><span class="line">Writing objects: 100% (5&#x2F;5), 578 bytes | 578.00 KiB&#x2F;s, done.</span><br><span class="line">Total 5 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1&#x2F;1), completed with 1 local object.</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git</span><br><span class="line">   10d4b36..5df4335  source -&gt; source</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Setting up Git deployment...</span><br><span class="line">Initialized empty Git repository in E:&#x2F;12&#x2F;.deploy_git&#x2F;.git&#x2F;</span><br><span class="line">[master (root-commit) 4c6e408] First commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 placeholder</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">warning: LF will be replaced by CRLF in 2020&#x2F;07&#x2F;14&#x2F;hello-world&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in 2020&#x2F;07&#x2F;14&#x2F;test&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in about&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in archives&#x2F;2020&#x2F;07&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in archives&#x2F;2020&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in archives&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in categories&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in css&#x2F;main.css.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;algolia-search.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;bookmark.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;local-search.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;motion.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;next-boot.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;schemes&#x2F;muse.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;schemes&#x2F;pisces.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in js&#x2F;utils.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in lib&#x2F;anime.min.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in lib&#x2F;font-awesome&#x2F;css&#x2F;all.min.css.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in lib&#x2F;velocity&#x2F;velocity.min.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in lib&#x2F;velocity&#x2F;velocity.ui.min.js.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in search.xml.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">warning: LF will be replaced by CRLF in tags&#x2F;index.html.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">[master 66f6452] Site updated: 2020-07-14 09:07:06</span><br><span class="line"> 40 files changed, 8653 insertions(+)</span><br><span class="line"> create mode 100644 2020&#x2F;07&#x2F;14&#x2F;hello-world&#x2F;index.html</span><br><span class="line"> create mode 100644 2020&#x2F;07&#x2F;14&#x2F;test&#x2F;index.html</span><br><span class="line"> create mode 100644 about&#x2F;index.html</span><br><span class="line"> create mode 100644 archives&#x2F;2020&#x2F;07&#x2F;index.html</span><br><span class="line"> create mode 100644 archives&#x2F;2020&#x2F;index.html</span><br><span class="line"> create mode 100644 archives&#x2F;index.html</span><br><span class="line"> create mode 100644 categories&#x2F;index.html</span><br><span class="line"> create mode 100644 css&#x2F;main.css</span><br><span class="line"> create mode 100644 images&#x2F;algolia_logo.svg</span><br><span class="line"> create mode 100644 images&#x2F;apple-touch-icon-next.png</span><br><span class="line"> create mode 100644 images&#x2F;avatar.gif</span><br><span class="line"> create mode 100644 images&#x2F;cc-by-nc-nd.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-by-nc-sa.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-by-nc.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-by-nd.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-by-sa.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-by.svg</span><br><span class="line"> create mode 100644 images&#x2F;cc-zero.svg</span><br><span class="line"> create mode 100644 images&#x2F;favicon-16x16-next.png</span><br><span class="line"> create mode 100644 images&#x2F;favicon-32x32-next.png</span><br><span class="line"> create mode 100644 images&#x2F;logo.svg</span><br><span class="line"> create mode 100644 index.html</span><br><span class="line"> create mode 100644 js&#x2F;algolia-search.js</span><br><span class="line"> create mode 100644 js&#x2F;bookmark.js</span><br><span class="line"> create mode 100644 js&#x2F;local-search.js</span><br><span class="line"> create mode 100644 js&#x2F;motion.js</span><br><span class="line"> create mode 100644 js&#x2F;next-boot.js</span><br><span class="line"> create mode 100644 js&#x2F;schemes&#x2F;muse.js</span><br><span class="line"> create mode 100644 js&#x2F;schemes&#x2F;pisces.js</span><br><span class="line"> create mode 100644 js&#x2F;utils.js</span><br><span class="line"> create mode 100644 lib&#x2F;anime.min.js</span><br><span class="line"> create mode 100644 lib&#x2F;font-awesome&#x2F;css&#x2F;all.min.css</span><br><span class="line"> create mode 100644 lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-brands-400.woff2</span><br><span class="line"> create mode 100644 lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-regular-400.woff2</span><br><span class="line"> create mode 100644 lib&#x2F;font-awesome&#x2F;webfonts&#x2F;fa-solid-900.woff2</span><br><span class="line"> create mode 100644 lib&#x2F;velocity&#x2F;velocity.min.js</span><br><span class="line"> create mode 100644 lib&#x2F;velocity&#x2F;velocity.ui.min.js</span><br><span class="line"> delete mode 100644 placeholder</span><br><span class="line"> create mode 100644 search.xml</span><br><span class="line"> create mode 100644 tags&#x2F;index.html</span><br><span class="line">Enumerating objects: 64, done.</span><br><span class="line">Counting objects: 100% (64&#x2F;64), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (52&#x2F;52), done.</span><br><span class="line">Writing objects: 100% (64&#x2F;64), 253.60 KiB | 9.75 MiB&#x2F;s, done.</span><br><span class="line">Total 64 (delta 13), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (13&#x2F;13), done.</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io</span><br><span class="line"> + b15a917...66f6452 HEAD -&gt; master (forced update)</span><br><span class="line">Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io&#39;.</span><br><span class="line">INFO  Deploy done: git</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  node_modules&#x2F;  package-lock.json  scaffolds&#x2F;  themes&#x2F;</span><br><span class="line">db.json      package.json   public&#x2F;            source&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls -a</span><br><span class="line">.&#x2F;            .git&#x2F;        db.json        package-lock.json  source&#x2F;</span><br><span class="line">..&#x2F;           .gitignore   node_modules&#x2F;  public&#x2F;            themes&#x2F;</span><br><span class="line">.deploy_git&#x2F;  _config.yml  package.json   scaffolds&#x2F;</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git pull origin source</span><br><span class="line">remote: Enumerating objects: 7, done.</span><br><span class="line">remote: Counting objects: 100% (7&#x2F;7), done.</span><br><span class="line">remote: Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 4 (delta 1), reused 4 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (4&#x2F;4), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io</span><br><span class="line"> * branch            source     -&gt; FETCH_HEAD</span><br><span class="line">   5df4335..dcf7612  source     -&gt; origin&#x2F;source</span><br><span class="line">Updating 5df4335..dcf7612</span><br><span class="line">Fast-forward</span><br><span class="line"> source&#x2F;_posts&#x2F;test.md | 7 -------</span><br><span class="line"> 1 file changed, 7 deletions(-)</span><br><span class="line"> delete mode 100644 source&#x2F;_posts&#x2F;test.md</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ git status</span><br><span class="line">On branch source</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;source&#39;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$ ls source&#x2F;_posts&#x2F;</span><br><span class="line">hello-world.md</span><br><span class="line"></span><br><span class="line">name@DESKTOP-xx MINGW64 &#x2F;e&#x2F;12 (source)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://blog.csdn.net/White_Idiot/article/details/80685990" target="_blank" rel="noopener">【GitHub】创建Git分支将Hexo博客迁移到其它电脑</a></p>
<p><a href="https://zouhua.top/archives/a2a13e.html" target="_blank" rel="noopener">git分支保存hexo博客源码</a></p>
<p><a href="https://kernelshow.com/2018/09/02/2018/09/0002-hexo_use_branch_to_backup_your_hexo_environment_and_blogs/" target="_blank" rel="noopener">使用 Hexo 搭建 GitHub Page 博客(二)–备份至 GitHub 过程</a></p>
<p><a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">基于hexo+github搭建一个独立博客</a></p>
<p><a href="https://blog.csdn.net/yellowmushroom/article/details/80680022" target="_blank" rel="noopener">搭建Hexo博客在git上执行 hexo d /hexo g 报错:ERROR Local hexo not found in D:\hexo 解决</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客及设置新主题</title>
    <url>/2020/05/07/%E5%B7%A5%E5%85%B7/hexo/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%96%B0%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Hexo搭建博客及设置新主题"><a href="#Hexo搭建博客及设置新主题" class="headerlink" title="Hexo搭建博客及设置新主题"></a>Hexo搭建博客及设置新主题</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>前面使用GitHub Pages和hexo搭建了博客，但是使用默认的Hexo主题，不怎么好看。因此，我网上搜了一下hexo主题，发现next主题在github上人气比较高，而且比较它的喜欢简洁的风格。本文以设置next主题为例子，介绍Hexo如何设置新主题。</p>
<h2 id="2-创建博客"><a href="#2-创建博客" class="headerlink" title="2 创建博客"></a>2 创建博客</h2><p>步骤1：</p>
<p>在E盘创建myhexo-next文件夹</p>
<p>步骤2：</p>
<p>打开window下的bash shell命令终端</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_001.jpg" alt="20200507_001"></p>
<p>步骤3：</p>
<p>在shell终端输入下面命令,进入myhexo-next文件夹目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myhexo-next</span><br></pre></td></tr></table></figure>

<p>步骤4：</p>
<p>执行初始化博客根目录的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>步骤5：</p>
<p>在博客根目录安装插件，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<p>不需要插件可以不用安装。</p>
<p>然后，在myhexo-next目录下会有下面的内容</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_002.png" alt="20200507_002"></p>
<p>步骤6：</p>
<p>在myhexo-next目录下，修改_config.yml文件的deploy属性(注意:之后有空格)。</p>
<p>默认是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;&#39;</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:name_xxx&#x2F;name_xx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>步骤7：</p>
<p>生成静态网页，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>本地预览，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开生成的静态网页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>

<p>默认的主题：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_011.png" alt="20200507_011"></p>
<p>上传github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>到此，利用hexo搭建博客已经完毕。</p>
<h2 id="3-更改主题为next主题"><a href="#3-更改主题为next主题" class="headerlink" title="3 更改主题为next主题"></a>3 更改主题为next主题</h2><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将博客根目录下的_config.yml称为 <strong>站点配置文件</strong>， 将主题目录下的_config.yml称为 <strong>主题配置文件。</strong></p>
<h3 id="3-1-下载主题"><a href="#3-1-下载主题" class="headerlink" title="3.1 下载主题"></a>3.1 下载主题</h3><p>在shell终端窗口下，进入博客 根目录myhexo-next目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myhexo-next</span><br></pre></td></tr></table></figure>

<p>使用 Git checkout 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>然后进入根目录下的themes </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>发现themes目录下多了一个next文件夹.</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_003.png" alt="20200507_003"></p>
<p>进入next文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd next</span><br></pre></td></tr></table></figure>

<p>在执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>发现next已经下载下来</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_004.png" alt="20200507_004"></p>
<h3 id="3-2-修改站点配置文件"><a href="#3-2-修改站点配置文件" class="headerlink" title="3.2 修改站点配置文件"></a>3.2 修改站点配置文件</h3><p>站点配置文件默认的主题配置为landscape</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure>

<p>将站点配置文件的主题修改为next(<strong>注意空格</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>回到博客根目录myhexo-next</p>
<p>执行调试命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server --debug</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_005.png" alt="20200507_005"></p>
<p>在浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br></pre></td></tr></table></figure>

<p>就可以看到博客了</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_007.png" alt="20200507_007"></p>
<p>进入next目录，修改主题配置文件的menu，默认为</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_008.png" alt="20200507_008"></p>
<p>改为</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_009.png" alt="20200507_009"></p>
<p>然后重新执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server --debug</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200507_010.png" alt="20200507_010"></p>
<p>参考：</p>
<p><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next主题源代码</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">维护版本的next源码</a></p>
<p><a href="https://zhoubofsy.github.io/" target="_blank" rel="noopener">模板参考1</a></p>
<p><a href="https://draapho.github.io/categories/" target="_blank" rel="noopener">模板参考2</a></p>
<p><a href="https://www.jianshu.com/p/b20fc983005f" target="_blank" rel="noopener">Hexo设置主题以及Next主题个性设置</a></p>
<p><a href="https://segmentfault.com/a/1190000012805627" target="_blank" rel="noopener">如何更换hexo博客主题</a></p>
<p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next主题官网文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/85037898" target="_blank" rel="noopener">Hexo系列 | Hexo+next主题搭建炫酷的个人博客网站</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建</title>
    <url>/2019/12/10/%E5%B7%A5%E5%85%B7/hexo/Hexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安装前提:<br>安装Node.js<br>安装Git</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>安装选项全部默认，一路点击Next。</p>
<p>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。</p>
<p><strong>更改为国内镜像源:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p>
<p>安装完成后在命令提示符中输入git –version验证是否安装成功。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>右键点击Git Bash Here，进入git shell<br>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>进阶安装和使用<br>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<p>npx hexo <command></p>
<p>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：</p>
<p>echo ‘PATH=”$PATH:./node_modules/.bin”‘ &gt;&gt; ~/.profile</p>
<h2 id="Github账户与本地Git绑定"><a href="#Github账户与本地Git绑定" class="headerlink" title="Github账户与本地Git绑定"></a>Github账户与本地Git绑定</h2><p><strong>鼠标右击打开Git Bash：</strong></p>
<p>设置user.name和user.email配置信息：</p>
<p>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”</p>
<p>生成ssh密钥文件：<br>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</p>
<p>设置github ssh<br>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。</p>
<p>git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key<br>在Git Bash中检测GitHub公钥设置是否成功:<br>输入ssh -T <a href="mailto:git@github.com">git@github.com</a>，如果如下图所示，出现你的用户名，那就成功了。</p>
<p><img src="http://jiali.clouddn.com/20200714_002.png.jpg" alt="20200714_002.png"></p>
<p><strong>Github</strong> 创建个人博客创库</p>
<p><img src="http://jiali.clouddn.com/20200714_003.jpg" alt="20200714_003"></p>
<p>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。</p>
<p><img src="http://jiali.clouddn.com/20200714_004.jpg" alt="20200714_004"></p>
<p>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样：</p>
<p><img src="http://jiali.clouddn.com/20200714_005.jpg" alt="20200714_005"></p>
<p>点击那个链接，就会出现自己的网页啦，效果如下：</p>
<p><img src="http://jiali.clouddn.com/20200714_006.jpg" alt="20200714_006"></p>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ol>
<li>创建博客根目录<br>在硬盘创建一个目录作为博客根目录blog</li>
<li>初始化博客根目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>

<p>3.安装deployer-git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在/blog/_config.yml中修改deploy属性(注意:之后有空格)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;thesingularityisnear&#x2F;thesingularityisnear.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>4.新建文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>

<p>markdown 格式编辑文章</p>
<p>5．生成静态网页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;产生静态博客网页</span><br><span class="line">hexo s&#x2F;&#x2F;本地预览</span><br><span class="line">hexo d &#x2F;&#x2F;上传到github</span><br></pre></td></tr></table></figure>

<p>遇到问题：</p>
<p>1.本地与github绑定失败：</p>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>然后直接三个回车即可，默认不需要设置密码</p>
<p>2.deploy 写错，导致不能发布到GIthub,正确格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>参考：</strong><br><a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a><br><a href="https://www.jianshu.com/p/84a8384be1ae" target="_blank" rel="noopener">Hexo使用指南</a><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo:Next主题博客优化</title>
    <url>/2020/05/09/%E5%B7%A5%E5%85%B7/hexo/Next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-在右上角或者左上角实现fork-me-on-github"><a href="#1-在右上角或者左上角实现fork-me-on-github" class="headerlink" title="1 在右上角或者左上角实现fork me on github"></a>1 在右上角或者左上角实现fork me on github</h2><p>从文字样式 <a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>或<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">图标样式</a>，选择一个样式模板，并复制文本框中的代码，例如：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200509_002.png" alt="20200509_002"></p>
<p>其中，href=”<a href="https://your-url&quot;修改为自己的github用户地址。" target="_blank" rel="noopener">https://your-url&quot;修改为自己的github用户地址。</a></p>
<p>打开 themes/next/layout/_layout.swig 文件，把代码复制到<div class="headband"></div>下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body itemscope itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;WebPage&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&#123;%- if theme.motion.enable %&#125; use-motion&#123;%- endif %&#125;&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;jialimeng&quot; class&#x3D;&quot;github-corner&quot; aria-label&#x3D;&quot;View source on GitHub&quot;&gt;&lt;svg width&#x3D;&quot;80&quot; height&#x3D;&quot;80&quot; viewBox&#x3D;&quot;0 0 250 250&quot; style&#x3D;&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;path d&#x3D;&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill&#x3D;&quot;currentColor&quot; style&#x3D;&quot;transform-origin: 130px 106px;&quot; class&#x3D;&quot;octo-arm&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill&#x3D;&quot;currentColor&quot; class&#x3D;&quot;octo-body&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;&#x2F;a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;&#x2F;style&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;header&quot; itemscope itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;WPHeader&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;header-inner&quot;&gt;&#123;% include &#39;_partials&#x2F;header&#x2F;index.swig&#39; %&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure>

<p>保存调试，就会看到效果如下：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200509_004.png" alt="20200509_004"></p>
<h2 id="侧边栏优化"><a href="#侧边栏优化" class="headerlink" title="侧边栏优化"></a>侧边栏优化</h2><ul>
<li>个人头像设置</li>
<li>社交栏图标设置</li>
<li>友情链接设置</li>
<li>RSS订阅设置</li>
</ul>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>在主题配置文件搜索avatar字段，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.gif</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>

<p>url是图像存放地址，可以是本地文件路径，也可以是网络地址。本配置使用默认的图片</p>
<h3 id="社交栏配置"><a href="#社交栏配置" class="headerlink" title="社交栏配置"></a>社交栏配置</h3><p>在主题配置文件中，搜索social，接下来，就看你需要显示什么社交网站，写上网站名+网址</p>
<p>比如原来配置中的网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimiter is the target permalink, value after &#96;||&#96; delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || fab fa-weibo</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || fab fa-google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br></pre></td></tr></table></figure>

<h3 id="友情链接配置"><a href="#友情链接配置" class="headerlink" title="友情链接配置"></a>友情链接配置</h3><p>打开 主题配置文件,搜索关键字 links：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: Links</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  Title: http:&#x2F;&#x2F;yoursite.com</span><br><span class="line">  百度: http:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>

<p>在links字段下，写上名字及其地址。</p>
<p><strong>备注</strong>：</p>
<p>layout作用：链接站点的排版</p>
<p>block:竖排</p>
<p>inline:横排</p>
<h3 id="RSS订阅设置"><a href="#RSS订阅设置" class="headerlink" title="RSS订阅设置"></a>RSS订阅设置</h3><p>安装网上给的步骤，RSS没有出来，不知道为什么。配置步骤是这样</p>
<p>步骤1：执行安装插件命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>

<p>步骤2：修改站点配置文件，添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">#RSS订阅</span><br><span class="line">#plugin: </span><br><span class="line">#- hexo-generator-feed</span><br><span class="line"># feed</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-generator-feed</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &#39; &#39;</span><br><span class="line">  order_by: -date</span><br><span class="line">  icon: icon.png</span><br><span class="line">  autodiscovery: true</span><br><span class="line">  template:</span><br></pre></td></tr></table></figure>

<p>步骤3：最后修改主题配置文件，修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">follow_me:</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;username || fab fa-twitter</span><br><span class="line">  #Telegram: https:&#x2F;&#x2F;t.me&#x2F;channel_name || fab fa-telegram</span><br><span class="line">  #WeChat: &#x2F;images&#x2F;wechat_channel.jpg || fab fa-weixin</span><br><span class="line">  RSS: atom.xml || fa fa-rss</span><br></pre></td></tr></table></figure>



<p>最后给侧栏的效果如下：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200509_005.png" alt="20200509_005"></p>
<p>参考：</p>
<p><a href="https://blog.junyu.io/posts/0005-next-theme-settings.html#menu" target="_blank" rel="noopener">Next主题配置文件说明</a></p>
<p><a href="https://juejin.im/post/5a71ab9f518825735300ee6c" target="_blank" rel="noopener">NexT主题的配置和优化指南</a></p>
<p><a href="http://shenzekun.cn/" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">Hexo+Next主题优化</a></p>
<p><a href="http://eternalzttz.com/hexo-next.html" target="_blank" rel="noopener">hexo next主题优化，打造个人精致网站</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo:next主题menu设置</title>
    <url>/2020/05/08/%E5%B7%A5%E5%85%B7/hexo/next%E4%B8%BB%E9%A2%98menu%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程针对next主题背景，给文章添加分类和标签。添加成功后，博客导航栏的分类和标签可以看到相应的文章。</p>
<h2 id="Hexo-next主题的菜单设置"><a href="#Hexo-next主题的菜单设置" class="headerlink" title="Hexo next主题的菜单设置"></a>Hexo next主题的菜单设置</h2><p>更改主题配置文件，将menu中相关字段取消屏蔽，更改后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before &#96;||&#96; delimiter is the target link, value after &#96;||&#96; delimiter is the name of Font Awesome icon.</span><br><span class="line"># When running the site in a subdirectory (e.g. yoursite.com&#x2F;blog), remove the leading slash from link value (&#x2F;archives -&gt; archives).</span><br><span class="line"># External url should start with http:&#x2F;&#x2F; or https:&#x2F;&#x2F;</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>然后执行调试命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200508_001.png" alt="20200508_001"></p>
<h2 id="给文章分类"><a href="#给文章分类" class="headerlink" title="给文章分类"></a>给文章分类</h2><p>打开bash终端，进入博客根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myhexo-next</span><br></pre></td></tr></table></figure>

<p>执行命令，创建分类page</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功会提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Created: E:\myhexo-next\source\categories\index.md</span><br></pre></td></tr></table></figure>

<p>根据提示的路径，找到index.md文件，打开默认内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-05-08 09:27:33</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>title字段：分类页的标题</p>
<p>修改index.md文件，添加type字段及其属性，修改后如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2020-05-08 09:27:33</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存文件，执行调试命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br></pre></td></tr></table></figure>

<p>查看效果：<br><img src="http://q9kx2gcuj.bkt.clouddn.com/20200508_003.png" alt="20200508_003"></p>
<h2 id="给文章分类-1"><a href="#给文章分类-1" class="headerlink" title="给文章分类"></a>给文章分类</h2><p>打开.md文章，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello-world.md</span><br></pre></td></tr></table></figure>

<p>在文章开头添加”YAML Front Matter”格式，然后添加分类字段属性。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2020-05-08 09:27:33</span><br><span class="line">categories: test</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：</p>
<p>title:文章标题</p>
<p>date:发表日期</p>
<p>同样，执行调试看效果</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200508_004.png" alt="20200508_004"></p>
<h2 id="给文章添加标签"><a href="#给文章添加标签" class="headerlink" title="给文章添加标签"></a>给文章添加标签</h2><p>步骤跟创建分类一样，区别在创建page命令。创建标签page命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>后面所有的步骤跟分类一样。过程略，文章添加标签效果如下：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200508_005.png" alt="20200508_005"></p>
<h2 id="创建About页面"><a href="#创建About页面" class="headerlink" title="创建About页面"></a>创建About页面</h2><p>新建一个About页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>

<p>成功则出现下面提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Created: E:\myhexo-next\source\about\index.md</span><br></pre></td></tr></table></figure>

<p>进入about目录，打开index.md，默认内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-05-08 19:29:10</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在默认内容下面，编辑about页面内容，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是张三，软件高级工程师，我爱编程</span><br></pre></td></tr></table></figure>

<p>执行调试命令，效果如下：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200508_006.png" alt="20200508_006"></p>
<h2 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a>添加本地搜索</h2><p>打开bash,进入博客的根目录，执行命令安装第三方搜索插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在站点配置文件，增加搜索功能字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>path：索引文件的路径，相对于站点根目录</li>
<li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面</li>
<li>limit：限制搜索的条目数</li>
</ul>
<p>然后修改主题配置文件，搜索关键字 local_search ,设置为 true，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<p>展示：</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/20200509_001.png" alt="20200509_001"></p>
<p>扩展：</p>
<p>多级分类配置：</p>
<p>打开source/categories/index.md,改为如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 文章分类</span><br><span class="line">date: 2020-07-10 13:27:56</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>然后，修改博文分类属性如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hexo环境搭建 </span><br><span class="line">date: 2019-12-10 21:02:06</span><br><span class="line">tags: Hexo</span><br><span class="line">categories:</span><br><span class="line">- 工具</span><br><span class="line">- hexo</span><br></pre></td></tr></table></figure>

<p>多级标签也是这样设置，最后效果如下。</p>
<p><img src="http://jiali.clouddn.com/20200716_001.png" alt="20200716_001"></p>
<p><strong>参考</strong>：</p>
<p><a href="https://rilzob.com/" target="_blank" rel="noopener">Hexo使用攻略：添加分类及标签</a></p>
<p><a href="https://whx4j8.github.io/" target="_blank" rel="noopener">hexo next 为文章添加分类</a></p>
<p><a href="https://linlif.github.io/" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+PicGo+七牛云实现图片上传</title>
    <url>/2020/04/30/%E5%B7%A5%E5%85%B7/markdown/Typora+PicGo+%E4%B8%83%E7%89%9B%E4%BA%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>Typora编写markdown，简洁高效。但是会遇到md文件拷贝到另一个电脑或者导入博客，图片失效的问题。解决的方法有很多。比较原始的是，拷贝md文件，连同图片一起拷贝放在一个目录。但是经常拷贝图片太麻烦，最好的办法就是把图片放在图床上。本人使用的是七牛云图床。本文总结Typora+PicGo+七牛云的实现过程。</p>
<h2 id="2-注册七牛云"><a href="#2-注册七牛云" class="headerlink" title="2 注册七牛云"></a>2 注册七牛云</h2><h3 id="2-1-进入官网注册"><a href="#2-1-进入官网注册" class="headerlink" title="2.1 进入官网注册"></a>2.1 进入官网注册</h3><p>点击<a href="https://www.qiniu.com/?utm_campaign=SEM&utm_content=pinzhuan&utm_medium=pinzhuan&utm_source=baiduSEM&utm_term=pinzhuan" target="_blank" rel="noopener">七牛云官网</a>，然后选择“注册有礼”，接着输入注册信息，然后下一步，点击个人申请。</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/202004301.png" alt="202004301"></p>
<h3 id="2-2-实名认证"><a href="#2-2-实名认证" class="headerlink" title="2.2 实名认证"></a>2.2 实名认证</h3><p>需要实名认证才能申请免费的10G空间</p>
<h3 id="2-3-建立存储空间"><a href="#2-3-建立存储空间" class="headerlink" title="2.3 建立存储空间"></a>2.3 建立存储空间</h3><p>回到<strong>主页</strong>，点击<strong>添加对象存储</strong>，然后，<strong>新建空间</strong>，填写<strong>空间配置信息</strong></p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/202004302.png" alt="202004302"></p>
<h3 id="2-4-上传图片"><a href="#2-4-上传图片" class="headerlink" title="2.4 上传图片"></a>2.4 上传图片</h3><p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043003.png" alt="2020043003"></p>
<p>为了方便编写md过程中，插入图片时候自动上传图片到七牛云图床，这需要用到PicGO工具。</p>
<h2 id="3-PicGo工具安装与配置"><a href="#3-PicGo工具安装与配置" class="headerlink" title="3 PicGo工具安装与配置"></a>3 PicGo工具安装与配置</h2><h3 id="3-1-下载安装PicGo"><a href="#3-1-下载安装PicGo" class="headerlink" title="3.1 下载安装PicGo"></a>3.1 下载安装PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo下载地址</a></p>
<h3 id="3-2打开PicGo并设置七牛云图床"><a href="#3-2打开PicGo并设置七牛云图床" class="headerlink" title="3.2打开PicGo并设置七牛云图床"></a>3.2打开PicGo并设置七牛云图床</h3><p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043004.png" alt="2020043004"></p>
<ul>
<li><p>AccessKey和Secretkey到七牛云个人中心的密钥管理获取</p>
</li>
<li><p>存储空间名设置为七牛云的存储空间的命令</p>
</li>
<li><p>访问地址在空间概况里获取（记得前面加http://）</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043005.png" alt="2020043005"></p>
</li>
</ul>
<p><strong>七牛云的存储区域对应的简称</strong></p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043006.png" alt="2020043006"></p>
<h3 id="3-3测试PicGo上传图片"><a href="#3-3测试PicGo上传图片" class="headerlink" title="3.3测试PicGo上传图片"></a>3.3测试PicGo上传图片</h3><p>可以把图片拖拽到PicGo上传区，测试是否可以正常上传图片。链接格式为MarkDown</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043007.png" alt="2020043007"></p>
<h2 id="4-Typora-配置-PicGo"><a href="#4-Typora-配置-PicGo" class="headerlink" title="4 Typora 配置 PicGo"></a>4 Typora 配置 PicGo</h2><h3 id="4-1配置图片上传"><a href="#4-1配置图片上传" class="headerlink" title="4.1配置图片上传"></a>4.1配置图片上传</h3><p>在Typora软件，打开<strong>文件</strong>选项，选择<strong>偏好设置</strong>，然后，选择<strong>图像</strong></p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043008.png" alt="2020043008"></p>
<p><strong>上传服务</strong>选择PicGo，<strong>PicGo路径</strong>为安装路径。<strong>点击验证图片上传选项</strong>，如果验证失败，请检查PicGo的监听接口是否为36677.</p>
<p><img src="http://q9kx2gcuj.bkt.clouddn.com/2020043009.png" alt="2020043009"></p>
<h3 id="4-2-上传图片"><a href="#4-2-上传图片" class="headerlink" title="4.2 上传图片"></a>4.2 上传图片</h3><p>上传方式有很多种。</p>
<p>方式一：在Typora,点击图片右键，选择上传图片</p>
<p>方式二：点击<strong>格式</strong>，选择<strong>图像</strong>，选中<strong>当插入图片时</strong>，勾选<strong>上传图片</strong></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/weimeibuqieryu/article/details/105315807" target="_blank" rel="noopener">typora+picgo+七牛云实现图片上传</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/114520225" target="_blank" rel="noopener">Typora 设置上传图片功能</a></p>
<p><a href="https://blog.csdn.net/sky0816/article/details/103638287" target="_blank" rel="noopener">Typora等markdown笔记软件图片链接失效的问题解决办法</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - 记录一次Pages服务部署失败的原因</title>
    <url>/2020/05/07/%E5%B7%A5%E5%85%B7/hexo/Hexo%20-%20%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Pages%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0(%E8%BD%AC%E8%BD%BD)/</url>
    <content><![CDATA[<p><strong>转载</strong><a href="https://www.cnblogs.com/yulinlewis/p/10777296.html" target="_blank" rel="noopener">Hexo - 记录一次Pages服务部署失败的原因 </a></p>
<h1 id="Hexo-记录一次Pages服务部署失败的原因"><a href="#Hexo-记录一次Pages服务部署失败的原因" class="headerlink" title="Hexo - 记录一次Pages服务部署失败的原因"></a>Hexo - 记录一次Pages服务部署失败的原因</h1><h2 id="问题与分析"><a href="#问题与分析" class="headerlink" title="问题与分析"></a>问题与分析</h2><p>某天忽然发现，一直运行得好好的Pages服务部署失败了，GitHub Pages报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your site is having problems building: The tag cq on line 3 in source&#x2F;high&#x2F;index.md is not a recognized Liquid tag.</span><br><span class="line">For more information, see https:&#x2F;&#x2F;help.github.com&#x2F;articles&#x2F;page-build-failed-unknown-tag-error&#x2F;.</span><br></pre></td></tr></table></figure>

<p>与此同时，Coding Pages同样也报错了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting jekyll build.</span><br><span class="line">&gt; jekyll build --safe</span><br><span class="line">Configuration file: &#x2F;usr&#x2F;src&#x2F;app&#x2F;_config.yml</span><br><span class="line">jekyll 3.6.2 | Error:  The next theme could not be found.</span><br><span class="line">Jekyll build exit with code 1.</span><br><span class="line">Fail to build jekyll site.</span><br></pre></td></tr></table></figure>

<p>首先我使用的是Hexo的next主题，而根据GitHub Pages的报错信息来看，是说在source/high/index.md里使用到了一个不认识的cq标签。<br>这个标签是next主题自带的，使用该标签快一年了，还是第一次遇到报这个错。接着根据Coding Pages的报错来看，则是说/usr/src/app/_config.yml里找不到jekyll的主题。<br>这就很奇怪了，我使用的明明是hexo，怎么忽然就变成jekyll了？一阵瞎折腾过后，一直部署失败。我忽然想起来一个事情，我之前曾经拿本地的博客仓库的git配置练过手，难道和这个有关？<br>我开始查找本地博客仓库的git配置，我是使用hexo-deployer-git这个插件来将本地生成的静态博客发送到远程仓库的。<br>当我在本地在执行hexo g后，会在博客根目录下生成一个public文件夹，这个文件夹里的文件组合起来就是一个完整的静态博客。<br>接着如果执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里，然后会把该文件夹里的所有文件全部推送push到远程库。之后会触发Pages服务的钩子去build项目，然后部署到网站上。</p>
<h2 id="发现线索"><a href="#发现线索" class="headerlink" title="发现线索"></a>发现线索</h2><p>我打开public文件夹，发现生成出来的文件很正常，接着打开.deploy_git文件夹，发现也很正常，接着查看远程库里的文件，终于发现了问题。<br>在远程库的分支里，根本就没有hexo相关的文件，至此算是找到原因了。<br>很显然，我在执行hexo d时出了问题，没能正常将文件push到远程库，于是部署就失败了。之前该命令是没问题的，可之前我曾经动过手脚，修改过博客项目里的git配置，手动修改了.git里的文件，莫非这就是问题的根源？</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>基于以上的猜想，我直接删掉了本地博客项目的.deploy_git文件夹，重新执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>等待片刻后，我终于看到远程部署成功，我的个人站点再次运转成功！<br>皇天不负有心人啊！原因终于明了，是.deploy_git文件夹出现问题，删掉该文件夹，重新运行hexo d即可。<br>记录下这次的遭遇，遇到问题应该静下心来，仔细分析，才不容易瞎折腾</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Markdown 语法手册 （完整整理版）</title>
    <url>/2020/04/30/%E5%B7%A5%E5%85%B7/markdown/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Markdown%20%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%20%EF%BC%88%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li>目录<br>{:toc}</li>
</ul>
<hr>
<h4 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*或_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p>view</p>
<p><em>斜体</em>或<em>斜体</em></p>
<p><strong>粗体</strong></p>
<p><strong><em>加粗斜体</em></strong></p>
<p><del>删除线</del></p>
<hr>
<h4 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<p>由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<hr>
<h4 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a>3. 超链接</h4><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>
<h5 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1. 行内式"></a>3.1. 行内式</h5><p>语法说明：</p>
<p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接地址与链接标题前有一个空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">欢迎来到[<span class="string">Demi的随笔和技术空间</span>](<span class="link">https://yuhongjun.github.io/</span>)</span><br><span class="line"></span><br><span class="line">欢迎来到[<span class="string">Demi的随笔和技术空间</span>](<span class="link">https://yuhongjun.github.io/ "Demi的随笔和技术空间"</span>)</span><br></pre></td></tr></table></figure>
<p>view</p>
<p>欢迎来到<a href="https://yuhongjun.github.io/" target="_blank" rel="noopener">Demi的随笔和技术空间</a></p>
<p>欢迎来到<a href="https://yuhongjun.github.io/" target="_blank" rel="noopener" title="Demi的随笔和技术空间">Demi的随笔和技术空间</a></p>
<h5 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2. 参考式"></a>3.2. 参考式</h5><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我经常去的几个网站[<span class="string">Google</span>][<span class="symbol">1</span>],[<span class="string">Demi的随笔和技术空间</span>][<span class="symbol">2</span>],[<span class="string">Demi的随笔和技术空间</span>][<span class="symbol"></span>]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.google.com</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://yuhongjun.github.io/ "Demi的随笔和技术空间"</span></span><br><span class="line">[<span class="symbol">Demi的随笔和技术空间</span>]:<span class="link">https://yuhongjun.github.io/</span></span><br></pre></td></tr></table></figure>

<p>我经常去的几个网站<a href="http://www.google.com" target="_blank" rel="noopener">Google</a>,<a href="https://yuhongjun.github.io/" target="_blank" rel="noopener" title="Demi的随笔和技术空间">Demi的随笔和技术空间</a>,<a href="https://yuhongjun.github.io/" target="_blank" rel="noopener">Demi的随笔和技术空间</a>。</p>
<h5 id="3-3-自动链接"><a href="#3-3-自动链接" class="headerlink" title="3.3. 自动链接"></a>3.3. 自动链接</h5><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">example.com</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">address@example.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>view</p>
<p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><br><a href="mailto:&#97;&#x64;&#x64;&#x72;&#101;&#115;&#115;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#97;&#x64;&#x64;&#x72;&#101;&#115;&#115;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></p>
<hr>
<h4 id="4-锚点"><a href="#4-锚点" class="headerlink" title="4. 锚点"></a>4. 锚点</h4><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p>
<p>注意： </p>
<ol>
<li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li>
<li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 0. 跳转测试&#123;#index&#125;</span></span><br><span class="line"></span><br><span class="line">跳转到[<span class="string">跳转测试</span>](<span class="link">#index</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h4><h5 id="5-1-无序列表"><a href="#5-1-无序列表" class="headerlink" title="5.1. 无序列表"></a>5.1. 无序列表</h5><p>使用 *，+，- 表示无序列表。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表项 一</span><br><span class="line"><span class="bullet">- </span>无序列表项 二</span><br><span class="line"><span class="bullet">- </span>无序列表项 三</span><br></pre></td></tr></table></figure>
<p>view</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h5 id="5-2-有序列表"><a href="#5-2-有序列表" class="headerlink" title="5.2. 有序列表"></a>5.2. 有序列表</h5><p>有序列表则使用数字接着一个英文句点。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表项 一</span><br><span class="line"><span class="bullet">2. </span>有序列表项 二</span><br><span class="line"><span class="bullet">3. </span>有序列表项 三</span><br></pre></td></tr></table></figure>
<p>view</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h5 id="5-3-定义型列表"><a href="#5-3-定义型列表" class="headerlink" title="5.3. 定义型列表"></a>5.3. 定义型列表</h5><p>语法说明：</p>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">代码块 1 Markdown</span><br><span class="line">:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"></span><br><span class="line">代码块 2</span><br><span class="line">:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"></span><br><span class="line"><span class="code">        代码块（左侧有八个不可见的空格）</span></span><br></pre></td></tr></table></figure>
<p>view</p>
<dl><dt>代码块 1 Markdown</dt><dd>轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h5 id="5-3-列表缩进"><a href="#5-3-列表缩进" class="headerlink" title="5.3. 列表缩进"></a>5.3. 列表缩进</h5><p>语法说明：</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </span><br><span class="line"><span class="bullet">*   </span>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 </span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>
<p>view</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h5 id="5-4-包含段落的列表"><a href="#5-4-包含段落的列表" class="headerlink" title="5.4. 包含段落的列表"></a>5.4. 包含段落的列表</h5><p>语法说明：</p>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line"></span><br><span class="line"><span class="code">     那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span></span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 </span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line"></span><br><span class="line"><span class="bullet">*    </span>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>
<p>view</p>
<ul>
<li><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p> 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </p>
</li>
<li><p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
<h5 id="5-5-包含引用的列表"><a href="#5-5-包含引用的列表" class="headerlink" title="5.5. 包含引用的列表"></a>5.5. 包含引用的列表</h5><p>语法说明：</p>
<p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>阅读的方法:</span><br><span class="line"><span class="code">    &gt; 打开书本。</span></span><br><span class="line"><span class="code">    &gt; 打开电灯。</span></span><br></pre></td></tr></table></figure>
<p>view</p>
<ul>
<li>阅读的方法:<blockquote>
<p>打开书本。<br>打开电灯。</p>
</blockquote>
</li>
</ul>
<h5 id="5-6-包含代码区块的引用"><a href="#5-6-包含代码区块的引用" class="headerlink" title="5.6. 包含代码区块的引用"></a>5.6. 包含代码区块的引用</h5><p>语法说明：<br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<h5 id="5-7-一个特殊情况"><a href="#5-7-一个特殊情况" class="headerlink" title="5.7. 一个特殊情况"></a>5.7. 一个特殊情况</h5><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1986. </span>What a great season.</span><br></pre></td></tr></table></figure>
<p>会显示成：</p>
<ol start="1986">
<li>What a great season.</li>
</ol>
<p>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure>
<p>才会正常显示成：</p>
<p>1986. What a great season.</p>
<hr>
<h4 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h4><p>语法说明：</p>
<p>引用需要在被引用的文本前加上&gt;符号。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个有两段文字的引用,</span></span><br><span class="line">无意义的占行文字1.</span><br><span class="line">无意义的占行文字2.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字3.</span></span><br><span class="line">无意义的占行文字4.</span><br></pre></td></tr></table></figure>
<p>view</p>
<blockquote>
<p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p>
</blockquote>
<blockquote>
<p>无意义的占行文字3.<br>无意义的占行文字4.</p>
</blockquote>
<h5 id="6-1-引用的多层嵌套"><a href="#6-1-引用的多层嵌套" class="headerlink" title="6.1. 引用的多层嵌套"></a>6.1. 引用的多层嵌套</h5><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白</span><br><span class="line"></span><br><span class="line">&gt;&gt; 自己看教程！ - 愤青</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 教程在哪？ - 小白</span></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h5 id="6-2-引用其它要素"><a href="#6-2-引用其它要素" class="headerlink" title="6.2. 引用其它要素"></a>6.2. 引用其它要素</h5><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1.   这是第一行列表项。</span></span><br><span class="line"><span class="quote">&gt; 2.   这是第二行列表项。</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 给出一些例子代码：</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt;     return shell_exec("echo $input | $markdown_script");</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote>
<hr>
<h4 id="7-插入图像"><a href="#7-插入图像" class="headerlink" title="7. 插入图像"></a>7. 插入图像</h4><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p>
<p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<h5 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1. 行内式"></a>7.1. 行内式</h5><p>语法说明：![图片Alt](图片地址 “图片Title”)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">美丽风景： </span><br><span class="line">![<span class="string">美丽风景</span>](<span class="link">https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景"</span>)</span><br></pre></td></tr></table></figure>
<p>view<br>美丽风景：<br><img src="https://yuhongjun.github.io/assets/media/scenery.jpeg" alt="美丽风景" title="美丽风景"></p>
<p>7.2. 参考式</p>
<p>语法说明：</p>
<p>在文档要插入图片的地方写![图片Alt][标记]</p>
<p>在文档的最后写上[标记]:图片地址 “Title”</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">美丽风景</span>](<span class="link">https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="symbol">scenery</span>]:<span class="link">https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景"</span></span><br></pre></td></tr></table></figure>
<p>view<br><img src="https://yuhongjun.github.io/assets/media/scenery.jpeg" alt="美丽风景" title="美丽风景"></p>
<hr>
<h4 id="8-内容目录"><a href="#8-内容目录" class="headerlink" title="8. 内容目录"></a>8. 内容目录</h4><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<p>效果参见最上方的目录</p>
<hr>
<h4 id="9-注脚"><a href="#9-注脚" class="headerlink" title="9. 注脚"></a>9. 注脚</h4><p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">Markdown是一种纯文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">HyperText Markup Language 超文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^Le</span>]:<span class="link">开源笔记平台，支持Markdown和笔记直接发为博文</span></span><br></pre></td></tr></table></figure>
<p>view</p>
<p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p>
<p>[^2]:HyperText Markup Language 超文本标记语言</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p>
<hr>
<h4 id="10-LaTeX-公式"><a href="#10-LaTeX-公式" class="headerlink" title="10. LaTeX 公式"></a>10. LaTeX 公式</h4><h5 id="10-1-表示行内公式："><a href="#10-1-表示行内公式：" class="headerlink" title="10.1. $ 表示行内公式："></a>10.1. $ 表示行内公式：</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br></pre></td></tr></table></figure>
<p>view<br>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<h5 id="10-2-表示整行公式："><a href="#10-2-表示整行公式：" class="headerlink" title="10.2 $$ 表示整行公式："></a>10.2 $$ 表示整行公式：</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$\sum<span class="emphasis">_&#123;i=1&#125;^n a_</span>i=0$$</span><br><span class="line">$$f(x<span class="emphasis">_1,x_</span>x,\ldots,x<span class="emphasis">_n) = x_</span>1^2 + x<span class="emphasis">_2^2 + \cdots + x_</span>n^2 $$</span><br><span class="line">$$\sum^&#123;j-1&#125;<span class="emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z_k&#125;$$</span><br></pre></td></tr></table></figure>
<p>访问 <a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener" title="MathJax basic tutorial and quick reference">MathJax</a> 参考更多使用方法。</p>
<hr>
<h4 id="11-流程图"><a href="#11-流程图" class="headerlink" title="11. 流程图"></a>11. 流程图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;textarea id&#x3D;&quot;code&quot; style&#x3D;&quot;width: 100%;&quot; rows&#x3D;&quot;11&quot;&gt;</span><br><span class="line">st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.google.com[blank]</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation|past</span><br><span class="line">op2&#x3D;&gt;operation: Stuff|current</span><br><span class="line">sub1&#x3D;&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond&#x3D;&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">c2&#x3D;&gt;condition: Good idea|rejected</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line">&lt;&#x2F;textarea&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;run&quot; type&#x3D;&quot;button&quot;&gt;Run&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>you can  try different in textarea,then run .</p>
<div>
<textarea id="code" style="width: 100%;" rows="11">
st=>start: Start|past:>https://yuhongjun.github.io[blank]
e=>end: End:>https://yuhongjun.github.io
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>https://yuhongjun.github.io
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

<p>st-&gt;op1(right)-&gt;cond<br>cond(yes, right)-&gt;c2<br>cond(no)-&gt;sub1(left)-&gt;op1<br>c2(yes)-&gt;io-&gt;e<br>c2(no)-&gt;op2-&gt;e<br></textarea></p>
</div>
<div>
<button id="run" type="button">Run</button>
</div>
<div id="canvas"></div>

<p>更多语法参考：<a href="https://flowchart.js.org/" target="_blank" rel="noopener" title="flowchart">流程图语法参考</a></p>
<hr>
<h4 id="12-表格"><a href="#12-表格" class="headerlink" title="12 .表格"></a>12 .表格</h4><p>语法说明：</p>
<p>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</p>
<ol>
<li><p>简单方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br></pre></td></tr></table></figure></li>
<li><p>原生方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|学号|姓名|分数|</span><br><span class="line">|-|-|-|</span><br><span class="line">|小明|男|75|</span><br><span class="line">|小红|女|79|</span><br><span class="line">|小陆|男|92|</span><br></pre></td></tr></table></figure></li>
<li><p>为表格第二列指定方向：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">产品|价格</span><br><span class="line">-|-:</span><br><span class="line">Leanote 高级账号|60元/年</span><br><span class="line">Leanote 超级账号|120元/年</span><br></pre></td></tr></table></figure>
<p>view</p>
</li>
<li><p>简单方式写表格：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody></table>
<p>2.原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody></table>
<p>3.为表格第二列指定方向：</p>
<table>
<thead>
<tr>
<th>产品</th>
<th align="right">价格</th>
</tr>
</thead>
<tbody><tr>
<td>Leanote 高级账号</td>
<td align="right">60元/年</td>
</tr>
<tr>
<td>Leanote 超级账号</td>
<td align="right">120元/年</td>
</tr>
</tbody></table>
<hr>
<h4 id="13-分隔线"><a href="#13-分隔线" class="headerlink" title="13. 分隔线"></a>13. 分隔线</h4><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>

<p>显示效果都一样</p>
<hr>
<h4 id="14-代码"><a href="#14-代码" class="headerlink" title="14. 代码"></a>14. 代码</h4><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p>
<p>语法说明：</p>
<ol>
<li>插入行内代码，即插入一个单词或者一句代码的情况，使用<code>code</code>这样的形式插入。</li>
<li>插入多行代码，可以使用缩进或者“<code>code “</code>,具体看示例。</li>
</ol>
<p><strong>注意： 缩进式插入前方必须有空行</strong></p>
<h5 id="14-1-行内式"><a href="#14-1-行内式" class="headerlink" title="14.1. 行内式"></a>14.1. 行内式</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">C语言里的函数 <span class="code">`scanf()`</span> 怎么使用？</span><br></pre></td></tr></table></figure>
<p>view<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<h5 id="14-2-缩进式多行代码"><a href="#14-2-缩进式多行代码" class="headerlink" title="14.2. 缩进式多行代码"></a>14.2. 缩进式多行代码</h5><p>缩进 4 个空格或是 1 个制表符</p>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include &lt;stdio.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf("Hello world\n");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>view</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}</code></pre><h5 id="14-3-用六个-包裹多行代码"><a href="#14-3-用六个-包裹多行代码" class="headerlink" title="14.3. 用六个`包裹多行代码"></a>14.3. 用六个`包裹多行代码</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">` `</span> `</span><br><span class="line"><span class="section">#include &lt;stdio.h&gt;</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    printf("Hello world\n");</span></span><br><span class="line">&#125;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure>

<h5 id="14-4-HTML-原始码"><a href="#14-4-HTML-原始码" class="headerlink" title="14.4. HTML 原始码"></a>14.4. HTML 原始码</h5><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p>第一个例子：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line">   © 2016 <span class="emphasis">***</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>view</p>
<div class="footer">
   © 2016 ***
</div>
转载：https://yuhongjun.github.io/tech/2017/05/02/Markdown-语法手册-完整整理版.html]]></content>
      <categories>
        <category>工具</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>input子系统应用程序开发</title>
    <url>/2021/01/06/Linux/Driver/Input/input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应用层如何使用内核提供的接口访问input 子系统上报的数据呢？设备的信息，存放在/dev 、/sys 和/proc三个目录中。其中，/dev存放的设备文件，用来跟应用层交互数据，比如/dev/input/event0文件，应用层调用open打开event0，接下来就是使用read和write与输入设备交互数据了。</p>
<h2 id="查看event设备信息"><a href="#查看event设备信息" class="headerlink" title="查看event设备信息"></a>查看event设备信息</h2><p>1、/dev/input</p>
<p>该目录下存放在驱动中调用input_register_device(struct input_dev *dev)产生的输入设备事件，比如鼠标，键盘、触摸屏。</p>
<p>查看/dev/input下的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;input # ls</span><br><span class="line">event0  event1  event2  mice    mouse0</span><br></pre></td></tr></table></figure>

<p>那么如何知道输入设备属于哪个事件呢？</p>
<p>2、/proc/bus/input</p>
<p>与event对应的相关设备信息位于/proc/bus/input/devices. 查看设备信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # cat &#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices </span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0001 Version&#x3D;0001</span><br><span class="line">N: Name&#x3D;&quot;rk29_ir_gpio&quot;</span><br><span class="line">P: Phys&#x3D;irm_kbd_gpio</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;kbd event0 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;7</span><br><span class="line">B: KEY&#x3D;1ff 0 0 0 0 0 0 0 0 10000 0 0 0 0 0 0 0</span><br><span class="line">B: REL&#x3D;3</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0018 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;Atmel_maXTouch_Touchscreen&quot;</span><br><span class="line">P: Phys&#x3D;i2c-1-004a&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;omap&#x2F;omap_i2c.1&#x2F;i2c-1&#x2F;1-004a&#x2F;input&#x2F;input1</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;mouse0 event1 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;b</span><br><span class="line">B: KEY&#x3D;400 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">B: ABS&#x3D;1000003</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0001 Product&#x3D;0001 Version&#x3D;0100</span><br><span class="line">N: Name&#x3D;&quot;gpio-keys&quot;</span><br><span class="line">P: Phys&#x3D;gpio-keys&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;gpio-keys&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event2 apm-power </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;1 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>通过看Name就知道是哪个设备。比如触摸屏设备Name=”Atmel_maXTouch_Touchscreen”，它的event是event1</p>
<p>/proc/bus/input/devices信息解释来自：</p>
<p><a href="https://qastack.cn/unix/74903/explain-ev-in-proc-bus-input-devices-data" target="_blank" rel="noopener">https://qastack.cn/unix/74903/explain-ev-in-proc-bus-input-devices-data</a></p>
<blockquote>
<p><code>devices</code>AT键盘输入示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I: Bus&#x3D;0011 Vendor&#x3D;0001 Product&#x3D;0001 Version&#x3D;ab41</span><br><span class="line">N: Name&#x3D;&quot;AT Translated Set 2 keyboard&quot;</span><br><span class="line">P: Phys&#x3D;isa0060&#x2F;serio0&#x2F;input0</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;platform&#x2F;i8042&#x2F;serio0&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;sysrq kbd event2 </span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;120013</span><br><span class="line">B: KEY&#x3D;20000 200 20 0 0 0 0 500f 2100002 3803078 f900d401 feffffdf ffefffff ffffffff fffffffe</span><br><span class="line">B: MSC&#x3D;10</span><br><span class="line">B: LED&#x3D;7</span><br></pre></td></tr></table></figure>

<p>在<code>B</code>前面的代表<code>bitmap</code>，<code>N</code>，<code>P</code>，<code>S</code>，<code>U</code>，<code>H</code>在相应的名字值只是第一个字母，<code>I</code>是<code>ID</code>。<a href="http://lxr.free-electrons.com/source/include/linux/input.h#L40" target="_blank" rel="noopener">以有序方式：</a></p>
<ul>
<li><pre><code>I =&gt; @id: id of the device 
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &#96;(struct input_id)&#96;</span><br><span class="line"></span><br><span class="line">  - &#96;Bus   &#x3D;&gt; id.bustype&#96;</span><br><span class="line">  - &#96;Vendor &#x3D;&gt; id.vendor&#96;</span><br><span class="line">  - &#96;Product &#x3D;&gt; id.product&#96;</span><br><span class="line">  - &#96;Version &#x3D;&gt; id.version&#96;</span><br><span class="line"></span><br><span class="line">- &#96;N &#x3D;&gt; name of the device.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;P &#x3D;&gt; physical path to the device in the system hierarchy.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;S &#x3D;&gt; sysfs path.&#96;</span><br><span class="line"></span><br><span class="line">- &#96;U &#x3D;&gt; unique identification code for the device (if device has it).&#96;</span><br><span class="line"></span><br><span class="line">- &#96;H &#x3D;&gt; list of input handles associated with the device.&#96;</span><br><span class="line"></span><br><span class="line">- </span><br></pre></td></tr></table></figure>
B =&gt; bitmaps
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - &#96;PROP &#x3D;&gt; device properties and quirks.&#96;</span><br><span class="line">  - **&#96;EV  &#x3D;&gt; types of events supported by the device.&#96;**</span><br><span class="line">  - &#96;KEY &#x3D;&gt; keys&#x2F;buttons this device has.&#96;</span><br><span class="line">  - &#96;MSC &#x3D;&gt; miscellaneous events supported by the device.&#96;</span><br><span class="line">  - &#96;LED &#x3D;&gt; leds present on the device.&#96;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">## 位掩码</span><br><span class="line"></span><br><span class="line">如您所知，计算机以二进制形式处理，因此：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
...
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因此，如果我有一个位图，其值&#96;5&#96;可以容纳换句话说的0和2位，则可以给每个数字起一个名称，并检查它们是否对应于一个值。</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br></pre></td></tr></table></figure>
A = 1,  001
B = 2,  010
C = 4,  100
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">那么，如果我&#96;MYVAR &#x3D; 5&#96;是&#96;101&#96;二进制，这将检查：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
MYVAR &amp; A == TRUE   (101 &amp; 001 =&gt; 001)
MYVAR &amp; B == FALSE  (101 &amp; 010 =&gt; 000)
MYVAR &amp; C == TRUE   (101 &amp; 100 =&gt; 100 )
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因此我的变量*有* A和C。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">内核使用更复杂的方式，并通过偏移量设置位。原因之一是使用了一台计算机（CPU）整数中的更多位数。例如看&#96;KEY&#96;位图。</span><br><span class="line"></span><br><span class="line">因此，如果我们说：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
A = 0
B = 1
C = 6
...
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接着</span><br><span class="line"></span><br></pre></td></tr></table></figure>
target = 0;
set_bit(A, target);  =&gt; target ==      0001
set_bit(C, target);  =&gt; target == 0100 0001
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">## 解码 &#96;120013&#96;</span><br><span class="line"></span><br><span class="line">取值&#96;120013&#96;为十六进制。作为二进制，它给我们：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
0x120013 == 0001 0010 0000 0000 0001 0011 binary
             1    2    0    0    1    3
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">从右到右编号为：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 2            1               &lt;= offset (10&apos;s)
3210 9876 5432 1098 7654 3210   &lt;= offset (counted from right)
0001 0010 0000 0000 0001 0011   &lt;= binary
</code></pre></li>
</ul>
<p>Set bits are:<br>   0, 1, 4, 17, 20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后检查[&#96;input.h&#96;](http:&#x2F;&#x2F;www.cs.fsu.edu&#x2F;~baker&#x2F;devices&#x2F;lxr&#x2F;http&#x2F;source&#x2F;linux&#x2F;include&#x2F;linux&#x2F;input.h?v&#x3D;2.6.11.8#L80)您是否发现它们对应于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   0  EV_SYN (0x00)<br>   1  EV_KEY (0x01)<br>   4  EV_MSC (0x04)<br>  17  EV_LED (0x11)<br>  20  EV_REP (0x14)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">要检查它们的含义，[内核文档](https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;input&#x2F;event-codes.txt)提供了快速介绍。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>EV_SYN:</p>
<ul>
<li>Used as markers to separate events. Events may be separated in time or in<br>space, such as with the multitouch protocol.</li>
</ul>
</li>
<li><p>EV_KEY:</p>
<ul>
<li>Used to describe state changes of keyboards, buttons, or other key-like<br>devices.</li>
</ul>
</li>
<li><p>EV_MSC:</p>
<ul>
<li>Used to describe miscellaneous input data that do not fit into other types.</li>
</ul>
</li>
<li><p>EV_LED:</p>
<ul>
<li>Used to turn LEDs on devices on and off.</li>
</ul>
</li>
<li><p>EV_REP:</p>
<ul>
<li>Used for autorepeating devices.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 编写应用程序</span><br><span class="line"></span><br><span class="line">这是一个Atmel_maXTouch_Touchscreen应用测试程序 </span><br></pre></td></tr></table></figure>
#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;sys/time.h&gt;<br>#include &lt;linux/input.h&gt;<br>#include &lt;sys/time.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;</li>
</ul>
</li>
</ul>
</blockquote>
<p>#define DEV  “/dev/input/event1”<br>#define SIZE 16</p>
<p>int main()<br>{<br>    int fd = -1;<br>    int Size = 0;<br>    unsigned int i;<br>    int retval;<br>    fd_set rfds;<br>    struct input_event event_stack[SIZE];</p>
<pre><code>fd = open(DEV, O_RDONLY | O_NONBLOCK);
if(fd &lt; 0)
{
    printf(&quot;open fail\n&quot;);
    return -1;
}
while(1)
{
    FD_ZERO(&amp;rfds);
    FD_SET(fd, &amp;rfds);
    retval = select(fd + 1, &amp;rfds, NULL, NULL, NULL);

    if (retval == -1){
        continue;
    }else if (retval){

    }else
        continue;
    Size = read(fd, event_stack, sizeof(event_stack));
    if(Size &gt;= 0)
    {
        for(i = 0; i &lt; Size/sizeof(event_stack[0]); i++)
            printf(&quot;type = %d\n  code = %d\n  value = %d\n&quot;,
             event_stack[i].type,
             event_stack[i].code,
             event_stack[i].value);
    }
    else
    {
        printf(&quot;Size %d\n&quot;,Size);
    }
}
close(fd);
return 0;</code></pre><p>}</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 应用层模拟键盘和鼠标</title>
    <url>/2020/07/28/Linux/Driver/Input/Linux%20%E5%BA%94%E7%94%A8%E5%B1%82%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E5%92%8C%E9%BC%A0%E6%A0%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>利用Linux做一些产品，有时候需要应用程序向系统发送一些键盘的值来替代手动敲键盘。因此，应用程序如何实现向系统发送键盘和鼠标的值？有三种方法可以解决这个问题。方法如下：</p>
<ol>
<li>因为Linux使用input子系统管理鼠标和键盘，所以执行cat /proc/bus/input/devices，找出鼠标和键盘的属于哪个事件，然后调用open()和 write()。</li>
<li>有时候，鼠标和键盘都没有，第一种方法就行不通。使用uinput module就可以解决没有鼠标和键盘仍然可以发送键盘和鼠标事件。</li>
<li>模仿uinput模块，自己编写input的字符驱动设备，然后在该字符设备基础上，把键盘值发送给系统。</li>
</ol>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="键盘CTRL-SPACE实现"><a href="#键盘CTRL-SPACE实现" class="headerlink" title="键盘CTRL+SPACE实现"></a>键盘CTRL+SPACE实现</h3><p>方法1–直接使用键盘input事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int SimulateKey(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct input_event event;</span><br><span class="line">    int fd &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(&quot;&#x2F;dev&#x2F;input&#x2F;event3&quot;, O_RDWR);</span><br><span class="line">    if(fd &lt;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;&#x2F;dev&#x2F;input&#x2F;event3 fail\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;先发送一个CTRL按下事件</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.value &#x3D; 1;</span><br><span class="line">    event.code &#x3D; KEY_LEFTCTRL;</span><br><span class="line">    gettimeofday(&amp;event.time,NULL);</span><br><span class="line">    write(fd,&amp;event,sizeof(event)) ;</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;然后发送一个SPACE按下事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    gettimeofday(&amp;event.time, NULL);</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.code &#x3D; KEY_SPACE;</span><br><span class="line">    event.value &#x3D; 1;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送一个释放SPACE事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    gettimeofday(&amp;event.time, NULL);</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.code &#x3D; KEY_SPACE;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送释放CTRL事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    event.code &#x3D; KEY_LEFTCTRL;</span><br><span class="line">    gettimeofday(&amp;event.time,NULL);</span><br><span class="line">    write(fd,&amp;event,sizeof(event)) ;</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2–使用uinput模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SimulateKey(int fd)</span><br><span class="line">&#123;</span><br><span class="line">    struct input_event event;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;先发送一个CTRL按下事件</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.value &#x3D; 1;</span><br><span class="line">    event.code &#x3D; KEY_LEFTCTRL;</span><br><span class="line">    gettimeofday(&amp;event.time,NULL);</span><br><span class="line">    write(fd,&amp;event,sizeof(event)) ;</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;然后发送一个SPACE按下事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    gettimeofday(&amp;event.time, NULL);</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.code &#x3D; KEY_SPACE;</span><br><span class="line">    event.value &#x3D; 1;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送一个释放SPACE事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    gettimeofday(&amp;event.time, NULL);</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.code &#x3D; KEY_SPACE;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">    &#x2F;&#x2F;发送释放CTRL事件</span><br><span class="line">    memset(&amp;event, 0, sizeof(event));</span><br><span class="line">    event.type &#x3D; EV_KEY;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    event.code &#x3D; KEY_LEFTCTRL;</span><br><span class="line">    gettimeofday(&amp;event.time,NULL);</span><br><span class="line">    write(fd,&amp;event,sizeof(event)) ;</span><br><span class="line">    &#x2F;&#x2F;发送同步事件</span><br><span class="line">    event.type &#x3D; EV_SYN;</span><br><span class="line">    event.code &#x3D; SYN_REPORT;</span><br><span class="line">    event.value &#x3D; 0;</span><br><span class="line">    write(fd, &amp;event, sizeof(event));</span><br><span class="line">&#125;</span><br><span class="line">void emit(int fd, int type, int code, int val)</span><br><span class="line">&#123;</span><br><span class="line">   struct input_event ie;</span><br><span class="line"></span><br><span class="line">   ie.type &#x3D; type;</span><br><span class="line">   ie.code &#x3D; code;</span><br><span class="line">   ie.value &#x3D; val;</span><br><span class="line">   &#x2F;* timestamp values below are ignored *&#x2F;</span><br><span class="line">   ie.time.tv_sec &#x3D; 0;</span><br><span class="line">   ie.time.tv_usec &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   write(fd, &amp;ie, sizeof(ie));</span><br><span class="line">&#125;</span><br><span class="line">struct input_event event &#x3D; &#123;0&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   struct uinput_setup usetup;</span><br><span class="line"></span><br><span class="line">   int fd &#x3D; open(&quot;&#x2F;dev&#x2F;uinput&quot;, O_WRONLY | O_NONBLOCK);</span><br><span class="line">	int i&#x3D;5;</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * The ioctls below will enable the device that is about to be</span><br><span class="line">    * created, to pass key events, in this case the space key.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;这里必须设置一下EVBIT类型和KEYBIT类型。这里设置为键盘类型，创建KEY_SPACE和KEY_LEFTCTRL键盘值</span><br><span class="line">   ioctl(fd, UI_SET_EVBIT, EV_KEY);</span><br><span class="line">   ioctl(fd, UI_SET_KEYBIT, KEY_SPACE);</span><br><span class="line">   ioctl(fd, UI_SET_KEYBIT, KEY_LEFTCTRL);</span><br><span class="line"></span><br><span class="line">   memset(&amp;usetup, 0, sizeof(usetup));</span><br><span class="line">   usetup.id.bustype &#x3D; BUS_USB;</span><br><span class="line">   usetup.id.vendor &#x3D; 0x1234; &#x2F;* sample vendor *&#x2F;</span><br><span class="line">   usetup.id.product &#x3D; 0x5678; &#x2F;* sample product *&#x2F;</span><br><span class="line">   strcpy(usetup.name, &quot;Example device&quot;);</span><br><span class="line"></span><br><span class="line">   ioctl(fd, UI_DEV_SETUP, &amp;usetup);</span><br><span class="line">   ioctl(fd, UI_DEV_CREATE);</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * On UI_DEV_CREATE the kernel will create the device node for this</span><br><span class="line">    * device. We are inserting a pause here so that userspace has time</span><br><span class="line">    * to detect, initialize the new device, and can start listening to</span><br><span class="line">    * the event, otherwise it will not notice the event we are about</span><br><span class="line">    * to send. This pause is only needed in our example code!</span><br><span class="line">    *&#x2F;</span><br><span class="line">   sleep(1);</span><br><span class="line"></span><br><span class="line">   &#x2F;* Key press, report the event, send key release, and report again *&#x2F;</span><br><span class="line">  &#x2F;* emit(fd, EV_KEY, KEY_SPACE, 1);</span><br><span class="line">   emit(fd, EV_SYN, SYN_REPORT, 0);</span><br><span class="line">   emit(fd, EV_KEY, KEY_SPACE, 0);</span><br><span class="line">   emit(fd, EV_SYN, SYN_REPORT, 0);*&#x2F;</span><br><span class="line">   SimulateKey(fd);</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Give userspace some time to read the events before we destroy the</span><br><span class="line">    * device with UI_DEV_DESTOY.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   sleep(1);</span><br><span class="line"></span><br><span class="line">   ioctl(fd, UI_DEV_DESTROY);</span><br><span class="line">   close(fd);</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标实现"><a href="#鼠标实现" class="headerlink" title="鼠标实现"></a>鼠标实现</h3><p>略。</p>
<p>参考：</p>
<p><a href="https://www.kernel.org/doc/html/v4.12/input/uinput.html" target="_blank" rel="noopener">uinput module</a></p>
<p><a href="https://my.oschina.net/u/4382392/blog/3920785" target="_blank" rel="noopener">linux系统下，在用户空间应用程序中模拟发送系统键盘事件</a></p>
<p><a href="http://ghostbaby.github.io/blog/2013/08/19/linuxxia-ru-he-mo-ni-an-jian-shu-ru-he-mo-ni-shu-biao/" target="_blank" rel="noopener">Linux下如何模拟按键输入和模拟鼠标</a></p>
<p><a href="http://blog.chinaunix.net/uid-23381466-id-3883164.html" target="_blank" rel="noopener">driver: linux下如何模拟按键输入和模拟鼠标</a></p>
<p><a href="https://www.iteye.com/blog/sipgreen-1774676" target="_blank" rel="noopener">使用UInput模拟系统输入设备–键盘，鼠标，触摸屏</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>linux input子系统设计</title>
    <url>/2021/01/04/Linux/Driver/Input/linux%20input%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>输入子系统，用于管理各种输入设备，采用软件分层的思想，把一些通用的操作和经常需要更改的操作分开。通用的部分就是纯软件逻辑，不涉及硬件操作，而经常需要更改的部分就是配置硬件。因此通过输入子系统，让各种输入设备开发比较简单，不需重复编写通用的代码，只需要专注硬件的配置就可以了。那么，什么是输入设备？从IO角度看，与cpu的输入IO引脚连接的设备就是输入设备，比如按键；从广义角度，人机交互的设备就是输入设备，比如鼠标，键盘，触摸屏。关于Input Subsystem定义：</p>
<p>The input subsystem is the part of the Linux kernel that manages the various input devices (such as keyboards, mice, joysticks, tablets and a wide range of other devices) that a user uses to interact with the kernel, command line and graphical user interface. This subsystem is included in the kernel because these devices usually are accessed through special hardware interfaces (such as serial ports, PS/2 ports, Apple Desktop Bus and the Universal Serial Bus), which are protected and managed by the kernel. The kernel then exposes the user input in a consistent, device-independent way to user space through a range of defined APIs</p>
<p>Linux 输入子系统全景图如下：</p>
<p><img src="http://jiali.clouddn.com/20210104_002.png" alt=""></p>
<p>​                                                                                                                       Linux 输入子系统全景图</p>
<p>input core 为event handlers和drivers层提供实现的接口；event handlers 为用户空间与内核空间交互提供接口；drivers,实现各种输入设备的操作。</p>
<h2 id="Input-Subsystem软件层次分析"><a href="#Input-Subsystem软件层次分析" class="headerlink" title="Input Subsystem软件层次分析"></a>Input Subsystem软件层次分析</h2><p> input subsystem 软件层次分为 input core层、drivers层 和 event handlers层。它们之间的关系如下图。</p>
<p><img src="http://jiali.clouddn.com/20210104_001.png" alt=""></p>
<p>​                                                                                                   input subsystem 软件层次图</p>
<ul>
<li>input core：提供input subsystem所有的核心操作，由drivers/input/input.c文件定义。</li>
<li>drivers:操作各种输入设备，与设备交互，把设备数据传给event handlers。</li>
<li>event handlers:定义应用层与内核交互的接口，并把收到的设备数据传给应用层。</li>
</ul>
<h2 id="Input-Subsystem设计"><a href="#Input-Subsystem设计" class="headerlink" title="Input Subsystem设计"></a>Input Subsystem设计</h2><p>1、主要数据结构</p>
<p><img src="http://jiali.clouddn.com/20210104_003.png" alt=""></p>
<p>​                                                                                                             表 输入子系统主要数据结构</p>
<p>数据链表如下：</p>
<p><img src="http://jiali.clouddn.com/20210107_001.png" alt=""></p>
<p>​                                                                                                      图 数据链表关系</p>
<p>2、软件设计</p>
<p>软件方案设计如下图</p>
<p><img src="http://jiali.clouddn.com/20210104_004.png" alt=""></p>
<p>​                                                                                                         图 软件方案设计</p>
<p>3、intput 子系统实现</p>
<p>input子系统实现如下图</p>
<p><img src="http://jiali.clouddn.com/20210105_001.png" alt=""></p>
<p>​                                                                                                              图 input 子系统实现</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>主要分析input.c 、evdev.c、触摸屏驱动atmel_mxt_ts.c这三个代表文件，理解input子系统如何工作。</p>
<h3 id="1、Linux-input-子系统目录层次"><a href="#1、Linux-input-子系统目录层次" class="headerlink" title="1、Linux input 子系统目录层次"></a>1、Linux input 子系统目录层次</h3><p>Linux input 子系统目录如下：</p>
<p><img src="http://jiali.clouddn.com/20210106_001.png" alt=""></p>
<p>input顶层目录包含各种event handlers(比如mousedev.c \evdev.c\joydev.c)和input core（input.c）,子目录就是输入设备驱动文件。</p>
<h3 id="2、主要数据结构关系"><a href="#2、主要数据结构关系" class="headerlink" title="2、主要数据结构关系"></a>2、主要数据结构关系</h3><p>（1）表示输入设备的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *phys;</span><br><span class="line">	const char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line"></span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	unsigned int hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">	unsigned int keycodemax;</span><br><span class="line">	unsigned int keycodesize;</span><br><span class="line">	void *keycode;</span><br><span class="line"></span><br><span class="line">	int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  const struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned int *old_keycode);</span><br><span class="line">	int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line"></span><br><span class="line">	struct ff_device *ff;</span><br><span class="line"></span><br><span class="line">	unsigned int repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line"></span><br><span class="line">	int rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">	struct input_mt_slot *mt;</span><br><span class="line">	int mtsize;</span><br><span class="line">	int slot;</span><br><span class="line">	int trkid;</span><br><span class="line"></span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line"></span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	int (*open)(struct input_dev *dev);</span><br><span class="line">	void (*close)(struct input_dev *dev);</span><br><span class="line">	int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br><span class="line"></span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line"></span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	unsigned int users;</span><br><span class="line">	bool going_away;</span><br><span class="line"></span><br><span class="line">	bool sync;</span><br><span class="line"></span><br><span class="line">	struct device dev;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）、表示evdev事件处理的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handler - implements one of interfaces for input devices</span><br><span class="line"> * @private: driver-specific data</span><br><span class="line"> * @event: event handler. This method is being called by input core with</span><br><span class="line"> *	interrupts disabled and dev-&gt;event_lock spinlock held and so</span><br><span class="line"> *	it may not sleep</span><br><span class="line"> * @filter: similar to @event; separates normal event handlers from</span><br><span class="line"> *	&quot;filters&quot;.</span><br><span class="line"> * @match: called after comparing device&#39;s id with handler&#39;s id_table</span><br><span class="line"> *	to perform fine-grained matching between device and handler</span><br><span class="line"> * @connect: called when attaching a handler to an input device</span><br><span class="line"> * @disconnect: disconnects a handler from input device</span><br><span class="line"> * @start: starts handler for given handle. This function is called by</span><br><span class="line"> *	input core right after connect() method and also when a process</span><br><span class="line"> *	that &quot;grabbed&quot; a device releases it</span><br><span class="line"> * @fops: file operations this driver implements</span><br><span class="line"> * @minor: beginning of range of 32 minors for devices this driver</span><br><span class="line"> *	can provide</span><br><span class="line"> * @name: name of the handler, to be shown in &#x2F;proc&#x2F;bus&#x2F;input&#x2F;handlers</span><br><span class="line"> * @id_table: pointer to a table of input_device_ids this driver can</span><br><span class="line"> *	handle</span><br><span class="line"> * @h_list: list of input handles associated with the handler</span><br><span class="line"> * @node: for placing the driver onto input_handler_list</span><br><span class="line"> *</span><br><span class="line"> * Input handlers attach to input devices and create input handles. There</span><br><span class="line"> * are likely several handlers attached to any given input device at the</span><br><span class="line"> * same time. All of them will get their copy of input event generated by</span><br><span class="line"> * the device.</span><br><span class="line"> *</span><br><span class="line"> * The very same structure is used to implement input filters. Input core</span><br><span class="line"> * allows filters to run first and will not pass event to regular handlers</span><br><span class="line"> * if any of the filters indicate that the event should be filtered (by</span><br><span class="line"> * returning %true from their filter() method).</span><br><span class="line"> *</span><br><span class="line"> * Note that input core serializes calls to connect() and disconnect()</span><br><span class="line"> * methods.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">	bool (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">	int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">	void (*disconnect)(struct input_handle *handle);</span><br><span class="line">	void (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">	const struct file_operations *fops;</span><br><span class="line">	int minor;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	const struct input_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）连接输入设备和event handler对象的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handle - links input device with an input handler</span><br><span class="line"> * @private: handler-specific data</span><br><span class="line"> * @open: counter showing whether the handle is &#39;open&#39;, i.e. should deliver</span><br><span class="line"> *	events from its device</span><br><span class="line"> * @name: name given to the handle by handler that created it</span><br><span class="line"> * @dev: input device the handle is attached to</span><br><span class="line"> * @handler: handler that works with the device through this handle</span><br><span class="line"> * @d_node: used to put the handle on device&#39;s list of attached handles</span><br><span class="line"> * @h_node: used to put the handle on handler&#39;s list of handles from which</span><br><span class="line"> *	it gets events</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	int open;</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	struct input_dev *dev;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line"></span><br><span class="line">	struct list_head	d_node;</span><br><span class="line">	struct list_head	h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、input子系统的类"><a href="#3、input子系统的类" class="headerlink" title="3、input子系统的类"></a>3、input子系统的类</h3><p>根据数据结构的关系，总结出input子系统的类，如下</p>
<p><img src="http://jiali.clouddn.com/20210107_002.png" alt=""></p>
<p>​                                                                                                                   图 input子系统的类</p>
<h3 id="4、主要函数分析"><a href="#4、主要函数分析" class="headerlink" title="4、主要函数分析"></a>4、主要函数分析</h3><p>结合触摸屏、evdev  handler和input core 分析input 代码流程</p>
<p>首先初始化input 子系统,文件为drivers/input/input.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	err &#x3D; class_register(&amp;input_class);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register input_dev class\n&quot;);</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err &#x3D; input_proc_init();</span><br><span class="line">	if (err)</span><br><span class="line">		goto fail1;</span><br><span class="line"></span><br><span class="line">	err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		pr_err(&quot;unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">		goto fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> fail2:	input_proc_exit();</span><br><span class="line"> fail1:	class_unregister(&amp;input_class);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit input_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_proc_exit();</span><br><span class="line">	unregister_chrdev(INPUT_MAJOR, &quot;input&quot;);</span><br><span class="line">	class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);</span><br><span class="line">module_exit(input_exit);</span><br></pre></td></tr></table></figure>

<p>其次，注册evdev handler</p>
<p>文件在drivers/input/evdev.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit evdev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，注册dev 驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_device - register device with input core</span><br><span class="line"> * @dev: device to be registered</span><br><span class="line"> *</span><br><span class="line"> * This function registers device with input core. The device must be</span><br><span class="line"> * allocated with input_allocate_device() and all it&#39;s capabilities</span><br><span class="line"> * set up before registering.</span><br><span class="line"> * If function fails the device must be freed with input_free_device().</span><br><span class="line"> * Once device has been successfully registered it can be unregistered</span><br><span class="line"> * with input_unregister_device(); input_free_device() should not be</span><br><span class="line"> * called in this case.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">	static atomic_t input_no &#x3D; ATOMIC_INIT(0);</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	const char *path;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Every input device generates EV_SYN&#x2F;SYN_REPORT events. *&#x2F;</span><br><span class="line">	__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* KEY_RESERVED is not supposed to be transmitted to userspace. *&#x2F;</span><br><span class="line">	__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. *&#x2F;</span><br><span class="line">	input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;hint_events_per_packet)</span><br><span class="line">		dev-&gt;hint_events_per_packet &#x3D;</span><br><span class="line">				input_estimate_events_per_packet(dev);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If delay and period are pre-set by the driver, then autorepeating</span><br><span class="line">	 * is handled by the driver itself and we don&#39;t do it in input.c.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	init_timer(&amp;dev-&gt;timer);</span><br><span class="line">	if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">		dev-&gt;timer.data &#x3D; (long) dev;</span><br><span class="line">		dev-&gt;timer.function &#x3D; input_repeat_key;</span><br><span class="line">		dev-&gt;rep[REP_DELAY] &#x3D; 250;</span><br><span class="line">		dev-&gt;rep[REP_PERIOD] &#x3D; 33;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;getkeycode)</span><br><span class="line">		dev-&gt;getkeycode &#x3D; input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;setkeycode)</span><br><span class="line">		dev-&gt;setkeycode &#x3D; input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,</span><br><span class="line">		     (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;dev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">	pr_info(&quot;%s as %s\n&quot;,</span><br><span class="line">		dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;,</span><br><span class="line">		path ? path : &quot;N&#x2F;A&quot;);</span><br><span class="line">	kfree(path);</span><br><span class="line"></span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		device_del(&amp;dev-&gt;dev);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">	input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>evdev handler 和dev注册都会判断evdev handler和dev 匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">	const struct input_device_id *id;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	id &#x3D; input_match_device(handler, dev);</span><br><span class="line">	if (!id)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	error &#x3D; handler-&gt;connect(handler, dev, id);</span><br><span class="line">	if (error &amp;&amp; error !&#x3D; -ENODEV)</span><br><span class="line">		pr_err(&quot;failed to attach handler %s to device %s, error: %d\n&quot;,</span><br><span class="line">		       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配成功后，调用 evdev handler 的connect函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Create new evdev device. Note that input core serializes calls</span><br><span class="line"> * to connect and disconnect so we don&#39;t need to lock evdev_table here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line">			 const struct input_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev *evdev;</span><br><span class="line">	int minor;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)</span><br><span class="line">		if (!evdev_table[minor])</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">	if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;</span><br><span class="line">		pr_err(&quot;no more free evdev devices\n&quot;);</span><br><span class="line">		return -ENFILE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);</span><br><span class="line">	if (!evdev)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">	spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">	mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">	init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);</span><br><span class="line">	evdev-&gt;exist &#x3D; true;</span><br><span class="line">	evdev-&gt;minor &#x3D; minor;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">	evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">	evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">	evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line"></span><br><span class="line">	evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);</span><br><span class="line">	evdev-&gt;dev.class &#x3D; &amp;input_class;</span><br><span class="line">	evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;</span><br><span class="line">	evdev-&gt;dev.release &#x3D; evdev_free;</span><br><span class="line">	device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_evdev;</span><br><span class="line"></span><br><span class="line">	error &#x3D; evdev_install_chrdev(evdev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_unregister_handle;</span><br><span class="line"></span><br><span class="line">	error &#x3D; device_add(&amp;evdev-&gt;dev);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">	evdev_cleanup(evdev);</span><br><span class="line"> err_unregister_handle:</span><br><span class="line">	input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line"> err_free_evdev:</span><br><span class="line">	put_device(&amp;evdev-&gt;dev);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在connect函数调用input_register_handle函数注册handle。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * input_register_handle - register a new input handle</span><br><span class="line"> * @handle: handle to register</span><br><span class="line"> *</span><br><span class="line"> * This function puts a new input handle onto device&#39;s</span><br><span class="line"> * and handler&#39;s lists so that events can flow through</span><br><span class="line"> * it once it is opened using input_open_device().</span><br><span class="line"> *</span><br><span class="line"> * This function is supposed to be called from handler&#39;s</span><br><span class="line"> * connect() method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int input_register_handle(struct input_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_handler *handler &#x3D; handle-&gt;handler;</span><br><span class="line">	struct input_dev *dev &#x3D; handle-&gt;dev;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * We take dev-&gt;mutex here to prevent race with</span><br><span class="line">	 * input_release_device().</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	error &#x3D; mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Filters go to the head of the list, normal handlers</span><br><span class="line">	 * to the tail.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (handler-&gt;filter)</span><br><span class="line">		list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">	else</span><br><span class="line">		list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Since we are supposed to be called from -&gt;connect()</span><br><span class="line">	 * which is mutually exclusive with -&gt;disconnect()</span><br><span class="line">	 * we can&#39;t be racing with input_unregister_handle()</span><br><span class="line">	 * and so separate lock is not needed here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">	if (handler-&gt;start)</span><br><span class="line">		handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码分析完毕，后面看看应用层如何与input 子系统交互。</p>
<h2 id="应用层与内核input子系统交互"><a href="#应用层与内核input子系统交互" class="headerlink" title="应用层与内核input子系统交互"></a>应用层与内核input子系统交互</h2><p>应用层与设备交互，通过 Linux一套接口实现，就是open 、read 、write函数。这些函数最终会调用input 子系统的evdev handler 的fops的open、read和write。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">#ifdef CONFIG_MACH_ADVANTECH</span><br><span class="line">	.match &#x3D; evdev_match,  &#x2F;* Added by EETI*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.fops		&#x3D; &amp;evdev_fops,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>evdev_fops定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct file_operations evdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.read		&#x3D; evdev_read,</span><br><span class="line">	.write		&#x3D; evdev_write,</span><br><span class="line">	.poll		&#x3D; evdev_poll,</span><br><span class="line">	.open		&#x3D; evdev_open,</span><br><span class="line">	.release	&#x3D; evdev_release,</span><br><span class="line">	.unlocked_ioctl	&#x3D; evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl	&#x3D; evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">	.fasync		&#x3D; evdev_fasync,</span><br><span class="line">	.flush		&#x3D; evdev_flush,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看一下evdev_read</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *buffer,</span><br><span class="line">			  size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev_client *client &#x3D; file-&gt;private_data;</span><br><span class="line">	struct evdev *evdev &#x3D; client-&gt;evdev;</span><br><span class="line">	struct input_event event;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	if (count &lt; input_event_size())</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (client-&gt;packet_head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp;</span><br><span class="line">	    (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">		client-&gt;packet_head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line"></span><br><span class="line">	if (!evdev-&gt;exist)</span><br><span class="line">		return -ENODEV;</span><br><span class="line"></span><br><span class="line">	while (retval + input_event_size() &lt;&#x3D; count &amp;&amp;</span><br><span class="line">	       evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">		if (input_event_to_user(buffer + retval, &amp;event))</span><br><span class="line">			return -EFAULT;</span><br><span class="line"></span><br><span class="line">		retval +&#x3D; input_event_size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，可以看出input 子系统简化了输入设备的驱动程序开发。这边设备驱动专注设备的配置和交互，不用重新编写与应用层交互的代码。设备驱动遵循下面的流程：</p>
<blockquote>
<p>1、input_allocate_device() 给input_dev分配空间</p>
<p>2、设置input_dev对象，设置事件类型、code</p>
<p>3、硬件初始化，中断初始化，定义中断处理程序</p>
<p>4、通过 input_register_device() 注册 </p>
<p>5、定义中断处理程序，上报事件并同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、上报事件</span><br><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_switch(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">2、同步</span><br><span class="line">void input_sync(struct input_dev *dev)</span><br></pre></td></tr></table></figure>


</blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/lcw/p/3293302.html" target="_blank" rel="noopener">input子系统全面分析</a></p>
<p><a href="https://www.linuxjournal.com/article/6396" target="_blank" rel="noopener">The Linux USB Input Subsystem, Part I</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>Atmel的mXT2952T2触摸屏驱动开发</title>
    <url>/2021/01/05/Linux/Driver/Input/Atmel%E7%9A%84mXT2952T2%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文总结使用input core 编写mxt2952t2触摸屏芯片驱动。先提几个问题如下：</p>
<p>1、mxt2952驱动，如何上报坐标轴的数据给event handlers？</p>
<p>2、输入设备产生的数据，用什么来描述？</p>
<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><p>配置Linux内核支持input子系统，event handlers和设备驱动。</p>
<p>1、配置input 支持的event handlers </p>
<p>配置支持event handlers 如下图所示</p>
<p><img src="http://jiali.clouddn.com/20210105_002.png" alt=""></p>
<p>​                                                                                                                  图 input支持的event handlers</p>
<p>2、配置触摸屏驱动</p>
<p>配置支持 Atmel mxt 驱动如下图所示</p>
<p><img src="http://jiali.clouddn.com/20210105_003.png" alt=""></p>
<p>​                                                                                                                         图配置Atmel mxt驱动</p>
<h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><p>描述一个设备对象的结构体定义在include/linux/input.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_dev - represents an input device</span><br><span class="line"> * @name: name of the device</span><br><span class="line"> * @phys: physical path to the device in the system hierarchy</span><br><span class="line"> * @uniq: unique identification code for the device (if device has it)</span><br><span class="line"> * @id: id of the device (struct input_id)</span><br><span class="line"> * @propbit: bitmap of device properties and quirks</span><br><span class="line"> * @evbit: bitmap of types of events supported by the device (EV_KEY,</span><br><span class="line"> *	EV_REL, etc.)</span><br><span class="line"> * @keybit: bitmap of keys&#x2F;buttons this device has</span><br><span class="line"> * @relbit: bitmap of relative axes for the device</span><br><span class="line"> * @absbit: bitmap of absolute axes for the device</span><br><span class="line"> * @mscbit: bitmap of miscellaneous events supported by the device</span><br><span class="line"> * @ledbit: bitmap of leds present on the device</span><br><span class="line"> * @sndbit: bitmap of sound effects supported by the device</span><br><span class="line"> * @ffbit: bitmap of force feedback effects supported by the device</span><br><span class="line"> * @swbit: bitmap of switches present on the device</span><br><span class="line"> * @hint_events_per_packet: average number of events generated by the</span><br><span class="line"> *	device in a packet (between EV_SYN&#x2F;SYN_REPORT events). Used by</span><br><span class="line"> *	event handlers to estimate size of the buffer needed to hold</span><br><span class="line"> *	events.</span><br><span class="line"> * @keycodemax: size of keycode table</span><br><span class="line"> * @keycodesize: size of elements in keycode table</span><br><span class="line"> * @keycode: map of scancodes to keycodes for this device</span><br><span class="line"> * @getkeycode: optional legacy method to retrieve current keymap.</span><br><span class="line"> * @setkeycode: optional method to alter current keymap, used to implement</span><br><span class="line"> *	sparse keymaps. If not supplied default mechanism will be used.</span><br><span class="line"> *	The method is being called while holding event_lock and thus must</span><br><span class="line"> *	not sleep</span><br><span class="line"> * @ff: force feedback structure associated with the device if device</span><br><span class="line"> *	supports force feedback effects</span><br><span class="line"> * @repeat_key: stores key code of the last key pressed; used to implement</span><br><span class="line"> *	software autorepeat</span><br><span class="line"> * @timer: timer for software autorepeat</span><br><span class="line"> * @rep: current values for autorepeat parameters (delay, rate)</span><br><span class="line"> * @mt: pointer to array of struct input_mt_slot holding current values</span><br><span class="line"> *	of tracked contacts</span><br><span class="line"> * @mtsize: number of MT slots the device uses</span><br><span class="line"> * @slot: MT slot currently being transmitted</span><br><span class="line"> * @trkid: stores MT tracking ID for the current contact</span><br><span class="line"> * @absinfo: array of &amp;struct input_absinfo elements holding information</span><br><span class="line"> *	about absolute axes (current value, min, max, flat, fuzz,</span><br><span class="line"> *	resolution)</span><br><span class="line"> * @key: reflects current state of device&#39;s keys&#x2F;buttons</span><br><span class="line"> * @led: reflects current state of device&#39;s LEDs</span><br><span class="line"> * @snd: reflects current state of sound effects</span><br><span class="line"> * @sw: reflects current state of device&#39;s switches</span><br><span class="line"> * @open: this method is called when the very first user calls</span><br><span class="line"> *	input_open_device(). The driver must prepare the device</span><br><span class="line"> *	to start generating events (start polling thread,</span><br><span class="line"> *	request an IRQ, submit URB, etc.)</span><br><span class="line"> * @close: this method is called when the very last user calls</span><br><span class="line"> *	input_close_device().</span><br><span class="line"> * @flush: purges the device. Most commonly used to get rid of force</span><br><span class="line"> *	feedback effects loaded into the device when disconnecting</span><br><span class="line"> *	from it</span><br><span class="line"> * @event: event handler for events sent _to_ the device, like EV_LED</span><br><span class="line"> *	or EV_SND. The device is expected to carry out the requested</span><br><span class="line"> *	action (turn on a LED, play sound, etc.) The call is protected</span><br><span class="line"> *	by @event_lock and must not sleep</span><br><span class="line"> * @grab: input handle that currently has the device grabbed (via</span><br><span class="line"> *	EVIOCGRAB ioctl). When a handle grabs a device it becomes sole</span><br><span class="line"> *	recipient for all input events coming from the device</span><br><span class="line"> * @event_lock: this spinlock is is taken when input core receives</span><br><span class="line"> *	and processes a new event for the device (in input_event()).</span><br><span class="line"> *	Code that accesses and&#x2F;or modifies parameters of a device</span><br><span class="line"> *	(such as keymap or absmin, absmax, absfuzz, etc.) after device</span><br><span class="line"> *	has been registered with input core must take this lock.</span><br><span class="line"> * @mutex: serializes calls to open(), close() and flush() methods</span><br><span class="line"> * @users: stores number of users (input handlers) that opened this</span><br><span class="line"> *	device. It is used by input_open_device() and input_close_device()</span><br><span class="line"> *	to make sure that dev-&gt;open() is only called when the first</span><br><span class="line"> *	user opens device and dev-&gt;close() is called when the very</span><br><span class="line"> *	last user closes the device</span><br><span class="line"> * @going_away: marks devices that are in a middle of unregistering and</span><br><span class="line"> *	causes input_open_device*() fail with -ENODEV.</span><br><span class="line"> * @sync: set to %true when there were no new events since last EV_SYN</span><br><span class="line"> * @dev: driver model&#39;s view of this device</span><br><span class="line"> * @h_list: list of input handles associated with the device. When</span><br><span class="line"> *	accessing the list dev-&gt;mutex must be held</span><br><span class="line"> * @node: used to place the device onto input_dev_list</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_dev &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *phys;</span><br><span class="line">	const char *uniq;</span><br><span class="line">	struct input_id id;</span><br><span class="line"></span><br><span class="line">	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">       &#x2F;&#x2F;EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件</span><br><span class="line">       &#x2F;&#x2F;EV_KEY       键盘事件</span><br><span class="line">       &#x2F;&#x2F;EV_REL       (relative)相对坐标事件，比如鼠标</span><br><span class="line">       &#x2F;&#x2F;EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应</span><br><span class="line">       &#x2F;&#x2F;EV_MSC      其他事件,功能</span><br><span class="line">       &#x2F;&#x2F;EV_LED       LED灯事件</span><br><span class="line">       &#x2F;&#x2F;EV_SND      (sound)声音事件</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_REP       重复键盘按键事件</span><br><span class="line">       &#x2F;&#x2F;(内部会定义一个定时器,若有键盘按键事件一直按下&#x2F;松开,就重复定时,时间一到就上报事件)   </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_FF         受力事件</span><br><span class="line">       &#x2F;&#x2F;EV_PWR      电源事件</span><br><span class="line">       &#x2F;&#x2F;EV_FF_STATUS  受力状态事件</span><br><span class="line">	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];   &#x2F;&#x2F;输入事件类型</span><br><span class="line">	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F;定义按键类型中的code,比如L、H键</span><br><span class="line">	unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;&#x2F;存放支持的相对坐标值</span><br><span class="line">	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; &#x2F;&#x2F;存放支持的绝对坐标值</span><br><span class="line">	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; &#x2F;&#x2F;存放支持的其它事件,也就是功能</span><br><span class="line">	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; &#x2F;&#x2F;存放支持的各种状态LED</span><br><span class="line">	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; &#x2F;&#x2F;存放支持的各种声音</span><br><span class="line">	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];   &#x2F;&#x2F;存放支持的受力设备</span><br><span class="line">	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];  &#x2F;&#x2F;存放支持的开关功能</span><br><span class="line"></span><br><span class="line">	unsigned int hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">	unsigned int keycodemax;</span><br><span class="line">	unsigned int keycodesize;</span><br><span class="line">	void *keycode;</span><br><span class="line"></span><br><span class="line">	int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">			  const struct input_keymap_entry *ke,</span><br><span class="line">			  unsigned int *old_keycode);</span><br><span class="line">	int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">			  struct input_keymap_entry *ke);</span><br><span class="line"></span><br><span class="line">	struct ff_device *ff;</span><br><span class="line"></span><br><span class="line">	unsigned int repeat_key;</span><br><span class="line">	struct timer_list timer;</span><br><span class="line"></span><br><span class="line">	int rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">	struct input_mt_slot *mt;</span><br><span class="line">	int mtsize;</span><br><span class="line">	int slot;</span><br><span class="line">	int trkid;</span><br><span class="line"></span><br><span class="line">	struct input_absinfo *absinfo;</span><br><span class="line"></span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F;映射设备当前按键的状态</span><br><span class="line">	unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">	unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">	unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">	int (*open)(struct input_dev *dev);</span><br><span class="line">	void (*close)(struct input_dev *dev);</span><br><span class="line">	int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br><span class="line"></span><br><span class="line">	struct input_handle __rcu *grab;</span><br><span class="line"></span><br><span class="line">	spinlock_t event_lock;</span><br><span class="line">	struct mutex mutex;</span><br><span class="line"></span><br><span class="line">	unsigned int users;</span><br><span class="line">	bool going_away;</span><br><span class="line"></span><br><span class="line">	bool sync;</span><br><span class="line"></span><br><span class="line">	struct device dev;</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list;</span><br><span class="line">	struct list_head	node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><blockquote>
<p>1、给struct input_dev对象分配一块内存</p>
<p>​      struct input_dev *input_allocate_device(void)</p>
<p>2、填充struct input_dev对象</p>
<p>比如，设置事件类型、事件类型的code</p>
<pre><code>set_bit(EV_ABS, input_dev-&gt;evbit);
input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
/* For single touch */
input_set_abs_params(input_dev, ABS_X, 0, data-&gt;max_x, 0, 0);
input_set_abs_params(input_dev, ABS_Y, 0, data-&gt;max_y, 0, 0);
input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);</code></pre><p>3、注册input_dev设备</p>
<p>int input_register_device(struct input_dev *dev)</p>
<p>4、配置中断，定义中断处理函数</p>
<p>5、上报事件并同步</p>
<p>void input_report_abs(struct input_dev *dev, unsigned int code, int value)</p>
<p>void input_sync(struct input_dev *dev)</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>mXT2952T2驱动位于drivers/input/touchscreen/atmel_mxt_ts.c</p>
<p>1、注册i2c 总线驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);</span><br><span class="line"></span><br><span class="line">static const struct of_device_id mxt_of_match[] &#x3D; &#123;</span><br><span class="line">	&#123; .compatible &#x3D; &quot;atmel,maxtouch&quot;, &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, mxt_of_match);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ACPI</span><br><span class="line">static const struct acpi_device_id mxt_acpi_id[] &#x3D; &#123;</span><br><span class="line">	&#123; &quot;ATML0000&quot;, 0 &#125;,	&#x2F;* Touchpad *&#x2F;</span><br><span class="line">	&#123; &quot;ATML0001&quot;, 0 &#125;,	&#x2F;* Touchscreen *&#x2F;</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(acpi, mxt_acpi_id);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const struct i2c_device_id mxt_id[] &#x3D; &#123;</span><br><span class="line">	&#123; &quot;qt602240_ts&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;atmel_mxt_ts&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;atmel_mxt_tp&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;maxtouch&quot;, 0 &#125;,</span><br><span class="line">	&#123; &quot;mXT224&quot;, 0 &#125;,</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(i2c, mxt_id);</span><br><span class="line"></span><br><span class="line">static struct i2c_driver mxt_driver &#x3D; &#123;</span><br><span class="line">	.driver &#x3D; &#123;</span><br><span class="line">		.name	&#x3D; &quot;atmel_mxt_ts&quot;,</span><br><span class="line">		.owner	&#x3D; THIS_MODULE,</span><br><span class="line">&#x2F;&#x2F;		.of_match_table &#x3D; of_match_ptr(mxt_of_match),</span><br><span class="line">&#x2F;&#x2F;		.acpi_match_table &#x3D; ACPI_PTR(mxt_acpi_id),</span><br><span class="line">		.pm	&#x3D; &amp;mxt_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe		&#x3D; mxt_probe,</span><br><span class="line">	.remove		&#x3D; mxt_remove,</span><br><span class="line">	.id_table	&#x3D; mxt_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init mxt_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	return i2c_add_driver(&amp;mxt_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mxt_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_del_driver(&amp;mxt_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mxt_init);</span><br><span class="line">module_exit(mxt_exit);</span><br><span class="line">&#x2F;* Module information *&#x2F;</span><br><span class="line">MODULE_AUTHOR(&quot;Joonyoung Shim &lt;jy0922.shim@samsung.com&gt;&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Atmel maXTouch Touchscreen driver&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p>2、编写probe函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mxt_data *data;</span><br><span class="line">	const struct mxt_platform_data *pdata;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	pdata &#x3D; mxt_get_platform_data(client);</span><br><span class="line">	if (IS_ERR(pdata))</span><br><span class="line">		return PTR_ERR(pdata);</span><br><span class="line"></span><br><span class="line">	data &#x3D; kzalloc(sizeof(struct mxt_data), GFP_KERNEL);</span><br><span class="line">	if (!data)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	snprintf(data-&gt;phys, sizeof(data-&gt;phys), &quot;i2c-%u-%04x&#x2F;input0&quot;,</span><br><span class="line">		 client-&gt;adapter-&gt;nr, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	data-&gt;client &#x3D; client;</span><br><span class="line"></span><br><span class="line">	data-&gt;pdata &#x3D; pdata;</span><br><span class="line">	i2c_set_clientdata(client, data);</span><br><span class="line"></span><br><span class="line">	if (data-&gt;pdata-&gt;cfg_name)</span><br><span class="line">		mxt_update_file_name(&amp;data-&gt;client-&gt;dev,</span><br><span class="line">				     &amp;data-&gt;cfg_name,</span><br><span class="line">				     data-&gt;pdata-&gt;cfg_name,</span><br><span class="line">				     strlen(data-&gt;pdata-&gt;cfg_name));</span><br><span class="line"></span><br><span class="line">	init_completion(&amp;data-&gt;chg_completion);</span><br><span class="line">	init_completion(&amp;data-&gt;reset_completion);</span><br><span class="line">	init_completion(&amp;data-&gt;crc_completion);</span><br><span class="line">	mutex_init(&amp;data-&gt;debug_msg_lock);</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;suspend_mode &#x3D;&#x3D; MXT_SUSPEND_REGULATOR) &#123;</span><br><span class="line">		error &#x3D; mxt_acquire_irq(data);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_mem;</span><br><span class="line"></span><br><span class="line">		error &#x3D; mxt_probe_regulators(data);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_irq;</span><br><span class="line"></span><br><span class="line">		disable_irq(data-&gt;irq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; sysfs_create_group(&amp;client-&gt;dev.kobj, &amp;mxt_fw_attr_group);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		dev_err(&amp;client-&gt;dev, &quot;Failure %d creating fw sysfs group\n&quot;,</span><br><span class="line">			error);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_initialize(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_irq;</span><br><span class="line"></span><br><span class="line">	setup_timer(&amp;data-&gt;timer, mxt_heartbeat_timer, (unsigned long)data);</span><br><span class="line">	data-&gt;timer.expires &#x3D; jiffies + msecs_to_jiffies(3 * 1000);</span><br><span class="line">	add_timer(&amp;data-&gt;timer);</span><br><span class="line"></span><br><span class="line">	INIT_WORK(&amp;data-&gt;reset_task, mxt_heartbeat_reset_task);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_irq:</span><br><span class="line">	if (data-&gt;irq)</span><br><span class="line">		free_irq(data-&gt;irq, data);</span><br><span class="line">err_free_mem:</span><br><span class="line">	kfree(data);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mxt_initialize函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int mxt_initialize(struct mxt_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client *client &#x3D; data-&gt;client;</span><br><span class="line">	int recovery_attempts &#x3D; 0;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		error &#x3D; mxt_read_info_block(data);</span><br><span class="line">		if (!error)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Check bootloader state *&#x2F;</span><br><span class="line">		error &#x3D; mxt_probe_bootloader(data, false);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			dev_info(&amp;client-&gt;dev, &quot;Trying alternate bootloader address\n&quot;);</span><br><span class="line">			error &#x3D; mxt_probe_bootloader(data, true);</span><br><span class="line">			if (error) &#123;</span><br><span class="line">				&#x2F;* Chip is not in appmode or bootloader mode *&#x2F;</span><br><span class="line">				return error;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;* OK, we are in bootloader, see if we can recover *&#x2F;</span><br><span class="line">		if (++recovery_attempts &gt; 1) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev, &quot;Could not recover from bootloader mode\n&quot;);</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * We can reflash from this state, so do not</span><br><span class="line">			 * abort initialization.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			data-&gt;in_bootloader &#x3D; true;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Attempt to exit bootloader into app mode *&#x2F;</span><br><span class="line">		mxt_send_bootloader_cmd(data, false);</span><br><span class="line">		msleep(MXT_FW_RESET_TIME);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_check_retrigen(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_acquire_irq(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_sysfs_init(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	error &#x3D; mxt_debug_msg_init(data);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free_object_table;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;cfg_name) &#123;</span><br><span class="line">		error &#x3D; request_firmware_nowait(THIS_MODULE, true,</span><br><span class="line">					data-&gt;cfg_name, &amp;data-&gt;client-&gt;dev,</span><br><span class="line">					GFP_KERNEL, data, mxt_config_cb);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev, &quot;Failed to invoke firmware loader: %d\n&quot;,</span><br><span class="line">				error);</span><br><span class="line">			goto err_free_object_table;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		error &#x3D; mxt_configure_objects(data, NULL);</span><br><span class="line">		if (error)</span><br><span class="line">			goto err_free_object_table;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_object_table:</span><br><span class="line">	mxt_free_object_table(data);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mxt_configure_objects(data, NULL)</p>
<p>  –mxt_initialize_input_device（）//注册input_dev</p>
<p>-mxt_initialize_input_device函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int mxt_initialize_input_device(struct mxt_data *data)</span><br><span class="line">&#123;</span><br><span class="line">	const struct mxt_platform_data *pdata &#x3D; data-&gt;pdata;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	struct input_dev *input_dev;</span><br><span class="line">	int error;</span><br><span class="line">	unsigned int num_mt_slots;</span><br><span class="line">	unsigned int mt_flags &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	switch (data-&gt;multitouch) &#123;</span><br><span class="line">	case MXT_TOUCH_MULTI_T9:</span><br><span class="line">		num_mt_slots &#x3D; data-&gt;T9_reportid_max - data-&gt;T9_reportid_min + 1;</span><br><span class="line">		error &#x3D; mxt_read_t9_resolution(data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to initialize T9 resolution\n&quot;);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case MXT_TOUCH_MULTITOUCHSCREEN_T100:</span><br><span class="line">		num_mt_slots &#x3D; data-&gt;num_touchids;</span><br><span class="line">		error &#x3D; mxt_read_t100_config(data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to read T100 config\n&quot;);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		dev_err(dev, &quot;Invalid multitouch object\n&quot;);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Handle default values and orientation switch *&#x2F;</span><br><span class="line">	if (data-&gt;max_x &#x3D;&#x3D; 0)</span><br><span class="line">		data-&gt;max_x &#x3D; 1023;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;max_y &#x3D;&#x3D; 0)</span><br><span class="line">		data-&gt;max_y &#x3D; 1023;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;xy_switch)</span><br><span class="line">		swap(data-&gt;max_x, data-&gt;max_y);</span><br><span class="line"></span><br><span class="line">	printk( &quot;Touchscreen size X%uY%u\n&quot;, data-&gt;max_x, data-&gt;max_y);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Register input device *&#x2F;</span><br><span class="line">	input_dev &#x3D; input_allocate_device();</span><br><span class="line">	if (!input_dev)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;pdata-&gt;input_name)</span><br><span class="line">		input_dev-&gt;name &#x3D; data-&gt;pdata-&gt;input_name;</span><br><span class="line">	else</span><br><span class="line">		input_dev-&gt;name &#x3D; &quot;Atmel_maXTouch_Touchscreen&quot;;</span><br><span class="line"></span><br><span class="line">	input_dev-&gt;phys &#x3D; data-&gt;phys;</span><br><span class="line">	input_dev-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">	input_dev-&gt;dev.parent &#x3D; dev;</span><br><span class="line">	input_dev-&gt;open &#x3D; mxt_input_open;</span><br><span class="line">	input_dev-&gt;close &#x3D; mxt_input_close;</span><br><span class="line"></span><br><span class="line">	set_bit(EV_ABS, input_dev-&gt;evbit);</span><br><span class="line">	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);</span><br><span class="line"></span><br><span class="line">	&#x2F;* For single touch *&#x2F;</span><br><span class="line">	input_set_abs_params(input_dev, ABS_X, 0, data-&gt;max_x, 0, 0);</span><br><span class="line">	input_set_abs_params(input_dev, ABS_Y, 0, data-&gt;max_y, 0, 0);</span><br><span class="line">	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* For T107 Active Stylus *&#x2F;</span><br><span class="line">	if (data-&gt;multitouch &#x3D;&#x3D; MXT_TOUCH_MULTITOUCHSCREEN_T100 &amp;&amp;</span><br><span class="line">	    data-&gt;T107_address) &#123;</span><br><span class="line">		error &#x3D; mxt_set_up_active_stylus(input_dev, data);</span><br><span class="line">		if (error)</span><br><span class="line">			dev_warn(dev, &quot;Failed to read T107 config\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* For T15 Key Array *&#x2F;</span><br><span class="line">	if (data-&gt;T15_reportid_min) &#123;</span><br><span class="line">		data-&gt;t15_keystatus &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (i &#x3D; 0; i &lt; data-&gt;pdata-&gt;t15_num_keys; i++)</span><br><span class="line">			input_set_capability(input_dev, EV_KEY,</span><br><span class="line">					data-&gt;pdata-&gt;t15_keymap[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_set_drvdata(input_dev, data);</span><br><span class="line"></span><br><span class="line">	error &#x3D; input_register_device(input_dev);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		dev_err(dev, &quot;Error %d registering input device\n&quot;, error);</span><br><span class="line">		goto err_free_mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;input_dev &#x3D; input_dev;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_free_mem:</span><br><span class="line">	input_free_device(input_dev);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写中断函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static irqreturn_t mxt_interrupt(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mxt_data *data &#x3D; dev_id;</span><br><span class="line"></span><br><span class="line">	complete(&amp;data-&gt;chg_completion);</span><br><span class="line"></span><br><span class="line">	if (data-&gt;in_bootloader) &#123;</span><br><span class="line">		if (data-&gt;flash &amp;&amp; &amp;data-&gt;flash-&gt;work)</span><br><span class="line">			cancel_delayed_work_sync(&amp;data-&gt;flash-&gt;work);</span><br><span class="line"></span><br><span class="line">		return IRQ_RETVAL(mxt_check_bootloader(data));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!data-&gt;object_table)</span><br><span class="line">		return IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">	if (data-&gt;T44_address) &#123;</span><br><span class="line">		return mxt_process_messages_t44(data);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return mxt_process_messages(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断函数处理过程</p>
<p> mxt_process_messages_t44</p>
<p>   –&gt;mxt_proc_message</p>
<p>​          –&gt;mxt_proc_t100_message //上报事件</p>
<p>看看mxt_proc_t100_message实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	struct input_dev *input_dev &#x3D; data-&gt;input_dev;</span><br><span class="line">	int id;</span><br><span class="line">	u8 status;</span><br><span class="line">	u8 type &#x3D; 0;</span><br><span class="line">	u16 x;</span><br><span class="line">	u16 y;</span><br><span class="line">	int distance &#x3D; 0;</span><br><span class="line">	int tool &#x3D; 0;</span><br><span class="line">	u8 major &#x3D; 0;</span><br><span class="line">	u8 pressure &#x3D; 0;</span><br><span class="line">	u8 orientation &#x3D; 0;</span><br><span class="line">	bool active &#x3D; false;</span><br><span class="line">	bool hover &#x3D; false;</span><br><span class="line"></span><br><span class="line">	id &#x3D; message[0] - data-&gt;T100_reportid_min - 2;</span><br><span class="line"></span><br><span class="line">	&#x2F;* ignore SCRSTATUS events *&#x2F;</span><br><span class="line">	if (id &lt; 0)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	status &#x3D; message[1];</span><br><span class="line">	x &#x3D; get_unaligned_le16(&amp;message[2]);</span><br><span class="line">	y &#x3D; get_unaligned_le16(&amp;message[4]);</span><br><span class="line"></span><br><span class="line">	if (status &amp; MXT_T100_DETECT) &#123;</span><br><span class="line">		type &#x3D; (status &amp; MXT_T100_TYPE_MASK) &gt;&gt; 4;</span><br><span class="line"></span><br><span class="line">		switch (type) &#123;</span><br><span class="line">		case MXT_T100_TYPE_HOVERING_FINGER:</span><br><span class="line">			tool &#x3D; MT_TOOL_FINGER;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_HOVERING;</span><br><span class="line">			hover &#x3D; true;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_FINGER:</span><br><span class="line">		case MXT_T100_TYPE_GLOVE:</span><br><span class="line">			tool &#x3D; MT_TOOL_FINGER;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			hover &#x3D; false;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_area)</span><br><span class="line">				major &#x3D; message[data-&gt;t100_aux_area];</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_ampl)</span><br><span class="line">				pressure &#x3D; message[data-&gt;t100_aux_ampl];</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_vect)</span><br><span class="line">				orientation &#x3D; message[data-&gt;t100_aux_vect];</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_PASSIVE_STYLUS:</span><br><span class="line">			tool &#x3D; MT_TOOL_PEN;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			hover &#x3D; false;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line"></span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * Passive stylus is reported with size zero so</span><br><span class="line">			 * hardcode.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			major &#x3D; MXT_TOUCH_MAJOR_DEFAULT;</span><br><span class="line"></span><br><span class="line">			if (data-&gt;t100_aux_ampl)</span><br><span class="line">				pressure &#x3D; message[data-&gt;t100_aux_ampl];</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_ACTIVE_STYLUS:</span><br><span class="line">			&#x2F;* Report input buttons *&#x2F;</span><br><span class="line">			input_report_key(input_dev, BTN_STYLUS,</span><br><span class="line">					 message[6] &amp; MXT_T107_STYLUS_BUTTON0);</span><br><span class="line">			input_report_key(input_dev, BTN_STYLUS2,</span><br><span class="line">					 message[6] &amp; MXT_T107_STYLUS_BUTTON1);</span><br><span class="line"></span><br><span class="line">			&#x2F;* stylus in range, but position unavailable *&#x2F;</span><br><span class="line">			if (!(message[6] &amp; MXT_T107_STYLUS_HOVER))</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			tool &#x3D; MT_TOOL_PEN;</span><br><span class="line">			distance &#x3D; MXT_DISTANCE_ACTIVE_TOUCH;</span><br><span class="line">			active &#x3D; true;</span><br><span class="line">			major &#x3D; MXT_TOUCH_MAJOR_DEFAULT;</span><br><span class="line"></span><br><span class="line">			if (!(message[6] &amp; MXT_T107_STYLUS_TIPSWITCH)) &#123;</span><br><span class="line">				hover &#x3D; true;</span><br><span class="line">				distance &#x3D; MXT_DISTANCE_HOVERING;</span><br><span class="line">			&#125; else if (data-&gt;stylus_aux_pressure) &#123;</span><br><span class="line">				pressure &#x3D; message[data-&gt;stylus_aux_pressure];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case MXT_T100_TYPE_LARGE_TOUCH:</span><br><span class="line">			&#x2F;* Ignore suppressed touch *&#x2F;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		default:</span><br><span class="line">			dev_dbg(dev, &quot;Unexpected T100 type\n&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Values reported should be non-zero if tool is touching the</span><br><span class="line">	 * device</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!pressure &amp;&amp; !hover)</span><br><span class="line">		pressure &#x3D; MXT_PRESSURE_DEFAULT;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;input_mt_slot(input_dev, id);</span><br><span class="line"></span><br><span class="line">	if (active) &#123;</span><br><span class="line">&#x2F;&#x2F;		printk( &quot;[%u] type:%u x:%u y:%u a:%02X p:%02X v:%02X\n&quot;,</span><br><span class="line">&#x2F;&#x2F;			id, type, x, y, major, pressure, orientation);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;		input_mt_report_slot_state(input_dev, tool, 1);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_POSITION_X, x);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_POSITION_Y, y);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, major);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_PRESSURE, pressure);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_DISTANCE, distance);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_MT_ORIENTATION, orientation);</span><br><span class="line"></span><br><span class="line">		input_report_abs(input_dev, ABS_X, x);</span><br><span class="line">		input_report_abs(input_dev, ABS_Y, y);</span><br><span class="line">		input_report_key(input_dev, BTN_TOUCH, 1);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_PRESSURE, 1);</span><br><span class="line">		input_sync(input_dev);</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;		printk( &quot;[%u] release\n&quot;, id);</span><br><span class="line"></span><br><span class="line">		&#x2F;* close out slot *&#x2F;</span><br><span class="line">&#x2F;&#x2F;		input_mt_report_slot_state(input_dev, 0, 0);</span><br><span class="line">		input_report_key(input_dev, BTN_TOUCH, 0);</span><br><span class="line">&#x2F;&#x2F;		input_report_abs(input_dev, ABS_PRESSURE, 0);</span><br><span class="line">		input_sync(input_dev);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;update_input &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # hexdump &#x2F;dev&#x2F;input&#x2F;event1</span><br><span class="line">0000000 45b4 386d 6bb2 000d 0003 0000 02e6 0000</span><br><span class="line">0000010 45b4 386d 6bb6 000d 0003 0001 01a5 0000</span><br><span class="line">0000020 45b4 386d 6bb9 000d 0001 014a 0001 0000</span><br><span class="line">0000030 45b4 386d 6bbb 000d 0000 0000 0000 0000</span><br><span class="line">0000040 45b4 386d 41ff 000e 0001 014a 0000 0000</span><br><span class="line">0000050 45b4 386d 4202 000e 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexdump &#x2F;dev&#x2F;event1</span><br><span class="line"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     # input_report_abs(ts.dev, ABS_X, ts.xp);</span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     # input_report_abs(ts.dev, ABS_Y, ts.yp);</span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     # input_report_abs(ts.dev, ABS_PRESSURE, 1);</span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     # input_report_key(ts.dev, BTN_TOUCH, 1);</span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     # input_sync(ts.dev);</span><br></pre></td></tr></table></figure>

<h2 id="q-amp-s"><a href="#q-amp-s" class="headerlink" title="q&amp;s"></a>q&amp;s</h2><p>1、mxt2952驱动，如何上报坐标轴的数据给event handlers？</p>
<p>驱动初始化中先设置设备的事件类型和code，触摸屏要设置坐标范围，然后就可以通过void input_report_abs(struct input_dev *dev, unsigned int code, int value)函数上报数据</p>
<p>2、输入设备产生的数据，用什么来描述？</p>
<p>设备产生的数据，经过event handlers 封装成struct input_event对象，然后递交给应用层。struct input_event结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_event &#123;</span><br><span class="line">	struct timeval time;</span><br><span class="line">	__u16 type;</span><br><span class="line">	__u16 code;</span><br><span class="line">	__s32 value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、如何事件类型、code和value关系</p>
<p>事件类型就是指各种输入设备，比如鼠标，键盘，触摸屏等</p>
<p>code就是对事件类型在划分一个层次，比如键盘事件类型，键盘有很多按键，比如H、L 、U,这些按键就是code。</p>
<p>value就是code的值</p>
<p>4、如何理解设置事件类型的函数</p>
<p>先看一下内核关于bit操作的宏定义在include/linux/bitops.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define BIT(nr)			(1UL &lt;&lt; (nr)) &#x2F;&#x2F;UL中的第几bit</span><br><span class="line">#define BIT_MASK(nr)		(1UL &lt;&lt; ((nr) % BITS_PER_LONG))</span><br><span class="line">#define BIT_WORD(nr)		((nr) &#x2F; BITS_PER_LONG) 表示bit在第几个long</span><br><span class="line">#define BITS_PER_BYTE		8</span><br><span class="line">#define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long)) &#x2F;&#x2F;根据占用long的bit的数量，计算数组的长度</span><br></pre></td></tr></table></figure>

<p>在include/linux/kernel.h定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) &#x2F; (d))</span><br></pre></td></tr></table></figure>

<p>在看input_dev结构体中如何表示一组事件类型和code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line">unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br></pre></td></tr></table></figure>

<p>从上面看出，用一个unsigned long 中的bit表示事件类型和code,用数组存储事件类型和code，数组的大小根据占用了多少bit来计算。</p>
<p>因此，设置事件类型可以使用下面的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dev-&gt;keybit[BIT_WORD(BTN_TOUCH)] &#x3D; BIT(BTN_TOUCH);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_bit(EV_ABS, input_dev-&gt;evbit);</span><br></pre></td></tr></table></figure>

<p>5、为什么要设置事件类型和code？</p>
<p>首先，上报事件函数根据具体的事件类型和code,判断input core 是否支持该类型和code，如果支持，才做下一步上报数据的操作。看一个按键上报函数实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有上报事件函数，都会直接调用input_event()函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void input_event(struct input_dev *dev,</span><br><span class="line">		 unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">		spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">		add_input_randomness(type, code, value);</span><br><span class="line">		input_handle_event(dev, type, code, value);</span><br><span class="line">		spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void input_handle_event(struct input_dev *dev,</span><br><span class="line">			       unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	int disposition &#x3D; INPUT_IGNORE_EVENT;</span><br><span class="line"></span><br><span class="line">	switch (type) &#123;</span><br><span class="line"></span><br><span class="line">	case EV_SYN:</span><br><span class="line">		switch (code) &#123;</span><br><span class="line">		case SYN_CONFIG:</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		case SYN_REPORT:</span><br><span class="line">			if (!dev-&gt;sync) &#123;</span><br><span class="line">				dev-&gt;sync &#x3D; true;</span><br><span class="line">				disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		case SYN_MT_REPORT:</span><br><span class="line">			dev-&gt;sync &#x3D; false;</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_KEY:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;keybit, KEY_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;key) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			if (value !&#x3D; 2) &#123;</span><br><span class="line">				__change_bit(code, dev-&gt;key);</span><br><span class="line">				if (value)</span><br><span class="line">					input_start_autorepeat(dev, code);</span><br><span class="line">				else</span><br><span class="line">					input_stop_autorepeat(dev);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_SW:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;sw) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;sw);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_ABS:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;absbit, ABS_MAX))</span><br><span class="line">			disposition &#x3D; input_handle_abs_event(dev, code, &amp;value);</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_REL:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_HANDLERS;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_MSC:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line"></span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_LED:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;</span><br><span class="line">		    !!test_bit(code, dev-&gt;led) !&#x3D; value) &#123;</span><br><span class="line"></span><br><span class="line">			__change_bit(code, dev-&gt;led);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_SND:</span><br><span class="line">		if (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">			if (!!test_bit(code, dev-&gt;snd) !&#x3D; !!value)</span><br><span class="line">				__change_bit(code, dev-&gt;snd);</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_REP:</span><br><span class="line">		if (code &lt;&#x3D; REP_MAX &amp;&amp; value &gt;&#x3D; 0 &amp;&amp; dev-&gt;rep[code] !&#x3D; value) &#123;</span><br><span class="line">			dev-&gt;rep[code] &#x3D; value;</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_FF:</span><br><span class="line">		if (value &gt;&#x3D; 0)</span><br><span class="line">			disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case EV_PWR:</span><br><span class="line">		disposition &#x3D; INPUT_PASS_TO_ALL;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (disposition !&#x3D; INPUT_IGNORE_EVENT &amp;&amp; type !&#x3D; EV_SYN)</span><br><span class="line">		dev-&gt;sync &#x3D; false;</span><br><span class="line"></span><br><span class="line">	if ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">		dev-&gt;event(dev, type, code, value);</span><br><span class="line"></span><br><span class="line">	if (disposition &amp; INPUT_PASS_TO_HANDLERS)</span><br><span class="line">		input_pass_event(dev, type, code, value); &#x2F;&#x2F;类型和code符合，上报事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Pass event first through all filters and then, if event has not been</span><br><span class="line"> * filtered out, through all open handles. This function is called with</span><br><span class="line"> * dev-&gt;event_lock held and interrupts disabled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void input_pass_event(struct input_dev *dev,</span><br><span class="line">			     unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct input_handler *handler;</span><br><span class="line">	struct input_handle *handle;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	handle &#x3D; rcu_dereference(dev-&gt;grab);</span><br><span class="line">	if (handle)</span><br><span class="line">		handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用event handler的event函数</span><br><span class="line">	else &#123;</span><br><span class="line">		bool filtered &#x3D; false;</span><br><span class="line"></span><br><span class="line">		list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) &#123;</span><br><span class="line">			if (!handle-&gt;open)</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			handler &#x3D; handle-&gt;handler;</span><br><span class="line">			if (!handler-&gt;filter) &#123;</span><br><span class="line">				if (filtered)</span><br><span class="line">					break;</span><br><span class="line"></span><br><span class="line">				handler-&gt;event(handle, type, code, value);</span><br><span class="line"></span><br><span class="line">			&#125; else if (handler-&gt;filter(handle, type, code, value))</span><br><span class="line">				filtered &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、为什么上报事件后，一定需要同步？</p>
<p>上报事件，实际上驱动把数据递交给event handlers ,然后event handlers 存在一个Buffer,需要同步，才把Buffer的数据递交给应用层。</p>
<p>驱动程序上报事件，本质是调用handlers的event事件处理函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Pass incoming event to all connected clients.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void evdev_event(struct input_handle *handle,</span><br><span class="line">			unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">	struct evdev *evdev &#x3D; handle-&gt;private;</span><br><span class="line">	struct evdev_client *client;</span><br><span class="line">	struct input_event event;</span><br><span class="line"></span><br><span class="line">	do_gettimeofday(&amp;event.time);</span><br><span class="line">	event.type &#x3D; type;</span><br><span class="line">	event.code &#x3D; code;</span><br><span class="line">	event.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	client &#x3D; rcu_dereference(evdev-&gt;grab);</span><br><span class="line">	if (client)</span><br><span class="line">		evdev_pass_event(client, &amp;event);</span><br><span class="line">	else</span><br><span class="line">		list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">			evdev_pass_event(client, &amp;event); &#x2F;&#x2F;把event事件存储起来</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	if (type &#x3D;&#x3D; EV_SYN &amp;&amp; code &#x3D;&#x3D; SYN_REPORT) &#x2F;&#x2F;收到同步信号，就唤醒read去去读buffer</span><br><span class="line">		wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>evdev_pass_event()函数把event事件存储在buffer里面，函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void evdev_pass_event(struct evdev_client *client,</span><br><span class="line">			     struct input_event *event)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Interrupts are disabled, just acquire the lock. *&#x2F;</span><br><span class="line">	spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">	client-&gt;buffer[client-&gt;head++] &#x3D; *event;</span><br><span class="line">	client-&gt;head &amp;&#x3D; client-&gt;bufsize - 1;</span><br><span class="line"></span><br><span class="line">	if (unlikely(client-&gt;head &#x3D;&#x3D; client-&gt;tail)) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * This effectively &quot;drops&quot; all unconsumed events, leaving</span><br><span class="line">		 * EV_SYN&#x2F;SYN_DROPPED plus the newest event in the queue.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		client-&gt;tail &#x3D; (client-&gt;head - 2) &amp; (client-&gt;bufsize - 1);</span><br><span class="line"></span><br><span class="line">		client-&gt;buffer[client-&gt;tail].time &#x3D; event-&gt;time;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].type &#x3D; EV_SYN;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].code &#x3D; SYN_DROPPED;</span><br><span class="line">		client-&gt;buffer[client-&gt;tail].value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		client-&gt;packet_head &#x3D; client-&gt;tail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (event-&gt;type &#x3D;&#x3D; EV_SYN &amp;&amp; event-&gt;code &#x3D;&#x3D; SYN_REPORT) &#123;</span><br><span class="line">		client-&gt;packet_head &#x3D; client-&gt;head;</span><br><span class="line">		kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>PCIe总线基础知识</title>
    <url>/2020/07/22/Linux/Driver/PCIe/PCIe%E6%80%BB%E7%BA%BF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PCIe,全称是PCI-Express（peripheral component interconnect express），这是一种高速串行计算机扩展总线标准。PCI总线使用并行总线结构，在同一条总线上的所有外部设备共享总线带宽，而PCIe总线使用高速串行差分总线，并采用端到端的连接方式，因此，在每一条PCIe链路中只能连接两个设备。两个设备之间的PCIe链路如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_001.png" alt=""></p>
<p>如果一条链路不够快，可以扩展多几个链路，犹如高速公路一样，车道越多，越少出现拥挤现象，开得越快。</p>
<p><img src="http://jiali.clouddn.com/20200722_002.png" alt=""></p>
<p>常见的PCIe插槽如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_007.png" alt=""></p>
<p>还有一些常见的PCIe设备如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_008.png" alt=""></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h3><p>PCIe链路使用端到端的数据传送，每一个端口都包含了发送端（TX）和接收端（RX），硬件接口如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_003.png" alt=""></p>
<p>从图可以看出，在PCIe总线物理链路的一条PCIe数据通路（Lane）中，发送端和接收端各自有一组差分信号D-和D+，共4根线。一条PCIe总线链路中可以由多个Lane组成。使用差分信号，抗干扰性更强，因此PCIe总线可以在很高频率下正常工作。</p>
<p>PCIe链路可以支持x1、x2、x4、x8、x12、x16和x32宽度的PCIe链路。频率和编码关系如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_004.png" alt=""></p>
<p>8/10b编码就是10bit中含有8bit有效数据，128/130b编码就是130bit含有128位有效数据。在PCIe总线中，使用GT(Gigatransfer)计算PCIe链路的峰值带宽。计算公式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总线频率*数据位宽*2</span><br></pre></td></tr></table></figure>

<h3 id="电气信号"><a href="#电气信号" class="headerlink" title="电气信号"></a>电气信号</h3><p>略。</p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>一个通用处理器的PCIe总线拓扑结构如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200723_002.png" alt=""></p>
<p>整个PCIe拓扑结构是一个树形结构，Root Complex（RC）是树的根。RC为CPU代言，与整个计算机系统其它部分通讯，比如CPU通过它访问内存，通过它访问PCIe系统中的设备。大多数PCIe总线结构中，都包含了RC 、Switch 、PCIe-to-PCI桥和Endpoint（PCIe设备）组件。</p>
<p>实际上，Root Complex,简称RC。RC设计比较复杂，一个虚拟的处理器系统的RC设计如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200723_003.png" alt=""></p>
<p><strong>RC组件</strong></p>
<p>在一个处理器系统PCIe总线中，都有一个RC控制器，主要完成地址转换，和物理信号转换。类似HOST主桥的角色。具体的RC设计，看具体的处理器系统。</p>
<p><strong>Switch</strong></p>
<p>因为一条PCIe链路使用端到端的连接方式，所以，只能连接一个设备。为了一条PCIe链路能挂载多个EP，因此，需要Switch器件进行扩展。一个标准的Switch具有一个上游端口和多个下游端口。Switch内部结构如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200723_004.png" alt=""></p>
<h2 id="PCIe总线分层结构"><a href="#PCIe总线分层结构" class="headerlink" title="PCIe总线分层结构"></a>PCIe总线分层结构</h2><p>PCIe总线采用串行硬件接口，并以数据包(Packet)格式进行数据传输。数据包需要通过事务层和数据链路层，最后达到物理层，发送出去。PCIe总线的分层如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_005.png" alt=""></p>
<p><strong>事务层</strong>的主要职责是创建（发送）或者解析（接收）TLP (Transaction Layer packet)，流量控制，QoS，事务排序等。</p>
<p><strong>数据链路层</strong>的主要职责是创建（发送）或者解析（接收）DLLP(Data Link Layer packet)，Ack/Nak协议（链路层检错和纠错），流控，电源管理等。</p>
<p><strong>物理层</strong>的主要职责是处理所有的Packet数据物理传输，发送端数据分发到各个Lane传输（stripe），接收端把各个Lane上的数据汇总起来（De-stripe），每个Lane上加扰（Scramble，目的是让0和1分布均匀，去除信道的电磁干扰EMI）去扰（De-scramble)，以及8/10或者128/130编码解码，等等。</p>
<p>每一层都会定义包头包尾的数据格式。如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_007.png" alt=""></p>
<p>CPU与设备端数据交互的过程如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_008.png" alt=""></p>
<h2 id="事务层的TLP协议"><a href="#事务层的TLP协议" class="headerlink" title="事务层的TLP协议"></a>事务层的TLP协议</h2><p>事务层将接收PCIe设备产生的数据请求，并封装成TLP协议。FPGA PCIe的开发工作，就是在PCIe核下封装TLP协议，其他层次基本看不到。因此，重点讲一下TLP协议。TLP的基本格式如下：</p>
<p><img src="http://jiali.clouddn.com/20200722_009.png" alt=""></p>
<p>TLP头是最重要的标志，TLP Head包含了当前TLP的总线事务类型、路由信息等一系列信息。Data Payload 表示有效数据，Data Payload 长度与Max_Payload_Size、Max_Read_Request_Size和RCB参数相关。</p>
<p><strong>TLP Head格式</strong></p>
<p>一个Header大小可以是3DW，也可以是4DW。以4DW的Header为例，TLP的Header长下面样子：</p>
<p><img src="http://jiali.clouddn.com/20200722_011.png" alt=""></p>
<p>红色区域为所有TLP Header公共部分，所有Header都有这些；其它则是跟具体的TLP相关。</p>
<p>注释：</p>
<p><strong>Fmt</strong>：Format, 表明该TLP是否带有数据，Header是3DW还是4DW；</p>
<p><strong>Type</strong>：TLP类型，上一节提到的，Memory Read, Memory Write, Configuration Read, Configuration Write, Message和Completion，等等；</p>
<p><strong>R：</strong> Reserved，为0；</p>
<p><strong>TC</strong>: Traffic Class，TLP也分三六九等，优先级高的先得到服务。这里是3比特，说明可以分为8个等级，0-7，TC默认是0，数字越大，优先级越高；</p>
<p><strong>Attr:</strong> Attrbiute, 属性，前后共三个bit，先不说；</p>
<p><strong>TH</strong>: TLP Processing Hints，先不说；</p>
<p><strong>TD</strong>: TLP Digest，之前说ECRC可选，如果这个这个bit置起来，说明该TLP包含ECRC，接收端应该做CRC校验；</p>
<p><strong>EP</strong>: Poisoned data, 有毒的数据，远离，哈哈；</p>
<p><strong>AT</strong>: Address Type，地址种类，先不说；</p>
<p><strong>Length</strong>： Payload数据长度，1~1024，单位DW（4byte），所以TLP最大数据长度是4KB; 该长度总是DW的整数倍，如果TLP的数据不是DW的整数倍（不是4Byte的整数倍），则需要用到两个域：Last DW BE 和 1st DW BE。</p>
<p><strong>存储器读写请求的TLP</strong></p>
<p>64位的处理器系统的存储器读写请求的TLP格式如下图</p>
<p><img src="http://jiali.clouddn.com/20200722_012.png" alt=""></p>
<p>32位的处理器系统的存储器读写请求的TLP格式如下图</p>
<p><img src="http://jiali.clouddn.com/20200722_013.png" alt=""></p>
<p>Requester ID字段包含了生成这个TLP报文的PCIe设备的总线号（Bus Number）、设备号（Device Number）和功能号（Function Number）。因此，Requester ID就是源地址，其格式如下：</p>
<p><img src="http://jiali.clouddn.com/20200722_014.png" alt=""></p>
<p>Address:目的地址。PCIe设备，进行DMA操作，往处理器的DDR读写数据时候，需要获取DDR的内存地址，来填充Address。</p>
<p><strong>注意：</strong></p>
<p>基于厂家FPGA 的PCIe开发，主要是做事务层开发工作，封装TLP，对TLP接收和发送进行处理。因此，熟悉事务层的存储器、I/O和配置读写请求TLP过程很重要。曾经，CPU写FPGA PCIe设备的BAR地址空间的某个寄存器，因为FPGA 不返回TLP，导致CPU卡住。</p>
<p><strong>Data Payload参数</strong> </p>
<p>Max_Payload_Size参数存放PCIe设备<strong>实际使用</strong>的TLP有效负载的最大值。<strong>该参数由PCIe链路两端的设备协商决定，是PCIe设备进行数据传送时，实际使用的参数</strong>。当PCIe设备发送数据报文时，设置Max_Payload_Size参数决定TLP的Data Payload 长度的最大值。</p>
<p>Max_Payload_Size_Supported参数表示一个PCIe设备中TLP有效负载的最大值，这是由PCIe设备的硬件逻辑决定，软件不能更改。</p>
<p>Max_Payload_Size和Max_Payload_Size_Supported分别在PCI Express Capability结构中的Device Capability和Device Control寄存器中定义。</p>
<p>Max_Payload_Size可以设置为128byte、256byte、512byte和1024byte.在FPGA实际应用中，需要配置Max_Payload_Size和<strong>TLP</strong>的Length字段。FPGA的Max_Payload_Size配置如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_010.png" alt=""></p>
<p><strong>注意：</strong></p>
<p>当PCIe设备接收TLP时，该TLP的最大有效负载不能超过Max_Payload_Size（就是Length字段不能超过Max_Payload_Size），如果Length字段超过Length字段，则接收TLP的PCIe设备认为TLP非法。因此一次TLP传输数据失败。曾经，FPGA进行DMA操作，往CPU系统的DDR写数据，因为一次性把很大的数据量填充到TLP中，所以导致，CPU收不到数据。</p>
<h2 id="PCIe设备的配置空间"><a href="#PCIe设备的配置空间" class="headerlink" title="PCIe设备的配置空间"></a>PCIe设备的配置空间</h2><p>0x00<del>0xff,这段地址空间共256byte，PCI\PCI-X\PCIe都包含了这256byte配置空间。大多数PCI设备仅支持0x00</del>0x3f，这64byte的配置空间。此外，0x40~0xff，这段配置空间，主要存放一些与MSI或者MSI-X中断管理和电源管理相关的Capability结构。大多数PCI设备不支持MSI\MSI-X中断，而PCIe设备必须支持MSI\MSI-X中断机制(<strong>大多是PCIe设备使用MSI中断</strong>)。</p>
<p>64byte的配置空间如下图：</p>
<p><img src="http://jiali.clouddn.com/20200721_004.png" alt=""></p>
<p>另外，PCIe设备支持0x100<del>0xfff这段扩展配置空间。因此PCIe设备的配置空间最大位4k。0x100</del>0xfff这段空间，存放PCIe设备所独有的一些Capability结构，PCI设备是不能使用这段空间（事实上，PCI设备仅支持0x00~0x3f这段配置空间）。</p>
<p>PCIe设备的配置空间如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200723_005.png" alt=""></p>
<p><strong>注意：</strong></p>
<p>在实际工程中，在FPGA PCIe核设置好BAR配置空间的大小，系统软件根据大小分配PCIe总线地址空间。FPGA配置如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_001.png" alt=""></p>
<h2 id="MSI中断机制"><a href="#MSI中断机制" class="headerlink" title="MSI中断机制"></a>MSI中断机制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在PCI总线中，所有需要提交的中断请求，必须通过INTx引脚向处理器提交中断请求；而在PCIe总线中，PCIe设备向处理器提交中断，是通过MSI机制实现，不需要通过INTx引脚。</p>
<p>MSI机制就是使用存储器写请求TLP向处理器提交中断请求。这种MSI消息，也简称为MSI报文。此外MSI中断最多支持32个中断。32位和64位的MSI 报文协议结构如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_002.png" alt=""></p>
<p><strong>Message Control:</strong> 该字段存放当前PCIe设备使用的MSI机制进行中断请求的状态与控制信息。</p>
<p><strong>Message Address:</strong> 该字段存放MSI存储器写事务的目的地址低32位。</p>
<p><strong>Message Upper Address:</strong> 该字段存放MSI存储器写事务的目的地址高32位。</p>
<p>重点关注Message Control字段含义，如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_003.png" alt=""></p>
<h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><p>FPGA PCIe MSI控制器配置寄存器地址，如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_004.png" alt=""></p>
<p>MSI Control Register，如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_005.png" alt=""></p>
<p>通过MSI控制寄存器可将MSI中断配置成多消息中断模式，中断个数可通过Multiple Message Enable 配置，只读字段Multiple Message Capable表示系统分配给PCIe设备的中断向量数量。</p>
<p><strong>注意：</strong></p>
<p>曾经FPGA没有配置字段Multiple Message Capable，因为该字段默认为0,所以，无论怎么配置Multiple Message Enable，MSI只产生1个中断（0号MSI中断）。</p>
<p>FPGA PCIe设备中，cfg_interrupt_msi_int MSI各中断寄存器如下表所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_006.png" alt=""></p>
<p>只要置位中断寄存器对应的Bit,就可以触发中断。例如，本次使用0，1，2号中断，在相应位置位就可以触发中断。</p>
<p>Linux MSI中断配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、申请四个中断</span><br><span class="line">pci_alloc_irq_vectors(pdev,1,4,PCI_IRQ_MSI);</span><br><span class="line">&#x2F;&#x2F;2、设置Multiple Message Enable字段为4</span><br><span class="line">control |&#x3D; 0x0020;</span><br><span class="line">pci_write_config_word(pdev,pdev-&gt;msi_cap+2,control);</span><br><span class="line">&#x2F;&#x2F;注册中断</span><br><span class="line">irq &#x3D; pci_irq_vector(pdev,0);</span><br><span class="line">err &#x3D; request_irq(irq, ps_pcie_intr_handler_no_msix, IRQF_SHARED, &quot;PCIE PS PCIe DMA Device&quot;, ptr_dma_desc_temp);</span><br><span class="line">irq &#x3D; pci_irq_vector(pdev,1);	</span><br><span class="line">err &#x3D; request_irq(irq, ps_pcie_intr_handler_no_msix_1, IRQF_SHARED, &quot;PCIE PS PCIe DMA Device_1&quot;, ptr_dma_desc_temp);</span><br><span class="line">irq &#x3D; pci_irq_vector(pdev,2);</span><br><span class="line">err &#x3D; request_irq(irq, ps_pcie_intr_handler_no_msix_2, IRQF_SHARED, &quot;PCIE PS PCIe DMA Device2&quot;, ptr_dma_desc_temp);</span><br><span class="line">&#x2F;&#x2F;编写中断函数</span><br><span class="line">略。。。</span><br></pre></td></tr></table></figure>









<p>参考：</p>
<p><a href="https://www.cnblogs.com/YINBin/p/10946247.html" target="_blank" rel="noopener">PCIe总线（协议简述）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26172972" target="_blank" rel="noopener">深入PCI与PCIe之一：硬件篇</a></p>
<p><a href="http://xilinx.eetrend.com/d6-xilinx/blog/2018-08/13327.html" target="_blank" rel="noopener">PCIe学习（一）：PCIe基础及生成PIO例程分析</a></p>
<p><a href="http://www.ssdfans.com/?p=8211" target="_blank" rel="noopener">老男孩读PCIe之一：从PCIe速度说起</a></p>
<p><a href="http://www.ssdfans.com/?p=8213" target="_blank" rel="noopener">老男孩读PCIe之二：PCIe拓扑结构</a></p>
<p><a href="http://www.ssdfans.com/?p=8214" target="_blank" rel="noopener">老男孩读PCIe之三：PCIe分层结构</a></p>
<p><a href="http://www.ssdfans.com/?p=8215" target="_blank" rel="noopener">老男孩读PCIe之四：TLP类型</a></p>
<p><a href="http://www.ssdfans.com/?p=8212" target="_blank" rel="noopener">老男孩读PCIe之五：TLP结构</a></p>
<p><a href="http://www.ssdfans.com/?p=8210" target="_blank" rel="noopener">老男孩读PCIe之六：配置和地址空间</a></p>
<p><a href="http://www.ssdfans.com/?p=8216" target="_blank" rel="noopener">老男孩读PCIe之七：TLP的路由</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>PCIe</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>PCIe MSI中断机制详解</title>
    <url>/2020/07/25/Linux/Driver/PCIe/PCIe%20MSI%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节重点讲MSI中断原理及Linux 驱动如何使用MSI中断。MSI机制跟处理器体系架构有关系，由于处理器公开的MSI机制资料有限，所以不讲解具体的处理器如何处理MSI中断。。</p>
<h2 id="MSI机制"><a href="#MSI机制" class="headerlink" title="MSI机制"></a>MSI机制</h2><p>1、什么是MSI？</p>
<p>CPU设计一个特殊的寄存器，往这个寄存器写数据，就会触发中断。PCIe设备就是利用memory写操作，往处理器发送TLP存储器写请求，TLP携带MSI报文信息，从而触发中断。</p>
<p>2、如何封装MSI TLP请求？</p>
<p>先看看MSI报文格式如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200724_002.png" alt=""></p>
<p>Message Address,就是这个寄存器的地址（触发MSI中断的寄存器）。</p>
<p>Message Data,就是往Message Address地址写的数据。</p>
<p>TLP格式如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200722_009.png" alt=""></p>
<p>64位系统的TLP Head格式如下图所示：</p>
<p><img src="http://jiali.clouddn.com/20200722_012.png" alt=""></p>
<p>PCIe设备封装TLP，Address字段存放Message Address;Data Payload字段存放Message Data。设置好TLP，然后向CPU发送存储器写请求，就可以触发MSI中断了。</p>
<p>查看配置空间如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~#lspci -xxx -s 03:00.0</span><br><span class="line">03:00.0 Memory controller: Xilinx Corporation Device 8034</span><br><span class="line">00: ee 10 34 80 02 04 10 00 00 00 80 05 10 00 00 00</span><br><span class="line">10: 00 00 00 dc 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 ee 10 07 00</span><br><span class="line">30: 00 00 00 00 80 00 00 00 00 00 00 00 0b 01 00 00</span><br><span class="line">40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">80: 01 90 03 00 08 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">90: 05 c0 a5 00 98 04 e0 fe 00 00 00 00 00 00 00 00</span><br><span class="line">a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">b0: 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">c0: 10 00 02 00 02 80 e8 07 30 28 00 00 43 f0 43 00</span><br><span class="line">d0: 40 00 43 10 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">e0: 00 00 00 00 12 00 00 00 00 00 00 00 0e 00 00 00</span><br><span class="line">f0: 03 00 1f 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>MSI的配置寄存器地址从0x90开始，分析0x90开始的16个byte</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90: 05 c0 a5 00 98 04 e0 fe 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>可以看出64位系统的Message Address地址为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000-0000-fee0-0498</span><br></pre></td></tr></table></figure>

<p>Message Data字段的值为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000-0000-0000-0000</span><br></pre></td></tr></table></figure>



<h2 id="ARM处理器如何处理MSI中断"><a href="#ARM处理器如何处理MSI中断" class="headerlink" title="ARM处理器如何处理MSI中断"></a>ARM处理器如何处理MSI中断</h2><p>略。</p>
<h2 id="linux-PCIe驱动中如何使用MSI中断"><a href="#linux-PCIe驱动中如何使用MSI中断" class="headerlink" title="linux PCIe驱动中如何使用MSI中断"></a>linux PCIe驱动中如何使用MSI中断</h2><p>参考：</p>
<p><a href="http://www.voidcn.com/article/p-gqxmmahv-ny.html" target="_blank" rel="noopener">MSI及MSIX详解</a></p>
<p><a href="https://blog.csdn.net/pwl999/article/details/78208151" target="_blank" rel="noopener">PCI&amp;PCIE MSI中断</a></p>
<p><a href="https://blog.csdn.net/JuanA1/article/details/6746011" target="_blank" rel="noopener">PCI-E配置MSI中断流程解析</a></p>
<p><a href="https://xbuba.com/questions/36790833" target="_blank" rel="noopener">MSI中断如何在linux驱动程序中工作</a></p>
<p><a href="https://www.cnblogs.com/TheGrandDesign/archive/2011/08/22/2149746.html" target="_blank" rel="noopener">PCI Express设备驱动</a></p>
<p><a href="https://www.cnblogs.com/gunl/archive/2011/06/09/2076892.html" target="_blank" rel="noopener">MSI中断与Linux实现</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/PCI/msi-howto.html" target="_blank" rel="noopener">linux PCI doc</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>PCIe</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>PCI总线基础知识</title>
    <url>/2020/07/20/Linux/Driver/PCIe/PCI%E6%80%BB%E7%BA%BF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PCI，英文全称：PeripheralComponent Interconnect，外围组件互联，由Intel于1991年提出。随着Intel Pentium处理器诞生而迅速发展，当时几乎所有的外围设备，从硬盘控制器、声卡、显卡和网卡，都使用PCI插槽来连接到计算机的主板上。计算机的PCI总线外设拓扑结构如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200720_002.png" alt="20200720_002"></p>
<h2 id="PCI基础知识"><a href="#PCI基础知识" class="headerlink" title="PCI基础知识"></a>PCI基础知识</h2><h3 id="PCI是什么？"><a href="#PCI是什么？" class="headerlink" title="PCI是什么？"></a>PCI是什么？</h3><p>PCI总线是并行、同步、数据地址复用的总线。在一个时钟周期内32个bit（或者64bit）同时被传输，地址和数据在一个时钟周期内按照协议，分别一次被传输。32bit/33MHz峰值带宽为132MB/s，64bit/66MHz峰值带宽为532MB/s。引脚定义如下：</p>
<p><img src="http://jiali.clouddn.com/20200720_001.png" alt="20200720_001"></p>
<p>特点：</p>
<ul>
<li>PCI总线地址空间与处理器的地址空间隔离：通过HOST主桥将PCI总线地址空间与CPU存储器域地址空间隔离。处理器访问PCI设备，先通过HOST主桥将处理器域的地址转换为PCI总线地址，同理，PCI设备进行DMA操作来传输数据时，也是先通过主桥将PCI总线地址转换为处理器存储器域地址。PCI总线地址是独立的地址空间，这跟处理器的存储器域地址空间不同。</li>
<li>可扩展性：同过HOST主桥引出一条PCI总线，然后在通过PCI桥引出一系列PCI总线，这样就构成一颗以HOST主桥为根的PCI总线树。</li>
<li>动态配置机制：每一个PCI设备都有独立的配置空间，在配置空间中包含了该设备在PCI总线地址空间中使用的物理基地址。这个基地址，可以通过软件动态分配，从而保证了每一个PCI设备使用的PCI总线地址不相同。</li>
<li>总线带宽：32bit/33MHz的PCI总线可以提供132MB/s的峰值带宽，64bit/66MHz的PCI总线可以提供532MB/s的峰值带宽。</li>
<li>共享总线机制：多个PCI设备可以共享一条PCI总线，PCI设备通过仲裁获得PCI总线的使用权后，才能进程数据传输。</li>
<li>中断机制。PCI总线上的设备可以通过四根中断请求信号INTA-D#向处理器提交中断请求。还可以通过MSI机制（该机制使用存储器写总线事务传递中断请求信号）提交中断请求。</li>
</ul>
<h3 id="PCI总线架构"><a href="#PCI总线架构" class="headerlink" title="PCI总线架构"></a>PCI总线架构</h3><p>在一个处理器系统中，PCI总线相关模块如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200720_003.png" alt="20200720_003"></p>
<h4 id="PCI总线相关模块"><a href="#PCI总线相关模块" class="headerlink" title="PCI总线相关模块"></a>PCI总线相关模块</h4><p><strong>HOST主桥</strong></p>
<p>HOST主桥主要功能是隔离CPU系统的存储器域与CPU系统的PCI总线域，并完成CPU与PCI设备间的数据交换。数据交换主要的类型：处理器访问PCI设备的地址空间和PCI设备使用DMA机制访问DDR内存。</p>
<p><strong>PCI总线</strong></p>
<p>有两个概念：PCI总线和PCI总线树。PCI总线是由桥引出来的一条总线，而PCI总线树是以HOST主桥为根的一系列PCI总线组成的。所有PCI桥引出总线地址共享PCI总线域（一颗PCI总线树）的地址。</p>
<p><strong>PCI设备</strong></p>
<p>三类设备：PCI主设备、PCI从设备和桥设备。</p>
<p>从设备：只能被动地接收来自HOST主桥或者其他PCI设备的读写请求</p>
<p>主设备:通过总线仲裁获得PCI总线的使用权，主动地向其他PCI设备或者主存储器（DDR）发起存储器读写请求。</p>
<p>桥设备：管理下游的PCI总线，并转发上下游总线之间的总线事务。</p>
<p>一个PCI设备可以既是主设备也是从设备，但是在同一个时刻，这个PCI设备只能是主设备或从设备。PCI总线规范把这类PCI主从设备称为PCI Agent设备。</p>
<p><strong>HOST处理器：</strong>CPU</p>
<p><strong>PCI总线负载</strong>：PCI总线能挂接的负载域总线频率相关。如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_001.png" alt=""></p>
<h4 id="PCI总线事务"><a href="#PCI总线事务" class="headerlink" title="PCI总线事务"></a>PCI总线事务</h4><p>CPU与PCI设备之间数据传输，通过PCI总线地址完成。CPU对PCI设备的地址空间进行读写，先发起存储器域地址读写，然后通过HOST主桥转换为PCI总线地址；PCI设备对CPU的DDR进行DMA操作，使用的目的地址是PCI总线地址，而不是CPU的存储器域地址，由HOST主桥完成PCI域地址到CPU的存储器域的地址转换。</p>
<ol>
<li><p><strong>存储器读写总线事务</strong></p>
<p>（1）事务类型</p>
<ul>
<li><p>CPU对PCI的BAR空间地址进行数据读写</p>
</li>
<li><p>PCI设备之间的数据传输</p>
</li>
<li><p>PCI设备对CPU的DDR进行DMA读写操作。</p>
</li>
</ul>
<p>（2）PCI总线传送方式:Posted 和Non-Posted</p>
<p>Posted:PCI主设备向PCI目标设备进行数据传递时，当数据到达PCI桥后，PCI桥接管该总线事务，并转发到下游总线，然后，该PCI桥上游的PCI总线可以结束当前总线事务，释放了PCI使用权。在一定程度上解决PCI总线拥塞问题。</p>
<p>Non-Posted:PCI主设备向PCI目标设备进行数据传递时，数据必须到达目的后，才能结束当前总线事务。</p>
</li>
<li><p><strong>CPU访问CPI设备</strong></p>
<p>（1）CPU对PCI设备的数据访问形式</p>
<ul>
<li>CPU向PCI设备发起存储器和I/O读写请求</li>
</ul>
</li>
</ol>
<ul>
<li><h2 id="CPU对PCI设备的配置空间进行读写。"><a href="#CPU对PCI设备的配置空间进行读写。" class="headerlink" title="CPU对PCI设备的配置空间进行读写。"></a>CPU对PCI设备的配置空间进行读写。</h2><p> （2）CPU向PCI设备发起存储器读写事务过程</p>
<p> ​    首先，CPU在初始化时，需要将PCI设备使用的BAR空间映射到存储器域地址空间。之后，CPU通过存储器读写指令访问存储器地址，HOST主桥将存储器地址请求转换为对PCI总线地址的请求，然后发给目标设备。注意：CPU只能使用CPU的存储器域的地址，而PCI设备只能使用PCI总线域的地址。</p>
<p> （3）I/O读写总线事务</p>
<p> ​    以X86处理器介绍CPU访问PCI设备的I/O地址空间的过程。X86处理器，具有独立的I/O地址空间，可以将PCI设备的I/O地址映射到CPU的I/O地址空间，之后    使用IN\OUT指令访问CPU自己的I/O地址，然后通过HOST主桥将CPU的I/O地址转换为PCI总线域的I/O地址，最后，使用PCI总线的I/O总线事务对PCI设备的    I/O地址访问。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>PCI设备读写CPU的DDR存储器</strong></p>
<p>PCI设备与CPU的DDR直接进行数据交换的过程被称为DMA。PCI设备进行DMA操作时候，需要获得数据传送的目的地址（已经与CPU的DDR内存地址映射的PCI总线地址）。HOST主桥负责完成PCI总线地址到CPU存储器域地址的转换，并向存储器控制器发起对DDR读写请求。注意，PCI设备不能直接访问没有经过HOST主桥映射的DDR内存地址。</p>
</li>
</ol>
<h2 id="PCI总线配置"><a href="#PCI总线配置" class="headerlink" title="PCI总线配置"></a>PCI总线配置</h2><h3 id="弄清几个区域概念"><a href="#弄清几个区域概念" class="headerlink" title="弄清几个区域概念"></a>弄清几个区域概念</h3><p>在一个处理器系统中，存在PCI总线域和存储器域。通过HOST主桥，将存储器域和PCI域隔离，形成各自独立的地址空间。它们之间的关系如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_003.png" alt=""></p>
<ol>
<li><p>存储器域</p>
<p>存储器域包括了CPU内部的通用寄存器、存储器控制器的寄存器、内存地址空间和外设地址空间。</p>
<p>2.PCI总线域</p>
</li>
</ol>
<p>​    PCI总线域由PCI设备所能直接访问的地址空间组成。在一个处理器系统中，存在几个HOST主桥，就存在几个PCI总线域。</p>
<p><strong>注释：</strong></p>
<p>（1）处理器访问PCI总线域地址空间时，首先需要访问存储器域的地址空间，在通过HOST主桥将存储器地址转换为PCI总线地址，之后，才能进入PCI总线域进行数据交换。PCI设备使用的PCI总线域地址空间保存在各自的BAR寄存器中。这些PCI总线地址空间需要在初始化时映射成为存储器域的地址空间，之后处理器才能访问BAR空间。</p>
<p>（2）PCI设备访问存储器域时，首先需要访问PCI总线域的地址空间，在通过HOST主桥将PCI总线地址转换为存储器地址，之后，才能跟CPU进行数据交换。因此，处理器需要通过HOST主桥将这个PCI总线地址反向映射为存储器地址。PCI设备不能访问在PCI总线域中没有进行映射的存储器域地址空间。</p>
<h3 id="PCI总线初始化"><a href="#PCI总线初始化" class="headerlink" title="PCI总线初始化"></a>PCI总线初始化</h3><h4 id="PCI设备配置空间寄存器地址"><a href="#PCI设备配置空间寄存器地址" class="headerlink" title="PCI设备配置空间寄存器地址"></a>PCI设备配置空间寄存器地址</h4><p>在PCI设备配置空间中出现的地址都是PCI总线地址，属于PCI总线域地址空间。系统软件需要完成这些寄存器的初始化。PCI  Agent设备的配置空间如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_004.png" alt=""></p>
<ul>
<li><p>Device ID 和Vendor ID寄存器:Vendor ID代表厂家，Device ID:代表厂家生产的具体设备</p>
</li>
<li><p>Base Address Register0-5寄存器：这组寄存器保存PCI设备使用的PCI总线域地址空间的基地址。</p>
<p>注释：</p>
<p>在PCI设备的配置空间中，有6个BAR寄存器。每一个BAR寄存器都与PCI设备使用的某一组PCI总线地址空间对应，BAR寄存器保存该组PCI总线地址空间的基地址，该组PCI总线地址空间也称为BAR空间。BAR空间可以存放I/O地址空间，也可以存放存储器地址空间。（是PCI总线的地址，不是CPU的存储器域地址）</p>
</li>
</ul>
<p>问：</p>
<p>1、如何访问这些配置空间？</p>
<p>在MPC8548处理器的HOST主桥中，与PCI设备配置空间相关的寄存器由CFG_ADDR、CFG_DATA和INT-ACK寄存器组成。系统软件使用CFG_ADDR、CFG_DATA寄存器访问PCI设备的配置空间</p>
<h4 id="PCI总线树BUS总线号初始化"><a href="#PCI总线树BUS总线号初始化" class="headerlink" title="PCI总线树BUS总线号初始化"></a>PCI总线树BUS总线号初始化</h4><p>在一个处理器系统中，每一个HOST主桥都推出一颗PCI总线树。在一块PCI总线树中有多少个PCI桥就含有多少条PCI总线。系统软件在遍历当前PCI总线树时，首先需要对这些PCI总线进行编号，即初始化PCI桥的Primary、Secondary和Subordinate Bus Number寄存器。</p>
<p>一般，将与HOST主桥直接相连的PCI总线命名为PCI总线0，然后，系统软件使用DFS算法，依次对其他PCI总线进行编号。最后得到的PCI总线结构如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_007.png" alt=""></p>
<h4 id="BAR空间的初始化"><a href="#BAR空间的初始化" class="headerlink" title="BAR空间的初始化"></a>BAR空间的初始化</h4><p>系统软件对PCI总线进行配置时，首先获得BAR寄存器中的初始化信息，之后，根据处理器系统的配置，将合理的PCI总线域的某个地址空间的基地址写入BAR寄存器中。</p>
<p>当处理器访问PCI设备的BAR空间时，需要使用BAR寄存器提供的基地址。注意的是，处理器使用存储器域的地址，不能直接使用<strong>BAR中的基地址+偏移</strong>的方式访问BAR空间，而应该将BAR中的基地址转换为CPU存储器域的地址。</p>
<p>linux中使用下面的接口获取BAR中的基地址对应的存储器域地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pci_resource_start();</span><br><span class="line">原型如下：</span><br><span class="line">#define pci_resource_start(dev, bar)	((dev)-&gt;resource[(bar)].start)</span><br></pre></td></tr></table></figure>

<p><strong>PCI设备BAR空间分配例子</strong></p>
<p>假设在HOST主桥中，存储器域域PCI总线域的映射关系如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_005.png" alt=""></p>
<p>BAR空间映射：0xf000-0000<del>0xf7ff-ffff —&gt;0x7000-0000</del>0x7800-0000 </p>
<p>DMA操作的内存映射：0x8000-0000<del>0xffff-ffff —&gt; 0x0000-0000</del>0x7fff-ffff</p>
<p>系统软件根据建立起的映射关系，初始化BAR寄存器，完成后如下图所示。</p>
<p><img src="http://jiali.clouddn.com/20200721_006.png" alt=""></p>
<h2 id="PCI总线数据传输"><a href="#PCI总线数据传输" class="headerlink" title="PCI总线数据传输"></a>PCI总线数据传输</h2><h3 id="处理器到PCI设备的数据传送"><a href="#处理器到PCI设备的数据传送" class="headerlink" title="处理器到PCI设备的数据传送"></a>处理器到PCI设备的数据传送</h3><p>略。</p>
<h3 id="PCI设备的DMA操作"><a href="#PCI设备的DMA操作" class="headerlink" title="PCI设备的DMA操作"></a>PCI设备的DMA操作</h3><p>略。</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26172972" target="_blank" rel="noopener">深入PCI与PCIe之一：硬件篇</a></p>
<p><a href="https://blog.csdn.net/qimoDIY/article/details/89784560" target="_blank" rel="noopener">接口技术【1】PCIe入门简介</a></p>
<p><a href="https://www.twblogs.net/a/5b7ec5632b717767c6abb3f2" target="_blank" rel="noopener">浅析PCI配置空间</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>PCIe</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>Microchip maXTouch Object Protocol理解</title>
    <url>/2021/01/13/Linux/Driver/Input/maXTouch%20Object%20Protocol%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microchip 为maXTouch controllers编写一份 不依赖芯片平台的Object Protocol，Object Protocol可以在每个芯片中进行移植，兼容主机驱动。那么如何理解Object Protocol？</p>
<p>本文讲解mXT2952TD芯片的Object Protocol  ，版本为version 1.0。</p>
<h2 id="Memory-Map-Structure-of-Object"><a href="#Memory-Map-Structure-of-Object" class="headerlink" title="Memory Map Structure of Object"></a>Memory Map Structure of Object</h2><p>设计协议的目的就是实现模块化管理。将芯片的整体功能，划分一个个小功能模块，一个模块代表某些特征，比如触摸屏功能。object可以理解为一个模块，代表触摸屏芯片的某一个功能。根据功能需要，object可以使能或者不使能。</p>
<p>每个object都有自己的配置空间，object 配置空间的内存映射如下：</p>
<p><img src="http://jiali.clouddn.com/20210113_001.png" alt=""></p>
<p>​                                                                                                             图 object 内存映射</p>
<p>ID Information ：芯片的基本信息</p>
<p>Objects：各种类型的object在内存的具体位置</p>
<p>Object Table:每一种object都有自己的object table,用来描述object的基本信息。</p>
<h3 id="如何理解Object-Table"><a href="#如何理解Object-Table" class="headerlink" title="如何理解Object Table"></a>如何理解Object Table</h3><p>Object Table的格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210113_002.png" alt=""></p>
<p>​                                                                                                                图 object table字段说明 </p>
<p><strong>Type:</strong>每种object都有唯一的类型识别码（1、2、3、4、5…）.比如Command Processor T6的识别码就是6，Command Processor T代表处理器的名字前缀，完整的名字就是Command Processor T6.</p>
<p><strong>start position:</strong>Object在内存映射的开始位置。用两个字节表示一个内存地址LSByte代表低字节,MSByte代表高字节。因此驱动程序读写object,需要知道object在内存映射中的地址，并且使用该地址与object交流数据</p>
<p><strong>size:</strong>object占多大的内存</p>
<p><strong>instance:</strong>表示相同类型的object的数量，也就是相同类型的object有多少个。 多个object instance在内存中的位置是按顺序分配。</p>
<p><strong>Report ID:</strong>object 传递消息给host，消息自带有Report ID,host通过Report ID来识别消息来自哪个object.每一个object instance，可以拥有一组 Report ID,也可以为一个Report ID.</p>
<p> 如何计算object的Report ID数量呢？</p>
<ul>
<li>读取 object table byte 4的值+1</li>
<li>读取object table byte 5的值</li>
<li>最后，将它们相乘的结果减1，就是一个object instance 最大的report id。</li>
</ul>
<p>注意：</p>
<p>所有object 的report id是按照顺序排列的，芯片规定从1开始排列report id。report id 分配如下图</p>
<p><img src="http://jiali.clouddn.com/20210114_001.png" alt=""></p>
<p>​                     </p>
<p>​                                                                                                 图 object report id 划分</p>
<p>report id 排列算法：</p>
<p>report_id=1</p>
<p><strong>object 1 report id 划分：</strong></p>
<p>min_id=report_id</p>
<p>report_id+=1*1，结果为2</p>
<p>max_id=report_id-1,结果为1</p>
<p><strong>object 2 report id 划分：</strong></p>
<p>min_id=object 1计算出来的report id 也就是2</p>
<p>report_id+=2*10，结果为22</p>
<p>max_id=report_id-1,结果为21</p>
<p><strong>object 3 report id 划分：</strong></p>
<p>min_id=object 2计算出来的report id 也就是22</p>
<p>report_id+=2*1，结果为24</p>
<p>max_id=report_id-1,结果为23</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	int i;</span><br><span class="line">	u8 reportid;</span><br><span class="line">	</span><br><span class="line">	reportid &#x3D; 1;</span><br><span class="line">	data-&gt;mem_size &#x3D; 0;</span><br><span class="line">	for (i &#x3D; 0; i &lt; data-&gt;info-&gt;object_num; i++) &#123;</span><br><span class="line">		struct mxt_object *object &#x3D; object_table + i;</span><br><span class="line">		u8 min_id, max_id;</span><br><span class="line"></span><br><span class="line">		le16_to_cpus(&amp;object-&gt;start_address);</span><br><span class="line"></span><br><span class="line">		if (object-&gt;num_report_ids) &#123;</span><br><span class="line">			min_id &#x3D; reportid;</span><br><span class="line">			reportid +&#x3D; object-&gt;num_report_ids *</span><br><span class="line">					mxt_obj_instances(object);</span><br><span class="line">			max_id &#x3D; reportid - 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			min_id &#x3D; 0;</span><br><span class="line">			max_id &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>host 驱动遍历mXT2952T2的Object ID 列表如下：</p>
<p><img src="http://jiali.clouddn.com/mxt_oject_list.png" alt=""> </p>
<p>​                                                           图 mXT2952T2的Object ID 列表</p>
<p>从上图可以理解instance：</p>
<p>比如T61 一个object instance的配置项如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_002.png" alt=""></p>
<p>​                                                                                                                                   图 T61 object 配置空间</p>
<p>所以，T61有几个instance，就有几个上面的配置空间。因此，T61占用内存空间大小为instance的数量乘以object配置空间的大小。                  </p>
<h3 id="object-分类"><a href="#object-分类" class="headerlink" title="object 分类"></a>object 分类</h3><p>The mXT2952TD contains the following classes of objects:<br>• Debug objects – provide a raw data output method for development and testing.<br>See Section 2.0 “Debug Objects”.<br>• General objects – required for global configuration, transmitting messages and receiving commands. See<br>Section 3.0 “General Objects”.<br>• Touch objects – operate on measured signals from the touch sensor and report touch data. See Section 4.0<br>“Touch Objects”.<br>• Signal processing objects – process data from other objects (typically signal filtering operations). See<br>Section 5.0 “Signal Processing Objects”.<br>• Support objects – provide additional functionality on the device. See Section 6.0 “Support Objects”.</p>
<h2 id="重要的object分析"><a href="#重要的object分析" class="headerlink" title="重要的object分析"></a>重要的object分析</h2><p>挑几个用到的object来讲解一下使用方法。</p>
<h3 id="Message-Processor-T5-Object"><a href="#Message-Processor-T5-Object" class="headerlink" title="Message Processor T5 Object"></a>Message Processor T5 Object</h3><p>Message Processor T5 object 的作用就是用来传递最新的消息给Host.所有产生消息的object 都通过Message Processor T5 object 传递给host.因此，maXTouch controllers 使用Message Processor T5 object与外界Host进行交流数据。</p>
<p>当maXTouch controllers有消息发送时候，通过CHG Line的电平拉低来告诉host消息已经生成，请Host去读消息，并且使用report id识别消息来自哪个object。因此，host 驱动检测CHG Line的电平，通过中断的方式来读取maXTouch controllers的消息。</p>
<p>Message Processor T5 Object 的配置空间如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_003.png" alt=""></p>
<p>​                                                                                                    图 Message Processor T5 Object 的配置空间</p>
<p><strong>REPORTID:</strong> 表示产生消息的object</p>
<p><strong>MESSAGE:</strong> object产生的消息内容</p>
<p>maXTouch controllers支持DMA读取Message Processor T5 Object的消息，具体配置如下：</p>
<ul>
<li>先读取Message Count T44 Object 的消息个数</li>
<li>然后根据消息个数，全部读取Message Processor T5 Object的消息</li>
</ul>
<p>程序处理如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Read T44 and T5 together *&#x2F;</span><br><span class="line">	ret &#x3D; __mxt_read_reg(data-&gt;client, data-&gt;T44_address,</span><br><span class="line">		data-&gt;T5_msg_size + 1, data-&gt;msg_buf);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_err(dev, &quot;Failed to read T44 and T5 (%d)\n&quot;, ret);</span><br><span class="line">		return IRQ_NONE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count &#x3D; data-&gt;msg_buf[0];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int mxt_read_and_process_messages(struct mxt_data *data, u8 count)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; &amp;data-&gt;client-&gt;dev;</span><br><span class="line">	int ret;</span><br><span class="line">	int i;</span><br><span class="line">	u8 num_valid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Safety check for msg_buf *&#x2F;</span><br><span class="line">	if (count &gt; data-&gt;max_reportid)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process remaining messages if necessary *&#x2F;</span><br><span class="line">	ret &#x3D; __mxt_read_reg(data-&gt;client, data-&gt;T5_address,</span><br><span class="line">				data-&gt;T5_msg_size * count, data-&gt;msg_buf);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_err(dev, &quot;Failed to read %u messages (%d)\n&quot;, count, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return num_valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Message-Processor-T44-Object"><a href="#Message-Processor-T44-Object" class="headerlink" title="Message Processor T44 Object"></a>Message Processor T44 Object</h3><p>统计存储在缓存中的消息个数，用于DMA读取数据。配置空间如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_004.png" alt=""></p>
<p>​                                                                                                                   图 T44 Object 配置空间</p>
<h3 id="Multiple-Touch-Touchscreen-T100-Object"><a href="#Multiple-Touch-Touchscreen-T100-Object" class="headerlink" title="Multiple Touch Touchscreen T100 Object"></a>Multiple Touch Touchscreen T100 Object</h3><p>1、T100 Object 配置空间</p>
<p>略</p>
<p>2、T100 Object产生消息的格式</p>
<p>The Multiple Touch Touchscreen T100 object reports the following screen and touch status information:<br>• Screen status information, such as the number of nodes affected and the number of reported touches<br>• Finger touches detected by the Multiple Touch Touchscreen T100 object<br>• Passive stylus touches detected by the Passive Stylus T47 object<br>• Glove touches detected by the Glove Detection T78 object<br>• Grip suppression by the Grip Suppression T40 object<br>• Screen suppression by the Touch Suppression T42 object</p>
<p>当手指触摸屏幕时候，T100 Object 产生消息，report id 分别为46-63。</p>
<p>（1）第一个report id产生的消息</p>
<p>该消息用来报告触摸屏的状态，消息格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_005.png" alt=""></p>
<p>​                                                                                                               图 T100 reportid=46消息格式</p>
<p>（2）第二个report id产生的消息</p>
<p>该消息用作预留功能。</p>
<p><img src="http://jiali.clouddn.com/20210114_006.png" alt=""></p>
<p>​                                                                                                             图 T100 reportid=46消息格式 </p>
<p>（2）剩余report id产生的消息</p>
<p>剩余的16个report id用于报告触摸点的信息。maXTouch controllers支持同时操作16个触摸点，因此在剩余的16个report id中，每一个report id产生的消息代表一个触摸点。消息格式如下：</p>
<p><img src="http://jiali.clouddn.com/20210114_007.png" alt=""></p>
<p>​                                                                                                        图 其中一个触摸点的消息格式</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>1、单个手指触摸，读取message</p>
<p><img src="http://jiali.clouddn.com/20210115_004.png" alt=""></p>
<p>2、两个手指同时触摸，读取message</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # dmesg -c</span><br><span class="line">[ 2855.705442] in mxt_interrpt</span><br><span class="line">[ 2855.705457] in data-&gt;T44_address</span><br><span class="line">[ 2855.705920] report_id:46</span><br><span class="line">[ 2855.705926] msg_buf[0]:46 msg_buf[1]:128 msg_buf[2]:0 msg_buf[3]:0 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.705952] mxt_proc_t100_message</span><br><span class="line">[ 2855.706680] mxt_read_and_process_messages count 2, report_id 48,t5_msg_size:10</span><br><span class="line">[ 2855.706690] report_id:48</span><br><span class="line">[ 2855.706695] msg_buf[0]:48 msg_buf[1]:148 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.706747] mxt_proc_t100_message</span><br><span class="line">[ 2855.706754] mxt_read_and_process_messages count 2, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.706762] report_id:49</span><br><span class="line">[ 2855.706767] msg_buf[0]:49 msg_buf[1]:148 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.720988] in mxt_interrpt</span><br><span class="line">[ 2855.721004] in data-&gt;T44_address</span><br><span class="line">[ 2855.721480] report_id:48</span><br><span class="line">[ 2855.721486] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.721523] mxt_proc_t100_message</span><br><span class="line">[ 2855.721989] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.721999] report_id:49</span><br><span class="line">[ 2855.722004] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.736746] in mxt_interrpt</span><br><span class="line">[ 2855.736755] in data-&gt;T44_address</span><br><span class="line">[ 2855.737202] report_id:48</span><br><span class="line">[ 2855.737207] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.737238] mxt_proc_t100_message</span><br><span class="line">[ 2855.737684] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.737693] report_id:49</span><br><span class="line">[ 2855.737698] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.752528] in mxt_interrpt</span><br><span class="line">[ 2855.752535] in data-&gt;T44_address</span><br><span class="line">[ 2855.752974] report_id:48</span><br><span class="line">[ 2855.752980] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.753009] mxt_proc_t100_message</span><br><span class="line">[ 2855.753450] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.753458] report_id:49</span><br><span class="line">[ 2855.753463] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.768293] in mxt_interrpt</span><br><span class="line">[ 2855.768306] in data-&gt;T44_address</span><br><span class="line">[ 2855.768761] report_id:48</span><br><span class="line">[ 2855.768768] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.768804] mxt_proc_t100_message</span><br><span class="line">[ 2855.769246] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.769255] report_id:49</span><br><span class="line">[ 2855.769259] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.784113] in mxt_interrpt</span><br><span class="line">[ 2855.784122] in data-&gt;T44_address</span><br><span class="line">[ 2855.784578] report_id:48</span><br><span class="line">[ 2855.784584] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.784615] mxt_proc_t100_message</span><br><span class="line">[ 2855.785057] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.785065] report_id:49</span><br><span class="line">[ 2855.785070] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.799808] in mxt_interrpt</span><br><span class="line">[ 2855.799817] in data-&gt;T44_address</span><br><span class="line">[ 2855.800262] report_id:48</span><br><span class="line">[ 2855.800268] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.800300] mxt_proc_t100_message</span><br><span class="line">[ 2855.800748] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.800758] report_id:49</span><br><span class="line">[ 2855.800762] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.815623] in mxt_interrpt</span><br><span class="line">[ 2855.815630] in data-&gt;T44_address</span><br><span class="line">[ 2855.816069] report_id:48</span><br><span class="line">[ 2855.816075] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.816104] mxt_proc_t100_message</span><br><span class="line">[ 2855.816549] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.816559] report_id:49</span><br><span class="line">[ 2855.816563] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.831364] in mxt_interrpt</span><br><span class="line">[ 2855.831371] in data-&gt;T44_address</span><br><span class="line">[ 2855.831818] report_id:48</span><br><span class="line">[ 2855.831824] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.831854] mxt_proc_t100_message</span><br><span class="line">[ 2855.832293] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.832301] report_id:49</span><br><span class="line">[ 2855.832306] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.847125] in mxt_interrpt</span><br><span class="line">[ 2855.847133] in data-&gt;T44_address</span><br><span class="line">[ 2855.847578] report_id:48</span><br><span class="line">[ 2855.847585] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.847614] mxt_proc_t100_message</span><br><span class="line">[ 2855.848055] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.848063] report_id:49</span><br><span class="line">[ 2855.848068] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.862910] in mxt_interrpt</span><br><span class="line">[ 2855.862918] in data-&gt;T44_address</span><br><span class="line">[ 2855.863355] report_id:48</span><br><span class="line">[ 2855.863361] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.863389] mxt_proc_t100_message</span><br><span class="line">[ 2855.863836] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.863845] report_id:49</span><br><span class="line">[ 2855.863850] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.878673] in mxt_interrpt</span><br><span class="line">[ 2855.878681] in data-&gt;T44_address</span><br><span class="line">[ 2855.879120] report_id:48</span><br><span class="line">[ 2855.879125] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.879155] mxt_proc_t100_message</span><br><span class="line">[ 2855.879597] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.879606] report_id:49</span><br><span class="line">[ 2855.879612] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.894455] in mxt_interrpt</span><br><span class="line">[ 2855.894462] in data-&gt;T44_address</span><br><span class="line">[ 2855.894901] report_id:48</span><br><span class="line">[ 2855.894907] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.894936] mxt_proc_t100_message</span><br><span class="line">[ 2855.895375] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.895383] report_id:49</span><br><span class="line">[ 2855.895388] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.910220] in mxt_interrpt</span><br><span class="line">[ 2855.910226] in data-&gt;T44_address</span><br><span class="line">[ 2855.910668] report_id:48</span><br><span class="line">[ 2855.910675] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.910704] mxt_proc_t100_message</span><br><span class="line">[ 2855.911144] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.911152] report_id:49</span><br><span class="line">[ 2855.911157] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.925984] in mxt_interrpt</span><br><span class="line">[ 2855.925992] in data-&gt;T44_address</span><br><span class="line">[ 2855.926458] report_id:48</span><br><span class="line">[ 2855.926466] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.926499] mxt_proc_t100_message</span><br><span class="line">[ 2855.926954] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.926964] report_id:49</span><br><span class="line">[ 2855.926969] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.941775] in mxt_interrpt</span><br><span class="line">[ 2855.941784] in data-&gt;T44_address</span><br><span class="line">[ 2855.942228] report_id:48</span><br><span class="line">[ 2855.942233] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.942264] mxt_proc_t100_message</span><br><span class="line">[ 2855.942707] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.942716] report_id:49</span><br><span class="line">[ 2855.942721] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.957554] in mxt_interrpt</span><br><span class="line">[ 2855.957565] in data-&gt;T44_address</span><br><span class="line">[ 2855.958029] report_id:48</span><br><span class="line">[ 2855.958035] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.958068] mxt_proc_t100_message</span><br><span class="line">[ 2855.958515] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.958525] report_id:49</span><br><span class="line">[ 2855.958530] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.973332] in mxt_interrpt</span><br><span class="line">[ 2855.973340] in data-&gt;T44_address</span><br><span class="line">[ 2855.973793] report_id:48</span><br><span class="line">[ 2855.973799] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.973831] mxt_proc_t100_message</span><br><span class="line">[ 2855.974271] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.974279] report_id:49</span><br><span class="line">[ 2855.974284] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.989151] in mxt_interrpt</span><br><span class="line">[ 2855.989158] in data-&gt;T44_address</span><br><span class="line">[ 2855.989607] report_id:48</span><br><span class="line">[ 2855.989613] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2855.989643] mxt_proc_t100_message</span><br><span class="line">[ 2855.990084] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2855.990092] report_id:49</span><br><span class="line">[ 2855.990097] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.004852] in mxt_interrpt</span><br><span class="line">[ 2856.004860] in data-&gt;T44_address</span><br><span class="line">[ 2856.005301] report_id:48</span><br><span class="line">[ 2856.005307] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.005337] mxt_proc_t100_message</span><br><span class="line">[ 2856.005795] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.005806] report_id:49</span><br><span class="line">[ 2856.005811] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.020607] in mxt_interrpt</span><br><span class="line">[ 2856.020615] in data-&gt;T44_address</span><br><span class="line">[ 2856.021057] report_id:48</span><br><span class="line">[ 2856.021063] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.021097] mxt_proc_t100_message</span><br><span class="line">[ 2856.021540] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.021549] report_id:49</span><br><span class="line">[ 2856.021554] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.036403] in mxt_interrpt</span><br><span class="line">[ 2856.036423] in data-&gt;T44_address</span><br><span class="line">[ 2856.036876] report_id:48</span><br><span class="line">[ 2856.036882] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.036913] mxt_proc_t100_message</span><br><span class="line">[ 2856.037354] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.037362] report_id:49</span><br><span class="line">[ 2856.037367] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.052161] in mxt_interrpt</span><br><span class="line">[ 2856.052168] in data-&gt;T44_address</span><br><span class="line">[ 2856.052610] report_id:48</span><br><span class="line">[ 2856.052617] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.052646] mxt_proc_t100_message</span><br><span class="line">[ 2856.053085] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.053093] report_id:49</span><br><span class="line">[ 2856.053098] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.067933] in mxt_interrpt</span><br><span class="line">[ 2856.067939] in data-&gt;T44_address</span><br><span class="line">[ 2856.068377] report_id:48</span><br><span class="line">[ 2856.068383] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.068423] mxt_proc_t100_message</span><br><span class="line">[ 2856.068870] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.068879] report_id:49</span><br><span class="line">[ 2856.068884] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.083717] in mxt_interrpt</span><br><span class="line">[ 2856.083724] in data-&gt;T44_address</span><br><span class="line">[ 2856.084162] report_id:48</span><br><span class="line">[ 2856.084167] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.084197] mxt_proc_t100_message</span><br><span class="line">[ 2856.084644] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.084653] report_id:49</span><br><span class="line">[ 2856.084657] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.099483] in mxt_interrpt</span><br><span class="line">[ 2856.099490] in data-&gt;T44_address</span><br><span class="line">[ 2856.099928] report_id:48</span><br><span class="line">[ 2856.099934] msg_buf[0]:48 msg_buf[1]:144 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.099964] mxt_proc_t100_message</span><br><span class="line">[ 2856.100403] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.100424] report_id:49</span><br><span class="line">[ 2856.100429] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.114993] in mxt_interrpt</span><br><span class="line">[ 2856.115001] in data-&gt;T44_address</span><br><span class="line">[ 2856.115440] report_id:48</span><br><span class="line">[ 2856.115446] msg_buf[0]:48 msg_buf[1]:21 msg_buf[2]:66 msg_buf[3]:2 msg_buf[4]:76 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.115483] mxt_proc_t100_message</span><br><span class="line">[ 2856.115940] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.115952] report_id:49</span><br><span class="line">[ 2856.115956] msg_buf[0]:49 msg_buf[1]:144 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.130327] in mxt_interrpt</span><br><span class="line">[ 2856.130339] in data-&gt;T44_address</span><br><span class="line">[ 2856.130802] report_id:46</span><br><span class="line">[ 2856.130808] msg_buf[0]:46 msg_buf[1]:0 msg_buf[2]:0 msg_buf[3]:0 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.130832] mxt_proc_t100_message</span><br><span class="line">[ 2856.131273] mxt_read_and_process_messages count 1, report_id 49,t5_msg_size:10</span><br><span class="line">[ 2856.131281] report_id:49</span><br><span class="line">[ 2856.131286] msg_buf[0]:49 msg_buf[1]:21 msg_buf[2]:184 msg_buf[3]:1 msg_buf[4]:57 msg_buf[5]:2 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.393232] in mxt_interrpt</span><br><span class="line">[ 2856.393249] in data-&gt;T44_address</span><br><span class="line">[ 2856.393869] report_id:10</span><br><span class="line">[ 2856.393877] msg_buf[0]:10 msg_buf[1]:193 msg_buf[2]:207 msg_buf[3]:7 msg_buf[4]:0 msg_buf[5]:0 msg_buf[6]:0 msg_buf[7]:0 msg_buf[8]:0 msg_buf[9]:0 </span><br><span class="line">[ 2856.393905] report_id&#x3D;10,modify timer</span><br></pre></td></tr></table></figure>



<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>本文总结Microchip maXTouch controller的object的使用和配置。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I2C驱动设计</title>
    <url>/2021/01/07/Linux/Driver/i2c/Linux%20I2C%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了网上一些关于Linux i2c驱动的博客文章，都将i2c分为device 、i2c core和driver三层。对于linux  i2c的分层，我有不同的理解。因此，把我的理解，记录下来。i2c对单片机来说，实现比较简单，但是Linux的i2c子系统为什么写得比较复杂？Linux把i2c做成一个通用平台，划分层次，方便分工合作。划分层次，每个方向专注一个层次，更改一个层次，不影响其他层次。因此，做Linux i2c驱动，跟i2c设备接触的开发者，专心配置设备的寄存器，降低了i2c开发难度。</p>
<h2 id="i2c架构理解"><a href="#i2c架构理解" class="headerlink" title="i2c架构理解"></a>i2c架构理解</h2><p><img src="http://jiali.clouddn.com/20210111_001.png" alt=""></p>
<p>client操作层：提供注册字符设备，实现应用层read、write、open等功能</p>
<p>i2c-core层：提供i2c适配器和driver的注册和注销等核心功能接口</p>
<p>i2c driver层：实现设备的驱动程序，包括初始化、挂起和唤醒等</p>
<p>i2c_adapter: 初始化i2c控制器，注册适配器，并提供一种适合设备的通信时序algorithm</p>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>1、struct i2c_driver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_driver - represent an I2C device driver</span><br><span class="line"> * @class: What kind of i2c device we instantiate (for detect)</span><br><span class="line"> * @attach_adapter: Callback for bus addition (deprecated)</span><br><span class="line"> * @detach_adapter: Callback for bus removal (deprecated)</span><br><span class="line"> * @probe: Callback for device binding</span><br><span class="line"> * @remove: Callback for device unbinding</span><br><span class="line"> * @shutdown: Callback for device shutdown</span><br><span class="line"> * @suspend: Callback for device suspend</span><br><span class="line"> * @resume: Callback for device resume</span><br><span class="line"> * @alert: Alert callback, for example for the SMBus alert protocol</span><br><span class="line"> * @command: Callback for bus-wide signaling (optional)</span><br><span class="line"> * @driver: Device driver model driver</span><br><span class="line"> * @id_table: List of I2C devices supported by this driver</span><br><span class="line"> * @detect: Callback for device detection</span><br><span class="line"> * @address_list: The I2C addresses to probe (for detect)</span><br><span class="line"> * @clients: List of detected clients we created (for i2c-core use only)</span><br><span class="line"> *</span><br><span class="line"> * The driver.owner field should be set to the module owner of this driver.</span><br><span class="line"> * The driver.name field should be set to the name of this driver.</span><br><span class="line"> *</span><br><span class="line"> * For automatic device detection, both @detect and @address_data must</span><br><span class="line"> * be defined. @class should also be set, otherwise only devices forced</span><br><span class="line"> * with module parameters will be created. The detect function must</span><br><span class="line"> * fill at least the name field of the i2c_board_info structure it is</span><br><span class="line"> * handed upon successful detection, and possibly also the flags field.</span><br><span class="line"> *</span><br><span class="line"> * If @detect is missing, the driver will still work fine for enumerated</span><br><span class="line"> * devices. Detected devices simply won&#39;t be supported. This is expected</span><br><span class="line"> * for the many I2C&#x2F;SMBus devices which can&#39;t be detected reliably, and</span><br><span class="line"> * the ones which can always be enumerated in practice.</span><br><span class="line"> *</span><br><span class="line"> * The i2c_client structure which is handed to the @detect callback is</span><br><span class="line"> * not a real i2c_client. It is initialized just enough so that you can</span><br><span class="line"> * call i2c_smbus_read_byte_data and friends on it. Don&#39;t do anything</span><br><span class="line"> * else with it. In particular, calling dev_dbg and friends on it is</span><br><span class="line"> * not allowed.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_driver &#123;</span><br><span class="line">	unsigned int class;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Notifies the driver that a new bus has appeared or is about to be</span><br><span class="line">	 * removed. You should avoid using this, it will be removed in a</span><br><span class="line">	 * near future.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line">	int (*detach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class="line">	int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">	int (*remove)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line">	&#x2F;* driver model interfaces that don&#39;t relate to enumeration  *&#x2F;</span><br><span class="line">	void (*shutdown)(struct i2c_client *);</span><br><span class="line">	int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br><span class="line">	int (*resume)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Alert callback, for example for the SMBus alert protocol.</span><br><span class="line">	 * The format and meaning of the data value depends on the protocol.</span><br><span class="line">	 * For the SMBus alert protocol, there is a single bit of data passed</span><br><span class="line">	 * as the alert response&#39;s low bit (&quot;event flag&quot;).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void (*alert)(struct i2c_client *, unsigned int data);</span><br><span class="line"></span><br><span class="line">	&#x2F;* a ioctl like command that can be used to perform specific functions</span><br><span class="line">	 * with the device.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class="line"></span><br><span class="line">	struct device_driver driver;</span><br><span class="line">	const struct i2c_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Device detection callback for automatic device creation *&#x2F;</span><br><span class="line">	int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">	const unsigned short *address_list;</span><br><span class="line">	struct list_head clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、struct i2c_adapter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	unsigned int class;		  &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">	const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class="line">	void *algo_data;</span><br><span class="line"></span><br><span class="line">	&#x2F;* data fields that are valid for all devices	*&#x2F;</span><br><span class="line">	struct rt_mutex bus_lock;</span><br><span class="line"></span><br><span class="line">	int timeout;			&#x2F;* in jiffies *&#x2F;</span><br><span class="line">	int retries;</span><br><span class="line">	struct device dev;		&#x2F;* the adapter device *&#x2F;</span><br><span class="line"></span><br><span class="line">	int nr;</span><br><span class="line">	char name[48];</span><br><span class="line">	struct completion dev_released;</span><br><span class="line"></span><br><span class="line">	struct mutex userspace_clients_lock;</span><br><span class="line">	struct list_head userspace_clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、struct i2c_algorithm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The following structs are for those who like to implement new bus drivers:</span><br><span class="line"> * i2c_algorithm is the interface to a class of hardware solutions which can</span><br><span class="line"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span><br><span class="line"> * to name two of the most common.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">	&#x2F;* If an adapter algorithm can&#39;t do I2C-level access, set master_xfer</span><br><span class="line">	   to NULL. If an adapter algorithm can do SMBus access, set</span><br><span class="line">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span><br><span class="line">	   using common I2C messages *&#x2F;</span><br><span class="line">	&#x2F;* master_xfer should return the number of messages successfully</span><br><span class="line">	   processed, or a negative value on error *&#x2F;</span><br><span class="line">	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">			   int num);</span><br><span class="line">	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">			   unsigned short flags, char read_write,</span><br><span class="line">			   u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	&#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、struct i2c_client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_client - represent an I2C slave device</span><br><span class="line"> * @flags: I2C_CLIENT_TEN indicates the device uses a ten bit chip address;</span><br><span class="line"> *	I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking</span><br><span class="line"> * @addr: Address used on the I2C bus connected to the parent adapter.</span><br><span class="line"> * @name: Indicates the type of the device, usually a chip name that&#39;s</span><br><span class="line"> *	generic enough to hide second-sourcing and compatible revisions.</span><br><span class="line"> * @adapter: manages the bus segment hosting this I2C device</span><br><span class="line"> * @driver: device&#39;s driver, hence pointer to access routines</span><br><span class="line"> * @dev: Driver model device node for the slave.</span><br><span class="line"> * @irq: indicates the IRQ generated by this device (if any)</span><br><span class="line"> * @detected: member of an i2c_driver.clients list or i2c-core&#39;s</span><br><span class="line"> *	userspace_devices list</span><br><span class="line"> *</span><br><span class="line"> * An i2c_client identifies a single device (i.e. chip) connected to an</span><br><span class="line"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span><br><span class="line"> * managing the device.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_client &#123;</span><br><span class="line">	unsigned short flags;		&#x2F;* div., see below		*&#x2F;</span><br><span class="line">	unsigned short addr;		&#x2F;* chip address - NOTE: 7bit	*&#x2F;</span><br><span class="line">					&#x2F;* addresses are stored in the	*&#x2F;</span><br><span class="line">					&#x2F;* _LOWER_ 7 bits		*&#x2F;</span><br><span class="line">	char name[I2C_NAME_SIZE];</span><br><span class="line">	struct i2c_adapter *adapter;	&#x2F;* the adapter we sit on	*&#x2F;</span><br><span class="line">	struct i2c_driver *driver;	&#x2F;* and our access routines	*&#x2F;</span><br><span class="line">	struct device dev;		&#x2F;* the device structure		*&#x2F;</span><br><span class="line">	int irq;			&#x2F;* irq issued by device		*&#x2F;</span><br><span class="line">	struct list_head detected;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5、struct i2c_msg描述传输数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct i2c_msg - an I2C transaction segment beginning with START</span><br><span class="line"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span><br><span class="line"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span><br><span class="line"> *	must support I2C_FUNC_10BIT_ADDR.</span><br><span class="line"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span><br><span class="line"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span><br><span class="line"> *	flags through i2c_check_functionality().</span><br><span class="line"> * @len: Number of data bytes in @buf being read from or written to the</span><br><span class="line"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span><br><span class="line"> *	is set, the caller guarantees that this buffer can hold up to</span><br><span class="line"> *	32 bytes in addition to the initial length byte sent by the</span><br><span class="line"> *	slave (plus, if used, the SMBus PEC); and this value will be</span><br><span class="line"> *	incremented by the number of block data bytes received.</span><br><span class="line"> * @buf: The buffer into which data is read, or from which it&#39;s written.</span><br><span class="line"> *</span><br><span class="line"> * An i2c_msg is the low level representation of one segment of an I2C</span><br><span class="line"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span><br><span class="line"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span><br><span class="line"> * @i2c_adapter.@master_xfer() method.</span><br><span class="line"> *</span><br><span class="line"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span><br><span class="line"> * the standard rules for I2C transactions.  Each transaction begins with a</span><br><span class="line"> * START.  That is followed by the slave address, and a bit encoding read</span><br><span class="line"> * versus write.  Then follow all the data bytes, possibly including a byte</span><br><span class="line"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span><br><span class="line"> * bytes have been transferred and ACKed.  If this is the last message in a</span><br><span class="line"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span><br><span class="line"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span><br><span class="line"> *</span><br><span class="line"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span><br><span class="line"> * passing certain @flags may have changed those standard protocol behaviors.</span><br><span class="line"> * Those flags are only for use with broken&#x2F;nonconforming slaves, and with</span><br><span class="line"> * adapters which are known to support the specific mangling options they</span><br><span class="line"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">	__u16 addr;	&#x2F;* slave address			*&#x2F;</span><br><span class="line">	__u16 flags;</span><br><span class="line">#define I2C_M_TEN		0x0010	&#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">#define I2C_M_RD		0x0001	&#x2F;* read data, from slave to master *&#x2F;</span><br><span class="line">#define I2C_M_NOSTART		0x4000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_REV_DIR_ADDR	0x2000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_IGNORE_NAK	0x1000	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_NO_RD_ACK		0x0800	&#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_RECV_LEN		0x0400	&#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">	__u16 len;		&#x2F;* msg length				*&#x2F;</span><br><span class="line">	__u8 *buf;		&#x2F;* pointer to msg data			*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这几个数据结构之间的关系，如何理解？</p>
<p>i2c_client描述一个i2c设备， i2c_adapter描述cpu i2c控制器，i2c_algorithm描述i2c总线的通信时序，i2c_driver描述设备对应的一套操作方法。因此，i2c_adapter与i2c_client是一对多关系，i2c_driver与i2c_client也是一对多关系。一个i2c_driver上可以支持多个同等类型的i2c_client。</p>
<h2 id="目录层次"><a href="#目录层次" class="headerlink" title="目录层次"></a>目录层次</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers\i2c：</span><br><span class="line">i2c-core.c：i2c核心层，设备驱动和总线驱动的桥梁</span><br><span class="line">i2c-dev.c：通用 i2c 设备驱动</span><br><span class="line">busses：开源的 adapter ，比如i2c-omap.c用来初始化i2c控制器，创建adapter</span><br><span class="line">algos：i2c 通信算法</span><br><span class="line"></span><br><span class="line">include\linux\i2c.h：i2c-core.c的接口头文件</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="注册i2c-adapter"><a href="#注册i2c-adapter" class="headerlink" title="注册i2c_adapter"></a>注册i2c_adapter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">		res &#x3D; -EAGAIN;</span><br><span class="line">		goto out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Sanity checks *&#x2F;</span><br><span class="line">	if (unlikely(adap-&gt;name[0] &#x3D;&#x3D; &#39;\0&#39;)) &#123;</span><br><span class="line">		pr_err(&quot;i2c-core: Attempt to register an adapter with &quot;</span><br><span class="line">		       &quot;no name!\n&quot;);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	if (unlikely(!adap-&gt;algo)) &#123;</span><br><span class="line">		pr_err(&quot;i2c-core: Attempt to register adapter &#39;%s&#39; with &quot;</span><br><span class="line">		       &quot;no algo!\n&quot;, adap-&gt;name);</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">	mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);&#x2F;&#x2F;初始化i2c_adapteruserspace_clients链表</span><br><span class="line"></span><br><span class="line">	&#x2F;* Set default timeout to 1 second if not already set *&#x2F;</span><br><span class="line">	if (adap-&gt;timeout &#x3D;&#x3D; 0)</span><br><span class="line">		adap-&gt;timeout &#x3D; HZ;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr); &#x2F;&#x2F;设置adapter名字</span><br><span class="line">	adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;      &#x2F;&#x2F;设置设备的总线类型</span><br><span class="line">	adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type; &#x2F;&#x2F;设置设备的设备类型</span><br><span class="line">	res &#x3D; device_register(&amp;adap-&gt;dev);  &#x2F;&#x2F; 注册设备&#x2F;sys&#x2F;devices&#x2F;i2c-%d</span><br><span class="line">	if (res)</span><br><span class="line">		goto out_list;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	res &#x3D; class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	if (res)</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">			 &quot;Failed to create compatibility class link\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;* create pre-declared device nodes *&#x2F;</span><br><span class="line">	if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		i2c_scan_static_board_info(adap); &#x2F;&#x2F;扫描并创建i2c设备</span><br><span class="line"></span><br><span class="line">	&#x2F;* Notify drivers *&#x2F;</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);&#x2F;&#x2F;遍历每个driver，选择匹配的driver</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="i2c-core初始化"><a href="#i2c-core初始化" class="headerlink" title="i2c-core初始化"></a>i2c-core初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;i2c&quot;,</span><br><span class="line">	.match		&#x3D; i2c_device_match,</span><br><span class="line">	.probe		&#x3D; i2c_device_probe,</span><br><span class="line">	.remove		&#x3D; i2c_device_remove,</span><br><span class="line">	.shutdown	&#x3D; i2c_device_shutdown,</span><br><span class="line">	.pm		&#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"></span><br><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; bus_register(&amp;i2c_bus_type); &#x2F;&#x2F;注册i2c总线</span><br><span class="line">	if (retval)</span><br><span class="line">		return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">	if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval &#x3D; -ENOMEM;</span><br><span class="line">		goto bus_err;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	retval &#x3D; i2c_add_driver(&amp;dummy_driver); &#x2F;&#x2F;注册虚拟bus driver,对象为dummy_driver</span><br><span class="line">	if (retval)</span><br><span class="line">		goto class_err;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line">#endif</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit i2c_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">	class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">#endif</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* We must initialize early, because some subsystems register i2c drivers</span><br><span class="line"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span><br><span class="line"> *&#x2F;</span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>



<h3 id="添加driver"><a href="#添加driver" class="headerlink" title="添加driver"></a>添加driver</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* use a define to avoid include chaining to get THIS_MODULE *&#x2F;</span><br><span class="line">#define i2c_add_driver(driver) \</span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span><br><span class="line"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">	if (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line"></span><br><span class="line">	&#x2F;* add the driver to the list of i2c drivers in the driver core *&#x2F;</span><br><span class="line">	driver-&gt;driver.owner &#x3D; owner;</span><br><span class="line">	driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line"></span><br><span class="line">	&#x2F;* When registration returns, the driver core</span><br><span class="line">	 * will have called probe() for all matching-but-unbound devices.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	res &#x3D; driver_register(&amp;driver-&gt;driver);&#x2F;&#x2F;注册bus driver</span><br><span class="line">	if (res)</span><br><span class="line">		return res;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Drivers should switch to dev_pm_ops instead. *&#x2F;</span><br><span class="line">	if (driver-&gt;suspend)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy suspend method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line">	if (driver-&gt;resume)</span><br><span class="line">		pr_warn(&quot;i2c-core: driver [%s] using legacy resume method\n&quot;,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">	&#x2F;* Walk the adapters that are already present *&#x2F;</span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver); &#x2F;&#x2F;遍历adapter，选择匹配的dev adapter</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_register_driver);</span><br></pre></td></tr></table></figure>



<h3 id="i2c-dev创建"><a href="#i2c-dev创建" class="headerlink" title="i2c-dev创建"></a>i2c-dev创建</h3><p>通用i2c-dev平台的例子drivers\i2c\i2c-dev.c，当然，可以不使用i2c-dev.c，自己创建其他的设备，提供应用层read、write、open等字符设备的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct file_operations i2cdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">	.read		&#x3D; i2cdev_read,</span><br><span class="line">	.write		&#x3D; i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	&#x3D; i2cdev_ioctl,</span><br><span class="line">	.open		&#x3D; i2cdev_open,</span><br><span class="line">	.release	&#x3D; i2cdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* ------------------------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">static struct class *i2c_dev_class;</span><br><span class="line"></span><br><span class="line">static int i2cdev_attach_adapter(struct device *dev, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *adap;</span><br><span class="line">	struct i2c_dev *i2c_dev;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	if (dev-&gt;type !&#x3D; &amp;i2c_adapter_type)</span><br><span class="line">		return 0;</span><br><span class="line">	adap &#x3D; to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	i2c_dev &#x3D; get_free_i2c_dev(adap);</span><br><span class="line">	if (IS_ERR(i2c_dev))</span><br><span class="line">		return PTR_ERR(i2c_dev);</span><br><span class="line"></span><br><span class="line">	&#x2F;* register this i2c device with the driver core *&#x2F;</span><br><span class="line">	i2c_dev-&gt;dev &#x3D; device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">				     MKDEV(I2C_MAJOR, adap-&gt;nr), NULL,</span><br><span class="line">				     &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">	if (IS_ERR(i2c_dev-&gt;dev)) &#123;</span><br><span class="line">		res &#x3D; PTR_ERR(i2c_dev-&gt;dev);</span><br><span class="line">		goto error;</span><br><span class="line">	&#125;</span><br><span class="line">	res &#x3D; device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	if (res)</span><br><span class="line">		goto error_destroy;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	return 0;</span><br><span class="line">error_destroy:</span><br><span class="line">	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line">error:</span><br><span class="line">	return_i2c_dev(i2c_dev);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int i2cdev_detach_adapter(struct device *dev, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_adapter *adap;</span><br><span class="line">	struct i2c_dev *i2c_dev;</span><br><span class="line"></span><br><span class="line">	if (dev-&gt;type !&#x3D; &amp;i2c_adapter_type)</span><br><span class="line">		return 0;</span><br><span class="line">	adap &#x3D; to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	i2c_dev &#x3D; i2c_dev_get_by_minor(adap-&gt;nr);</span><br><span class="line">	if (!i2c_dev) &#x2F;* attach_adapter must have failed *&#x2F;</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	device_remove_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	return_i2c_dev(i2c_dev);</span><br><span class="line">	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;i2c-dev: adapter [%s] unregistered\n&quot;, adap-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,</span><br><span class="line">			 void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev &#x3D; data;</span><br><span class="line"></span><br><span class="line">	switch (action) &#123;</span><br><span class="line">	case BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		return i2cdev_attach_adapter(dev, NULL);</span><br><span class="line">	case BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		return i2cdev_detach_adapter(dev, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct notifier_block i2cdev_notifier &#x3D; &#123;</span><br><span class="line">	.notifier_call &#x3D; i2cdev_notifier_call,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* ------------------------------------------------------------------------- *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * module load&#x2F;unload record keeping</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int __init i2c_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO &quot;i2c &#x2F;dev entries driver\n&quot;);</span><br><span class="line"></span><br><span class="line">	res &#x3D; register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	i2c_dev_class &#x3D; class_create(THIS_MODULE, &quot;i2c-dev&quot;);</span><br><span class="line">	if (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">		res &#x3D; PTR_ERR(i2c_dev_class);</span><br><span class="line">		goto out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Keep track of adapters which will be added or removed later *&#x2F;</span><br><span class="line">	res &#x3D; bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out_unreg_class;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Bind to already existing adapters right away *&#x2F;</span><br><span class="line">	i2c_for_each_dev(NULL, i2cdev_attach_adapter);&#x2F;&#x2F;绑定存在的 i2c 控制器（adapter）</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">	unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">out:</span><br><span class="line">	printk(KERN_ERR &quot;%s: Driver Initialisation failed\n&quot;, __FILE__);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit i2c_dev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	bus_unregister_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	i2c_for_each_dev(NULL, i2cdev_detach_adapter);</span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">	unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(&quot;Frodo Looijaard &lt;frodol@dds.nl&gt; and &quot;</span><br><span class="line">		&quot;Simon G. Vogl &lt;simon@tk.uni-linz.ac.at&gt;&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;I2C &#x2F;dev entries driver&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line">module_init(i2c_dev_init);</span><br><span class="line">module_exit(i2c_dev_exit);</span><br></pre></td></tr></table></figure>



<h2 id="用户空间操作"><a href="#用户空间操作" class="headerlink" title="用户空间操作"></a>用户空间操作</h2><p>1、查看所有i2c设备，nr为adapter的编号，如，nr有0、1、2、3等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # ls -la &#x2F;dev&#x2F;i2c*</span><br><span class="line">crw-rw----    1 root     root       89,   1 Jan  2 14:33 &#x2F;dev&#x2F;i2c-1</span><br></pre></td></tr></table></figure>

<p>2、查询i2c设备地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # ls &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;</span><br><span class="line">1-001b  1-0029  1-0030  1-0032  1-0034  1-0036  1-0048  1-0057  i2c-1</span><br><span class="line">1-0022  1-002d  1-0031  1-0033  1-0035  1-0037  1-004a  1-0076</span><br></pre></td></tr></table></figure>

<p>3、查询i2c设备名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ # cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;i2c-1&#x2F;name</span><br><span class="line">OMAP I2C adapter</span><br><span class="line">查看触摸屏i2c设备名称</span><br><span class="line">~ # cat &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;devices&#x2F;1-004a&#x2F;name</span><br><span class="line">atmel_mxt_ts</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>应用层可以使用i2ctools工具调试i2c设备，参考下面连接</p>
<p>【<a href="https://i2c.wiki.kernel.org/index.php/I2C_Tools】" target="_blank" rel="noopener">https://i2c.wiki.kernel.org/index.php/I2C_Tools】</a></p>
<p>【<a href="https://elinux.org/Interfacing_with_I2C_Devices】" target="_blank" rel="noopener">https://elinux.org/Interfacing_with_I2C_Devices】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>总线设备驱动模型</title>
    <url>/2021/01/15/Linux/Driver/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux 驱动中，bus、device和driver模型应用很广。比如i2c总线、PCI总线 、platform总线等。设计总线设备驱动模型意义在哪里？在一个系统中，会有很多bus,比如i2c、spi,usart等，因此需要有一个通用的平台管理这些总线，总线设备驱动就是建立通用总线的管理平台。每条总线管理driver和device，把设备操作层和通用软件操作隔开，达到driver复用目的。本文简单介绍总线设备驱动模型，总结bus注册、device注册和driver注册的流程。</p>
<h2 id="总线设备驱动模型理解"><a href="#总线设备驱动模型理解" class="headerlink" title="总线设备驱动模型理解"></a>总线设备驱动模型理解</h2><p>总线设备驱动的工作原理如下</p>
<p><img src="http://jiali.clouddn.com/20210115_005.png" alt=""></p>
<p>​                                                                                                                       图 总线设备驱动模型工作原理</p>
<p>device和driver是一对多关系，一个driver，可以匹配多个device.</p>
<p>bus的代码在drivers/base/bus.c中实现。</p>
<h2 id="bus注册"><a href="#bus注册" class="headerlink" title="bus注册"></a>bus注册</h2><p>bus数据结构定义位于include\linux\device.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct bus_type - The bus type of the device</span><br><span class="line"> *</span><br><span class="line"> * @name:	The name of the bus.</span><br><span class="line"> * @bus_attrs:	Default attributes of the bus.</span><br><span class="line"> * @dev_attrs:	Default attributes of the devices on the bus.</span><br><span class="line"> * @drv_attrs:	Default attributes of the device drivers on the bus.</span><br><span class="line"> * @match:	Called, perhaps multiple times, whenever a new device or driver</span><br><span class="line"> *		is added for this bus. It should return a nonzero value if the</span><br><span class="line"> *		given device can be handled by the given driver.</span><br><span class="line"> * @uevent:	Called when a device is added, removed, or a few other things</span><br><span class="line"> *		that generate uevents to add the environment variables.</span><br><span class="line"> * @probe:	Called when a new device or driver add to this bus, and callback</span><br><span class="line"> *		the specific driver&#39;s probe to initial the matched device.</span><br><span class="line"> * @remove:	Called when a device removed from this bus.</span><br><span class="line"> * @shutdown:	Called at shut-down time to quiesce the device.</span><br><span class="line"> * @suspend:	Called when a device on this bus wants to go to sleep mode.</span><br><span class="line"> * @resume:	Called to bring a device on this bus out of sleep mode.</span><br><span class="line"> * @pm:		Power management operations of this bus, callback the specific</span><br><span class="line"> *		device driver&#39;s pm-ops.</span><br><span class="line"> * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU</span><br><span class="line"> *              driver implementations to a bus and allow the driver to do</span><br><span class="line"> *              bus-specific setup</span><br><span class="line"> * @p:		The private data of the driver core, only the driver core can</span><br><span class="line"> *		touch this.</span><br><span class="line"> *</span><br><span class="line"> * A bus is a channel between the processor and one or more devices. For the</span><br><span class="line"> * purposes of the device model, all devices are connected via a bus, even if</span><br><span class="line"> * it is an internal, virtual, &quot;platform&quot; bus. Buses can plug into each other.</span><br><span class="line"> * A USB controller is usually a PCI device, for example. The device model</span><br><span class="line"> * represents the actual connections between buses and the devices they control.</span><br><span class="line"> * A bus is represented by the bus_type structure. It contains the name, the</span><br><span class="line"> * default attributes, the bus&#39; methods, PM operations, and the driver core&#39;s</span><br><span class="line"> * private data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct bus_type &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	struct bus_attribute	*bus_attrs;</span><br><span class="line">	struct device_attribute	*dev_attrs;</span><br><span class="line">	struct driver_attribute	*drv_attrs;</span><br><span class="line"></span><br><span class="line">	int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">	int (*probe)(struct device *dev);</span><br><span class="line">	int (*remove)(struct device *dev);</span><br><span class="line">	void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	struct iommu_ops *iommu_ops;</span><br><span class="line"></span><br><span class="line">	struct subsys_private *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bus注册函数接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * bus_register - register a bus with the system.</span><br><span class="line"> * @bus: bus.</span><br><span class="line"> *</span><br><span class="line"> * Once we have that, we registered the bus with the kobject</span><br><span class="line"> * infrastructure, then register the children subsystems it has:</span><br><span class="line"> * the devices and drivers that belong to the bus.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int bus_register(struct bus_type *bus)</span><br><span class="line">&#123;</span><br><span class="line">	int retval;</span><br><span class="line">	struct subsys_private *priv;</span><br><span class="line"></span><br><span class="line">	priv &#x3D; kzalloc(sizeof(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	if (!priv)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	priv-&gt;bus &#x3D; bus;</span><br><span class="line">	bus-&gt;p &#x3D; priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval &#x3D; kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);</span><br><span class="line">	if (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset &#x3D; bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype &#x3D; &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	if (retval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">	priv-&gt;devices_kset &#x3D; kset_create_and_add(&quot;devices&quot;, NULL,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	if (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval &#x3D; -ENOMEM;</span><br><span class="line">		goto bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset &#x3D; kset_create_and_add(&quot;drivers&quot;, NULL,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	if (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval &#x3D; -ENOMEM;</span><br><span class="line">		goto bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);</span><br><span class="line"></span><br><span class="line">	retval &#x3D; add_probe_files(bus);</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval &#x3D; bus_add_attrs(bus);</span><br><span class="line">	if (retval)</span><br><span class="line">		goto bus_attrs_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;bus: &#39;%s&#39;: registered\n&quot;, bus-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">bus_attrs_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p &#x3D; NULL;</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>



<h2 id="device注册"><a href="#device注册" class="headerlink" title="device注册"></a>device注册</h2><p>device 数据结构的定义位于include\linux\device.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct device - The basic device structure</span><br><span class="line"> * @parent:	The device&#39;s &quot;parent&quot; device, the device to which it is attached.</span><br><span class="line"> * 		In most cases, a parent device is some sort of bus or host</span><br><span class="line"> * 		controller. If parent is NULL, the device, is a top-level device,</span><br><span class="line"> * 		which is not usually what you want.</span><br><span class="line"> * @p:		Holds the private data of the driver core portions of the device.</span><br><span class="line"> * 		See the comment of the struct device_private for detail.</span><br><span class="line"> * @kobj:	A top-level, abstract class from which other classes are derived.</span><br><span class="line"> * @init_name:	Initial name of the device.</span><br><span class="line"> * @type:	The type of device.</span><br><span class="line"> * 		This identifies the device type and carries type-specific</span><br><span class="line"> * 		information.</span><br><span class="line"> * @mutex:	Mutex to synchronize calls to its driver.</span><br><span class="line"> * @bus:	Type of bus device is on.</span><br><span class="line"> * @driver:	Which driver has allocated this</span><br><span class="line"> * @platform_data: Platform data specific to the device.</span><br><span class="line"> * 		Example: For devices on custom boards, as typical of embedded</span><br><span class="line"> * 		and SOC based hardware, Linux often uses platform_data to point</span><br><span class="line"> * 		to board-specific structures describing devices and how they</span><br><span class="line"> * 		are wired.  That can include what ports are available, chip</span><br><span class="line"> * 		variants, which GPIO pins act in what additional roles, and so</span><br><span class="line"> * 		on.  This shrinks the &quot;Board Support Packages&quot; (BSPs) and</span><br><span class="line"> * 		minimizes board-specific #ifdefs in drivers.</span><br><span class="line"> * @power:	For device power management.</span><br><span class="line"> * 		See Documentation&#x2F;power&#x2F;devices.txt for details.</span><br><span class="line"> * @pm_domain:	Provide callbacks that are executed during system suspend,</span><br><span class="line"> * 		hibernation, system resume and during runtime PM transitions</span><br><span class="line"> * 		along with subsystem-level and driver-level callbacks.</span><br><span class="line"> * @numa_node:	NUMA node this device is close to.</span><br><span class="line"> * @dma_mask:	Dma mask (if dma&#39;ble device).</span><br><span class="line"> * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all</span><br><span class="line"> * 		hardware supports 64-bit addresses for consistent allocations</span><br><span class="line"> * 		such descriptors.</span><br><span class="line"> * @dma_parms:	A low level driver may set these to teach IOMMU code about</span><br><span class="line"> * 		segment limitations.</span><br><span class="line"> * @dma_pools:	Dma pools (if dma&#39;ble device).</span><br><span class="line"> * @dma_mem:	Internal for coherent mem override.</span><br><span class="line"> * @archdata:	For arch-specific additions.</span><br><span class="line"> * @of_node:	Associated device tree node.</span><br><span class="line"> * @devt:	For creating the sysfs &quot;dev&quot;.</span><br><span class="line"> * @devres_lock: Spinlock to protect the resource of the device.</span><br><span class="line"> * @devres_head: The resources list of the device.</span><br><span class="line"> * @knode_class: The node used to add the device to the class list.</span><br><span class="line"> * @class:	The class of the device.</span><br><span class="line"> * @groups:	Optional attribute groups.</span><br><span class="line"> * @release:	Callback to free the device after all references have</span><br><span class="line"> * 		gone away. This should be set by the allocator of the</span><br><span class="line"> * 		device (i.e. the bus driver that discovered the device).</span><br><span class="line"> *</span><br><span class="line"> * At the lowest level, every device in a Linux system is represented by an</span><br><span class="line"> * instance of struct device. The device structure contains the information</span><br><span class="line"> * that the device model core needs to model the system. Most subsystems,</span><br><span class="line"> * however, track additional information about the devices they host. As a</span><br><span class="line"> * result, it is rare for devices to be represented by bare device structures;</span><br><span class="line"> * instead, that structure, like kobject structures, is usually embedded within</span><br><span class="line"> * a higher-level representation of the device.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct device &#123;</span><br><span class="line">	struct device		*parent;</span><br><span class="line"></span><br><span class="line">	struct device_private	*p;</span><br><span class="line"></span><br><span class="line">	struct kobject kobj;</span><br><span class="line">	const char		*init_name; &#x2F;* initial name of the device *&#x2F;</span><br><span class="line">	const struct device_type *type;</span><br><span class="line"></span><br><span class="line">	struct mutex		mutex;	&#x2F;* mutex to synchronize calls to</span><br><span class="line">					 * its driver.</span><br><span class="line">					 *&#x2F;</span><br><span class="line"></span><br><span class="line">	struct bus_type	*bus;		&#x2F;* type of bus device is on *&#x2F;</span><br><span class="line">	struct device_driver *driver;	&#x2F;* which driver has allocated this</span><br><span class="line">					   device *&#x2F;</span><br><span class="line">	void		*platform_data;	&#x2F;* Platform specific data, device</span><br><span class="line">					   core doesn&#39;t touch it *&#x2F;</span><br><span class="line">	struct dev_pm_info	power;</span><br><span class="line">	struct dev_pm_domain	*pm_domain;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">	int		numa_node;	&#x2F;* NUMA node this device is close to *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	u64		*dma_mask;	&#x2F;* dma mask (if dma&#39;able device) *&#x2F;</span><br><span class="line">	u64		coherent_dma_mask;&#x2F;* Like dma_mask, but for</span><br><span class="line">					     alloc_coherent mappings as</span><br><span class="line">					     not all hardware supports</span><br><span class="line">					     64 bit addresses for consistent</span><br><span class="line">					     allocations such descriptors. *&#x2F;</span><br><span class="line"></span><br><span class="line">	struct device_dma_parameters *dma_parms;</span><br><span class="line"></span><br><span class="line">	struct list_head	dma_pools;	&#x2F;* dma pools (if dma&#39;ble) *&#x2F;</span><br><span class="line"></span><br><span class="line">	struct dma_coherent_mem	*dma_mem; &#x2F;* internal for coherent mem</span><br><span class="line">					     override *&#x2F;</span><br><span class="line">	&#x2F;* arch specific additions *&#x2F;</span><br><span class="line">	struct dev_archdata	archdata;</span><br><span class="line"></span><br><span class="line">	struct device_node	*of_node; &#x2F;* associated device tree node *&#x2F;</span><br><span class="line"></span><br><span class="line">	dev_t			devt;	&#x2F;* dev_t, creates the sysfs &quot;dev&quot; *&#x2F;</span><br><span class="line"></span><br><span class="line">	spinlock_t		devres_lock;</span><br><span class="line">	struct list_head	devres_head;</span><br><span class="line"></span><br><span class="line">	struct klist_node	knode_class;</span><br><span class="line">	struct class		*class;</span><br><span class="line">	const struct attribute_group **groups;	&#x2F;* optional groups *&#x2F;</span><br><span class="line"></span><br><span class="line">	void	(*release)(struct device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出device的数据结构相当复杂。</p>
<p>向总线添加一个设备接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * bus_add_device - add device to bus</span><br><span class="line"> * @dev: device being added</span><br><span class="line"> *</span><br><span class="line"> * - Add device&#39;s bus attributes.</span><br><span class="line"> * - Create links to device&#39;s bus.</span><br><span class="line"> * - Add the device to its bus&#39;s list of devices.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int bus_add_device(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct bus_type *bus &#x3D; bus_get(dev-&gt;bus);</span><br><span class="line">	int error &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (bus) &#123;</span><br><span class="line">		pr_debug(&quot;bus: &#39;%s&#39;: add device %s\n&quot;, bus-&gt;name, dev_name(dev));</span><br><span class="line">		error &#x3D; device_add_attrs(bus, dev);</span><br><span class="line">		if (error)</span><br><span class="line">			goto out_put;</span><br><span class="line">		error &#x3D; sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">						&amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">		if (error)</span><br><span class="line">			goto out_id;</span><br><span class="line">		error &#x3D; sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);</span><br><span class="line">		if (error)</span><br><span class="line">			goto out_subsys;</span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">	sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_id:</span><br><span class="line">	device_remove_attrs(bus, dev);</span><br><span class="line">out_put:</span><br><span class="line">	bus_put(dev-&gt;bus);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>驱动程序注册一个设备：device_register(struct device *dev)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int device_register(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    return device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int device_add(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">     bus_add_device(dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="driver注册"><a href="#driver注册" class="headerlink" title="driver注册"></a>driver注册</h2><p>driver的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct device_driver - The basic device driver structure</span><br><span class="line"> * @name:	Name of the device driver.</span><br><span class="line"> * @bus:	The bus which the device of this driver belongs to.</span><br><span class="line"> * @owner:	The module owner.</span><br><span class="line"> * @mod_name:	Used for built-in modules.</span><br><span class="line"> * @suppress_bind_attrs: Disables bind&#x2F;unbind via sysfs.</span><br><span class="line"> * @of_match_table: The open firmware table.</span><br><span class="line"> * @probe:	Called to query the existence of a specific device,</span><br><span class="line"> *		whether this driver can work with it, and bind the driver</span><br><span class="line"> *		to a specific device.</span><br><span class="line"> * @remove:	Called when the device is removed from the system to</span><br><span class="line"> *		unbind a device from this driver.</span><br><span class="line"> * @shutdown:	Called at shut-down time to quiesce the device.</span><br><span class="line"> * @suspend:	Called to put the device to sleep mode. Usually to a</span><br><span class="line"> *		low power state.</span><br><span class="line"> * @resume:	Called to bring a device from sleep mode.</span><br><span class="line"> * @groups:	Default attributes that get created by the driver core</span><br><span class="line"> *		automatically.</span><br><span class="line"> * @pm:		Power management operations of the device which matched</span><br><span class="line"> *		this driver.</span><br><span class="line"> * @p:		Driver core&#39;s private data, no one other than the driver</span><br><span class="line"> *		core can touch this.</span><br><span class="line"> *</span><br><span class="line"> * The device driver-model tracks all of the drivers known to the system.</span><br><span class="line"> * The main reason for this tracking is to enable the driver core to match</span><br><span class="line"> * up drivers with new devices. Once drivers are known objects within the</span><br><span class="line"> * system, however, a number of other things become possible. Device drivers</span><br><span class="line"> * can export information and configuration variables that are independent</span><br><span class="line"> * of any specific device.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct device_driver &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	struct bus_type		*bus;</span><br><span class="line"></span><br><span class="line">	struct module		*owner;</span><br><span class="line">	const char		*mod_name;	&#x2F;* used for built-in modules *&#x2F;</span><br><span class="line"></span><br><span class="line">	bool suppress_bind_attrs;	&#x2F;* disables bind&#x2F;unbind via sysfs *&#x2F;</span><br><span class="line"></span><br><span class="line">	const struct of_device_id	*of_match_table;</span><br><span class="line"></span><br><span class="line">	int (*probe) (struct device *dev);</span><br><span class="line">	int (*remove) (struct device *dev);</span><br><span class="line">	void (*shutdown) (struct device *dev);</span><br><span class="line">	int (*suspend) (struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume) (struct device *dev);</span><br><span class="line">	const struct attribute_group **groups;</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	struct driver_private *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>向总线添加一个driver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * bus_add_driver - Add a driver to the bus.</span><br><span class="line"> * @drv: driver.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int bus_add_driver(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	struct bus_type *bus;</span><br><span class="line">	struct driver_private *priv;</span><br><span class="line">	int error &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	bus &#x3D; bus_get(drv-&gt;bus);</span><br><span class="line">	if (!bus)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;bus: &#39;%s&#39;: add driver %s\n&quot;, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	priv &#x3D; kzalloc(sizeof(*priv), GFP_KERNEL);</span><br><span class="line">	if (!priv) &#123;</span><br><span class="line">		error &#x3D; -ENOMEM;</span><br><span class="line">		goto out_put_bus;</span><br><span class="line">	&#125;</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);</span><br><span class="line">	priv-&gt;driver &#x3D; drv;</span><br><span class="line">	drv-&gt;p &#x3D; priv;</span><br><span class="line">	priv-&gt;kobj.kset &#x3D; bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">	error &#x3D; kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</span><br><span class="line">				     &quot;%s&quot;, drv-&gt;name);</span><br><span class="line">	if (error)</span><br><span class="line">		goto out_unregister;</span><br><span class="line"></span><br><span class="line">	if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">		error &#x3D; driver_attach(drv);</span><br><span class="line">		if (error)</span><br><span class="line">			goto out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">	module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">	error &#x3D; driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;%s: uevent attr (%s) failed\n&quot;,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	error &#x3D; driver_add_attrs(bus, drv);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		&#x2F;* How the hell do we get out of this pickle? Give up *&#x2F;</span><br><span class="line">		printk(KERN_ERR &quot;%s: driver_add_attrs(%s) failed\n&quot;,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">		error &#x3D; add_bind_files(drv);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			&#x2F;* Ditto *&#x2F;</span><br><span class="line">			printk(KERN_ERR &quot;%s: add_bind_files(%s) failed\n&quot;,</span><br><span class="line">				__func__, drv-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">	kfree(drv-&gt;p);</span><br><span class="line">	drv-&gt;p &#x3D; NULL;</span><br><span class="line">out_put_bus:</span><br><span class="line">	bus_put(bus);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>驱动程序向总线注册一个driver:driver_register(struct device_driver *drv)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * driver_register - register driver with bus</span><br><span class="line"> * @drv: driver to register</span><br><span class="line"> *</span><br><span class="line"> * We pass off most of the work to the bus_add_driver() call,</span><br><span class="line"> * since most of the things we have to do deal with the bus</span><br><span class="line"> * structures.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int driver_register(struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct device_driver *other;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!drv-&gt;bus-&gt;p);</span><br><span class="line"></span><br><span class="line">	if ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">	    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">		printk(KERN_WARNING &quot;Driver &#39;%s&#39; needs updating - please use &quot;</span><br><span class="line">			&quot;bus_type methods\n&quot;, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	other &#x3D; driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">	if (other) &#123;</span><br><span class="line">		put_driver(other);</span><br><span class="line">		printk(KERN_ERR &quot;Error: Driver &#39;%s&#39; is already registered, &quot;</span><br><span class="line">			&quot;aborting...\n&quot;, drv-&gt;name);</span><br><span class="line">		return -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; bus_add_driver(drv);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line">	ret &#x3D; driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">	if (ret)</span><br><span class="line">		bus_remove_driver(drv);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>设备驱动模型</category>
      </categories>
      <tags>
        <tag>bus</tag>
      </tags>
  </entry>
  <entry>
    <title>nordic Soc Ble协议栈介绍</title>
    <url>/2020/10/10/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/nordic%20Soc%20Ble%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nordic 厂家提供的sdk，分为两部分，一部分是蓝牙协议栈以Hex格式提供，可以单独烧录；另一部份是应用程序，应用程序只需要通过SVC宏调用协议栈的接口函数就可以了。蓝牙协议栈可以单独编译，应用层单独编译时候，不在重新编译蓝牙协议栈。本文简单介绍nordic sdk 软件框架。</p>
<h2 id="nordic-Soc-SDK框架"><a href="#nordic-Soc-SDK框架" class="headerlink" title="nordic Soc SDK框架"></a>nordic Soc SDK框架</h2><p>本文是根据S132协议栈来介绍。The S132 SoftDevice is a precompiled and linked binary image implementing a Bluetooth 5.1 Low Energy<br>protocol stack for the nRF52 Series of SoCs。</p>
<p>SDK框架如下</p>
<p><img src="http://jiali.clouddn.com/20201010.png" alt=""></p>
<p>It includes the standard ARM Cortex Microcontroller Software Interface Standard (CMSIS) interface for nRF52 hardware, the MBR, profile and application code, application specific peripheral drivers, and a firmware module identified as a SoftDevice。</p>
<ul>
<li>nRF SoftDevice 提供的API接口用SVCALL声明，API以头文件的形式提供。</li>
<li>nRF SoftDevice以hex文件格式提供给用户</li>
</ul>
<p>A SoftDevice consists of three main components:<br>• SoC Library: implementation and nRF Application Programming Interface (API) for shared hardware<br>resource management (application coexistence)<br>• SoftDevice Manager (SDM): implementation and nRF API for SoftDevice management (enabling/<br>disabling the SoftDevice, etc.)<br>• Bluetooth 5.1 Low Energy protocol stack: implementation of protocol stack and API</p>
<h2 id="应用程序编程接口"><a href="#应用程序编程接口" class="headerlink" title="应用程序编程接口"></a>应用程序编程接口</h2><p>应用层调用协议栈提供的接口，是通过SVC中断实现。通过SVC中断，找到API接口对应的内存位置，然后执行。</p>
<p>应用层调用协议栈函数流程如下图。</p>
<p><img src="http://jiali.clouddn.com/20201010_002.png" alt=""></p>
<p><strong><em>1、协议栈提供两种类型接口：</em></strong></p>
<ul>
<li>操作Soc外设，比如flash</li>
<li>ble低功耗蓝牙</li>
</ul>
<p><strong>2、SVC number的范围</strong></p>
<p><img src="http://jiali.clouddn.com/20201010_003.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note: The SVC number allocation does not change with the state of the SoftDevice (enabled or</span><br><span class="line">disabled).</span><br></pre></td></tr></table></figure>

<p>协议栈使用0x10<del>0xff，应用层使用0x00</del>0x0f。</p>
<p>协议栈使用SVC number的范围在ble_ranges.h定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define BLE_SVC_BASE           0x60       &#x2F;**&lt; Common BLE SVC base. *&#x2F;</span><br><span class="line">#define BLE_SVC_LAST           0x6B       &#x2F;**&lt; Common BLE SVC last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GAP_SVC_BASE       0x6C       &#x2F;**&lt; GAP BLE SVC base. *&#x2F;</span><br><span class="line">#define BLE_GAP_SVC_LAST       0x9A       &#x2F;**&lt; GAP BLE SVC last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTC_SVC_BASE     0x9B       &#x2F;**&lt; GATTC BLE SVC base. *&#x2F;</span><br><span class="line">#define BLE_GATTC_SVC_LAST     0xA7       &#x2F;**&lt; GATTC BLE SVC last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTS_SVC_BASE     0xA8       &#x2F;**&lt; GATTS BLE SVC base. *&#x2F;</span><br><span class="line">#define BLE_GATTS_SVC_LAST     0xB7       &#x2F;**&lt; GATTS BLE SVC last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_L2CAP_SVC_BASE     0xB8       &#x2F;**&lt; L2CAP BLE SVC base. *&#x2F;</span><br><span class="line">#define BLE_L2CAP_SVC_LAST     0xBF       &#x2F;**&lt; L2CAP BLE SVC last. *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define BLE_EVT_INVALID        0x00       &#x2F;**&lt; Invalid BLE Event. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_EVT_BASE           0x01       &#x2F;**&lt; Common BLE Event base. *&#x2F;</span><br><span class="line">#define BLE_EVT_LAST           0x0F       &#x2F;**&lt; Common BLE Event last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GAP_EVT_BASE       0x10       &#x2F;**&lt; GAP BLE Event base. *&#x2F;</span><br><span class="line">#define BLE_GAP_EVT_LAST       0x2F       &#x2F;**&lt; GAP BLE Event last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTC_EVT_BASE     0x30       &#x2F;**&lt; GATTC BLE Event base. *&#x2F;</span><br><span class="line">#define BLE_GATTC_EVT_LAST     0x4F       &#x2F;**&lt; GATTC BLE Event last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTS_EVT_BASE     0x50       &#x2F;**&lt; GATTS BLE Event base. *&#x2F;</span><br><span class="line">#define BLE_GATTS_EVT_LAST     0x6F       &#x2F;**&lt; GATTS BLE Event last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_L2CAP_EVT_BASE     0x70       &#x2F;**&lt; L2CAP BLE Event base. *&#x2F;</span><br><span class="line">#define BLE_L2CAP_EVT_LAST     0x8F       &#x2F;**&lt; L2CAP BLE Event last. *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define BLE_OPT_INVALID        0x00       &#x2F;**&lt; Invalid BLE Option. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_OPT_BASE           0x01       &#x2F;**&lt; Common BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_OPT_LAST           0x1F       &#x2F;**&lt; Common BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GAP_OPT_BASE       0x20       &#x2F;**&lt; GAP BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_GAP_OPT_LAST       0x3F       &#x2F;**&lt; GAP BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATT_OPT_BASE      0x40       &#x2F;**&lt; GATT BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_GATT_OPT_LAST      0x5F       &#x2F;**&lt; GATT BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTC_OPT_BASE     0x60       &#x2F;**&lt; GATTC BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_GATTC_OPT_LAST     0x7F       &#x2F;**&lt; GATTC BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTS_OPT_BASE     0x80       &#x2F;**&lt; GATTS BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_GATTS_OPT_LAST     0x9F       &#x2F;**&lt; GATTS BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_L2CAP_OPT_BASE     0xA0       &#x2F;**&lt; L2CAP BLE Option base. *&#x2F;</span><br><span class="line">#define BLE_L2CAP_OPT_LAST     0xBF       &#x2F;**&lt; L2CAP BLE Option last. *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define BLE_CFG_INVALID        0x00       &#x2F;**&lt; Invalid BLE configuration. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_CFG_BASE           0x01       &#x2F;**&lt; Common BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_CFG_LAST           0x1F       &#x2F;**&lt; Common BLE configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_CONN_CFG_BASE      0x20       &#x2F;**&lt; BLE connection configuration base. *&#x2F;</span><br><span class="line">#define BLE_CONN_CFG_LAST      0x3F       &#x2F;**&lt; BLE connection configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GAP_CFG_BASE       0x40       &#x2F;**&lt; GAP BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_GAP_CFG_LAST       0x5F       &#x2F;**&lt; GAP BLE configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATT_CFG_BASE      0x60       &#x2F;**&lt; GATT BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_GATT_CFG_LAST      0x7F       &#x2F;**&lt; GATT BLE configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTC_CFG_BASE     0x80       &#x2F;**&lt; GATTC BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_GATTC_CFG_LAST     0x9F       &#x2F;**&lt; GATTC BLE configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_GATTS_CFG_BASE     0xA0       &#x2F;**&lt; GATTS BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_GATTS_CFG_LAST     0xBF       &#x2F;**&lt; GATTS BLE configuration last. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define BLE_L2CAP_CFG_BASE     0xC0       &#x2F;**&lt; L2CAP BLE configuration base. *&#x2F;</span><br><span class="line">#define BLE_L2CAP_CFG_LAST     0xDF       &#x2F;**&lt; L2CAP BLE configuration last. *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="硬件外设资源访问"><a href="#硬件外设资源访问" class="headerlink" title="硬件外设资源访问"></a>硬件外设资源访问</h2><p><strong>1、Soc的外设资源访问</strong></p>
<p>在协议栈开启下，应用程序并不能访问所有的Soc外设资源。下面列出协议栈在开启与不开启的情况下，应用程序能访问的硬件外设资源。</p>
<p><img src="http://jiali.clouddn.com/20201010_008.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201010_004.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note: Some of the peripherals in this table are not present on all devices. For a complete</span><br><span class="line">overview of the peripherals on a device, see the relevant product specification (Table 1: Additional</span><br><span class="line">documentation on page 14).</span><br></pre></td></tr></table></figure>

<p><strong>2、软中断资源访问</strong></p>
<p>Software interrupts are used by the SoftDevice to signal events to the application。</p>
<p>Allocation of software interrupt vectors to SoftDevice signals如下图。</p>
<p><img src="http://jiali.clouddn.com/20201010_007.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nordic协议栈不熟悉情况下，出现问题，不知道怎么排查。因为协议栈封装后，根本不知道底层实现细节，而且协议栈也使用了一些硬件外设资源。初级开发者，容易使用协议栈占用的硬件资源，从而导致程序异常。因此，需要阅读《SoftDevice Specification》来了解协议栈</p>
<p>参考：</p>
<p><a href="http://wywiot.com/nordic-ble-soc-sw-primary-sd/" target="_blank" rel="noopener">NORDIC BLE SOC 软件入门-协议栈</a></p>
<p><a href="https://blog.csdn.net/wulazula/article/details/80847262" target="_blank" rel="noopener">Nordic协议栈与应用层API的实现方式</a></p>
<p><a href="https://blog.csdn.net/wulazula/article/details/80280855" target="_blank" rel="noopener">协议栈与app的调用方式</a></p>
<p>《SoftDevice Specification》第七章System on Chip resource requirements、</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
  <entry>
    <title>application timer深入分析</title>
    <url>/2020/09/30/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/application%20timer%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nRF52382,有两个外部晶振，一个为32.768kHz,另一个为32MHz。程序是在高频时钟32MHz下运行，而低频时钟32.768kHz提供时基供调度使用。之所以提供两个外部时钟，是为了芯片进入休眠后，减少功耗。芯片进入休眠，关闭32Mhz时钟，使用低频时钟来保持程序调度，达到了减少功耗目的。nRF52 SDK,使用了RTC0、RTC1和timer0定时器，其中，RTC1提供软件定时，暴露给用户使用,RTC0和timer0是蓝牙协议栈内部使用，用户看不到。下面分析基于RTC1的app_timer软件定时器的实现过程。</p>
<h2 id="app-timer-原理"><a href="#app-timer-原理" class="headerlink" title="app_timer 原理"></a>app_timer 原理</h2><p><strong>定时原理</strong></p>
<p>app_timer软件定时器是根据实时计数器RTC1比较事件来实现定时。nRF52382 实时计数器RTC拥有一个24位的计数器。RTC启动后，app_timer,通过不断调整比较寄存器CC0的值，计数器的值与比较的值匹配后，产生中断，处理app_timer设置的回调函数。</p>
<p>计数器的值与比较的值匹配，产生匹配事件，如下图所示：</p>
<p><img src="http://jiali.clouddn.com/20200930_001.png" alt=""></p>
<p>​                                                                                                                    COMPARE事件时序图</p>
<p><strong>app_timer软件设计</strong></p>
<p>软件定时器处理流程如下</p>
<p><img src="http://jiali.clouddn.com/20200930_002.png" alt="20200930_002"></p>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>初始化过程分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">|---&gt;timers_init()</span><br><span class="line">|   初始化app定时器</span><br><span class="line">	|---&gt;app_timer_init()</span><br><span class="line">	|   初始化RTC1，建立RTC1中断回调函数rtc_irq()</span><br><span class="line">	|---&gt;app_timer_create()</span><br><span class="line">	|   创建app超时事件处理回调函数,处理用户业务</span><br><span class="line">|---&gt;application_timers_start()</span><br><span class="line">|   启动创建的定时器</span><br><span class="line">    |---&gt;app_timer_start()</span><br><span class="line">    |    1、timer比较值</span><br><span class="line">    |    2、软件触发产生中断，提交timer请求</span><br><span class="line">        |---&gt;timer_req_schedule()</span><br><span class="line">        |    1、申请请求对象，然后放入FIFO</span><br><span class="line">        |    2、提交请求</span><br><span class="line">            |---&gt;timer_request_proc_trigger()</span><br><span class="line">            |   |---&gt; drv_rtc_irq_trigger()</span><br><span class="line">            |       |---&gt;NVIC_SetPendingIRQ(p_instance-&gt;irq)</span><br><span class="line">                    |   软件触发产生中断</span><br></pre></td></tr></table></figure>

<p>RTC1 中断处理过程分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drv_rtc_rtc_1_irq_handler</span><br><span class="line">|RTC1中断函数入口，在中断里面执行回调函数</span><br><span class="line">|---&gt;rtc_irq()</span><br><span class="line">    |---&gt;on_overflow_evt()</span><br><span class="line">    |    执行计数溢出事件</span><br><span class="line">    |---&gt;on_compare_evt()</span><br><span class="line">    |    执行CC0寄存器比较事件</span><br><span class="line">    |---&gt;on_compare1_evt()</span><br><span class="line">    |    执行CC1寄存器比较事件</span><br><span class="line">    |---&gt;timer_req_process()</span><br><span class="line">    |    处理app timer请求，并加入链表，标记为活动timer</span><br><span class="line">    |---&gt;rtc_update()</span><br><span class="line">    |    调度timer,并更新rtc1 CC0值</span><br><span class="line">        |---&gt;rtc_schedule()</span><br><span class="line">        |    比较值设置</span><br></pre></td></tr></table></figure>

<h2 id="关键代码注释"><a href="#关键代码注释" class="headerlink" title="关键代码注释"></a>关键代码注释</h2><p><strong>app_timer_init()函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret_code_t app_timer_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t err_code;</span><br><span class="line">    drv_rtc_config_t config &#x3D; &#123;</span><br><span class="line">        .prescaler          &#x3D; APP_TIMER_CONFIG_RTC_FREQUENCY,&#x2F;&#x2F;分频系数</span><br><span class="line">        .interrupt_priority &#x3D; APP_TIMER_CONFIG_IRQ_PRIORITY&#x2F;&#x2F;优先级</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; NRF_ATFIFO_INIT(m_req_fifo);</span><br><span class="line">    if (err_code !&#x3D; NRFX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        return err_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; drv_rtc_init(&amp;m_rtc_inst, &amp;config, rtc_irq); &#x2F;&#x2F;设置回调函数rtc_irq,在中断入口函数会执行回调函数</span><br><span class="line">    if (err_code !&#x3D; NRFX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        return err_code;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_rtc_overflow_enable(&amp;m_rtc_inst, true);</span><br><span class="line">	drv_rtc_compare_set(&amp;m_rtc_inst, 1, DRV_RTC_MAX_CNT &gt;&gt; 1, true);</span><br><span class="line">    if (APP_TIMER_KEEPS_RTC_ACTIVE)&#x2F;&#x2F;是否把RTC1设置为一直运行的状态</span><br><span class="line">    &#123;</span><br><span class="line">        drv_rtc_start(&amp;m_rtc_inst);&#x2F;&#x2F;启动RTC1计数器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_global_active &#x3D; true;</span><br><span class="line">    return err_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret_code_t drv_rtc_init(drv_rtc_t const * const  p_instance,</span><br><span class="line">                        drv_rtc_config_t const * p_config,</span><br><span class="line">                        drv_rtc_handler_t        handler)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(p_instance);</span><br><span class="line">    ASSERT(p_config);</span><br><span class="line">    ASSERT(handler);</span><br><span class="line"></span><br><span class="line">    ret_code_t err_code;</span><br><span class="line"></span><br><span class="line">    m_handlers[p_instance-&gt;instance_id] &#x3D; handler; &#x2F;&#x2F;存储回调函数</span><br><span class="line"></span><br><span class="line">    if (m_cb[p_instance-&gt;instance_id].state !&#x3D; NRFX_DRV_STATE_UNINITIALIZED)</span><br><span class="line">    &#123;</span><br><span class="line">        err_code &#x3D; NRF_ERROR_INVALID_STATE;</span><br><span class="line">        NRF_LOG_WARNING(&quot;RTC instance already initialized.&quot;);</span><br><span class="line">        return err_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nrf_rtc_prescaler_set(p_instance-&gt;p_reg, p_config-&gt;prescaler);</span><br><span class="line">    NRFX_IRQ_PRIORITY_SET(p_instance-&gt;irq, p_config-&gt;interrupt_priority);</span><br><span class="line">    NRFX_IRQ_ENABLE(p_instance-&gt;irq);</span><br><span class="line"></span><br><span class="line">    m_cb[p_instance-&gt;instance_id].state &#x3D; NRFX_DRV_STATE_INITIALIZED;</span><br><span class="line">    m_cb[p_instance-&gt;instance_id].p_instance &#x3D; p_instance;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; NRF_SUCCESS;</span><br><span class="line">    NRF_LOG_INFO(&quot;RTC: initialized.&quot;);</span><br><span class="line">    return err_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;RTC回调函数，RTC1中断入口调用该函数</span><br><span class="line">static void rtc_irq(drv_rtc_t const * const  p_instance)</span><br><span class="line">&#123;</span><br><span class="line">    if (drv_rtc_overflow_pending(p_instance))&#x2F;&#x2F;发生溢出事件</span><br><span class="line">    &#123;</span><br><span class="line">        on_overflow_evt();</span><br><span class="line">    &#125;</span><br><span class="line">    if (drv_rtc_compare_pending(p_instance, 0))&#x2F;&#x2F;发生CC0比较事件</span><br><span class="line">    &#123;</span><br><span class="line">        on_compare_evt(p_instance);</span><br><span class="line">    &#125;</span><br><span class="line">    if (drv_rtc_compare_pending(p_instance, 1))&#x2F;&#x2F;发生CC1比较事件</span><br><span class="line">    &#123;</span><br><span class="line">        on_compare1_evt(p_instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer_req_process(p_instance);  &#x2F;&#x2F;处理请求</span><br><span class="line">    rtc_update(p_instance);  &#x2F;&#x2F;调度app timer，更新比较值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>app_timer_start()函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret_code_t app_timer_start(app_timer_t * p_timer, uint32_t timeout_ticks, void * p_context)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(p_timer);</span><br><span class="line">    app_timer_t * p_t &#x3D; (app_timer_t *) p_timer;</span><br><span class="line"></span><br><span class="line">    if (p_t-&gt;active)</span><br><span class="line">    &#123;</span><br><span class="line">        return NRF_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p_t-&gt;p_context &#x3D; p_context;</span><br><span class="line">    p_t-&gt;end_val &#x3D; get_now() + timeout_ticks;&#x2F;&#x2F;设置app timer 时间戳</span><br><span class="line"></span><br><span class="line">    if (p_t-&gt;repeat_period)</span><br><span class="line">    &#123;</span><br><span class="line">        p_t-&gt;repeat_period &#x3D; timeout_ticks; &#x2F;&#x2F;设置循环运行的周期</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return timer_req_schedule(TIMER_REQ_START, p_t);&#x2F;&#x2F;软件触发RTC1中断,发起timer请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @brief Function for putting user request into the request queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ret_code_t timer_req_schedule(app_timer_req_type_t type, app_timer_t * p_timer)</span><br><span class="line">&#123;</span><br><span class="line">    nrf_atfifo_item_put_t fifo_ctx;</span><br><span class="line">    timer_req_t * p_req;</span><br><span class="line">#if APP_TIMER_WITH_PROFILER</span><br><span class="line">    CRITICAL_REGION_ENTER();</span><br><span class="line">#endif</span><br><span class="line">    p_req &#x3D; nrf_atfifo_item_alloc(m_req_fifo, &amp;fifo_ctx);  &#x2F;&#x2F;申请请求对象资源</span><br><span class="line">#if APP_TIMER_WITH_PROFILER</span><br><span class="line">    if (p_req)</span><br><span class="line">    &#123;</span><br><span class="line">        ++m_current_user_op_queue_utilization;</span><br><span class="line">    &#125;</span><br><span class="line">    CRITICAL_REGION_EXIT();</span><br><span class="line">#endif &#x2F;* APP_TIMER_WITH_PROFILER *&#x2F;</span><br><span class="line">    if (p_req)</span><br><span class="line">    &#123;</span><br><span class="line">        p_req-&gt;type    &#x3D; type;</span><br><span class="line">        p_req-&gt;p_timer &#x3D; p_timer;</span><br><span class="line">        if (nrf_atfifo_item_put(m_req_fifo, &amp;fifo_ctx))&#x2F;&#x2F;加入FIFO</span><br><span class="line">        &#123;</span><br><span class="line">            timer_request_proc_trigger();&#x2F;&#x2F;软件触发RTC1中断</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_LOG_WARNING(&quot;Scheduling interrupted another scheduling.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return NRF_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return NRF_ERROR_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void timer_request_proc_trigger(void)</span><br><span class="line">&#123;</span><br><span class="line">    drv_rtc_irq_trigger(&amp;m_rtc_inst);</span><br><span class="line">&#125;</span><br><span class="line">void drv_rtc_irq_trigger(drv_rtc_t const * const p_instance)</span><br><span class="line">&#123;</span><br><span class="line">    NVIC_SetPendingIRQ(p_instance-&gt;irq);  &#x2F;&#x2F;这是stm32，中断操作接口，作用是软件设置Irq，产生中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理请求timer_req_process()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @brief Function for processing user requests.</span><br><span class="line"> *</span><br><span class="line"> * Function is called only in the context of RTC interrupt.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void timer_req_process(drv_rtc_t const * const  p_instance)</span><br><span class="line">&#123;</span><br><span class="line">    nrf_atfifo_item_get_t fifo_ctx;</span><br><span class="line">    timer_req_t *         p_req &#x3D; nrf_atfifo_item_get(m_req_fifo, &amp;fifo_ctx);&#x2F;&#x2F;获取请求对象</span><br><span class="line"></span><br><span class="line">    while (p_req)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (p_req-&gt;type)</span><br><span class="line">        &#123;</span><br><span class="line">            case TIMER_REQ_START:</span><br><span class="line">                if (!p_req-&gt;p_timer-&gt;active)</span><br><span class="line">                &#123;</span><br><span class="line">                    p_req-&gt;p_timer-&gt;active &#x3D; true;&#x2F;&#x2F;设置为活动状态</span><br><span class="line">                    nrf_sortlist_add(&amp;m_app_timer_sortlist, &amp;(p_req-&gt;p_timer-&gt;list_item));&#x2F;&#x2F;把请求timer加入链表</span><br><span class="line">                    NRF_LOG_INST_DEBUG(p_req-&gt;p_timer-&gt;p_log,&quot;Start request (expiring at %d&#x2F;0x%08x).&quot;,</span><br><span class="line">                                                  p_req-&gt;p_timer-&gt;end_val, p_req-&gt;p_timer-&gt;end_val);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case TIMER_REQ_STOP:</span><br><span class="line">                if (p_req-&gt;p_timer &#x3D;&#x3D; mp_active_timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    mp_active_timer &#x3D; NULL;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    bool found &#x3D; nrf_sortlist_remove(&amp;m_app_timer_sortlist, &amp;(p_req-&gt;p_timer-&gt;list_item));</span><br><span class="line">                    if (!found)</span><br><span class="line">                    &#123;</span><br><span class="line">                         NRF_LOG_INFO(&quot;Timer not found on sortlist (stopping expired timer).&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                NRF_LOG_INST_DEBUG(p_req-&gt;p_timer-&gt;p_log,&quot;Stop request.&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case TIMER_REQ_STOP_ALL:</span><br><span class="line">                sorted_list_stop_all();</span><br><span class="line">                m_global_active &#x3D; true;</span><br><span class="line">                NRF_LOG_INFO(&quot;Stop all request.&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">#if APP_TIMER_WITH_PROFILER</span><br><span class="line">        CRITICAL_REGION_ENTER();</span><br><span class="line">#endif</span><br><span class="line">        UNUSED_RETURN_VALUE(nrf_atfifo_item_free(m_req_fifo, &amp;fifo_ctx));</span><br><span class="line">#if APP_TIMER_WITH_PROFILER</span><br><span class="line">        if (m_max_user_op_queue_utilization &lt; m_current_user_op_queue_utilization)</span><br><span class="line">        &#123;</span><br><span class="line">            m_max_user_op_queue_utilization &#x3D; m_current_user_op_queue_utilization;</span><br><span class="line">        &#125;</span><br><span class="line">        --m_current_user_op_queue_utilization;</span><br><span class="line">        CRITICAL_REGION_EXIT();</span><br><span class="line">#endif &#x2F;* APP_TIMER_WITH_PROFILER *&#x2F;</span><br><span class="line">        p_req &#x3D; nrf_atfifo_item_get(m_req_fifo, &amp;fifo_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rtc_update()函数,该函数是调度timer的核心功能，调度逻辑比较复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @brief Function updates RTC.</span><br><span class="line"> *</span><br><span class="line"> * Function is called at the end of RTC interrupt when all new user request and&#x2F;or timer expiration</span><br><span class="line"> * occured. It configures RTC if there is any pending timer, reconfigures if the are timers with</span><br><span class="line"> * shorted timeout than active one or stops RTC if there is no active timers.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void rtc_update(drv_rtc_t const * const  p_instance)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">    &#123;     </span><br><span class="line">		app_timer_t * p_next &#x3D; sortlist_peek();&#x2F;&#x2F;探测链表是否为空，空则返回NULL，否则返回当前节点</span><br><span class="line">        bool rtc_reconf &#x3D; false;</span><br><span class="line">        if (p_next) &#x2F;&#x2F;Candidate for active timer&#x2F;&#x2F;存在timer</span><br><span class="line">        &#123;</span><br><span class="line">            if (mp_active_timer &#x3D;&#x3D; NULL)&#x2F;&#x2F;判断是否已经存在活动的timer,即下一次比较事件发生的timer</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;There is no active timer so candidate will become active timer.</span><br><span class="line">                rtc_reconf &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p_next-&gt;end_val &lt; mp_active_timer-&gt;end_val)&#x2F;&#x2F;当前节点的定时时间与活动的timer定时时间比较</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;Candidate has shorter timeout than current active timer. Candidate will replace active timer.</span><br><span class="line">                &#x2F;&#x2F;Active timer is put back into sorted list.</span><br><span class="line">                rtc_reconf &#x3D; true;</span><br><span class="line">                if (mp_active_timer-&gt;active)</span><br><span class="line">                &#123;</span><br><span class="line">                    NRF_LOG_INST_DEBUG(mp_active_timer-&gt;p_log, &quot;Timer preempted.&quot;);</span><br><span class="line">                    nrf_sortlist_add(&amp;m_app_timer_sortlist, &amp;mp_active_timer-&gt;list_item);&#x2F;&#x2F;抢占活动的timer,即放在活动timer的前面</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (rtc_reconf)</span><br><span class="line">            &#123;</span><br><span class="line">                bool rerun;</span><br><span class="line">                p_next &#x3D; sortlist_pop();&#x2F;&#x2F;取出当前节点timer</span><br><span class="line">                NRF_LOG_INST_DEBUG(p_next-&gt;p_log, &quot;Activating timer (CC:%d&#x2F;%08x).&quot;, p_next-&gt;end_val, p_next-&gt;end_val);</span><br><span class="line">                if (rtc_schedule(p_next, &amp;rerun))&#x2F;&#x2F;重新设置比较值，返回true</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!APP_TIMER_KEEPS_RTC_ACTIVE &amp;&amp; (mp_active_timer &#x3D;&#x3D; NULL))</span><br><span class="line">                    &#123;                     									</span><br><span class="line">						drv_rtc_start(p_instance);&#x2F;&#x2F;启动rtc1，这里每次重新设置比较值后，都要启动rtc1,不会清零counter计数器</span><br><span class="line">                    &#125;</span><br><span class="line">                    mp_active_timer &#x3D; p_next;&#x2F;&#x2F;把当前节点timer设置为活动timer,即下一次比较事件发生时，处理当前timer的回调函数，</span><br><span class="line"></span><br><span class="line">                    if (rerun &#x3D;&#x3D; false)  &#x2F;&#x2F;rtc_schedule返回true，这里rerun为false</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;&#x2F;RTC was successfully updated and sortlist was not updated. Function can be terminated.</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#x2F;&#x2F;这里，说明调度过程，该timer定时已经到了，在rtc_schedule中已经处理timer回调函数，所以这里mp_active_timer为NULL</span><br><span class="line">                &#123;   &#x2F;&#x2F;比如，2个timer,timer1一个设置为500ms，timer2设置为1s.timer1两次定时到，重新调度，发现1s时间到，因此马上执行timer2</span><br><span class="line">                    &#x2F;&#x2F;If RTC driver indicated that timeout already occured a new candidate will be taken from sorted list.</span><br><span class="line">                    NRF_LOG_INST_DEBUG(p_next-&gt;p_log,&quot;Timer expired before scheduled to RTC.&quot;);</span><br><span class="line">                    mp_active_timer &#x3D; NULL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;RTC will not be updated. Function can terminate.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;No candidate for active timer.</span><br><span class="line">        &#123;</span><br><span class="line">            if (!APP_TIMER_KEEPS_RTC_ACTIVE &amp;&amp; (mp_active_timer &#x3D;&#x3D; NULL))</span><br><span class="line">            &#123;</span><br><span class="line">                drv_rtc_stop(p_instance);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>存在一个情况：两个timer发起请求，一个时间短，一个时间长，如果时间长的先发起请求，那么时间短后发起的请求，则会抢占时间长的。因此时间短的定时会先到来。</p>
<p>rtc_schedule函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @brief Function is configuring RTC driver to trigger timeout interrupt for given timer.</span><br><span class="line"> *</span><br><span class="line"> * It is possible that RTC driver will indicate that timeout already occured. In that case timer</span><br><span class="line"> * expires and function indicates that RTC was not configured.</span><br><span class="line"> *</span><br><span class="line"> * @param          p_timer Timer instance.</span><br><span class="line"> * @param [in,out] p_rerun Flag indicating that sortlist reevaluation is required.</span><br><span class="line"> *</span><br><span class="line"> * @return True if RTC was successfully configured, false if timer already expired and RTC was not</span><br><span class="line"> *         configured.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">static bool rtc_schedule(app_timer_t * p_timer, bool * p_rerun)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t ret &#x3D; NRF_ERROR_TIMEOUT;</span><br><span class="line">    *p_rerun &#x3D; false;</span><br><span class="line">    int64_t remaining &#x3D; (int64_t)(p_timer-&gt;end_val - get_now());&#x2F;&#x2F;timer结束时间戳和当前时间戳比较</span><br><span class="line">	&#x2F;&#x2F;如果remaining大于0，说明timer定时的时间没有到来，则设置CC0寄存器的值</span><br><span class="line">    if (remaining &gt; 0) &#123;</span><br><span class="line">        uint32_t cc_val &#x3D; ((uint32_t)remaining &gt; APP_TIMER_RTC_MAX_VALUE) ?</span><br><span class="line">                (app_timer_cnt_get() + APP_TIMER_RTC_MAX_VALUE) : p_timer-&gt;end_val;</span><br><span class="line"></span><br><span class="line">        ret &#x3D; drv_rtc_windowed_compare_set(&amp;m_rtc_inst, 0, cc_val, APP_TIMER_SAFE_WINDOW);&#x2F;&#x2F;设置比较值</span><br><span class="line">        NRF_LOG_DEBUG(&quot;Setting CC to 0x%08x (err: %d)&quot;, cc_val &amp; DRV_RTC_MAX_CNT, ret);</span><br><span class="line">        if (ret &#x3D;&#x3D; NRF_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        drv_rtc_compare_disable(&amp;m_rtc_inst, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;如果ret &#x3D;&#x3D; NRF_ERROR_TIMEOUT，则表明当前节点timer的定时时间已经到了或者超时了，需要马上执行，不用再等下一次比较事件发生。</span><br><span class="line">    if (ret &#x3D;&#x3D; NRF_ERROR_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        *p_rerun &#x3D; timer_expire(p_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        NRF_LOG_ERROR(&quot;Unexpected error: %d&quot;, ret);				</span><br><span class="line">        ASSERT(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时时间到了处理函数timer_expire()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @brief Function called on timer expiration</span><br><span class="line"> * If end value is not reached it is assumed that it was partial expiration and time is put back</span><br><span class="line"> * into the list. Otherwise function calls user handler if timer was not stopped before. If timer</span><br><span class="line"> * is in repeated mode then timer is rescheduled.</span><br><span class="line"> *</span><br><span class="line"> * @param p_timer Timer instance.</span><br><span class="line"> *</span><br><span class="line"> * @return True if reevaluation of sortlist needed (becasue it was updated).</span><br><span class="line"> *&#x2F;</span><br><span class="line">static bool timer_expire(app_timer_t * p_timer)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(p_timer-&gt;handler);</span><br><span class="line">    bool ret &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if ((m_global_active &#x3D;&#x3D; true) &amp;&amp; (p_timer !&#x3D; NULL) &amp;&amp; (p_timer-&gt;active))</span><br><span class="line">    &#123;</span><br><span class="line">        if (get_now() &gt;&#x3D; p_timer-&gt;end_val) &#123;</span><br><span class="line">            &#x2F;* timer expired *&#x2F;</span><br><span class="line">            if (p_timer-&gt;repeat_period &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                p_timer-&gt;active &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">    #if APP_TIMER_CONFIG_USE_SCHEDULER</span><br><span class="line">            app_timer_event_t timer_event;</span><br><span class="line"></span><br><span class="line">            timer_event.timeout_handler &#x3D; p_timer-&gt;handler;</span><br><span class="line">            timer_event.p_context       &#x3D; p_timer-&gt;p_context;</span><br><span class="line">            uint32_t err_code &#x3D; app_sched_event_put(&amp;timer_event,</span><br><span class="line">                                                    sizeof(timer_event),</span><br><span class="line">                                                    scheduled_timeout_handler);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">    #else</span><br><span class="line">            NRF_LOG_DEBUG(&quot;Timer expired (context: %d)&quot;, (uint32_t)p_timer-&gt;p_context)</span><br><span class="line">            p_timer-&gt;handler(p_timer-&gt;p_context);&#x2F;&#x2F;执行app timer回调函数</span><br><span class="line">    #endif</span><br><span class="line">            &#x2F;* check active flag as it may have been stopped in the user handler *&#x2F;</span><br><span class="line">            if ((p_timer-&gt;repeat_period) &amp;&amp; (p_timer-&gt;active))</span><br><span class="line">            &#123;</span><br><span class="line">                p_timer-&gt;end_val +&#x3D; p_timer-&gt;repeat_period;&#x2F;&#x2F;更新时间戳</span><br><span class="line">                nrf_sortlist_add(&amp;m_app_timer_sortlist, &amp;p_timer-&gt;list_item);&#x2F;&#x2F;改变节点指向，放到链表末尾。</span><br><span class="line">                ret &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nrf_sortlist_add(&amp;m_app_timer_sortlist, &amp;p_timer-&gt;list_item);</span><br><span class="line">            ret &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><a href="http://wywiot.com/nordic-ble-soc-sw-primary-howtouse-apptimer/" target="_blank" rel="noopener">NORDIC BLE SOC 软件入门-APPTIMER的使用</a></p>
<p><a href="https://www.cnblogs.com/iini/p/9347460.html" target="_blank" rel="noopener">定时模块app_timer用法及常见问题—nRF5 SDK模块系列二</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
  <entry>
    <title>linux查看PCIe的配置空间</title>
    <url>/2020/07/25/Linux/Driver/PCIe/linux%E6%9F%A5%E7%9C%8BPCIe%E7%9A%84%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统完成PCI/PCIe的初始化后，建立了PCI总线树。在Linux中，用户空间如何访问PCI/PCIe的配置空间和查看PCIe设备信息呢？本节重点讲在应用层读取配置空间和显示PCI/PCIe设备信息。</p>
<h2 id="查看配置空间信息"><a href="#查看配置空间信息" class="headerlink" title="查看配置空间信息"></a>查看配置空间信息</h2><p>读取PCIe设备配置空间的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure>

<p>lspci 是一个用来显示系统中所有PCI总线设备或连接到该总线上的所有设备的工具。</p>
<p>常用的几个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v</span><br><span class="line">使得 lspci 以冗余模式显示所有设备的详细信息。</span><br><span class="line">-vv</span><br><span class="line">使得 lspci 以过冗余模式显示更详细的信息 (事实上是 PCI 设备能给出的所有东西)。这些数据的确切意义没有在此手册页中解释，如果你想知道更多，请参照 &#x2F;usr&#x2F;include&#x2F;linux&#x2F;pci.h 或者 PCI 规范。</span><br><span class="line">-vvv 显示设备所有可解析的信息</span><br><span class="line">-n</span><br><span class="line">以数字形式显示 PCI 生产厂商和设备号，而不是在 PCI ID 数据库中查找它们。</span><br><span class="line">-x</span><br><span class="line">以十六进制显示 配置空间 (configuration space) 的前64个字节映像 (标准头部信息)。此参数对调试驱动和 lspci 本身很有用。</span><br><span class="line">-xxx</span><br><span class="line">以十六进制显示所有配置空间的256Byte映像。此选项只有 root 可用，并且很多 PCI 设备在你试图读取配置空间的未定义部分时会崩溃 (此操作可能不违反PCI标准，但是它至少非常愚蠢)。</span><br><span class="line">-xxxx 以16进制显示整个PCIe配置空间（4096字节）。</span><br><span class="line">-t</span><br><span class="line">以树形方式显示包含所有总线、桥、设备和它们的连接的图表。</span><br><span class="line">-s [[]:][][.[]]</span><br><span class="line">仅显示指定总线、插槽上的设备或设备上的功能块信息。设备地址的任何部分都可以忽略，或以「*」代替 (意味著所有值)。所有数字都是十六进制。例如：「0：」指的是在0号总线上的所有设备；「0」指的是在任意总线上0号设备的所有功能块；「0.3」选择 了所有总线上0号设备的第三个功能块；「.4」则是只列出每一设备上的第四个功能块。</span><br><span class="line">-d []:[]</span><br><span class="line">只显示指定生产厂商和设备 ID 的设备。 这两个 ID 都以十六进制表示，可以忽略或者以「*」代替 (意味著所有值)。</span><br></pre></td></tr></table></figure>

<p>操作示例</p>
<p>示例1：只是简单显示目前所有的硬件设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~# lspci </span><br><span class="line">00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6&#x2F;7th Gen Core Processor Host Bridge&#x2F;DRAM Registers (rev 05)</span><br><span class="line">00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v5&#x2F;E3-1500 v5&#x2F;6th Gen Core Processor PCIe Controller (x16) (rev 05)</span><br><span class="line">00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5&#x2F;v6 &#x2F; E3-1500 v5 &#x2F; 6th&#x2F;7th Gen Core Processor Gaussian Mixture Model</span><br><span class="line">00:14.0 USB controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family USB 3.0 xHCI Controller (rev 31)</span><br><span class="line">00:14.2 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Thermal Subsystem (rev 31)</span><br><span class="line">00:15.0 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #0 (rev 31)</span><br><span class="line">00:15.1 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #1 (rev 31)</span><br><span class="line">00:16.0 Communication controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family MEI Controller #1 (rev 31)</span><br><span class="line">00:16.3 Serial controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family KT Redirection (rev 31)</span><br><span class="line">00:17.0 SATA controller: Intel Corporation Q170&#x2F;Q150&#x2F;B150&#x2F;H170&#x2F;H110&#x2F;Z170&#x2F;CM236 Chipset SATA Controller [AHCI Mode] (rev 31)</span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family PCI Express Root Port #6 (rev f1)</span><br><span class="line">00:1d.0 PCI bridge: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family PCI Express Root Port #9 (rev f1)</span><br><span class="line">00:1f.0 ISA bridge: Intel Corporation Q170 Chipset LPC&#x2F;eSPI Controller (rev 31)</span><br><span class="line">00:1f.2 Memory controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Power Management Controller (rev 31)</span><br><span class="line">00:1f.3 Audio device: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family HD Audio Controller (rev 31)</span><br><span class="line">00:1f.4 SMBus: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family SMBus (rev 31)</span><br><span class="line">00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection (2) I219-LM (rev 31)</span><br><span class="line">01:00.0 VGA compatible controller: NVIDIA Corporation GP107 [GeForce GTX 1050 Ti] (rev a1)</span><br><span class="line">01:00.1 Audio device: NVIDIA Corporation GP107GL High Definition Audio Controller (rev a1)</span><br><span class="line">02:00.0 Ethernet controller: Intel Corporation I211 Gigabit Network Connection (rev 03)</span><br><span class="line">03:00.0 Memory controller: Xilinx Corporation Device 8034</span><br></pre></td></tr></table></figure>

<p>示例2：显示所有设备详细的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~# lspci -v</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6&#x2F;7th Gen Core Processor Host Bridge&#x2F;DRAM Registers (rev 05)</span><br><span class="line">	Subsystem: Intel Corporation Xeon E3-1200 v6&#x2F;7th Gen Core Processor Host Bridge&#x2F;DRAM Registers</span><br><span class="line">	Flags: bus master, fast devsel, latency 0</span><br><span class="line">	Capabilities: [e0] Vendor Specific Information: Len&#x3D;10 &lt;?&gt;</span><br><span class="line"></span><br><span class="line">00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v5&#x2F;E3-1500 v5&#x2F;6th Gen Core Processor PCIe Controller (x16) (rev 05) (prog-if 00 [Normal decode])</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 121</span><br><span class="line">	Bus: primary&#x3D;00, secondary&#x3D;01, subordinate&#x3D;01, sec-latency&#x3D;0</span><br><span class="line">	I&#x2F;O behind bridge: 0000e000-0000efff</span><br><span class="line">	Memory behind bridge: de000000-df0fffff</span><br><span class="line">	Prefetchable memory behind bridge: 00000000c0000000-00000000d1ffffff</span><br><span class="line">	Capabilities: [88] Subsystem: Intel Corporation Skylake PCIe Controller (x16)</span><br><span class="line">	Capabilities: [80] Power Management version 3</span><br><span class="line">	Capabilities: [90] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Capabilities: [a0] Express Root Port (Slot+), MSI 00</span><br><span class="line">	Capabilities: [100] Virtual Channel</span><br><span class="line">	Capabilities: [140] Root Complex Link</span><br><span class="line">	Capabilities: [d94] #19</span><br><span class="line">	Kernel driver in use: pcieport</span><br><span class="line">	Kernel modules: shpchp</span><br><span class="line"></span><br><span class="line">00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5&#x2F;v6 &#x2F; E3-1500 v5 &#x2F; 6th&#x2F;7th Gen Core Processor Gaussian Mixture Model</span><br><span class="line">	Subsystem: Intel Corporation Skylake Gaussian Mixture Model</span><br><span class="line">	Flags: fast devsel, IRQ 11</span><br><span class="line">	Memory at df252000 (64-bit, non-prefetchable) [disabled] [size&#x3D;4K]</span><br><span class="line">	Capabilities: [90] MSI: Enable- Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Capabilities: [dc] Power Management version 2</span><br><span class="line">	Capabilities: [f0] PCI Advanced Features</span><br><span class="line"></span><br><span class="line">00:14.0 USB controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family USB 3.0 xHCI Controller (rev 31) (prog-if 30 [XHCI])</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H USB 3.0 xHCI Controller</span><br><span class="line">	Flags: bus master, medium devsel, latency 0, IRQ 124</span><br><span class="line">	Memory at df230000 (64-bit, non-prefetchable) [size&#x3D;64K]</span><br><span class="line">	Capabilities: [70] Power Management version 2</span><br><span class="line">	Capabilities: [80] MSI: Enable+ Count&#x3D;1&#x2F;8 Maskable- 64bit+</span><br><span class="line">	Kernel driver in use: xhci_hcd</span><br><span class="line"></span><br><span class="line">00:14.2 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Thermal Subsystem (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H Thermal subsystem</span><br><span class="line">	Flags: fast devsel, IRQ 18</span><br><span class="line">	Memory at df251000 (64-bit, non-prefetchable) [size&#x3D;4K]</span><br><span class="line">	Capabilities: [50] Power Management version 3</span><br><span class="line">	Capabilities: [80] MSI: Enable- Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Kernel driver in use: intel_pch_thermal</span><br><span class="line">	Kernel modules: intel_pch_thermal</span><br><span class="line"></span><br><span class="line">00:15.0 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #0 (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H Serial IO I2C Controller</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 16</span><br><span class="line">	Memory at df250000 (64-bit, non-prefetchable) [size&#x3D;4K]</span><br><span class="line">	Capabilities: [80] Power Management version 3</span><br><span class="line">	Capabilities: [90] Vendor Specific Information: Len&#x3D;14 &lt;?&gt;</span><br><span class="line">	Kernel driver in use: intel-lpss</span><br><span class="line">	Kernel modules: intel_lpss_pci</span><br><span class="line"></span><br><span class="line">00:15.1 Signal processing controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #1 (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H Serial IO I2C Controller</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 17</span><br><span class="line">	Memory at df24f000 (64-bit, non-prefetchable) [size&#x3D;4K]</span><br><span class="line">	Capabilities: [80] Power Management version 3</span><br><span class="line">	Capabilities: [90] Vendor Specific Information: Len&#x3D;14 &lt;?&gt;</span><br><span class="line">	Kernel driver in use: intel-lpss</span><br><span class="line">	Kernel modules: intel_lpss_pci</span><br><span class="line"></span><br><span class="line">00:16.0 Communication controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family MEI Controller #1 (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H CSME HECI</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 324</span><br><span class="line">	Memory at df24e000 (64-bit, non-prefetchable) [size&#x3D;4K]</span><br><span class="line">	Capabilities: [50] Power Management version 3</span><br><span class="line">	Capabilities: [8c] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Kernel driver in use: mei_me</span><br><span class="line">	Kernel modules: mei_me</span><br><span class="line"></span><br><span class="line">00:16.3 Serial controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family KT Redirection (rev 31) (prog-if 02 [16550])</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H KT Redirection</span><br><span class="line">	Flags: 66MHz, fast devsel, IRQ 19</span><br><span class="line">	I&#x2F;O ports at f060 [size&#x3D;8]</span><br><span class="line">	Memory at df24d000 (32-bit, non-prefetchable) [size&#x3D;4K]</span><br><span class="line">	Capabilities: [40] MSI: Enable- Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Capabilities: [50] Power Management version 3</span><br><span class="line">	Kernel driver in use: serial</span><br><span class="line"></span><br><span class="line">00:17.0 SATA controller: Intel Corporation Q170&#x2F;Q150&#x2F;B150&#x2F;H170&#x2F;H110&#x2F;Z170&#x2F;CM236 Chipset SATA Controller [AHCI Mode] (rev 31) (prog-if 01 [AHCI 1.0])</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H SATA controller [AHCI mode]</span><br><span class="line">	Flags: bus master, 66MHz, medium devsel, latency 0, IRQ 317</span><br><span class="line">	Memory at df248000 (32-bit, non-prefetchable) [size&#x3D;8K]</span><br><span class="line">	Memory at df24c000 (32-bit, non-prefetchable) [size&#x3D;256]</span><br><span class="line">	I&#x2F;O ports at f050 [size&#x3D;8]</span><br><span class="line">	I&#x2F;O ports at f040 [size&#x3D;4]</span><br><span class="line">	I&#x2F;O ports at f020 [size&#x3D;32]</span><br><span class="line">	Memory at df24b000 (32-bit, non-prefetchable) [size&#x3D;2K]</span><br><span class="line">	Capabilities: [80] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Capabilities: [70] Power Management version 3</span><br><span class="line">	Capabilities: [a8] SATA HBA v1.0</span><br><span class="line">	Kernel driver in use: ahci</span><br><span class="line">	Kernel modules: ahci</span><br><span class="line"></span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family PCI Express Root Port #6 (rev f1) (prog-if 00 [Normal decode])</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 122</span><br><span class="line">	Bus: primary&#x3D;00, secondary&#x3D;02, subordinate&#x3D;02, sec-latency&#x3D;0</span><br><span class="line">	I&#x2F;O behind bridge: 0000d000-0000dfff</span><br><span class="line">	Memory behind bridge: df100000-df1fffff</span><br><span class="line">	Capabilities: [40] Express Root Port (Slot+), MSI 00</span><br><span class="line">	Capabilities: [80] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Capabilities: [90] Subsystem: Intel Corporation Sunrise Point-H PCI Express Root Port</span><br><span class="line">	Capabilities: [a0] Power Management version 3</span><br><span class="line">	Capabilities: [100] Advanced Error Reporting</span><br><span class="line">	Capabilities: [140] Access Control Services</span><br><span class="line">	Capabilities: [200] L1 PM Substates</span><br><span class="line">	Capabilities: [220] #19</span><br><span class="line">	Kernel driver in use: pcieport</span><br><span class="line">	Kernel modules: shpchp</span><br><span class="line"></span><br><span class="line">00:1d.0 PCI bridge: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family PCI Express Root Port #9 (rev f1) (prog-if 00 [Normal decode])</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 123</span><br><span class="line">	Bus: primary&#x3D;00, secondary&#x3D;03, subordinate&#x3D;03, sec-latency&#x3D;0</span><br><span class="line">	Memory behind bridge: dc000000-ddffffff</span><br><span class="line">	Capabilities: [40] Express Root Port (Slot+), MSI 00</span><br><span class="line">	Capabilities: [80] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit-</span><br><span class="line">	Capabilities: [90] Subsystem: Intel Corporation Sunrise Point-H PCI Express Root Port</span><br><span class="line">	Capabilities: [a0] Power Management version 3</span><br><span class="line">	Capabilities: [100] Advanced Error Reporting</span><br><span class="line">	Capabilities: [140] Access Control Services</span><br><span class="line">	Capabilities: [200] L1 PM Substates</span><br><span class="line">	Capabilities: [220] #19</span><br><span class="line">	Kernel driver in use: pcieport</span><br><span class="line">	Kernel modules: shpchp</span><br><span class="line"></span><br><span class="line">00:1f.0 ISA bridge: Intel Corporation Q170 Chipset LPC&#x2F;eSPI Controller (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H LPC Controller</span><br><span class="line">	Flags: bus master, medium devsel, latency 0</span><br><span class="line"></span><br><span class="line">00:1f.2 Memory controller: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Power Management Controller (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H PMC</span><br><span class="line">	Flags: bus master, fast devsel, latency 0</span><br><span class="line">	Memory at df244000 (32-bit, non-prefetchable) [size&#x3D;16K]</span><br><span class="line"></span><br><span class="line">00:1f.3 Audio device: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family HD Audio Controller (rev 31)</span><br><span class="line">	Subsystem: Advantech Co. Ltd Sunrise Point-H HD Audio</span><br><span class="line">	Flags: bus master, fast devsel, latency 32, IRQ 325</span><br><span class="line">	Memory at df240000 (64-bit, non-prefetchable) [size&#x3D;16K]</span><br><span class="line">	Memory at df220000 (64-bit, non-prefetchable) [size&#x3D;64K]</span><br><span class="line">	Capabilities: [50] Power Management version 3</span><br><span class="line">	Capabilities: [60] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Kernel driver in use: snd_hda_intel</span><br><span class="line">	Kernel modules: snd_hda_intel</span><br><span class="line"></span><br><span class="line">00:1f.4 SMBus: Intel Corporation 100 Series&#x2F;C230 Series Chipset Family SMBus (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Sunrise Point-H SMBus</span><br><span class="line">	Flags: medium devsel, IRQ 11</span><br><span class="line">	Memory at df24a000 (64-bit, non-prefetchable) [size&#x3D;256]</span><br><span class="line">	I&#x2F;O ports at f000 [size&#x3D;32]</span><br><span class="line">	Kernel modules: i2c_i801</span><br><span class="line"></span><br><span class="line">00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection (2) I219-LM (rev 31)</span><br><span class="line">	Subsystem: Intel Corporation Ethernet Connection (2) I219-LM</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 318</span><br><span class="line">	Memory at df200000 (32-bit, non-prefetchable) [size&#x3D;128K]</span><br><span class="line">	Capabilities: [c8] Power Management version 3</span><br><span class="line">	Capabilities: [d0] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Capabilities: [e0] PCI Advanced Features</span><br><span class="line">	Kernel driver in use: e1000e</span><br><span class="line">	Kernel modules: e1000e</span><br><span class="line"></span><br><span class="line">01:00.0 VGA compatible controller: NVIDIA Corporation GP107 [GeForce GTX 1050 Ti] (rev a1) (prog-if 00 [VGA controller])</span><br><span class="line">	Subsystem: NVIDIA Corporation Device 11bf</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 326</span><br><span class="line">	Memory at de000000 (32-bit, non-prefetchable) [size&#x3D;16M]</span><br><span class="line">	Memory at c0000000 (64-bit, prefetchable) [size&#x3D;256M]</span><br><span class="line">	Memory at d0000000 (64-bit, prefetchable) [size&#x3D;32M]</span><br><span class="line">	I&#x2F;O ports at e000 [size&#x3D;128]</span><br><span class="line">	[virtual] Expansion ROM at 000c0000 [disabled] [size&#x3D;128K]</span><br><span class="line">	Capabilities: [60] Power Management version 3</span><br><span class="line">	Capabilities: [68] MSI: Enable+ Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Capabilities: [78] Express Legacy Endpoint, MSI 00</span><br><span class="line">	Capabilities: [100] Virtual Channel</span><br><span class="line">	Capabilities: [250] Latency Tolerance Reporting</span><br><span class="line">	Capabilities: [128] Power Budgeting &lt;?&gt;</span><br><span class="line">	Capabilities: [420] Advanced Error Reporting</span><br><span class="line">	Capabilities: [600] Vendor Specific Information: ID&#x3D;0001 Rev&#x3D;1 Len&#x3D;024 &lt;?&gt;</span><br><span class="line">	Capabilities: [900] #19</span><br><span class="line">	Kernel driver in use: nvidia</span><br><span class="line">	Kernel modules: nvidiafb, nouveau, nvidia_drm, nvidia</span><br><span class="line"></span><br><span class="line">01:00.1 Audio device: NVIDIA Corporation GP107GL High Definition Audio Controller (rev a1)</span><br><span class="line">	Subsystem: NVIDIA Corporation Device 11bf</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 17</span><br><span class="line">	Memory at df080000 (32-bit, non-prefetchable) [size&#x3D;16K]</span><br><span class="line">	Capabilities: [60] Power Management version 3</span><br><span class="line">	Capabilities: [68] MSI: Enable- Count&#x3D;1&#x2F;1 Maskable- 64bit+</span><br><span class="line">	Capabilities: [78] Express Endpoint, MSI 00</span><br><span class="line">	Capabilities: [100] Advanced Error Reporting</span><br><span class="line">	Kernel driver in use: snd_hda_intel</span><br><span class="line">	Kernel modules: snd_hda_intel</span><br><span class="line"></span><br><span class="line">02:00.0 Ethernet controller: Intel Corporation I211 Gigabit Network Connection (rev 03)</span><br><span class="line">	Subsystem: Intel Corporation I211 Gigabit Network Connection</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 17</span><br><span class="line">	Memory at df100000 (32-bit, non-prefetchable) [size&#x3D;128K]</span><br><span class="line">	I&#x2F;O ports at d000 [size&#x3D;32]</span><br><span class="line">	Memory at df120000 (32-bit, non-prefetchable) [size&#x3D;16K]</span><br><span class="line">	Capabilities: [40] Power Management version 3</span><br><span class="line">	Capabilities: [50] MSI: Enable- Count&#x3D;1&#x2F;1 Maskable+ 64bit+</span><br><span class="line">	Capabilities: [70] MSI-X: Enable+ Count&#x3D;5 Masked-</span><br><span class="line">	Capabilities: [a0] Express Endpoint, MSI 00</span><br><span class="line">	Capabilities: [100] Advanced Error Reporting</span><br><span class="line">	Capabilities: [140] Device Serial Number c4-00-ad-ff-ff-3a-e7-2d</span><br><span class="line">	Capabilities: [1a0] Transaction Processing Hints</span><br><span class="line">	Kernel driver in use: igb</span><br><span class="line">	Kernel modules: igb</span><br><span class="line"></span><br><span class="line">03:00.0 Memory controller: Xilinx Corporation Device 8034</span><br><span class="line">	Subsystem: Xilinx Corporation Device 0007</span><br><span class="line">	Flags: fast devsel, IRQ 11</span><br><span class="line">	Memory at dc000000 (32-bit, non-prefetchable) [disabled] [size&#x3D;32M]</span><br><span class="line">	Capabilities: [80] Power Management version 3</span><br><span class="line">	Capabilities: [90] MSI: Enable- Count&#x3D;1&#x2F;4 Maskable- 64bit+</span><br><span class="line">	Capabilities: [c0] Express Endpoint, MSI 00</span><br><span class="line">	Capabilities: [100] Advanced Error Reporting</span><br><span class="line">	Capabilities: [300] #19</span><br></pre></td></tr></table></figure>

<p>示例3：显示具体设备更详细的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~# lspci -vv -s 03:00.0</span><br><span class="line">03:00.0 Memory controller: Xilinx Corporation Device 8034</span><br><span class="line">	Subsystem: Xilinx Corporation Device 0007</span><br><span class="line">	Control: I&#x2F;O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-</span><br><span class="line">	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL&#x3D;fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">	Interrupt: pin A routed to IRQ 11</span><br><span class="line">	Region 0: Memory at dc000000 (32-bit, non-prefetchable) [disabled] [size&#x3D;32M]</span><br><span class="line">	Capabilities: [80] Power Management version 3</span><br><span class="line">		Flags: PMEClk- DSI- D1- D2- AuxCurrent&#x3D;0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)</span><br><span class="line">		Status: D0 NoSoftRst+ PME-Enable- DSel&#x3D;0 DScale&#x3D;0 PME-</span><br><span class="line">	Capabilities: [90] MSI: Enable- Count&#x3D;1&#x2F;4 Maskable- 64bit+</span><br><span class="line">		Address: 0000000000000000  Data: 0000</span><br><span class="line">	Capabilities: [c0] Express (v2) Endpoint, MSI 00</span><br><span class="line">		DevCap:	MaxPayload 512 bytes, PhantFunc 0, Latency L0s &lt;64ns, L1 &lt;1us</span><br><span class="line">			ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset-</span><br><span class="line">		DevCtl:	Report errors: Correctable- Non-Fatal- Fatal- Unsupported-</span><br><span class="line">			RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+</span><br><span class="line">			MaxPayload 256 bytes, MaxReadReq 512 bytes</span><br><span class="line">		DevSta:	CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-</span><br><span class="line">		LnkCap:	Port #0, Speed 8GT&#x2F;s, Width x4, ASPM not supported, Exit Latency L0s unlimited, L1 unlimited</span><br><span class="line">			ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+</span><br><span class="line">		LnkCtl:	ASPM Disabled; RCB 64 bytes Disabled- CommClk+</span><br><span class="line">			ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-</span><br><span class="line">		LnkSta:	Speed 8GT&#x2F;s, Width x4, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-</span><br><span class="line">		DevCap2: Completion Timeout: Range B, TimeoutDis+, LTR-, OBFF Not Supported</span><br><span class="line">		DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled</span><br><span class="line">		LnkCtl2: Target Link Speed: 8GT&#x2F;s, EnterCompliance- SpeedDis-</span><br><span class="line">			 Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-</span><br><span class="line">			 Compliance De-emphasis: -6dB</span><br><span class="line">		LnkSta2: Current De-emphasis Level: -3.5dB, EqualizationComplete+, EqualizationPhase1+</span><br><span class="line">			 EqualizationPhase2+, EqualizationPhase3+, LinkEqualizationRequest-</span><br><span class="line">	Capabilities: [100 v2] Advanced Error Reporting</span><br><span class="line">		UESta:	DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">		UEMsk:	DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">		UESvrt:	DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-</span><br><span class="line">		CESta:	RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr-</span><br><span class="line">		CEMsk:	RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+</span><br><span class="line">		AERCap:	First Error Pointer: 00, GenCap- CGenEn- ChkCap- ChkEn-</span><br><span class="line">	Capabilities: [300 v1] #19</span><br></pre></td></tr></table></figure>

<p>示例4：显示具体设备的256byte配置空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~# lspci -xxx -s 03:00.0</span><br><span class="line">03:00.0 Memory controller: Xilinx Corporation Device 8034</span><br><span class="line">00: ee 10 34 80 00 00 10 00 00 00 80 05 10 00 00 00</span><br><span class="line">10: 00 00 00 dc 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 ee 10 07 00</span><br><span class="line">30: 00 00 00 00 80 00 00 00 00 00 00 00 0b 01 00 00</span><br><span class="line">40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">80: 01 90 03 00 08 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">90: 05 c0 84 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">b0: 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">c0: 10 00 02 00 02 80 e8 07 30 28 00 00 43 f0 43 00</span><br><span class="line">d0: 40 00 43 10 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">e0: 00 00 00 00 12 00 00 00 00 00 00 00 0e 00 00 00</span><br><span class="line">f0: 03 00 1f 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>示例5：显示总线树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ivus:~# lspci -tv</span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation Xeon E3-1200 v6&#x2F;7th Gen Core Processor Host Bridge&#x2F;DRAM Registers</span><br><span class="line">           +-01.0-[01]--+-00.0  NVIDIA Corporation GP107 [GeForce GTX 1050 Ti]</span><br><span class="line">           |            \-00.1  NVIDIA Corporation GP107GL High Definition Audio Controller</span><br><span class="line">           +-08.0  Intel Corporation Xeon E3-1200 v5&#x2F;v6 &#x2F; E3-1500 v5 &#x2F; 6th&#x2F;7th Gen Core Processor Gaussian Mixture Model</span><br><span class="line">           +-14.0  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family USB 3.0 xHCI Controller</span><br><span class="line">           +-14.2  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Thermal Subsystem</span><br><span class="line">           +-15.0  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #0</span><br><span class="line">           +-15.1  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Serial IO I2C Controller #1</span><br><span class="line">           +-16.0  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family MEI Controller #1</span><br><span class="line">           +-16.3  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family KT Redirection</span><br><span class="line">           +-17.0  Intel Corporation Q170&#x2F;Q150&#x2F;B150&#x2F;H170&#x2F;H110&#x2F;Z170&#x2F;CM236 Chipset SATA Controller [AHCI Mode]</span><br><span class="line">           +-1c.0-[02]----00.0  Intel Corporation I211 Gigabit Network Connection</span><br><span class="line">           +-1d.0-[03]----00.0  Xilinx Corporation Device 8034</span><br><span class="line">           +-1f.0  Intel Corporation Q170 Chipset LPC&#x2F;eSPI Controller</span><br><span class="line">           +-1f.2  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family Power Management Controller</span><br><span class="line">           +-1f.3  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family HD Audio Controller</span><br><span class="line">           +-1f.4  Intel Corporation 100 Series&#x2F;C230 Series Chipset Family SMBus</span><br><span class="line">           \-1f.6  Intel Corporation Ethernet Connection (2) I219-LM</span><br></pre></td></tr></table></figure>

<p>示例6：查看厂家和设备号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~# lspci -n</span><br><span class="line">00:00.0 0600: 8086:591f (rev 05)</span><br><span class="line">00:01.0 0604: 8086:1901 (rev 05)</span><br><span class="line">00:08.0 0880: 8086:1911</span><br><span class="line">00:14.0 0c03: 8086:a12f (rev 31)</span><br><span class="line">00:14.2 1180: 8086:a131 (rev 31)</span><br><span class="line">00:15.0 1180: 8086:a160 (rev 31)</span><br><span class="line">00:15.1 1180: 8086:a161 (rev 31)</span><br><span class="line">00:16.0 0780: 8086:a13a (rev 31)</span><br><span class="line">00:16.3 0700: 8086:a13d (rev 31)</span><br><span class="line">00:17.0 0106: 8086:a102 (rev 31)</span><br><span class="line">00:1c.0 0604: 8086:a115 (rev f1)</span><br><span class="line">00:1d.0 0604: 8086:a118 (rev f1)</span><br><span class="line">00:1f.0 0601: 8086:a146 (rev 31)</span><br><span class="line">00:1f.2 0580: 8086:a121 (rev 31)</span><br><span class="line">00:1f.3 0403: 8086:a170 (rev 31)</span><br><span class="line">00:1f.4 0c05: 8086:a123 (rev 31)</span><br><span class="line">00:1f.6 0200: 8086:15b7 (rev 31)</span><br><span class="line">01:00.0 0300: 10de:1c82 (rev a1)</span><br><span class="line">01:00.1 0403: 10de:0fb9 (rev a1)</span><br><span class="line">02:00.0 0200: 8086:1539 (rev 03)</span><br><span class="line">03:00.0 0580: 10ee:8034</span><br></pre></td></tr></table></figure>

<p>解释最后一条信息的含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">03:00.0 0580: 10ee:8034</span><br></pre></td></tr></table></figure>

<p>03:00.0代表什么意思？</p>
<p>就是 bus number = 03 ,device number = 00 function = 0 </p>
<p>0580就是Class code</p>
<p>10ee就是厂家ID</p>
<p>8034就是设备ID</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="修改配置空间"><a href="#修改配置空间" class="headerlink" title="修改配置空间"></a>修改配置空间</h3><p>在应用层修改配置空间的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setpci</span><br></pre></td></tr></table></figure>

<h3 id="扫描PCI设备"><a href="#扫描PCI设备" class="headerlink" title="扫描PCI设备"></a>扫描PCI设备</h3><p>探测PCI/PCIe设备的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scanpci</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="http://ilinuxkernel.com/?p=166" target="_blank" rel="noopener">Linux PCI/PCI-E设备配置空间读取与修改</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>PCIe</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>2.4G nRF24LE1原理</title>
    <url>/2020/11/19/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/2.4G%20nRF24LE1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是2.4G？射频收发器工作在国际ISM频段2.400~2.4835Ghz范围。2.4G协议分为公有协议和私有协议。公有协议，比如，zigbee,ble协议。私有协议就是厂家自己定义的协议，只能跟自家的通信，常说私有2.4G协议，就是自己制定协议，运行2.4G Soc芯片上。本文总结2.4G soc  nRF24LE1射频收发器原理。</p>
<h2 id="2-4G-soc结构"><a href="#2-4G-soc结构" class="headerlink" title="2.4G soc结构"></a>2.4G soc结构</h2><p><img src="http://jiali.clouddn.com/20201119_001.png" alt=""></p>
<p>MCU通过SPI接口控制RF transceiver，具体RF transceiver内部结构如下图</p>
<p><img src="http://jiali.clouddn.com/20201119_002.png" alt=""></p>
<p>MCU通SPI发送命令，来配置RF transceiver的寄存器。</p>
<p> 2.4G soc nRF24LE1的封装如下图</p>
<p><img src="http://jiali.clouddn.com/20201119_003.png" alt=""></p>
<p>管脚定义如下表</p>
<p><img src="http://jiali.clouddn.com/20201119_004.png" alt=""></p>
<h2 id="射频收发器工作原理"><a href="#射频收发器工作原理" class="headerlink" title="射频收发器工作原理"></a>射频收发器工作原理</h2><p><strong>1、工作模式</strong></p>
<ul>
<li>掉电模式</li>
<li>待机模式：待机模式-I和待机模式-II</li>
<li>接收模式</li>
<li>发射模式</li>
</ul>
<p>工作模式的寄存器配置如下表</p>
<p><img src="http://jiali.clouddn.com/20201119_005.png" alt=""></p>
<p><strong>2、Enhanced ShockBurst</strong></p>
<p>MCU负责把读写FIFO，剩下的事情 由ShockBurst完成。 ShockBurst功能如下：</p>
<ul>
<li>根据数据的长度来设置1~32字节范围内的动态数据长度;</li>
<li>自动打包和拆包;</li>
<li>自动进行包的CRC校验:自动应答,自动重传;</li>
<li>MultiCeiver1~6通道星形网络的数据管理</li>
</ul>
<p>在发送端，MCU把数据写入TX FIFO，ShockBurst从TX FIFO取出数据，封装成一个数据包，并发送出去，在接收端，将解调后的数据，拆包并经过CRC校验后，确定是正确的数据，就把数据移动到RX FIFO，产生数据达到RX FIFO中断，MCU判断中断读取RX FIFO数据。</p>
<p>带ACK的ShockBurst处理过程如下：</p>
<ol>
<li><p>先从PTX 发送一个数据包到PRX,增强型ShockBurst将设置PTX 为接收并等待<br>ACK 包。</p>
</li>
<li><p>如果数据包被PRX 所接收,增强型ShockBurst将自动装配并发送一个应答包(ACK<br>包)给PTX 然后返回接收模式。</p>
</li>
<li><p>如果PTX 没有即时收到ACK 包,增强型ShockBurst将会在一个可编程的延时间隔后自动重发此数据包,然后将PTX 设为接收模式等待ACK 包。</p>
<p>在增强型ShockBurst中可以设定重发的次数和重发的间隔参数,而后所有的工作均由增强型ShockBurst自动完成而无需MCU 的干预。</p>
</li>
</ol>
<p>增强型ShockBurst包格式</p>
<p><img src="http://jiali.clouddn.com/20201119_006.png" alt=""></p>
<p>带ACK增强型ShockBurst时序图</p>
<p><img src="http://jiali.clouddn.com/20201119_008.png" alt=""></p>
<p>Tul是SPI发送数据到FIFI的时间，RFCE产生至少10us的脉冲，激活发射模式，再过130us开始发送数据，Toa是空中传输的时间，数据发送完毕，ShockBurst自动把发送模式转换为接收模式，等待ACK。PRX RX FIFO收到数据，产生中断，在中断函数中读取FIFO数据。PRX收到数据，ShockBurst把接收模式转换为发送模式，发送ACK.</p>
<p><strong>3、收发通道和RF收发地址</strong></p>
<p>在接收模式下，可以接收六路PIPE数据，PIPE叫逻辑通道，实际上，不是并行接收六路PIPE，而是串行。接收模式下，多路接收示意图如下</p>
<p><img src="http://jiali.clouddn.com/20201119_007.png" alt=""></p>
<p>从图可以看出， 2.4G soc nRF24LE1,只有一个TX_ADDR寄存器来配置发送地址，由于由六个接收通道，所以，就有六个接收地址配置寄存器RX_ADDR_P0<del>RX_ADDR_P5。默认使能的接收只有RX_ADDR_P0和RX_ADDR_P1通道，其他通道需要手动使能。如果没有设置动态数据长度，则需要配置RX_PW_P0</del>RX_PW_P5对应使能通道的数据长度。</p>
<p><strong>注意：</strong></p>
<p>发送地址和某个接收通道地址要一致。发送地址需要配置TX_ADDR寄存器，与某个PIPE地址要相同。</p>
<p>数据通道地址配置如下图</p>
<p><img src="http://jiali.clouddn.com/20201119_009.png" alt=""></p>
<p>每个数据通道可配置最多5字节地址。数据通道0有一个5字节的独特地址,数据通道1~5使用与之相同的高4 字节地址,而所有6 个数据通道的最低地址字节是不同。</p>
<p><strong>注意:必须确保所有的数据通道地址不相同。</strong></p>
<p><strong>4、RF收发器数据FIFO</strong></p>
<p>RF数据FIFO分为发送FIFO和接收FIFO。这两个FIFO在发射和接收模式下，都可以访问。数据FIFO最多能容纳3个payload，每个payload为1~32byte。MCU通过SPI接口发送SPI 命令来操作数据FIFO。发射模式下，写FIFO的命令：W_TX_PAYLOAD  和W_TX_PAYLOAD_NO_ACK 。接收模式下，写FIFO命令：W_ACK_PAYLOAD 。在发射模式和接收模式下，都可以使用R_RX_PAYLOAD命令读FIFO。</p>
<p>FIFO结构图如下：</p>
<p><img src="http://jiali.clouddn.com/20201119_010.png" alt=""></p>
<p><strong>5、中断</strong></p>
<p>The RF transceiver can send interrupts to the MCU. The interrupt (RFIRQ) is activated when TX_DS,RX_DR or MAX_RT are set high by the state machine in the STATUS register.RFIRQ is deactivated when the MCU writes ‘1’ to the interrupt source bit in the STATUS register.The interrupt mask in the CONFIG register is used to select the IRQ sources that are allowed to activate RFIRQ. By setting one of the mask bits high, the corresponding interrupt source is disabled. By default all interrupt sources are enabled.</p>
<p><strong>Note:</strong> </p>
<p>The 3 bit pipe information in the STATUS register is updated during the RFIRQ high to low transition. The pipe information is unreliable if the STATUS register is read during a RFIRQ high to low transition.</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>参考芯片手册。</p>
<p><strong>参考：</strong></p>
<p>《nRF24LE1 Specification》</p>
<p>《nRF无线SOC单片机原理与高级应用》</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>2.4G</category>
        <category>Nordic Soc开发</category>
      </categories>
      <tags>
        <tag>2.4G</tag>
      </tags>
  </entry>
  <entry>
    <title>Power Management</title>
    <url>/2020/10/12/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/Power%20Management/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>低功耗蓝牙应用对功耗要求越低越好，功耗越低电池续航时间就越长。本文介绍System OFF mode和System On mode.</p>
<h2 id="电源管理单元"><a href="#电源管理单元" class="headerlink" title="电源管理单元"></a>电源管理单元</h2><p>Power and clock management in nRF52832 is optimized for ultra-low power applications.<br>The core of the power and clock management system is the Power Management Unit (PMU) illustrated As shown in.</p>
<p><img src="http://jiali.clouddn.com/20201012_006.png" alt=""></p>
<p>The user application is not required to actively control power and clock, since the PMU is able to automatically detect which resources are required by the different components in the system at any given time. The PMU will continuously optimize the system based on this information to achieve the lowest power consumption possible without user interaction.</p>
<h2 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h2><p>nRF5 Soc 有两种休眠模式，它们区别如下：</p>
<p><img src="http://jiali.clouddn.com/20201012_007.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>System OFF mode：System OFF is the deepest power saving mode the system can enter. In this mode, the system’s core functionality is powered down and all ongoing tasks are terminated.</p>
<p>The device can be put into System OFF mode using the POWER register interface. When in System OFF mode, the device can be woken up through one of the following signals:</p>
<ol>
<li>The DETECT signal, optionally generated by the GPIO peripheral</li>
<li>The ANADETECT signal, optionally generated by the LPCOMP module</li>
<li>The SENSE signal, optionally generated by the NFC module to “wake-on-field”</li>
<li>A reset</li>
</ol>
</li>
<li><p>System ON mode：System ON is the default state after power-on reset. In System ON, all functional blocks such as the CPU or peripherals, can be in IDLE or RUN mode, depending on the configuration set by the software and the state of the application executing.</p>
</li>
</ul>
<p>The system can switch on and off the appropriate internal power sources, depending on how much power is needed at any given time. The power requirement of a peripheral is directly related to its activity level, and the activity level of a peripheral is usually raised and lowered when specific tasks are triggered or events are generated.</p>
<h3 id="System-ON"><a href="#System-ON" class="headerlink" title="System ON"></a>System ON</h3><p>在System ON模式下，芯片仍然可以正常发出广播或者与手机保持蓝牙连接，所以大部分BLE应用都是工作在idle模式下，这样既保持了BLE功能又可以实现低功耗。使能softdevice时，进入System ON模式，函数接口如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sd_app_evt_wait()</span><br></pre></td></tr></table></figure>

<p>不带协议栈下进入System ON模式，指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Wait for an event.</span><br><span class="line">__WFE();</span><br><span class="line">&#x2F;&#x2F; Clear the internal event register.</span><br><span class="line">__SEV();</span><br><span class="line">__WFE();</span><br></pre></td></tr></table></figure>

<p><strong>summary:</strong></p>
<p><img src="http://jiali.clouddn.com/20201012_008.png" alt=""></p>
<p>nRF5 SDK 给出的例子，关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**@brief Function for handling the idle state (main loop).</span><br><span class="line"> *</span><br><span class="line"> * @details If there is no pending log operation, then sleep until next the next event occurs.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void idle_state_handle(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (NRF_LOG_PROCESS() &#x3D;&#x3D; false)</span><br><span class="line">    &#123;</span><br><span class="line">        nrf_pwr_mgmt_run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**@brief Function for application main entry.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    bool     erase_bonds;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Initialize.</span><br><span class="line">    log_init();</span><br><span class="line">    timers_init();</span><br><span class="line">    buttons_leds_init(&amp;erase_bonds);</span><br><span class="line">    power_management_init();</span><br><span class="line">    ble_stack_init();</span><br><span class="line">    gap_params_init();</span><br><span class="line">    gatt_init();</span><br><span class="line">    advertising_init();</span><br><span class="line">    services_init();</span><br><span class="line">    sensor_simulator_init();</span><br><span class="line">    conn_params_init();</span><br><span class="line">    peer_manager_init();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Start execution.</span><br><span class="line">    NRF_LOG_INFO(&quot;Blood Pressure example started.&quot;);</span><br><span class="line">    application_timers_start();</span><br><span class="line"></span><br><span class="line">    advertising_start(erase_bonds);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Enter main loop.</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        idle_state_handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nrf_pwr_mgmt_run()函数代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void nrf_pwr_mgmt_run(void)</span><br><span class="line">&#123;</span><br><span class="line">    PWR_MGMT_FPU_SLEEP_PREPARE();</span><br><span class="line">    PWR_MGMT_SLEEP_LOCK_ACQUIRE();</span><br><span class="line">    PWR_MGMT_CPU_USAGE_MONITOR_SECTION_ENTER();</span><br><span class="line">    PWR_MGMT_DEBUG_PIN_SET();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Wait for an event.</span><br><span class="line">#ifdef SOFTDEVICE_PRESENT</span><br><span class="line">    if (nrf_sdh_is_enabled())  &#x2F;&#x2F;使能协议栈</span><br><span class="line">    &#123;</span><br><span class="line">        ret_code_t ret_code &#x3D; sd_app_evt_wait();</span><br><span class="line">        ASSERT((ret_code &#x3D;&#x3D; NRF_SUCCESS) || (ret_code &#x3D;&#x3D; NRF_ERROR_SOFTDEVICE_NOT_ENABLED));</span><br><span class="line">        UNUSED_VARIABLE(ret_code);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">#endif &#x2F;&#x2F; SOFTDEVICE_PRESENT</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Wait for an event.</span><br><span class="line">        __WFE();</span><br><span class="line">        &#x2F;&#x2F; Clear the internal event register.</span><br><span class="line">        __SEV();</span><br><span class="line">        __WFE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PWR_MGMT_DEBUG_PIN_CLEAR();</span><br><span class="line">    PWR_MGMT_CPU_USAGE_MONITOR_SECTION_EXIT();</span><br><span class="line">    PWR_MGMT_SLEEP_LOCK_RELEASE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电流消耗"><a href="#电流消耗" class="headerlink" title="电流消耗"></a>电流消耗</h2><p>nordic nRF52382 规格书，给出 System ON 和System OFF模式功耗，如下</p>
<p><img src="http://jiali.clouddn.com/20201012_009.png" alt=""></p>
<p>参考：</p>
<p><a href="https://embeddedcentric.com/lesson-14-nrf5x-power-management-tutorial/" target="_blank" rel="noopener">nrf5x-power-management</a></p>
<p><a href="https://www.cnblogs.com/iini/p/9351048.html" target="_blank" rel="noopener">板子功耗高的原因有哪些</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
  <entry>
    <title>nRF5 SDK app_scheduler原理</title>
    <url>/2020/10/12/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/nRF5%20SDK%20app_scheduler%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要放在main loop里面执行的函数，可以放到app_scheduler队列里面，使用app_scheduler来调度执行。调度程序主要负责从中断上下文向main函数上下文传送执行命令。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><strong>Logic in main context:</strong></p>
<ul>
<li>Define an event handler for each type of event expected.</li>
<li>Initialize the scheduler by calling the <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/group__app__scheduler.html#gaa9670ed0053a67304c3d2d0cb3eb1333" target="_blank" rel="noopener">APP_SCHED_INIT()</a> macro before entering the application main loop.</li>
<li>Call <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/group__app__scheduler.html#gab725820c32a8d05379db4567cf30e862" target="_blank" rel="noopener">app_sched_execute()</a> from the main loop each time the application wakes up because of an event (typically when <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s140.api.v6.0.0/group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga11d88d38ac99fb72cde74c9385d36433" target="_blank" rel="noopener">sd_app_evt_wait()</a> returns).</li>
</ul>
<p><strong>Logic in interrupt context:</strong></p>
<ul>
<li>In the interrupt handler, call <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/group__app__scheduler.html#ga65ba3e30627bb62882d15cde87b610f0" target="_blank" rel="noopener">app_sched_event_put()</a> with the appropriate data and event handler. This will insert an event into the scheduler’s queue. The <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/group__app__scheduler.html#gab725820c32a8d05379db4567cf30e862" target="_blank" rel="noopener">app_sched_execute()</a> function will pull this event and call its handler in the main context.</li>
</ul>
<h2 id="app-scheduler设计"><a href="#app-scheduler设计" class="headerlink" title="app_scheduler设计"></a>app_scheduler设计</h2><p>app_scheduler软件设计框架如下</p>
<p><img src="http://jiali.clouddn.com/20201012_001.png" alt=""></p>
<p><strong>1、Applications using the Scheduler</strong></p>
<p>Sequence diagrams illustrating the flow of events for various scenarios in the example applications when using the Scheduler.</p>
<p><img src="http://jiali.clouddn.com/20201012_002.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201012_003.png" alt=""></p>
<p><strong>2、Applications not using the Scheduler</strong></p>
<p>Sequence diagrams illustrating the flow of events for various scenarios in the example applications when not using the Scheduler.</p>
<p><img src="http://jiali.clouddn.com/20201012_004.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201012_005.png" alt=""></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line"> * The information contained herein is property of Nordic Semiconductor ASA.</span><br><span class="line"> * Terms and conditions of usage are described in detail in NORDIC</span><br><span class="line"> * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.</span><br><span class="line"> *</span><br><span class="line"> * Licensees are granted free, non-transferable use of the information. NO</span><br><span class="line"> * WARRANTY of ANY KIND is provided. This heading must NOT be removed from</span><br><span class="line"> * the file.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This example is basically the ble_app_uart example in nRF5 SDK 12.2.0 with nRF51 ADC addon</span><br><span class="line"> * functionality. ADC sampling is triggered with pressing Button 4 (search for BSP_EVENT_KEY_3</span><br><span class="line"> * in this file) on the nRF51-DK board. When Button 4 is pressed, ADC sample task is put into </span><br><span class="line"> * app_scheduler queue, which results in the adc_sample function to be executed in the main </span><br><span class="line"> * context. The ADC outputs the result on UART.</span><br><span class="line"> *</span><br><span class="line"> * In this example, a single ADC channel is configured to sample on Analog Input 2, which maps</span><br><span class="line"> * to physical pin P0.01 on the nRF51 IC. Buffer size is set to 3, which makes the nrf_drv_adc</span><br><span class="line"> * driver return callback first when three samples have been triggered with three calls to </span><br><span class="line"> * nrf_drv_adc_sample function. When Button 4 is pressed once, buffer is allocated and the </span><br><span class="line"> * nrf_drv_adc_sample funciton is called three times which will output three ADC sample results</span><br><span class="line"> * on the UART. The ADC_BUFFER_SIZE constant configures the ADC buffer size. </span><br><span class="line"> *</span><br><span class="line"> * The UART output can be seen by connecting with e.g. Realterm UART terminal program for PC </span><br><span class="line"> * (when nRF51-DK connected to PC via USB) with the UART settings configured in the uart_init </span><br><span class="line"> * function, which is also described in the ble_app_uart documentation at </span><br><span class="line"> * http:&#x2F;&#x2F;infocenter.nordicsemi.com&#x2F;topic&#x2F;com.nordic.infocenter.sdk5.v12.2.0&#x2F;ble_sdk_app_nus_eval.html?cp&#x3D;4_0_1_4_2_2_18_2#project_uart_nus_eval_test</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &quot;nordic_common.h&quot;</span><br><span class="line">#include &quot;nrf.h&quot;</span><br><span class="line">#include &quot;ble_hci.h&quot;</span><br><span class="line">#include &quot;ble_advdata.h&quot;</span><br><span class="line">#include &quot;ble_advertising.h&quot;</span><br><span class="line">#include &quot;ble_conn_params.h&quot;</span><br><span class="line">#include &quot;softdevice_handler.h&quot;</span><br><span class="line">#include &quot;app_timer.h&quot;</span><br><span class="line">#include &quot;app_button.h&quot;</span><br><span class="line">#include &quot;ble_nus.h&quot;</span><br><span class="line">#include &quot;app_uart.h&quot;</span><br><span class="line">#include &quot;app_util_platform.h&quot;</span><br><span class="line">#include &quot;bsp.h&quot;</span><br><span class="line">#include &quot;bsp_btn_ble.h&quot;</span><br><span class="line">#include &quot;nrf_drv_adc.h&quot;</span><br><span class="line">#include &quot;app_scheduler.h&quot;</span><br><span class="line"></span><br><span class="line">#define IS_SRVC_CHANGED_CHARACT_PRESENT 0                                           &#x2F;**&lt; Include the service_changed characteristic. If not enabled, the server&#39;s database cannot be changed for the lifetime of the device. *&#x2F;</span><br><span class="line"></span><br><span class="line">#if (NRF_SD_BLE_API_VERSION &#x3D;&#x3D; 3)</span><br><span class="line">#define NRF_BLE_MAX_MTU_SIZE            GATT_MTU_SIZE_DEFAULT                       &#x2F;**&lt; MTU size used in the softdevice enabling and to reply to a BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event. *&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define APP_FEATURE_NOT_SUPPORTED       BLE_GATT_STATUS_ATTERR_APP_BEGIN + 2        &#x2F;**&lt; Reply when unsupported features are requested. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define CENTRAL_LINK_COUNT              0                                           &#x2F;**&lt; Number of central links used by the application. When changing this number remember to adjust the RAM settings*&#x2F;</span><br><span class="line">#define PERIPHERAL_LINK_COUNT           1                                           &#x2F;**&lt; Number of peripheral links used by the application. When changing this number remember to adjust the RAM settings*&#x2F;</span><br><span class="line"></span><br><span class="line">#define DEVICE_NAME                     &quot;Nordic_UART&quot;                               &#x2F;**&lt; Name of device. Will be included in the advertising data. *&#x2F;</span><br><span class="line">#define NUS_SERVICE_UUID_TYPE           BLE_UUID_TYPE_VENDOR_BEGIN                  &#x2F;**&lt; UUID type for the Nordic UART Service (vendor specific). *&#x2F;</span><br><span class="line"></span><br><span class="line">#define APP_ADV_INTERVAL                64                                          &#x2F;**&lt; The advertising interval (in units of 0.625 ms. This value corresponds to 40 ms). *&#x2F;</span><br><span class="line">#define APP_ADV_TIMEOUT_IN_SECONDS      180                                         &#x2F;**&lt; The advertising timeout (in units of seconds). *&#x2F;</span><br><span class="line"></span><br><span class="line">#define APP_TIMER_PRESCALER             0                                           &#x2F;**&lt; Value of the RTC1 PRESCALER register. *&#x2F;</span><br><span class="line">#define APP_TIMER_OP_QUEUE_SIZE         4                                           &#x2F;**&lt; Size of timer operation queues. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define MIN_CONN_INTERVAL               MSEC_TO_UNITS(20, UNIT_1_25_MS)             &#x2F;**&lt; Minimum acceptable connection interval (20 ms), Connection interval uses 1.25 ms units. *&#x2F;</span><br><span class="line">#define MAX_CONN_INTERVAL               MSEC_TO_UNITS(75, UNIT_1_25_MS)             &#x2F;**&lt; Maximum acceptable connection interval (75 ms), Connection interval uses 1.25 ms units. *&#x2F;</span><br><span class="line">#define SLAVE_LATENCY                   0                                           &#x2F;**&lt; Slave latency. *&#x2F;</span><br><span class="line">#define CONN_SUP_TIMEOUT                MSEC_TO_UNITS(4000, UNIT_10_MS)             &#x2F;**&lt; Connection supervisory timeout (4 seconds), Supervision Timeout uses 10 ms units. *&#x2F;</span><br><span class="line">#define FIRST_CONN_PARAMS_UPDATE_DELAY  APP_TIMER_TICKS(5000, APP_TIMER_PRESCALER)  &#x2F;**&lt; Time from initiating event (connect or start of notification) to first time sd_ble_gap_conn_param_update is called (5 seconds). *&#x2F;</span><br><span class="line">#define NEXT_CONN_PARAMS_UPDATE_DELAY   APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER) &#x2F;**&lt; Time between each call to sd_ble_gap_conn_param_update after the first call (30 seconds). *&#x2F;</span><br><span class="line">#define MAX_CONN_PARAMS_UPDATE_COUNT    3                                           &#x2F;**&lt; Number of attempts before giving up the connection parameter negotiation. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define DEAD_BEEF                       0xDEADBEEF                                  &#x2F;**&lt; Value used as error code on stack dump, can be used to identify stack location on stack unwind. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define UART_TX_BUF_SIZE                1024                                         &#x2F;**&lt; UART TX buffer size. *&#x2F;</span><br><span class="line">#define UART_RX_BUF_SIZE                256                                         &#x2F;**&lt; UART RX buffer size. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define APP_SCHED_MAX_EVT_SIZE          30</span><br><span class="line">#define APP_SCHED_QUEUE_SIZE            10</span><br><span class="line"></span><br><span class="line">#define ADC_BUFFER_SIZE 3                                                           &#x2F;**&lt; Size of buffer for ADC samples.  *&#x2F;</span><br><span class="line">static nrf_adc_value_t                  adc_buffer[ADC_BUFFER_SIZE];                &#x2F;**&lt; ADC buffer. *&#x2F;</span><br><span class="line">static nrf_drv_adc_channel_t            m_channel_config &#x3D; NRF_DRV_ADC_DEFAULT_CHANNEL(NRF_ADC_CONFIG_INPUT_2); &#x2F;**&lt; Channel instance. Default configuration used. *&#x2F;</span><br><span class="line">static uint8_t                          adc_event_counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">static ble_nus_t                        m_nus;                                      &#x2F;**&lt; Structure to identify the Nordic UART Service. *&#x2F;</span><br><span class="line">static uint16_t                         m_conn_handle &#x3D; BLE_CONN_HANDLE_INVALID;    &#x2F;**&lt; Handle of the current connection. *&#x2F;</span><br><span class="line"></span><br><span class="line">static ble_uuid_t                       m_adv_uuids[] &#x3D; &#123;&#123;BLE_UUID_NUS_SERVICE, NUS_SERVICE_UUID_TYPE&#125;&#125;;  &#x2F;**&lt; Universally unique service identifier. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for placing the application in low power state while waiting for events.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void power_manage(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code &#x3D; sd_app_evt_wait();</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for assert macro callback.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will be called in case of an assert in the SoftDevice.</span><br><span class="line"> *</span><br><span class="line"> * @warning This handler is an example only and does not fit a final product. You need to analyse</span><br><span class="line"> *          how your product is supposed to react in case of Assert.</span><br><span class="line"> * @warning On assert from the SoftDevice, the system can only recover on reset.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] line_num    Line number of the failing ASSERT call.</span><br><span class="line"> * @param[in] p_file_name File name of the failing ASSERT call.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)</span><br><span class="line">&#123;</span><br><span class="line">    app_error_handler(DEAD_BEEF, line_num, p_file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for the GAP initialization.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will set up all the necessary GAP (Generic Access Profile) parameters of</span><br><span class="line"> *          the device. It also sets the permissions and appearance.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void gap_params_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t                err_code;</span><br><span class="line">    ble_gap_conn_params_t   gap_conn_params;</span><br><span class="line">    ble_gap_conn_sec_mode_t sec_mode;</span><br><span class="line"></span><br><span class="line">    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&amp;sec_mode);</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; sd_ble_gap_device_name_set(&amp;sec_mode,</span><br><span class="line">                                          (const uint8_t *) DEVICE_NAME,</span><br><span class="line">                                          strlen(DEVICE_NAME));</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    memset(&amp;gap_conn_params, 0, sizeof(gap_conn_params));</span><br><span class="line"></span><br><span class="line">    gap_conn_params.min_conn_interval &#x3D; MIN_CONN_INTERVAL;</span><br><span class="line">    gap_conn_params.max_conn_interval &#x3D; MAX_CONN_INTERVAL;</span><br><span class="line">    gap_conn_params.slave_latency     &#x3D; SLAVE_LATENCY;</span><br><span class="line">    gap_conn_params.conn_sup_timeout  &#x3D; CONN_SUP_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; sd_ble_gap_ppcp_set(&amp;gap_conn_params);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for handling the data from the Nordic UART Service.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will process the data received from the Nordic UART BLE Service and send</span><br><span class="line"> *          it to the UART module.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] p_nus    Nordic UART Service structure.</span><br><span class="line"> * @param[in] p_data   Data to be send to UART module.</span><br><span class="line"> * @param[in] length   Length of the data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**@snippet [Handling the data received over BLE] *&#x2F;</span><br><span class="line">static void nus_data_handler(ble_nus_t * p_nus, uint8_t * p_data, uint16_t length)</span><br><span class="line">&#123;</span><br><span class="line">    for (uint32_t i &#x3D; 0; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while (app_uart_put(p_data[i]) !&#x3D; NRF_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    while (app_uart_put(&#39;\r&#39;) !&#x3D; NRF_SUCCESS);</span><br><span class="line">    while (app_uart_put(&#39;\n&#39;) !&#x3D; NRF_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**@snippet [Handling the data received over BLE] *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for initializing services that will be used by the application.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void services_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t       err_code;</span><br><span class="line">    ble_nus_init_t nus_init;</span><br><span class="line"></span><br><span class="line">    memset(&amp;nus_init, 0, sizeof(nus_init));</span><br><span class="line"></span><br><span class="line">    nus_init.data_handler &#x3D; nus_data_handler;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; ble_nus_init(&amp;m_nus, &amp;nus_init);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for handling an event from the Connection Parameters Module.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will be called for all events in the Connection Parameters Module</span><br><span class="line"> *          which are passed to the application.</span><br><span class="line"> *</span><br><span class="line"> * @note All this function does is to disconnect. This could have been done by simply setting</span><br><span class="line"> *       the disconnect_on_fail config parameter, but instead we use the event handler</span><br><span class="line"> *       mechanism to demonstrate its use.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] p_evt  Event received from the Connection Parameters Module.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void on_conn_params_evt(ble_conn_params_evt_t * p_evt)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line"></span><br><span class="line">    if (p_evt-&gt;evt_type &#x3D;&#x3D; BLE_CONN_PARAMS_EVT_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        err_code &#x3D; sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);</span><br><span class="line">        APP_ERROR_CHECK(err_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for handling errors from the Connection Parameters module.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] nrf_error  Error code containing information about what went wrong.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void conn_params_error_handler(uint32_t nrf_error)</span><br><span class="line">&#123;</span><br><span class="line">    APP_ERROR_HANDLER(nrf_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for initializing the Connection Parameters module.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void conn_params_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t               err_code;</span><br><span class="line">    ble_conn_params_init_t cp_init;</span><br><span class="line"></span><br><span class="line">    memset(&amp;cp_init, 0, sizeof(cp_init));</span><br><span class="line"></span><br><span class="line">    cp_init.p_conn_params                  &#x3D; NULL;</span><br><span class="line">    cp_init.first_conn_params_update_delay &#x3D; FIRST_CONN_PARAMS_UPDATE_DELAY;</span><br><span class="line">    cp_init.next_conn_params_update_delay  &#x3D; NEXT_CONN_PARAMS_UPDATE_DELAY;</span><br><span class="line">    cp_init.max_conn_params_update_count   &#x3D; MAX_CONN_PARAMS_UPDATE_COUNT;</span><br><span class="line">    cp_init.start_on_notify_cccd_handle    &#x3D; BLE_GATT_HANDLE_INVALID;</span><br><span class="line">    cp_init.disconnect_on_fail             &#x3D; false;</span><br><span class="line">    cp_init.evt_handler                    &#x3D; on_conn_params_evt;</span><br><span class="line">    cp_init.error_handler                  &#x3D; conn_params_error_handler;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; ble_conn_params_init(&amp;cp_init);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for putting the chip into sleep mode.</span><br><span class="line"> *</span><br><span class="line"> * @note This function will not return.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void sleep_mode_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code &#x3D; bsp_indication_set(BSP_INDICATE_IDLE);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prepare wakeup buttons.</span><br><span class="line">    err_code &#x3D; bsp_btn_ble_sleep_mode_prepare();</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Go to system-off mode (this function will not return; wakeup will cause a reset).</span><br><span class="line">    err_code &#x3D; sd_power_system_off();</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for handling advertising events.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will be called for advertising events which are passed to the application.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] ble_adv_evt  Advertising event.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void on_adv_evt(ble_adv_evt_t ble_adv_evt)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line"></span><br><span class="line">    switch (ble_adv_evt)</span><br><span class="line">    &#123;</span><br><span class="line">        case BLE_ADV_EVT_FAST:</span><br><span class="line">            err_code &#x3D; bsp_indication_set(BSP_INDICATE_ADVERTISING);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break;</span><br><span class="line">        case BLE_ADV_EVT_IDLE:</span><br><span class="line">            sleep_mode_enter();</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for the application&#39;s SoftDevice event handler.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] p_ble_evt SoftDevice event.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void on_ble_evt(ble_evt_t * p_ble_evt)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line"></span><br><span class="line">    switch (p_ble_evt-&gt;header.evt_id)</span><br><span class="line">    &#123;</span><br><span class="line">        case BLE_GAP_EVT_CONNECTED:</span><br><span class="line">            err_code &#x3D; bsp_indication_set(BSP_INDICATE_CONNECTED);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            m_conn_handle &#x3D; p_ble_evt-&gt;evt.gap_evt.conn_handle;</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GAP_EVT_CONNECTED</span><br><span class="line"></span><br><span class="line">        case BLE_GAP_EVT_DISCONNECTED:</span><br><span class="line">            err_code &#x3D; bsp_indication_set(BSP_INDICATE_IDLE);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            m_conn_handle &#x3D; BLE_CONN_HANDLE_INVALID;</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GAP_EVT_DISCONNECTED</span><br><span class="line"></span><br><span class="line">        case BLE_GAP_EVT_SEC_PARAMS_REQUEST:</span><br><span class="line">            &#x2F;&#x2F; Pairing not supported</span><br><span class="line">            err_code &#x3D; sd_ble_gap_sec_params_reply(m_conn_handle, BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP, NULL, NULL);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GAP_EVT_SEC_PARAMS_REQUEST</span><br><span class="line"></span><br><span class="line">        case BLE_GATTS_EVT_SYS_ATTR_MISSING:</span><br><span class="line">            &#x2F;&#x2F; No system attributes have been stored.</span><br><span class="line">            err_code &#x3D; sd_ble_gatts_sys_attr_set(m_conn_handle, NULL, 0, 0);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GATTS_EVT_SYS_ATTR_MISSING</span><br><span class="line"></span><br><span class="line">        case BLE_GATTC_EVT_TIMEOUT:</span><br><span class="line">            &#x2F;&#x2F; Disconnect on GATT Client timeout event.</span><br><span class="line">            err_code &#x3D; sd_ble_gap_disconnect(p_ble_evt-&gt;evt.gattc_evt.conn_handle,</span><br><span class="line">                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GATTC_EVT_TIMEOUT</span><br><span class="line"></span><br><span class="line">        case BLE_GATTS_EVT_TIMEOUT:</span><br><span class="line">            &#x2F;&#x2F; Disconnect on GATT Server timeout event.</span><br><span class="line">            err_code &#x3D; sd_ble_gap_disconnect(p_ble_evt-&gt;evt.gatts_evt.conn_handle,</span><br><span class="line">                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GATTS_EVT_TIMEOUT</span><br><span class="line"></span><br><span class="line">        case BLE_EVT_USER_MEM_REQUEST:</span><br><span class="line">            err_code &#x3D; sd_ble_user_mem_reply(p_ble_evt-&gt;evt.gattc_evt.conn_handle, NULL);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_EVT_USER_MEM_REQUEST</span><br><span class="line"></span><br><span class="line">        case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:</span><br><span class="line">        &#123;</span><br><span class="line">            ble_gatts_evt_rw_authorize_request_t  req;</span><br><span class="line">            ble_gatts_rw_authorize_reply_params_t auth_reply;</span><br><span class="line"></span><br><span class="line">            req &#x3D; p_ble_evt-&gt;evt.gatts_evt.params.authorize_request;</span><br><span class="line"></span><br><span class="line">            if (req.type !&#x3D; BLE_GATTS_AUTHORIZE_TYPE_INVALID)</span><br><span class="line">            &#123;</span><br><span class="line">                if ((req.request.write.op &#x3D;&#x3D; BLE_GATTS_OP_PREP_WRITE_REQ)     ||</span><br><span class="line">                    (req.request.write.op &#x3D;&#x3D; BLE_GATTS_OP_EXEC_WRITE_REQ_NOW) ||</span><br><span class="line">                    (req.request.write.op &#x3D;&#x3D; BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (req.type &#x3D;&#x3D; BLE_GATTS_AUTHORIZE_TYPE_WRITE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        auth_reply.type &#x3D; BLE_GATTS_AUTHORIZE_TYPE_WRITE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        auth_reply.type &#x3D; BLE_GATTS_AUTHORIZE_TYPE_READ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    auth_reply.params.write.gatt_status &#x3D; APP_FEATURE_NOT_SUPPORTED;</span><br><span class="line">                    err_code &#x3D; sd_ble_gatts_rw_authorize_reply(p_ble_evt-&gt;evt.gatts_evt.conn_handle,</span><br><span class="line">                                                               &amp;auth_reply);</span><br><span class="line">                    APP_ERROR_CHECK(err_code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break; &#x2F;&#x2F; BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST</span><br><span class="line"></span><br><span class="line">#if (NRF_SD_BLE_API_VERSION &#x3D;&#x3D; 3)</span><br><span class="line">        case BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST:</span><br><span class="line">            err_code &#x3D; sd_ble_gatts_exchange_mtu_reply(p_ble_evt-&gt;evt.gatts_evt.conn_handle,</span><br><span class="line">                                                       NRF_BLE_MAX_MTU_SIZE);</span><br><span class="line">            APP_ERROR_CHECK(err_code);</span><br><span class="line">            break; &#x2F;&#x2F; BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            &#x2F;&#x2F; No implementation needed.</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for dispatching a SoftDevice event to all modules with a SoftDevice</span><br><span class="line"> *        event handler.</span><br><span class="line"> *</span><br><span class="line"> * @details This function is called from the SoftDevice event interrupt handler after a</span><br><span class="line"> *          SoftDevice event has been received.</span><br><span class="line"> *</span><br><span class="line"> * @param[in] p_ble_evt  SoftDevice event.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ble_evt_dispatch(ble_evt_t * p_ble_evt)</span><br><span class="line">&#123;</span><br><span class="line">    ble_conn_params_on_ble_evt(p_ble_evt);</span><br><span class="line">    ble_nus_on_ble_evt(&amp;m_nus, p_ble_evt);</span><br><span class="line">    on_ble_evt(p_ble_evt);</span><br><span class="line">    ble_advertising_on_ble_evt(p_ble_evt);</span><br><span class="line">    bsp_btn_ble_on_ble_evt(p_ble_evt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for the SoftDevice initialization.</span><br><span class="line"> *</span><br><span class="line"> * @details This function initializes the SoftDevice and the BLE event interrupt.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ble_stack_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line"></span><br><span class="line">    nrf_clock_lf_cfg_t clock_lf_cfg &#x3D; NRF_CLOCK_LFCLKSRC;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Initialize SoftDevice.</span><br><span class="line">    SOFTDEVICE_HANDLER_INIT(&amp;clock_lf_cfg, NULL);</span><br><span class="line"></span><br><span class="line">    ble_enable_params_t ble_enable_params;</span><br><span class="line">    err_code &#x3D; softdevice_enable_get_default_config(CENTRAL_LINK_COUNT,</span><br><span class="line">                                                    PERIPHERAL_LINK_COUNT,</span><br><span class="line">                                                    &amp;ble_enable_params);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Check the ram settings against the used number of links</span><br><span class="line">    CHECK_RAM_START_ADDR(CENTRAL_LINK_COUNT,PERIPHERAL_LINK_COUNT);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Enable BLE stack.</span><br><span class="line">#if (NRF_SD_BLE_API_VERSION &#x3D;&#x3D; 3)</span><br><span class="line">    ble_enable_params.gatt_enable_params.att_mtu &#x3D; NRF_BLE_MAX_MTU_SIZE;</span><br><span class="line">#endif</span><br><span class="line">    err_code &#x3D; softdevice_enable(&amp;ble_enable_params);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Subscribe for BLE events.</span><br><span class="line">    err_code &#x3D; softdevice_ble_evt_handler_set(ble_evt_dispatch);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void adc_sample(void)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t ret_code;</span><br><span class="line">	</span><br><span class="line">    ret_code &#x3D; nrf_drv_adc_buffer_convert(adc_buffer, ADC_BUFFER_SIZE);        &#x2F;&#x2F; Allocate buffer for ADC</span><br><span class="line">    APP_ERROR_CHECK(ret_code);</span><br><span class="line">	</span><br><span class="line">    for (uint32_t i &#x3D; 0; i &lt; ADC_BUFFER_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while((NRF_ADC-&gt;BUSY &amp; ADC_BUSY_BUSY_Msk) &#x3D;&#x3D; ADC_BUSY_BUSY_Busy) &#123;&#125;    &#x2F;&#x2F;Wait until the ADC is finished sampling</span><br><span class="line">        printf(&quot;Start sampling ... \r\n&quot;);</span><br><span class="line">        nrf_drv_adc_sample();</span><br><span class="line">    &#125;					</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for handling events from the BSP module.</span><br><span class="line"> *</span><br><span class="line"> * @param[in]   event   Event generated by button press.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void bsp_event_handler(bsp_event_t event)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line">    switch (event)</span><br><span class="line">    &#123;</span><br><span class="line">        case BSP_EVENT_SLEEP:</span><br><span class="line">            sleep_mode_enter();</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BSP_EVENT_DISCONNECT:</span><br><span class="line">            err_code &#x3D; sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);</span><br><span class="line">            if (err_code !&#x3D; NRF_ERROR_INVALID_STATE)</span><br><span class="line">            &#123;</span><br><span class="line">                APP_ERROR_CHECK(err_code);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BSP_EVENT_WHITELIST_OFF:</span><br><span class="line">            if (m_conn_handle &#x3D;&#x3D; BLE_CONN_HANDLE_INVALID)</span><br><span class="line">            &#123;</span><br><span class="line">                err_code &#x3D; ble_advertising_restart_without_whitelist();</span><br><span class="line">                if (err_code !&#x3D; NRF_ERROR_INVALID_STATE)</span><br><span class="line">                &#123;</span><br><span class="line">                    APP_ERROR_CHECK(err_code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        case BSP_EVENT_KEY_3:</span><br><span class="line">            printf(&quot;\r\n    BUTTON 4 is pressed...\r\n&quot;);                      &#x2F;&#x2F;Indicate on UART that Button 4 is pressed</span><br><span class="line">            app_sched_event_put(0,0,(app_sched_event_handler_t)adc_sample);    &#x2F;&#x2F;Put adc_sample function into the scheduler queue, which will then be executed in the main context (lowest priority) when app_sched_execute is called in the main loop</span><br><span class="line">            break;	</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief   Function for handling app_uart events.</span><br><span class="line"> *</span><br><span class="line"> * @details This function will receive a single character from the app_uart module and append it to</span><br><span class="line"> *          a string. The string will be be sent over BLE when the last character received was a</span><br><span class="line"> *          &#39;new line&#39; i.e &#39;\r\n&#39; (hex 0x0D) or if the string has reached a length of</span><br><span class="line"> *          @ref NUS_MAX_DATA_LENGTH.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**@snippet [Handling the data received over UART] *&#x2F;</span><br><span class="line">void uart_event_handle(app_uart_evt_t * p_event)</span><br><span class="line">&#123;</span><br><span class="line">    static uint8_t data_array[BLE_NUS_MAX_DATA_LEN];</span><br><span class="line">    static uint8_t index &#x3D; 0;</span><br><span class="line">    uint32_t       err_code;</span><br><span class="line"></span><br><span class="line">    switch (p_event-&gt;evt_type)</span><br><span class="line">    &#123;</span><br><span class="line">        case APP_UART_DATA_READY:</span><br><span class="line">            UNUSED_VARIABLE(app_uart_get(&amp;data_array[index]));</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            if ((data_array[index - 1] &#x3D;&#x3D; &#39;\n&#39;) || (index &gt;&#x3D; (BLE_NUS_MAX_DATA_LEN)))</span><br><span class="line">            &#123;</span><br><span class="line">                err_code &#x3D; ble_nus_string_send(&amp;m_nus, data_array, index);</span><br><span class="line">                if (err_code !&#x3D; NRF_ERROR_INVALID_STATE)</span><br><span class="line">                &#123;</span><br><span class="line">                    APP_ERROR_CHECK(err_code);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                index &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case APP_UART_COMMUNICATION_ERROR:</span><br><span class="line">            APP_ERROR_HANDLER(p_event-&gt;data.error_communication);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case APP_UART_FIFO_ERROR:</span><br><span class="line">            APP_ERROR_HANDLER(p_event-&gt;data.error_code);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**@snippet [Handling the data received over UART] *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief  Function for initializing the UART module.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**@snippet [UART Initialization] *&#x2F;</span><br><span class="line">static void uart_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t                     err_code;</span><br><span class="line">    const app_uart_comm_params_t comm_params &#x3D;</span><br><span class="line">    &#123;</span><br><span class="line">        RX_PIN_NUMBER,</span><br><span class="line">        TX_PIN_NUMBER,</span><br><span class="line">        RTS_PIN_NUMBER,</span><br><span class="line">        CTS_PIN_NUMBER,</span><br><span class="line">        APP_UART_FLOW_CONTROL_DISABLED,</span><br><span class="line">        false,</span><br><span class="line">        UART_BAUDRATE_BAUDRATE_Baud115200</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    APP_UART_FIFO_INIT( &amp;comm_params,</span><br><span class="line">                       UART_RX_BUF_SIZE,</span><br><span class="line">                       UART_TX_BUF_SIZE,</span><br><span class="line">                       uart_event_handle,</span><br><span class="line">                       APP_IRQ_PRIORITY_LOWEST,</span><br><span class="line">                       err_code);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**@snippet [UART Initialization] *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for initializing the Advertising functionality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void advertising_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t               err_code;</span><br><span class="line">    ble_advdata_t          advdata;</span><br><span class="line">    ble_advdata_t          scanrsp;</span><br><span class="line">    ble_adv_modes_config_t options;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Build advertising data struct to pass into @ref ble_advertising_init.</span><br><span class="line">    memset(&amp;advdata, 0, sizeof(advdata));</span><br><span class="line">    advdata.name_type          &#x3D; BLE_ADVDATA_FULL_NAME;</span><br><span class="line">    advdata.include_appearance &#x3D; false;</span><br><span class="line">    advdata.flags              &#x3D; BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE;</span><br><span class="line"></span><br><span class="line">    memset(&amp;scanrsp, 0, sizeof(scanrsp));</span><br><span class="line">    scanrsp.uuids_complete.uuid_cnt &#x3D; sizeof(m_adv_uuids) &#x2F; sizeof(m_adv_uuids[0]);</span><br><span class="line">    scanrsp.uuids_complete.p_uuids  &#x3D; m_adv_uuids;</span><br><span class="line"></span><br><span class="line">    memset(&amp;options, 0, sizeof(options));</span><br><span class="line">    options.ble_adv_fast_enabled  &#x3D; true;</span><br><span class="line">    options.ble_adv_fast_interval &#x3D; APP_ADV_INTERVAL;</span><br><span class="line">    options.ble_adv_fast_timeout  &#x3D; APP_ADV_TIMEOUT_IN_SECONDS;</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; ble_advertising_init(&amp;advdata, &amp;scanrsp, &amp;options, on_adv_evt, NULL);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Function for initializing buttons and leds.</span><br><span class="line"> *</span><br><span class="line"> * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void buttons_leds_init(bool * p_erase_bonds)</span><br><span class="line">&#123;</span><br><span class="line">    bsp_event_t startup_event;</span><br><span class="line"></span><br><span class="line">    uint32_t err_code &#x3D; bsp_init(BSP_INIT_LED | BSP_INIT_BUTTONS,</span><br><span class="line">                                 APP_TIMER_TICKS(100, APP_TIMER_PRESCALER),</span><br><span class="line">                                 bsp_event_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    err_code &#x3D; bsp_btn_ble_init(NULL, &amp;startup_event);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    *p_erase_bonds &#x3D; (startup_event &#x3D;&#x3D; BSP_EVENT_CLEAR_BONDING_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @brief ADC interrupt handler.</span><br><span class="line"> * Prints ADC results on hardware UART and over BLE via the NUS service.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void adc_event_handler(nrf_drv_adc_evt_t const * p_event)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t adc_result[ADC_BUFFER_SIZE*2];	</span><br><span class="line">	</span><br><span class="line">    if (p_event-&gt;type &#x3D;&#x3D; NRF_DRV_ADC_EVT_DONE)</span><br><span class="line">    &#123;</span><br><span class="line">        adc_event_counter++;</span><br><span class="line">        printf(&quot;    ADC event counter: %d\r\n&quot;, adc_event_counter);</span><br><span class="line">        for (uint32_t i &#x3D; 0; i &lt; p_event-&gt;data.done.size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Sample value %u: %d\r\n&quot;, (unsigned int)i+1, p_event-&gt;data.done.p_buffer[i]);</span><br><span class="line">            adc_result[(i*2)] &#x3D; p_event-&gt;data.done.p_buffer[i] &gt;&gt; 8;</span><br><span class="line">            adc_result[(i*2)+1] &#x3D; p_event-&gt;data.done.p_buffer[i];					</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        if(ADC_BUFFER_SIZE &lt;&#x3D; 10)</span><br><span class="line">        &#123;</span><br><span class="line">            ble_nus_string_send(&amp;m_nus, &amp;adc_result[0], ADC_BUFFER_SIZE*2);</span><br><span class="line">        &#125;					</span><br><span class="line">        LEDS_INVERT(BSP_LED_3_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @brief ADC initialization.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void adc_config(void)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t ret_code;</span><br><span class="line">    nrf_drv_adc_config_t config &#x3D; NRF_DRV_ADC_DEFAULT_CONFIG;</span><br><span class="line"></span><br><span class="line">    ret_code &#x3D; nrf_drv_adc_init(&amp;config, adc_event_handler);</span><br><span class="line">    APP_ERROR_CHECK(ret_code);</span><br><span class="line"></span><br><span class="line">    nrf_drv_adc_channel_enable(&amp;m_channel_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**@brief Application main function.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t err_code;</span><br><span class="line">    bool erase_bonds;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Initialize.</span><br><span class="line">    APP_SCHED_INIT(APP_SCHED_MAX_EVT_SIZE, APP_SCHED_QUEUE_SIZE);            &#x2F;&#x2F;Initialize scheduler</span><br><span class="line">    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);</span><br><span class="line">    uart_init();</span><br><span class="line"></span><br><span class="line">    buttons_leds_init(&amp;erase_bonds);</span><br><span class="line">    ble_stack_init();</span><br><span class="line">    gap_params_init();</span><br><span class="line">    services_init();</span><br><span class="line">    advertising_init();</span><br><span class="line">    conn_params_init();</span><br><span class="line"></span><br><span class="line">    printf(&quot;\r\nUART Start!\r\n&quot;);</span><br><span class="line">    err_code &#x3D; ble_advertising_start(BLE_ADV_MODE_FAST);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">    </span><br><span class="line">    adc_config();                &#x2F;&#x2F;Initialize ADC</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Enter main loop.</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        power_manage();          &#x2F;&#x2F; Enter sleep mode</span><br><span class="line">        app_sched_execute();     &#x2F;&#x2F;Let scheduler execute whatever is in the scheduler queue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @&#125;</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<p>Q&amp;S</p>
<p>问题1：app_sched_execute followed by sd_app_evt_wait</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app_sched_execute followed by sd_app_evt_wait</span><br><span class="line">Hello,</span><br><span class="line">I am working on a project based on the nRF51822 with the softdevice S110.</span><br><span class="line">I am trying to develop an application using the main loop provided in an example application:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Enter main loop</span><br><span class="line">for (;;)</span><br><span class="line">&#123;</span><br><span class="line">    app_sched_execute();</span><br><span class="line">    &lt;&lt;-- interrupt raised here that calls app_sched_event_put</span><br><span class="line">    sd_app_evt_wait();</span><br><span class="line">&#125;</span><br><span class="line">I am puzzled by this code for the idle loop, I do not understand how the system handles a situation where an interrupt is raised between the execution of app_shed_execute and sd_app_evt_wait. If the interrupt invokes a app_sched_event_put, then the system will still go to (deep) sleep mode and will not execute the event handler until the next loop which could come much later. Am I missing something in the architecture?</span><br><span class="line"></span><br><span class="line">Thanks Louis</span><br></pre></td></tr></table></figure>

<p>答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**@brief Waits for an application event.</span><br><span class="line"> *</span><br><span class="line"> * An application event is either an application interrupt or a pended interrupt when the interrupt</span><br><span class="line"> * is disabled.</span><br><span class="line"> *</span><br><span class="line"> * When the application waits for an application event by calling this function, an interrupt that</span><br><span class="line"> * is enabled will be taken immediately on pending since this function will wait in thread mode,</span><br><span class="line"> * then the execution will return in the application&#39;s main thread.</span><br><span class="line"> *</span><br><span class="line"> * In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M</span><br><span class="line"> * MCU&#39;s System Control Register (SCR), CMSIS_SCB. In that case, when a disabled interrupt gets</span><br><span class="line"> * pended, this function will return to the application&#39;s main thread.</span><br><span class="line"> *</span><br><span class="line"> * @note The application must ensure that the pended flag is cleared using ::sd_nvic_ClearPendingIRQ</span><br><span class="line"> *       in order to sleep using this function. This is only necessary for disabled interrupts, as</span><br><span class="line"> *       the interrupt handler will clear the pending flag automatically for enabled interrupts.</span><br><span class="line"> *</span><br><span class="line"> * @note If an application interrupt has happened since the last time sd_app_evt_wait was</span><br><span class="line"> *       called this function will return immediately and not go to sleep. This is to avoid race</span><br><span class="line"> *       conditions that can occur when a flag is updated in the interrupt handler and processed</span><br><span class="line"> *       in the main loop.</span><br><span class="line"> *</span><br><span class="line"> * @post An application interrupt has happened or a interrupt pending flag is set.</span><br><span class="line"> *</span><br><span class="line"> * @retval ::NRF_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));</span><br></pre></td></tr></table></figure>

<p>sd_app_evt_wait()函数是电源管理函数，执行该函数，系统进入sleep on 模式。产生中断，可唤醒系统，从sd_app_evt_wait()返回后，执行app_sched_execute()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* @note If an application interrupt has happened since the last time sd_app_evt_wait was</span><br><span class="line"> *       called this function will return immediately and not go to sleep. This is to avoid race</span><br><span class="line"> *       conditions that can occur when a flag is updated in the interrupt handler and processed</span><br><span class="line"> *       in the main loop.</span><br><span class="line"> 大概意思就是如果在调用sd_app_evt_wait之前，产生了中断，那么sd_app_evt_wait()不进入休眠，立即返回。这样避免了因进去休眠，本次中断产生的任务不能立即执行的情况</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://infocenter.nordicsemi.com/index.jsp" target="_blank" rel="noopener">Schedule handling library</a></p>
<p><a href="https://www.cnblogs.com/zjutlitao/p/5092871.html" target="_blank" rel="noopener">图解nRF51 SDK中的Schedule handling library 和Timer library</a></p>
<p><a href="https://embeddedcentric.com/lesson-14-nrf5x-power-management-tutorial/" target="_blank" rel="noopener">nrf5x-power-management-tutorial</a></p>
<p><a href="https://blog.csdn.net/huitailang_1_1/article/details/88556149" target="_blank" rel="noopener">nordic 调度器代码分析</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
  <entry>
    <title>Linux framebuffer软件架构</title>
    <url>/2021/01/19/Linux/Driver/video/Linux%20framebuffer%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想想用51单片机控制8088液晶屏的过程，首先编写一系列控制液晶屏的子函数，包括画点，画线、画圆，显示字符等子函数，这些子函数的功能控制lcd寄存器，在液晶屏上画一个点。然后在main函数里面调用这些子函数，实现字符显示功能。那么，在Linux上，实现控制液晶屏的原理也是跟单片机一样，都需要控制lcd的寄存器和时序。只不过，Linux分为应用层和内核，应用层和内核交互必须通过一套机制去实现，这套机制就是open,read,write等接口。因此，应用层想要在液晶屏上显示内容，就必须通过open,read,write等函数实现。为了更好的管理显示设备，Linux设计出一套管理显示设备的通用软件架构，名称就是framebuffer.</p>
<h2 id="什么是framebuffer"><a href="#什么是framebuffer" class="headerlink" title="什么是framebuffer"></a>什么是framebuffer</h2><p>帧缓冲（Framebuffer）是Linux系统为显示设备提供一种抽象描述。framebuffer代表显示设备的缓存区，应用程序通过open,read,write等接口，就可以访问显示屏，不需要知道底层硬件的具体操作。</p>
<p>framebuffer帧缓冲设备给用户态提供的读写接口file_operations实际由fbmem.c文件里的特定file_operatins结构对象来提供。而具体帧缓冲设备由fb_info结构体的注册、注销及其中成员的维护，比较重要的成员fb_ops，fb_ops中的成员函数最终会操作LCD控制器的寄存器。</p>
<h2 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h2><p>framebuffer设备是一种字符设备。因此，framebuffer驱动设计基于字符设备驱动的机制来实现。软件架构如下</p>
<p><img src="http://jiali.clouddn.com/20210120_001.png" alt=""></p>
<p>​                                                                                                                    图 framebuffer 软件架构设计</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>1、fb_info结构体是显示器的抽象描述，定义在include/linux/fb.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct fb_info &#123;</span><br><span class="line">	atomic_t count;</span><br><span class="line">	int node;</span><br><span class="line">	int flags;</span><br><span class="line">	struct mutex lock;		&#x2F;* Lock for open&#x2F;release&#x2F;ioctl funcs *&#x2F;</span><br><span class="line">	struct mutex mm_lock;		&#x2F;* Lock for fb_mmap and smem_* fields *&#x2F;</span><br><span class="line">	struct fb_var_screeninfo var;	&#x2F;* Current var *&#x2F; &#x2F;&#x2F;LCD可变的参数</span><br><span class="line">	struct fb_fix_screeninfo fix;	&#x2F;* Current fix *&#x2F; &#x2F;&#x2F;LCD固定的参数</span><br><span class="line">	struct fb_monspecs monspecs;	&#x2F;* Current Monitor specs *&#x2F; &#x2F;&#x2F; LCD显示器标准</span><br><span class="line">	struct work_struct queue;	&#x2F;* Framebuffer event queue *&#x2F; &#x2F;&#x2F;帧缓冲事件队列</span><br><span class="line">	struct fb_pixmap pixmap;	&#x2F;* Image hardware mapper *&#x2F; &#x2F;&#x2F;图像硬件mapper</span><br><span class="line">	struct fb_pixmap sprite;	&#x2F;* Cursor hardware mapper *&#x2F; &#x2F;&#x2F;光标硬件mapper</span><br><span class="line">	struct fb_cmap cmap;		&#x2F;* Current cmap *&#x2F; &#x2F;&#x2F;当前的颜色表</span><br><span class="line">	struct list_head modelist;      &#x2F;* mode list *&#x2F; </span><br><span class="line">	struct fb_videomode *mode;	&#x2F;* current mode *&#x2F; &#x2F;&#x2F;当前的显示模式</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FB_BACKLIGHT</span><br><span class="line">	&#x2F;* assigned backlight device *&#x2F;</span><br><span class="line">	&#x2F;* set before framebuffer registration, </span><br><span class="line">	   remove after unregister *&#x2F;</span><br><span class="line">	struct backlight_device *bl_dev;  &#x2F;&#x2F;对应的背光设备</span><br><span class="line"></span><br><span class="line">	&#x2F;* Backlight level curve *&#x2F;</span><br><span class="line">	struct mutex bl_curve_mutex;	</span><br><span class="line">	u8 bl_curve[FB_BACKLIGHT_LEVELS];  &#x2F;&#x2F;背光调整</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FB_DEFERRED_IO</span><br><span class="line">	struct delayed_work deferred_work;</span><br><span class="line">	struct fb_deferred_io *fbdefio;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	struct fb_ops *fbops;  &#x2F;&#x2F;对底层硬件操作的函数指针</span><br><span class="line">	struct device *device;		&#x2F;* This is the parent *&#x2F;</span><br><span class="line">	struct device *dev;		&#x2F;* This is this fb device *&#x2F;</span><br><span class="line">	int class_flag;                    &#x2F;* private sysfs flags *&#x2F;</span><br><span class="line">#ifdef CONFIG_FB_TILEBLITTING</span><br><span class="line">	struct fb_tile_ops *tileops;    &#x2F;* Tile Blitting *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	char __iomem *screen_base;	&#x2F;* Virtual address *&#x2F;</span><br><span class="line">	unsigned long screen_size;	&#x2F;* Amount of ioremapped VRAM or 0 *&#x2F; &#x2F;&#x2F;LCD IO映射的虚拟内存大小</span><br><span class="line">	void *pseudo_palette;		&#x2F;* Fake palette of 16 colors *&#x2F; &#x2F;&#x2F;伪16色颜色表</span><br><span class="line">#define FBINFO_STATE_RUNNING	0</span><br><span class="line">#define FBINFO_STATE_SUSPENDED	1</span><br><span class="line">	u32 state;			&#x2F;* Hardware state i.e suspend *&#x2F;&#x2F;&#x2F;LCD的挂起或恢复状态</span><br><span class="line">	void *fbcon_par;                &#x2F;* fbcon use-only private area *&#x2F;</span><br><span class="line">	&#x2F;* From here on everything is device dependent *&#x2F;</span><br><span class="line">	void *par;</span><br><span class="line">	&#x2F;* we need the PCI or similar aperture base&#x2F;size not</span><br><span class="line">	   smem_start&#x2F;size as smem_start may just be an object</span><br><span class="line">	   allocated inside the aperture so may not actually overlap *&#x2F;</span><br><span class="line">	struct apertures_struct &#123;</span><br><span class="line">		unsigned int count;</span><br><span class="line">		struct aperture &#123;</span><br><span class="line">			resource_size_t base;</span><br><span class="line">			resource_size_t size;</span><br><span class="line">		&#125; ranges[0];</span><br><span class="line">	&#125; *apertures;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、var对可变的配置对象抽象描述</p>
<p>fb_var_screeninfo结构体主要记录用户可以修改的控制器的参数，比如屏幕的分辨率和每个像素的比特数等。该结构体定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct fb_var_screeninfo &#123;</span><br><span class="line">	__u32 xres;			&#x2F;* visible resolution		*&#x2F;&#x2F;&#x2F;可见屏幕一行有多少个像素点</span><br><span class="line">	__u32 yres;                               &#x2F;&#x2F;可见屏幕一列有多少个像素点</span><br><span class="line">	__u32 xres_virtual;		&#x2F;* virtual resolution		*&#x2F;&#x2F;&#x2F;虚拟屏幕一行有多少个像素点</span><br><span class="line">	__u32 yres_virtual;  &#x2F;&#x2F;虚拟屏幕一列有多少个像素点</span><br><span class="line">	__u32 xoffset;			&#x2F;* offset from virtual to visible *&#x2F;</span><br><span class="line">	__u32 yoffset;			&#x2F;* resolution			*&#x2F;</span><br><span class="line"></span><br><span class="line">	__u32 bits_per_pixel;		&#x2F;* guess what			*&#x2F;&#x2F;&#x2F;每个像素的位数</span><br><span class="line">	__u32 grayscale;		&#x2F;* !&#x3D; 0 Graylevels instead of colors *&#x2F; &#x2F;&#x2F;非0时，指的是灰度</span><br><span class="line"></span><br><span class="line">	struct fb_bitfield red;		&#x2F;* bitfield in fb mem if true color, *&#x2F;</span><br><span class="line">	struct fb_bitfield green;	&#x2F;* else only length is significant *&#x2F;</span><br><span class="line">	struct fb_bitfield blue;</span><br><span class="line">	struct fb_bitfield transp;	&#x2F;* transparency			*&#x2F;	&#x2F;&#x2F;透明度</span><br><span class="line"></span><br><span class="line">	__u32 nonstd;			&#x2F;* !&#x3D; 0 Non standard pixel format *&#x2F;</span><br><span class="line"></span><br><span class="line">	__u32 activate;			&#x2F;* see FB_ACTIVATE_*		*&#x2F;</span><br><span class="line"></span><br><span class="line">	__u32 height;			&#x2F;* height of picture in mm    *&#x2F;</span><br><span class="line">	__u32 width;			&#x2F;* width of picture in mm     *&#x2F;</span><br><span class="line"></span><br><span class="line">	__u32 accel_flags;		&#x2F;* (OBSOLETE) see fb_info.flags *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Timing: All values in pixclocks, except pixclock (of course) *&#x2F;</span><br><span class="line">	__u32 pixclock;			&#x2F;* pixel clock in ps (pico seconds) *&#x2F;</span><br><span class="line">	__u32 left_margin;		&#x2F;* time from sync to picture	*&#x2F;</span><br><span class="line">	__u32 right_margin;		&#x2F;* time from picture to sync	*&#x2F;</span><br><span class="line">	__u32 upper_margin;		&#x2F;* time from sync to picture	*&#x2F;</span><br><span class="line">	__u32 lower_margin;</span><br><span class="line">	__u32 hsync_len;		&#x2F;* length of horizontal sync	*&#x2F;</span><br><span class="line">	__u32 vsync_len;		&#x2F;* length of vertical sync	*&#x2F;</span><br><span class="line">	__u32 sync;			&#x2F;* see FB_SYNC_*		*&#x2F;</span><br><span class="line">	__u32 vmode;			&#x2F;* see FB_VMODE_*		*&#x2F;</span><br><span class="line">	__u32 rotate;			&#x2F;* angle we rotate counter clockwise *&#x2F;</span><br><span class="line">	__u32 reserved[5];		&#x2F;* Reserved for future compatibility *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、fb_fix_screeninfo描述LCD不可修改的控制器的参数</p>
<p>fb_fix_screeninfo结构体又主要记录用户不可以修改的控制器的参数，比如屏幕缓冲区的物理地址和长度等。当帧缓冲设备进行映射操作的时候，就是从fb_fix_screeninfo中取得缓冲区物理地址。该结构体的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct fb_fix_screeninfo &#123;</span><br><span class="line">	char id[16];			&#x2F;* identification string eg &quot;TT Builtin&quot; *&#x2F;</span><br><span class="line">	unsigned long smem_start;	&#x2F;* Start of frame buffer mem *&#x2F;</span><br><span class="line">					&#x2F;* (physical address) *&#x2F;</span><br><span class="line">	__u32 smem_len;			&#x2F;* Length of frame buffer mem *&#x2F;</span><br><span class="line">	__u32 type;			&#x2F;* see FB_TYPE_*		*&#x2F;</span><br><span class="line">	__u32 type_aux;			&#x2F;* Interleave for interleaved Planes *&#x2F;</span><br><span class="line">	__u32 visual;			&#x2F;* see FB_VISUAL_*		*&#x2F; </span><br><span class="line">	__u16 xpanstep;			&#x2F;* zero if no hardware panning  *&#x2F;</span><br><span class="line">	__u16 ypanstep;			&#x2F;* zero if no hardware panning  *&#x2F;</span><br><span class="line">	__u16 ywrapstep;		&#x2F;* zero if no hardware ywrap    *&#x2F;</span><br><span class="line">	__u32 line_length;		&#x2F;* length of a line in bytes    *&#x2F;</span><br><span class="line">	unsigned long mmio_start;	&#x2F;* Start of Memory Mapped I&#x2F;O   *&#x2F;</span><br><span class="line">					&#x2F;* (physical address) *&#x2F;</span><br><span class="line">	__u32 mmio_len;			&#x2F;* Length of Memory Mapped I&#x2F;O  *&#x2F;</span><br><span class="line">	__u32 accel;			&#x2F;* Indicate to driver which	*&#x2F;</span><br><span class="line">					&#x2F;*  specific chip&#x2F;card we have	*&#x2F;</span><br><span class="line">	__u16 reserved[3];		&#x2F;* Reserved for future compatibility *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、fb_ops描述对lcd屏幕的具体操作</p>
<p> fb_ops结构体是对底层硬件操作的函数指针，该结构体中定义了对硬件的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Frame buffer operations</span><br><span class="line"> *</span><br><span class="line"> * LOCKING NOTE: those functions must _ALL_ be called with the console</span><br><span class="line"> * semaphore held, this is the only suitable locking mechanism we have</span><br><span class="line"> * in 2.6. Some may be called at interrupt time at this point though.</span><br><span class="line"> *</span><br><span class="line"> * The exception to this is the debug related hooks.  Putting the fb</span><br><span class="line"> * into a debug state (e.g. flipping to the kernel console) and restoring</span><br><span class="line"> * it must be done in a lock-free manner, so low level drivers should</span><br><span class="line"> * keep track of the initial console (if applicable) and may need to</span><br><span class="line"> * perform direct, unlocked hardware writes in these hooks.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">struct fb_ops &#123;</span><br><span class="line">	&#x2F;* open&#x2F;release and usage marking *&#x2F;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	int (*fb_open)(struct fb_info *info, int user);</span><br><span class="line">	int (*fb_release)(struct fb_info *info, int user);</span><br><span class="line"></span><br><span class="line">	&#x2F;* For framebuffers with strange non linear layouts or that do not</span><br><span class="line">	 * work with normal memory mapped access</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	ssize_t (*fb_read)(struct fb_info *info, char __user *buf,</span><br><span class="line">			   size_t count, loff_t *ppos);</span><br><span class="line">	ssize_t (*fb_write)(struct fb_info *info, const char __user *buf,</span><br><span class="line">			    size_t count, loff_t *ppos);</span><br><span class="line"></span><br><span class="line">	&#x2F;* checks var and eventually tweaks it to something supported,</span><br><span class="line">	 * DO NOT MODIFY PAR *&#x2F;</span><br><span class="line">	int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* set the video mode according to info-&gt;var *&#x2F;</span><br><span class="line">	int (*fb_set_par)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* set color register *&#x2F;</span><br><span class="line">	int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green,</span><br><span class="line">			    unsigned blue, unsigned transp, struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* set color registers in batch *&#x2F;</span><br><span class="line">	int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* blank display *&#x2F;</span><br><span class="line">	int (*fb_blank)(int blank, struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* pan display *&#x2F;</span><br><span class="line">	int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Draws a rectangle *&#x2F;</span><br><span class="line">	void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);</span><br><span class="line">	&#x2F;* Copy data from area to another *&#x2F;</span><br><span class="line">	void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);</span><br><span class="line">	&#x2F;* Draws a image to the display *&#x2F;</span><br><span class="line">	void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Draws cursor *&#x2F;</span><br><span class="line">	int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Rotates the display *&#x2F;</span><br><span class="line">	void (*fb_rotate)(struct fb_info *info, int angle);</span><br><span class="line"></span><br><span class="line">	&#x2F;* wait for blit idle, optional *&#x2F;</span><br><span class="line">	int (*fb_sync)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* perform fb specific ioctl (optional) *&#x2F;</span><br><span class="line">	int (*fb_ioctl)(struct fb_info *info, unsigned int cmd,</span><br><span class="line">			unsigned long arg);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Handle 32bit compat ioctl (optional) *&#x2F;</span><br><span class="line">	int (*fb_compat_ioctl)(struct fb_info *info, unsigned cmd,</span><br><span class="line">			unsigned long arg);</span><br><span class="line"></span><br><span class="line">	&#x2F;* perform fb specific mmap *&#x2F;</span><br><span class="line">	int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line">	&#x2F;* get capability given var *&#x2F;</span><br><span class="line">	void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,</span><br><span class="line">			    struct fb_var_screeninfo *var);</span><br><span class="line"></span><br><span class="line">	&#x2F;* teardown any resources to do with this framebuffer *&#x2F;</span><br><span class="line">	void (*fb_destroy)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line">	&#x2F;* called at KDB enter and leave time to prepare the console *&#x2F;</span><br><span class="line">	int (*fb_debug_enter)(struct fb_info *info);</span><br><span class="line">	int (*fb_debug_leave)(struct fb_info *info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="framebuffer子系统初始化"><a href="#framebuffer子系统初始化" class="headerlink" title="framebuffer子系统初始化"></a>framebuffer子系统初始化</h2><p>初始化framebuffer子系统 ，为framebuffer对象创建一个字符设备fb,主设备为29，同时注册fb_fops，提供给应用层访问fb的接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct file_operations fb_fops &#x3D; &#123;</span><br><span class="line">	.owner &#x3D;	THIS_MODULE,</span><br><span class="line">	.read &#x3D;		fb_read,</span><br><span class="line">	.write &#x3D;	fb_write,</span><br><span class="line">	.unlocked_ioctl &#x3D; fb_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl &#x3D; fb_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">	.mmap &#x3D;		fb_mmap,</span><br><span class="line">	.open &#x3D;		fb_open,</span><br><span class="line">	.release &#x3D;	fb_release,</span><br><span class="line">#ifdef HAVE_ARCH_FB_UNMAPPED_AREA</span><br><span class="line">	.get_unmapped_area &#x3D; get_fb_unmapped_area,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FB_DEFERRED_IO</span><br><span class="line">	.fsync &#x3D;	fb_deferred_io_fsync,</span><br><span class="line">#endif</span><br><span class="line">	.llseek &#x3D;	default_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class *fb_class;</span><br><span class="line">EXPORT_SYMBOL(fb_class);</span><br><span class="line">#define FB_MAJOR		29   &#x2F;* &#x2F;dev&#x2F;fb* framebuffers *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *	fbmem_init - init frame buffer subsystem</span><br><span class="line"> *</span><br><span class="line"> *	Initialize the frame buffer subsystem.</span><br><span class="line"> *</span><br><span class="line"> *	NOTE: This function is _only_ to be called by drivers&#x2F;char&#x2F;mem.c.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int __init</span><br><span class="line">fbmem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	proc_create(&quot;fb&quot;, 0, NULL, &amp;fb_proc_fops);</span><br><span class="line"></span><br><span class="line">	if (register_chrdev(FB_MAJOR,&quot;fb&quot;,&amp;fb_fops))</span><br><span class="line">		printk(&quot;unable to get major %d for fb devs\n&quot;, FB_MAJOR);</span><br><span class="line"></span><br><span class="line">	fb_class &#x3D; class_create(THIS_MODULE, &quot;graphics&quot;);</span><br><span class="line">	if (IS_ERR(fb_class)) &#123;</span><br><span class="line">		printk(KERN_WARNING &quot;Unable to create fb class; errno &#x3D; %ld\n&quot;, PTR_ERR(fb_class));</span><br><span class="line">		fb_class &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef MODULE</span><br><span class="line">module_init(fbmem_init);</span><br><span class="line">static void __exit</span><br><span class="line">fbmem_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(&quot;fb&quot;, NULL);</span><br><span class="line">	class_destroy(fb_class);</span><br><span class="line">	unregister_chrdev(FB_MAJOR, &quot;fb&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_exit(fbmem_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Framebuffer base&quot;);</span><br><span class="line">#else</span><br><span class="line">subsys_initcall(fbmem_init);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>





<h2 id="framebuffer驱动程序"><a href="#framebuffer驱动程序" class="headerlink" title="framebuffer驱动程序"></a>framebuffer驱动程序</h2><ol>
<li>调用 framebuffer_alloc()分配一个fb_info结构体</li>
<li>设置fb_info</li>
<li>设置硬件相关的操作</li>
<li>调用register_framebuffer()注册fb_info</li>
</ol>
<p>lcd驱动：略</p>
<h2 id="应用层如何使用framebuffer"><a href="#应用层如何使用framebuffer" class="headerlink" title="应用层如何使用framebuffer"></a>应用层如何使用framebuffer</h2><ol>
<li>打开framebuffer设备文件： /dev/fb0</li>
<li>获取framebuffer设备信息 #include &lt;linux/fb.h&gt;</li>
<li>mmap做映射</li>
<li>填充framebuffer</li>
</ol>
<p>开发板端, 测试方法</p>
<p>echo hello &gt; /dev/tty1  // 可以在LCD上看见hello, tty1会用到 fbcon.c文件<br>cat lcd.ko &gt; /dev/fb0   // 花屏</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>video</category>
      </categories>
      <tags>
        <tag>LCD</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙连接事件</title>
    <url>/2020/11/05/IoT/%E8%93%9D%E7%89%99/ble%E6%8A%80%E6%9C%AF/%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于连接间隔和连接事件之间的关系，还是花了很多时间搞明白，主要是不明白连接事件长度怎么定义的。后来是通过nordic 52382 SDK,了解到连接事件长度是可以设置的。通过设置连接事件长度，就可以在一个连接间隔中，发送多个包，提高数据吞吐量。这篇文章<a href="https://www.cnblogs.com/iini/p/8972635.html" target="_blank" rel="noopener">详解BLE连接建立过程</a>对连接事件讲得明白，对我理解连接事件起到很大帮助。</p>
<h2 id="连接事件"><a href="#连接事件" class="headerlink" title="连接事件"></a>连接事件</h2><p>连接成功后，master和slave在每一个connection interval开始的时候，都必须交互一次，即master给slave发一个包，slave再给master发一个包，整个交互过程称为一个connection event或者gap event。蓝牙芯片只有在connection event期间才把射频模块打开，此时功耗比较高，其余时间蓝牙芯片都是处于idle状态的，因此蓝牙芯片平均功耗就非常低。在nordic nRF5 SDK中，可以设置连接事件长度，实现一个间隔期间发送多个包。Master不可能时时刻刻都有数据发给slave，所以master大部分时候都是发的空包（empty packet）给slave。同样slave也不是时时刻刻都有数据给master，因此slave回复给master的包大部分时候也是空包。另外在一个connection event期间，master也可以发多个包给slave，以提高吞吐率。</p>
<p>连接成功后的通信时序图（每个connection event只发一个包），如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_001.png" alt=""></p>
<p>实验：一个连接间隔100ms，连接事件保持时间为7.5ms,通过抓包分析，每个连接间隔slave只发送一个包给master，如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_009.png" alt=""></p>
<p>连接成功后的通信时序图（ connection event可能发多个包），如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_002.png" alt=""></p>
<p>实验：连接间隔100ms,连接事件保持时间为50ms,抓包可以看出，在100ms内，连续发送了三个包，如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_0010.png" alt=""></p>
<p>connection event通信细节图，如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_003.png" alt=""></p>
<p><strong>Slave latency</strong><br>connection event通信细节图中出现了slave latency（slave latency = 1），是什么意思？</p>
<p>答：slave latency = 1，跳过一个连接间隔，也就是说，slave设备在第二个连接间隔才回复一个packet.</p>
<p><strong>那么什么叫slave latency？</strong></p>
<p>如前所述，在每一个connection interval开始的时候，Master和Slave必须交互一次，哪怕两者之间交互的是empty packet（空包），但如果slave定义了slave latency，比如slave latency = 9，此时slave可以间隔9个connection interval才回复一次master，也就是说slave可以在前面9个connection interval期间一直睡眠，直到第10个connection interval到来之后，才回复一个packet给master，这样将大大节省slave的功耗，提高电池续航时间。当然如果slave有数据需要上报给master，它也可以不等到第10个connection interval才上报，直接像正常情况进行传输即可，这样既节省了功耗，又提高了数据传输的实时性。</p>
<p>连接间隔为100ms，连接事件保持时间为50ms，slave latency=2（延迟两个间隔），通信抓包结果如下所示</p>
<p><img src="http://jiali.clouddn.com/20201105_004.png" alt=""></p>
<p>对比，连接间隔也为100ms，连接事件保持时间为7.5ms,slave latency=2,结果跟上面一样，slave仍然跳过两个间隔,才回复一个empty packet,如下图所示</p>
<p><img src="http://jiali.clouddn.com/20201105_008.png" alt=""></p>
<h2 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h2><p>阅读nordic nRD5 sdk 发现连接参数配置的宏定义，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MIN_CONN_INTERVAL               MSEC_TO_UNITS(100, UNIT_1_25_MS)  &#x2F;&#x2F;最小间隔 </span><br><span class="line">#define MAX_CONN_INTERVAL               MSEC_TO_UNITS(100, UNIT_1_25_MS) &#x2F;&#x2F;最大间隔</span><br><span class="line">#define SLAVE_LATENCY                   0                               &#x2F;&#x2F;0表示不延迟  </span><br><span class="line">#define CONN_SUP_TIMEOUT                MSEC_TO_UNITS(4000, UNIT_10_MS) &#x2F;&#x2F;监督超时4s</span><br><span class="line">&#x2F;&#x2F;首次调用sd_ble_gap_conn_param_update()更新连接参数，延迟5s才能更新连接参数</span><br><span class="line">#define FIRST_CONN_PARAMS_UPDATE_DELAY  APP_TIMER_TICKS(5000)              </span><br><span class="line">&#x2F;&#x2F;非首次调用sd_ble_gap_conn_param_update()更新连接参数，延迟30s才能更新连接参数</span><br><span class="line">#define NEXT_CONN_PARAMS_UPDATE_DELAY   APP_TIMER_TICKS(30000)             </span><br><span class="line">&#x2F;&#x2F;尝试三次连续参数协商，如果不成功，就放弃连接参数协商</span><br><span class="line">#define MAX_CONN_PARAMS_UPDATE_COUNT    3                                  </span><br><span class="line">&#x2F;&#x2F;广播间隔时间</span><br><span class="line">#define APP_ADV_INTERVAL                320                               </span><br><span class="line">&#x2F;&#x2F;一次广播持续的时间，0表示不超时</span><br><span class="line">#define APP_ADV_DURATION                0</span><br></pre></td></tr></table></figure>

<p><strong>CONN_SUP_TIMEOUT –连接监控超时</strong></p>
<p>有时设备会丢失它们之间的连接，例如当它们移出彼此的传输范围时。 这些设备不知道连接是否丢失，但是如果没有从另一方接收到任何信息，他们可以假设已经有足够的时间了。 我们定义为“足够”以确定连接丢失的时间称为超时 。 连接监控超时（Connection Supervision Timeout）参数定义为在假设连接丢失之前等待数据传输的时间。</p>
<p><strong>总结</strong></p>
<p>由于连接参数对能源消耗有影响，我们应该考虑一下，即使知道中央可能会选择不遵守我们的建议。 一个考虑因素是我们的连接间隔应该与我们期望生成新数据的速率相匹配。 例如，如果我们每秒读取一个传感器，则连接间隔不应该小于此。 如果它更小，那么当没有数据生成时，我们将处理很多请求。 作为相反的示例，对于数据更新非定期（例如鼠标移动）的应用，连接间隔可以确定用户在应用等待更新时经历的延迟。 由于我们重视用户体验超过能量，我们将使用一个短的连接间隔。 我们可以补充短连接间隔，具有高从机延迟，让鼠标在运动之间睡眠更长。</p>
<p>对于电池寿命，我们使用射频越少越好。 所有的参数总体意味着我们可以很少使用射频：在广告模式下，我们可以每10.28秒使用一次射频。</p>
<p>在连接模式下，我们可以设置四秒的最大连接间隔，但是当我们没有生成新数据时，没有无线电活动的最长持续时间可能只要[(max interval) * (slave latency)]。 但是，请记住，我们受到监督超时（supervision timeout）的限制; 如果我们的间隔太大，中央设备可能会断开连接（请记住，我们不能强制中央设备接受我们的监控超时设置，因此可能会出现不匹配）。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q1:(在nrf52832上面测，发现连接间隔低于10Ms，发送数据失败,但是蓝牙规范是7.5ms?</strong><br><a href="http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1730&amp;fromuid=2151" target="_blank" rel="noopener">http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1730&amp;fromuid=2151</a></p>
<p><img src="http://jiali.clouddn.com/20201105_010.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201105_011.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201105_012.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201105_013.png" alt=""></p>
<p><img src="http://jiali.clouddn.com/20201105_014.png" alt=""></p>
<p><strong>Q2:SDK52382 如何在一个连接保持时间下发送多个数据包?</strong><br><a href="http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1739&amp;fromuid=2151" target="_blank" rel="noopener">http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1739&amp;fromuid=2151</a></p>
<p><img src="http://jiali.clouddn.com/20201105_015.png" alt=""></p>
<p><strong>Q3:设置连接事件保持时间等于连接间隔，会产生怎样的结果 ?</strong></p>
<p>意味着连接事件占满整个连接间隔，导致蓝牙没有时间休眠，一直打开RF收发器，功耗增大。</p>
<p><strong>Q4:52382,sdk16.0射频FIFO大小多大，是否可以调整？如何调整？</strong><br><a href="http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1746&amp;fromuid=2151" target="_blank" rel="noopener">http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1746&amp;fromuid=2151</a><br><img src="http://jiali.clouddn.com/20201105_016.png" alt=""></p>
<p><strong>Q5:在一个连接事件中，任意一个时刻，都能把数据发送出去吗 (比如，连接间隔设置100ms,连接事件保持时间设置为80ms。第一个连接事件到来后50ms,才调用发送函数，这时候，数据能发送出去吗)</strong></p>
<p><strong>Q6:nRF5 SFK,在一个连接事件中，间隔时间调用发送函数，数据是否也是间隔发送出去？(比如，100ms为连接间隔，50ms为连接事件保持的事件NRF_SDH_BLE_GAP_EVENT_LENGTH 设置为40，那么在50ms的连接事件内，间隔4ms发送数据。Ps问：间隔4ms调用发送函数，每次调用是否都把数据发送出去？还是说先缓存起来，等到下一次连接事件，在全部一起发送？)</strong></p>
<p><strong>Q7:快速发送数据时候，当协议栈因缓存不足，产生NRF_ERROR_RESOURCES 的根本原因</strong><br><a href="http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1755&amp;fromuid=2151" target="_blank" rel="noopener">http://930ebbs.com/forum.php?mod=viewthread&amp;tid=1755&amp;fromuid=2151</a></p>
<p>A1:</p>
<p><img src="http://jiali.clouddn.com/20201105_017.png" alt=""></p>
<p>A2:<a href="http://wywiot.com/nordic-ble-soc-2-4ghz-comm-info/?unapproved=18&amp;moderation-hash=5946eeafc1027885e91b90902dc24445#comment-18" target="_blank" rel="noopener">http://wywiot.com/nordic-ble-soc-2-4ghz-comm-info/?unapproved=18&amp;moderation-hash=5946eeafc1027885e91b90902dc24445#comment-18</a></p>
<p><img src="http://jiali.clouddn.com/nordic_sdk_%E6%94%B6%E5%8F%91%E5%99%A8%E7%BC%93%E5%AD%98.png" alt=""></p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/iini/p/8972635.html" target="_blank" rel="noopener">详解BLE连接建立过程</a></p>
<p><a href="https://blog.csdn.net/zzfenglin/article/details/51304084" target="_blank" rel="noopener">低功耗蓝牙BLE之连接事件、连接参数和更新方法</a></p>
<p><a href="https://www.jianshu.com/p/c8a7cc25d500" target="_blank" rel="noopener">BLE 连接参数</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】Android(Linux) 输入子系统解析</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android(Linux)%20%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：githubpage–<a href="http://huaqianlee.github.io/" target="_blank" rel="noopener">Andy.Lee’s Blog</a>【<a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/】" target="_blank" rel="noopener">http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/】</a></p>
<h1 id="Android-Linux-输入子系统解析"><a href="#Android-Linux-输入子系统解析" class="headerlink" title="Android(Linux) 输入子系统解析"></a>Android(Linux) 输入子系统解析</h1><p> Posted on Nov 23 2017  Edited on Apr 6 2019  In <a href="http://huaqianlee.github.io/categories/Android/" target="_blank" rel="noopener">Android</a></p>
<p>Android 源码分析系列综述博文： <a href="http://huaqianlee.github.io/2100/11/21/Android/A-summary-of-Android-source-analysis/" target="_blank" rel="noopener">Android 系统源码分析综述</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android/Linux 输入设备总类繁杂，常见的有按键、键盘、触摸屏、鼠标、摇杆等，之前其驱动都是采用字符设备、misc 设备处理的，但是如此多的设备就导致驱动混乱，所以 Linux 引入了输入子系统在字符设备等上抽象出一层来统一输入设备的驱动。本文就基于 MTK Android 7.0 源码来分析一下输入子系统。</p>
<h1 id="输入子系统架构"><a href="#输入子系统架构" class="headerlink" title="输入子系统架构"></a>输入子系统架构</h1><p>输入子系统的系统架构如下图所示：<br><img src="https://andylee-1258982386.cos.ap-chengdu.myqcloud.com/android/mtk/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="input_system_arch"></p>
<blockquote>
<p>Framework 层以上只是简单跟了一下源码，没有深入查看</p>
</blockquote>
<h1 id="输入子系统分层解析"><a href="#输入子系统分层解析" class="headerlink" title="输入子系统分层解析"></a>输入子系统分层解析</h1><h2 id="Hardware层"><a href="#Hardware层" class="headerlink" title="Hardware层"></a>Hardware层</h2><p>硬件层主要就是按键、触摸屏、Sensor等各种输入设备。</p>
<h2 id="Kernel层"><a href="#Kernel层" class="headerlink" title="Kernel层"></a>Kernel层</h2><p>Kernel 层主要分为三层，如下：</p>
<ol>
<li>Input 设备驱动层: 采集输入设备的数据信息，通过 Input Core 的 API 上报数据。</li>
<li>Input Core（核心层）：为事件处理层和设备驱动层提供接口API。</li>
<li>Event Handler（事件处理层）：通过核心层的API获取输入事件上报的数据，定义API与应用层交互。</li>
</ol>
<p>Kernel 层重要的数据结构如下：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>定义位置</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>struct input_dev</td>
<td>input.h</td>
<td>Input 设备驱动中实例化</td>
</tr>
<tr>
<td>struct evdev struct mousedev struct keybdev</td>
<td>evdev.c mousedev.c keybdev.c</td>
<td>Event Handler 层逻辑 input 设备的数据结构</td>
</tr>
<tr>
<td>struct input_handler</td>
<td>Input.h</td>
<td>Event handler 的结构，handler 层实例化</td>
</tr>
<tr>
<td>Struct input_handle</td>
<td>Input.h</td>
<td>用于创建驱动层 input_dev 和 handler 链表的链表项结构</td>
</tr>
</tbody></table>
<h3 id="数据结构部分"><a href="#数据结构部分" class="headerlink" title="数据结构部分"></a>数据结构部分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\include\linux\input.h</span><br><span class="line">&#x2F;* 输入设备的语言描述 *&#x2F;</span><br><span class="line">struct input_dev &#123;  &#x2F;&#x2F; 代表一个输入设备</span><br><span class="line">    const char *name;  &#x2F;&#x2F; 设备名字，sys 文件名</span><br><span class="line">    struct input_id id; &#x2F;&#x2F; 与 handler 匹配，总线类型、厂商、版本等信息</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 输入设备支持事件的位图（bitmap）*&#x2F;</span><br><span class="line">    unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; &#x2F;&#x2F; 所有事件</span><br><span class="line">    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;&#x2F; 按键事件</span><br><span class="line">    unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;&#x2F; 相对位移事件</span><br><span class="line">    ...</span><br><span class="line">    unsigned int keycodemax;  &#x2F;&#x2F; 支持按键值个数</span><br><span class="line">    unsigned int repeat_key; &#x2F;&#x2F; 最近一次按键值，用于连击</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int (*setkeycode)()   &#x2F;&#x2F; 修改当前 keymap</span><br><span class="line">    int (*getkeycode)()   &#x2F;&#x2F; 检索keymap</span><br><span class="line">	...</span><br><span class="line">	unsigned long key[BITS_TO_LONGS(KEY_CNT)];&#x2F;&#x2F; 设备当前按键状态</span><br><span class="line">	...</span><br><span class="line">	int (*open)()</span><br><span class="line">	int (*flush)();&#x2F;&#x2F; 处理传递给设备的事件，如：LED事件和声音事件</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    struct input_handle __rcu *grab; &#x2F;&#x2F; 当前占用该设备的 input_handle</span><br><span class="line">    </span><br><span class="line">	struct list_head	h_list; &#x2F;&#x2F; handle 链表，链接此input_dev</span><br><span class="line">	struct list_head	node; &#x2F;&#x2F;  链入 input_dev_list</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 事件处理，类似于中断处理函数 *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line"></span><br><span class="line">	void *private;</span><br><span class="line"></span><br><span class="line">	void (*event)(); &#x2F;&#x2F; 处理设备驱动报告的事件</span><br><span class="line">	int (*connect)();  &#x2F;&#x2F; 连接 handler 和 input_dev</span><br><span class="line">	void (*disconnect)(); &#x2F;&#x2F; 断开连接</span><br><span class="line">	void (*start)();  &#x2F;&#x2F; 启动指定 handle 的 handler 函数</span><br><span class="line"></span><br><span class="line">	const char *name; &#x2F;&#x2F; handler 名</span><br><span class="line"></span><br><span class="line">	const struct input_device_id *id_table; &#x2F;&#x2F; 输入设备id列表，匹配 input_dev</span><br><span class="line"></span><br><span class="line">	struct list_head	h_list; &#x2F;&#x2F; 链入handle 链表</span><br><span class="line">	struct list_head	node;  &#x2F;&#x2F; 链入 input_handler_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"> * 连接 input_dev 和 handler 的桥梁</span><br><span class="line"> * 一个 input_dev 可以对应多个 handler ， 一个 handler 也可以对应多个dev</span><br><span class="line">*&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line"></span><br><span class="line">	int open; &#x2F;&#x2F; 设备打开次数（上层访问次数）</span><br><span class="line">	const char *name;</span><br><span class="line"></span><br><span class="line">	struct input_dev *dev;  &#x2F;&#x2F; 所属 input_dev</span><br><span class="line">	struct input_handler *handler; &#x2F;&#x2F; 所属 handler</span><br><span class="line"></span><br><span class="line">	struct list_head	d_node; &#x2F;&#x2F; 链入对应 input_dev 的 h_list</span><br><span class="line">	struct list_head	h_node; &#x2F;&#x2F; 链入对应 handler de h_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># alps&#x2F;kernel-3.18&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;input.h</span><br><span class="line">&#x2F;* 事件载体，输入子系统的事件包装为 input_event 上传到 Framework*&#x2F;</span><br><span class="line">struct input_event &#123;</span><br><span class="line"> struct timeval time; &#x2F;&#x2F; 时间戳</span><br><span class="line"> __u16 type;  &#x2F;&#x2F; 事件类型</span><br><span class="line"> __u16 code;  &#x2F;&#x2F; 事件代码</span><br><span class="line"> __s32 value;  &#x2F;&#x2F; 事件值，如坐标的偏移值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Input-设备驱动层"><a href="#Input-设备驱动层" class="headerlink" title="Input 设备驱动层"></a>Input 设备驱动层</h3><p>这部分主要实现各种输入设备的自己硬件相关的驱动并上报事件，这部分驱动基本遵循如下流程：</p>
<ol>
<li>声明实例化input_dev 对象</li>
<li>注册 input_dev<ul>
<li>input_allocate_device() 给设备分配空间，设置dev （实现于 input.c）</li>
<li>通过 input_register_device() 注册 （实现于 input.c）</li>
</ul>
</li>
<li>硬件初始化，中断初始化，定义中断处理程序</li>
<li>设置input_dev对象</li>
<li>定义中断处理程序，上报事件</li>
</ol>
<p>由于我自己有个外设系列源码分析，这里就不详细查看相关源码了，主要分析输入子系统的通用部分。设备驱动路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alps\kernel-3.18\drivers\input</span><br></pre></td></tr></table></figure>

<h3 id="Input-Core"><a href="#Input-Core" class="headerlink" title="Input Core"></a>Input Core</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\input\input.c</span><br><span class="line">input_init()</span><br><span class="line">    class_register(&amp;input_class); &#x2F;&#x2F; 注册为输入设备类，创建 input_class</span><br><span class="line">    input_proc_init(); &#x2F;&#x2F; 创建 proc&#x2F;bus&#x2F;input 路径下设备文件</span><br><span class="line">        proc_mkdir(&quot;bus&#x2F;input&quot;, NULL);</span><br><span class="line">        proc_create(&quot;devices&quot;..&amp;input_devices_fileops);  &#x2F;&#x2F; </span><br><span class="line">		proc_create(&quot;handlers&quot;..&amp;input_handlers_fileops);	    </span><br><span class="line">    register_chrdev_region(MKDEV(INPUT_MAJOR, 0),INPUT_MAX_CHAR_DEVICES, &quot;input&quot;);</span><br><span class="line"></span><br><span class="line">input_register_device() &#x2F;&#x2F; 通过 input core 注册 input_dev ，为设备驱动所调用 </span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit); &#x2F;&#x2F; 设为 EV_SYN&#x2F;SYN_REPORT 事件，所有设备默认支持</span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit); &#x2F;&#x2F; KEY_RESERVED 事件不支持上传到用户空间</span><br><span class="line">    ... &#x2F;&#x2F; 设置 input_dev </span><br><span class="line">    device_add(&amp;dev-&gt;dev); &#x2F;&#x2F; 将 input_dev 注册到 sysfs</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); &#x2F;&#x2F; 将 input_dev 加入input_dev_list</span><br><span class="line">	list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);   &#x2F;&#x2F; 配对并 connect handler 和 input_dev</span><br><span class="line">		</span><br><span class="line">input_attach_handler()	</span><br><span class="line">    input_match_device(handler, dev) &#x2F;&#x2F; 配对handler 和 input_dev</span><br><span class="line">    handler-&gt;connect(handler, dev, id); &#x2F;&#x2F; connect</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">input_register_handler  &#x2F;&#x2F; 注册一个 input_handler </span><br><span class="line">	INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">	list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">	list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">		input_attach_handler(dev, handler);  &#x2F;&#x2F; 同上</span><br><span class="line">		</span><br><span class="line">input_event() &#x2F;&#x2F; 上报新事件</span><br><span class="line">    input_handle_event()&#x2F;input_repeat_key()</span><br><span class="line">      input_get_disposition &#x2F;&#x2F; 处理事件类型</span><br><span class="line">        input_pass_values()</span><br><span class="line">            input_to_handler()</span><br><span class="line">                handler-&gt;events() &#x2F;&#x2F; 对应 evdev.c 中 evdev_event()</span><br><span class="line">            input_start_autorepeat() &#x2F;&#x2F; 根据需要启动或停止自动重复上报</span><br><span class="line">            input_stop_autorepeat(dev)</span><br><span class="line">      input_handle_abs_event()      </span><br><span class="line">        input_abs_set_val(dev, ABS_MT_SLOT, mt-&gt;slot) &#x2F;&#x2F; 刷新等待槽事件</span><br><span class="line">input_start_autorepeat() &#x2F;&#x2F; 启动定时器，自动重复上报</span><br><span class="line"></span><br><span class="line">&#x2F;* 类似于 input_event() , 不过忽略已经被捕获的事件和非拥有 dev 注入事件 *&#x2F;</span><br><span class="line">input_inject_event() </span><br><span class="line">    input_handle_event()</span><br><span class="line"></span><br><span class="line">input_open_device</span><br><span class="line">    handle-&gt;open++</span><br><span class="line">    dev-&gt;open(dev) &#x2F;&#x2F; 设备 open</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_dev_suspend()    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\include\linux\input.h</span><br><span class="line">input_report_xx() &#x2F;&#x2F; 上报事件，如键值</span><br><span class="line">	input_event()</span><br><span class="line">input_sync &#x2F;&#x2F; 同步事件</span><br><span class="line">	input_event()</span><br><span class="line"></span><br><span class="line">&#x2F;*********************************************************************</span><br><span class="line"> * 基于 input system 封装了一层轮询设备，为需要轮询的设备驱动提供支持</span><br><span class="line"> *********************************************************************&#x2F;</span><br><span class="line"># alps\kernel-3.18\include\linux\input-polldev.h</span><br><span class="line">struct input_polled_dev</span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\drivers\input\input-polldev.c</span><br><span class="line">input_register_polled_device()</span><br><span class="line">    NIT_DELAYED_WORK(&amp;dev-&gt;work, input_polled_device_work);</span><br><span class="line">input_open_polled_device()</span><br><span class="line">input_polldev_set_poll()</span><br></pre></td></tr></table></figure>

<h3 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h3><p>Event Handler 层以通用的 evdev.c 为例来解析，上层和 Kernel 层的交互在此文件完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\input\evdev.c</span><br><span class="line">static struct input_handler evdev_handler &#x3D; &#123;   &#x2F;&#x2F; input_handler</span><br><span class="line">	.event		&#x3D; evdev_event,</span><br><span class="line">	.events		&#x3D; evdev_events,</span><br><span class="line">	.connect	&#x3D; evdev_connect,</span><br><span class="line">	.disconnect	&#x3D; evdev_disconnect,</span><br><span class="line">	.legacy_minors	&#x3D; true,</span><br><span class="line">	.minor		&#x3D; EVDEV_MINOR_BASE,</span><br><span class="line">	.name		&#x3D; &quot;evdev&quot;,</span><br><span class="line">	.id_table	&#x3D; evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line">truct file_operations evdev_fops &#x3D; &#123;  &#x2F;&#x2F; 对应于上层的操作函数</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.read		&#x3D; evdev_read,</span><br><span class="line">	.write		&#x3D; evdev_write,</span><br><span class="line">	.poll		&#x3D; evdev_poll,</span><br><span class="line">	.open		&#x3D; evdev_open,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">struct evdev_client &#123;</span><br><span class="line">	unsigned int head;</span><br><span class="line">	unsigned int tail;</span><br><span class="line">    ....</span><br><span class="line">	struct wake_lock wake_lock;</span><br><span class="line">	struct list_head node;</span><br><span class="line">	struct input_event buffer[];  &#x2F;&#x2F; 事件存储 buffer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">evdev_init()</span><br><span class="line">    input_register_handler(&amp;evdev_handler) &#x2F;&#x2F; 定义于 input.c</span><br><span class="line">    </span><br><span class="line">evdev_connect()    </span><br><span class="line">    struct evdev *evdev;</span><br><span class="line">    &#x2F;* 设置evdev *&#x2F;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, dev_no); &#x2F;&#x2F; 根据设备号命名handler</span><br><span class="line">    &#x2F;* 完成dev 和 handler 的连接关系*&#x2F;</span><br><span class="line">    evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); &#x2F;&#x2F;绑定 File 操作函数 </span><br><span class="line">    device_add(&amp;evdev-&gt;dev);&#x2F;&#x2F;注册设备到内核，会在 &#x2F;dev&#x2F;input 生成设备</span><br><span class="line">    </span><br><span class="line">evdev_event()</span><br><span class="line">    evdev_events()</span><br><span class="line">        evdev_pass_values()</span><br><span class="line">            __pass_event() &#x2F;&#x2F; 将事件加入 evdev_client， 并加入EV_SYN</span><br><span class="line">            wake_up_interruptible(&amp;evdev-&gt;wait) &#x2F;&#x2F; 唤醒，让上层读取事件数据（存于 evdev buffer）</span><br><span class="line">            </span><br><span class="line">evdev_flush()</span><br><span class="line">    input_flush_device() &#x2F;&#x2F; input.c</span><br><span class="line">    </span><br><span class="line">evdev_write()   &#x2F;&#x2F; 上层写入数据</span><br><span class="line">    input_event_from_user()</span><br><span class="line">    input_inject_event()</span><br><span class="line">evdev_read()   &#x2F;&#x2F;  上层读取数据</span><br><span class="line">    </span><br><span class="line">&#x2F;* 内核与用户空间交互函数实现 *&#x2F;    </span><br><span class="line"># alps\kernel-3.18\drivers\input\input-compat.c </span><br><span class="line">input_event_from_user()</span><br><span class="line">    copy_from_user()  </span><br><span class="line">input_event_to_user()</span><br></pre></td></tr></table></figure>

<h2 id="Framework-层"><a href="#Framework-层" class="headerlink" title="Framework 层"></a>Framework 层</h2><p>Framework 层涉及面太广，内容也多，我现在阅读这部分上层源码也有些吃力，再加上时间原因，只简单跟读了几个关键文件。以后抽时间再跟读一下源码，产出一篇博客。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* native 部分关键路径*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger</span><br><span class="line"># alps\frameworks\native\libs\input</span><br><span class="line">&#x2F;* 从设备文件（&#x2F;dev&#x2F;input）获取信息）*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\EventHub.cpp</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputManager.cpp</span><br><span class="line">&#x2F;* 从 EventHub 获取事件信息*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputReader.cpp</span><br><span class="line">&#x2F;* 分发事件信息*&#x2F;</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputDispatcher.cpp</span><br><span class="line"># alps\frameworks\native\services\inputflinger\InputListener.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* framework 部分关键路径*&#x2F;</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\input</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\wm</span><br><span class="line"></span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\input\InputManagerService.java</span><br><span class="line"># alps\frameworks\base\services\core\java\com\android\server\wm\WindowManagerService.java</span><br></pre></td></tr></table></figure>

<h1 id="附-Shell-操作路径"><a href="#附-Shell-操作路径" class="headerlink" title="附 Shell 操作路径"></a>附 Shell 操作路径</h1><p>在 Kernel 层生成三个路径及相关设备文件，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;sys&#x2F;class&#x2F;input&#x2F;</span><br><span class="line">event0  event11 event4 event7 input0  input11 input4 input7</span><br><span class="line">event1  event2  event5 event8 input1  input2  input5 input8</span><br><span class="line">event10 event3  event6 event9 input10 input3  input6 input9</span><br><span class="line"></span><br><span class="line"># &#x2F;dev&#x2F;input </span><br><span class="line">event0 event10 event2 event4 event6 event8</span><br><span class="line">event1 event11 event3 event5 event7 event9</span><br><span class="line"></span><br><span class="line"># &#x2F;proc&#x2F;bus&#x2F;input  </span><br><span class="line">devices handlers</span><br><span class="line"># cat devices  查看总线上的已经注册上的输入设备</span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;ACCDET&quot;</span><br><span class="line">P: Phys&#x3D;</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;gpufreq_ib event0</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;40 0 0 0 0 0 0 1000000000 c000001800000 0</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0019 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0001</span><br><span class="line">N: Name&#x3D;&quot;fingerprint_key&quot;</span><br><span class="line">P: Phys&#x3D;</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input2</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;gpufreq_ib event2</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;3</span><br><span class="line">B: KEY&#x3D;2000100000000000 180001f 8000000000000000</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cat handlers &#x2F;&#x2F; 查看注册的handler</span><br><span class="line">N: Number&#x3D;0 Name&#x3D;gpufreq_ib</span><br><span class="line">N: Number&#x3D;1 Name&#x3D;evdev Minor&#x3D;64</span><br></pre></td></tr></table></figure>

<p><a href="http://huaqianlee.github.io/tags/源码分析/" target="_blank" rel="noopener"># 源码分析</a> <a href="http://huaqianlee.github.io/tags/MTK/" target="_blank" rel="noopener"># MTK</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】input子系统整体流程全面分析（触摸屏驱动为例）</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90%EF%BC%88%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3294356.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3294356.html】</a></p>
<h1 id="【驱动】input子系统整体流程全面分析（触摸屏驱动为例）"><a href="#【驱动】input子系统整体流程全面分析（触摸屏驱动为例）" class="headerlink" title="【驱动】input子系统整体流程全面分析（触摸屏驱动为例）"></a><a href="https://www.cnblogs.com/lcw/p/3294356.html" target="_blank" rel="noopener">【驱动】input子系统整体流程全面分析（触摸屏驱动为例）</a></h1><h2 id="input输入子系统整体流程"><a href="#input输入子系统整体流程" class="headerlink" title="input输入子系统整体流程"></a>input输入子系统整体流程</h2><p>　　</p>
<p>　　input子系统在内核中的实现，包括输入子系统（Input Core），事件处理层（Event Handler）和设备驱动层。</p>
<p>　　在开头部分会从设备驱动层做为线索，分析输入子系统和事件处理层是如何配合的，最后从用户角度出发，从“/dev/input/*”接口如何使用输入子系统提供的服务。</p>
<p>　　既然需要详细分析，有一个这样的流程图能够帮助我们在被绕进代码的过程中，找到出口，你能够知道你现在位于代码框架的什么位置，不会忘记正在分析的代码的“身份”。</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/01112058-b025a20bc60a469cb1ae2def7eeeab84.png" alt="img"></p>
<h2 id="设备驱动层注册到input子系统"><a href="#设备驱动层注册到input子系统" class="headerlink" title="设备驱动层注册到input子系统"></a>设备驱动层注册到input子系统</h2><p>　　以S3C2440触摸屏的驱动代码代例，初始化函数定义了struct input_dev input结构体，它用于描述一个输入子系统设备。</p>
<p>　　任何驱动设备如果想标明自己是输入设备，都应该通过初始化这样的结构体，并且调用input_allocate_device（）函数进行注册。</p>
<p>　　了解这一过程，先看一下struct input_dev结构体的内容：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_dev &#123;  </span><br><span class="line"> 2   </span><br><span class="line"> 3     void *private;              &#x2F;&#x2F;输入设备私有指针，一般指向用于描述设备驱动层的设备结构  </span><br><span class="line"> 4   </span><br><span class="line"> 5     const char *name;           &#x2F;&#x2F;提供给用户的输入设备的名称  </span><br><span class="line"> 6     const char *phys;           &#x2F;&#x2F;提供给编程者的设备节点的名称  </span><br><span class="line"> 7     const char *uniq;           &#x2F;&#x2F;指定唯一的ID号，就像MAC地址一样  </span><br><span class="line"> 8     struct input_id id;         &#x2F;&#x2F;输入设备标识ID，用于和事件处理层进行匹配  </span><br><span class="line"> 9   </span><br><span class="line">10     unsigned long evbit[NBITS(EV_MAX)];     &#x2F;&#x2F;位图，记录设备支持的事件类型  </span><br><span class="line">11     unsigned long keybit[NBITS(KEY_MAX)];       &#x2F;&#x2F;位图，记录设备支持的按键类型  </span><br><span class="line">12     unsigned long relbit[NBITS(REL_MAX)];       &#x2F;&#x2F;位图，记录设备支持的相对坐标  </span><br><span class="line">13     unsigned long absbit[NBITS(ABS_MAX)];       &#x2F;&#x2F;位图，记录设备支持的绝对坐标  </span><br><span class="line">14     unsigned long mscbit[NBITS(MSC_MAX)];   &#x2F;&#x2F;位图，记录设备支持的其他功能  </span><br><span class="line">15     unsigned long ledbit[NBITS(LED_MAX)];       &#x2F;&#x2F;位图，记录设备支持的指示灯  </span><br><span class="line">16     unsigned long sndbit[NBITS(SND_MAX)];       &#x2F;&#x2F;位图，记录设备支持的声音或警报  </span><br><span class="line">17     unsigned long ffbit[NBITS(FF_MAX)];     &#x2F;&#x2F;位图，记录设备支持的作用力功能  </span><br><span class="line">18     unsigned long swbit[NBITS(SW_MAX)];     &#x2F;&#x2F;位图，记录设备支持的开关功能  </span><br><span class="line">19   </span><br><span class="line">20     unsigned int keycodemax;        &#x2F;&#x2F;设备支持的最大按键值个数  </span><br><span class="line">21     unsigned int keycodesize;       &#x2F;&#x2F;每个按键的字节大小  </span><br><span class="line">22     void *keycode;              &#x2F;&#x2F;指向按键池，即指向按键值数组首地址  </span><br><span class="line">23     int (*setkeycode)(struct input_dev *dev, int scancode, int keycode);    &#x2F;&#x2F;修改按键值  </span><br><span class="line">24     int (*getkeycode)(struct input_dev *dev, int scancode, int *keycode);   &#x2F;&#x2F;获取按键值  </span><br><span class="line">25   </span><br><span class="line">26     struct ff_device *ff;           &#x2F;&#x2F;用于强制更新输入设备的部分内容  </span><br><span class="line">27   </span><br><span class="line">28     unsigned int repeat_key;        &#x2F;&#x2F;重复按键的键值  </span><br><span class="line">29     struct timer_list timer;        &#x2F;&#x2F;设置当有连击时的延时定时器  </span><br><span class="line">30   </span><br><span class="line">31     int state;      &#x2F;&#x2F;设备状态  </span><br><span class="line">32   </span><br><span class="line">33     int sync;       &#x2F;&#x2F;同步事件完成标识，为1说明事件同步完成  </span><br><span class="line">34   </span><br><span class="line">35     int abs[ABS_MAX + 1];       &#x2F;&#x2F;记录坐标的值  </span><br><span class="line">36     int rep[REP_MAX + 1];       &#x2F;&#x2F;记录重复按键的参数值  </span><br><span class="line">37   </span><br><span class="line">38     unsigned long key[NBITS(KEY_MAX)];      &#x2F;&#x2F;位图，按键的状态  </span><br><span class="line">39     unsigned long led[NBITS(LED_MAX)];      &#x2F;&#x2F;位图，led的状态  </span><br><span class="line">40     unsigned long snd[NBITS(SND_MAX)];      &#x2F;&#x2F;位图，声音的状态  </span><br><span class="line">41     unsigned long sw[NBITS(SW_MAX)];            &#x2F;&#x2F;位图，开关的状态  </span><br><span class="line">42   </span><br><span class="line">43     int absmax[ABS_MAX + 1];                    &#x2F;&#x2F;位图，记录坐标的最大值  </span><br><span class="line">44     int absmin[ABS_MAX + 1];                    &#x2F;&#x2F;位图，记录坐标的最小值  </span><br><span class="line">45     int absfuzz[ABS_MAX + 1];                   &#x2F;&#x2F;位图，记录坐标的分辨率  </span><br><span class="line">46     int absflat[ABS_MAX + 1];                   &#x2F;&#x2F;位图，记录坐标的基准值  </span><br><span class="line">47   </span><br><span class="line">48     int (*open)(struct input_dev *dev);         &#x2F;&#x2F;输入设备打开函数  </span><br><span class="line">49     void (*close)(struct input_dev *dev);           &#x2F;&#x2F;输入设备关闭函数  </span><br><span class="line">50     int (*flush)(struct input_dev *dev, struct file *file); &#x2F;&#x2F;输入设备断开后刷新函数  </span><br><span class="line">51     int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);   &#x2F;&#x2F;事件处理  </span><br><span class="line">52   </span><br><span class="line">53     struct input_handle *grab;      &#x2F;&#x2F;类似私有指针，可以直接访问到事件处理接口event  </span><br><span class="line">54   </span><br><span class="line">55     struct mutex mutex;     &#x2F;&#x2F;用于open、close函数的连续访问互斥  </span><br><span class="line">56     unsigned int users;     &#x2F;&#x2F;设备使用计数  </span><br><span class="line">57   </span><br><span class="line">58     struct class_device cdev;   &#x2F;&#x2F;输入设备的类信息  </span><br><span class="line">59     union &#123;             &#x2F;&#x2F;设备结构体  </span><br><span class="line">60         struct device *parent;  </span><br><span class="line">61     &#125; dev;  </span><br><span class="line">62   </span><br><span class="line">63     struct list_head    h_list; &#x2F;&#x2F;handle链表  </span><br><span class="line">64     struct list_head    node;   &#x2F;&#x2F;input_dev链表  </span><br><span class="line">65 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　就这样赤裸裸的看上面的结构体，会觉得摸不着头脑，但是有一点是确定的，我们在写输入设备驱动时会定义这样一个输入设备结构体，并调用input_allocate_device()函数，这个函数的功能是为新添加的输入设备分配内存，如果成功，将返回input_dev *的指针结构，因此在写驱动的时候应该接受返回值，作为驱动层获得了一个新的输入设备操作的接口。</p>
<p>　　那么<strong>input_allocate_device()</strong>函数做了什么呢？打开函数看一下（input.c中实现）：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_dev *input_allocate_device(void)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     struct input_dev *dev;  </span><br><span class="line"> 4   </span><br><span class="line"> 5 &#x2F;&#x2F;动态申请内存，使用GFP_KERNEL方式，注意GFP_KERNEL可能导致睡眠，不能在中断中调用这个函数  </span><br><span class="line"> 6     dev &#x3D; kzalloc(sizeof(struct input_dev), GFP_KERNEL);  </span><br><span class="line"> 7 &#x2F;&#x2F;分配成功执行的代码，进行成员的默认填充  </span><br><span class="line"> 8     if (dev) &#123;  </span><br><span class="line"> 9         dev-&gt;cdev.class &#x3D; &amp;input_class;          &#x2F;&#x2F;支持热插拔的结构体  </span><br><span class="line">10         dev-&gt;cdev.groups &#x3D; input_dev_attr_groups; &#x2F;&#x2F;描述设备的硬件信息和支持的事件类型  </span><br><span class="line">11         class_device_initialize(&amp;dev-&gt;cdev);     &#x2F;&#x2F;类设备初始化，添加进input类设备模型中  </span><br><span class="line">12         mutex_init(&amp;dev-&gt;mutex);             &#x2F;&#x2F;初始化互斥锁  </span><br><span class="line">13         INIT_LIST_HEAD(&amp;dev-&gt;h_list);        &#x2F;&#x2F;初始化handle链表  </span><br><span class="line">14         INIT_LIST_HEAD(&amp;dev-&gt;node);          &#x2F;&#x2F;初始化输入设备链表  </span><br><span class="line">15   </span><br><span class="line">16     &#125;  </span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　通过input_allocate_device()函数，我们设备驱动现在持有的input_dev里面就被赋予了input的“形象”，但是还需要我们去充实一下“内在”，因此，设备驱动程序，还需要为自己的设备增加自己的特性，才能创造独有的设备“形象”。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_dev *input_dev &#x3D; input_allocate_device();  </span><br><span class="line"> 2 input_dev-&gt;name &#x3D; &quot;s3c2410 Touchscreen&quot;;  </span><br><span class="line"> 3 input_dev-&gt;phys &#x3D; &quot;s3c2410ts&#x2F;input0&quot;;  </span><br><span class="line"> 4 input_dev-&gt;id.bustype &#x3D; BUS_HOST;  </span><br><span class="line"> 5 input_dev-&gt;id.vendor &#x3D; 0x0001;  </span><br><span class="line"> 6 input_dev-&gt;id.product &#x3D; 0x0002;  </span><br><span class="line"> 7 input_dev-&gt;id.version &#x3D; 0x0100;  </span><br><span class="line"> 8 input_dev-&gt;evbit[0] &#x3D; BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);  </span><br><span class="line"> 9 input_dev-&gt;keybit[BIT_WORD(BTN_TOUCH)] &#x3D; BIT_MASK(BTN_TOUCH);   </span><br><span class="line">10 input_set_abs_params(input_dev, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);  </span><br><span class="line">11 input_set_abs_params(input_dev, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);  </span><br><span class="line">12 input_set_abs_params(input_dev, ABS_PRESSURE, PRESSURE_MIN, PRESSURE_MAX, 0, 0);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这部分完成了输入设备的初始化工作。但是这仅是初始化自己的“特点”，还需要通知输入子系统有这样一个新设备诞生了，这就需要调用输入子系统的注册函数input_register_device（input_dev）来完成。</p>
<p>　　<strong>input_register_device()</strong>用于注册一个输入设备。那么<strong>注册过程是怎样的呢？这是一个重点，</strong>在下面的代码中进行注释分析：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     &#x2F;* 用于记录输入设备名称的索引值 *&#x2F;  </span><br><span class="line"> 4     static atomic_t input_no &#x3D; ATOMIC_INIT(0);  </span><br><span class="line"> 5     &#x2F;* 输入事件的处理接口指针，用于和设备的事件类型进行匹配 *&#x2F;  </span><br><span class="line"> 6     struct input_handler *handler;  </span><br><span class="line"> 7     const char *path;  </span><br><span class="line"> 8     int error;  </span><br><span class="line"> 9   </span><br><span class="line">10     &#x2F;* 默认所有的输入设备都支持EV_SYN同步事件 *&#x2F;  </span><br><span class="line">11     set_bit(EV_SYN, dev-&gt;evbit);  </span><br><span class="line">12   </span><br><span class="line">13     &#x2F;* </span><br><span class="line">14      * 如果设备驱动没有指定重复按键（连击），系统默认提供以下的支持 </span><br><span class="line">15      * 其中init_timer为连击产生的定时器，时间到调用input_repeat_key函数 </span><br><span class="line">16      * 上报，REP_DELAY用于设置重复按键的键值，REP_PERIOD设置延时时间 </span><br><span class="line">17      *&#x2F;  </span><br><span class="line">18     init_timer(&amp;dev-&gt;timer);  </span><br><span class="line">19     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;  </span><br><span class="line">20         dev-&gt;timer.data &#x3D; (long) dev;  </span><br><span class="line">21         dev-&gt;timer.function &#x3D; input_repeat_key;  </span><br><span class="line">22         dev-&gt;rep[REP_DELAY] &#x3D; 250;  </span><br><span class="line">23         dev-&gt;rep[REP_PERIOD] &#x3D; 33;  </span><br><span class="line">24     &#125;  </span><br><span class="line">25   </span><br><span class="line">26     &#x2F;* 如果设备驱动没有设置自己的获取键值的函数，系统默认 *&#x2F;  </span><br><span class="line">27     if (!dev-&gt;getkeycode)  </span><br><span class="line">28         dev-&gt;getkeycode &#x3D; input_default_getkeycode;  </span><br><span class="line">29   </span><br><span class="line">30     &#x2F;* 如果设备驱动没有指定按键重置函数，系统默认 *&#x2F;  </span><br><span class="line">31     if (!dev-&gt;setkeycode)  </span><br><span class="line">32         dev-&gt;setkeycode &#x3D; input_default_setkeycode;  </span><br><span class="line">33   </span><br><span class="line">34     &#x2F;* 重要，把设备挂到全局的input子系统设备链表input_dev_list上 *&#x2F;  </span><br><span class="line">35     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);  </span><br><span class="line">36   </span><br><span class="line">37     &#x2F;* 动态获取input设备的ID号，名称为input*，其中后面的“*”动态获得，唯一的 *&#x2F;  </span><br><span class="line">38     snprintf(dev-&gt;cdev.class_id, sizeof(dev-&gt;cdev.class_id),  </span><br><span class="line">39          &quot;input%ld&quot;, (unsigned long) atomic_inc_return(&amp;input_no) - 1);  </span><br><span class="line">40   </span><br><span class="line">41     &#x2F;* 如果这个值没有设置，系统把输入设备挂入设备链表 *&#x2F;  </span><br><span class="line">42     if (!dev-&gt;cdev.dev)  </span><br><span class="line">43         dev-&gt;cdev.dev &#x3D; dev-&gt;dev.parent;  </span><br><span class="line">44   </span><br><span class="line">45     &#x2F;* 在&#x2F;sys目录下创建设备目录和文件 *&#x2F;  </span><br><span class="line">46     error &#x3D; class_device_add(&amp;dev-&gt;cdev);  </span><br><span class="line">47     if (error)  </span><br><span class="line">48         return error;  </span><br><span class="line">49   </span><br><span class="line">50     &#x2F;* 获取并打印设备的绝对路径名称 *&#x2F;  </span><br><span class="line">51     path &#x3D; kobject_get_path(&amp;dev-&gt;cdev.kobj, GFP_KERNEL);  </span><br><span class="line">52     printk(KERN_INFO &quot;input: %s as %s\n&quot;,  </span><br><span class="line">53         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);  </span><br><span class="line">54     kfree(path);  </span><br><span class="line">55   </span><br><span class="line">56     &#x2F;* 核心重点，input设备在增加到input_dev_list链表上之后，会查找 </span><br><span class="line">57      * input_handler_list事件处理链表上的handler进行匹配，这里的匹配 </span><br><span class="line">58      * 方式与设备模型的device和driver匹配过程很相似，所有的input </span><br><span class="line">59      * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list </span><br><span class="line">60      * 上，进行“匹配相亲”*&#x2F;  </span><br><span class="line">61     list_for_each_entry(handler, &amp;input_handler_list, node)  </span><br><span class="line">62         input_attach_handler(dev, handler);  </span><br><span class="line">63   </span><br><span class="line">64     input_wakeup_procfs_readers();  </span><br><span class="line">65   </span><br><span class="line">66     return 0;  </span><br><span class="line">67 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p>
<ul>
<li><p>进一步初始化输入设备，例如连击事件；</p>
</li>
<li><p>注册输入设备到input类中；</p>
</li>
<li><p>把输入设备挂到输入设备链表input_dev_list中；</p>
</li>
<li><p>查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p>
<p>　我们需要再分析下这个匹配的过程，但是需要注意的是下面分析的代码是我们暂时无法分析的，因为那样会使得情况变得更加复杂，当我们从应用层往下分析的时候一切都会明白。<strong>input_attach_handler</strong>匹配过程如下：</p>
</li>
</ul>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 const struct input_device_id *id;  </span><br><span class="line"> 2     int error;  </span><br><span class="line"> 3   </span><br><span class="line"> 4 &#x2F;* 如果handler的blacklist被赋值了并且则优先匹配 *&#x2F;  </span><br><span class="line"> 5     if (handler-&gt;blacklist &amp;&amp; input_match_device(handler-&gt;blacklist, dev))  </span><br><span class="line"> 6         return -ENODEV;  </span><br><span class="line"> 7   </span><br><span class="line"> 8     &#x2F;* 否则利用handler-&gt;id_table和dev进行匹配，后面讲述匹配什么和过程 *&#x2F;  </span><br><span class="line"> 9     id &#x3D; input_match_device(handler-&gt;id_table, dev);  </span><br><span class="line">10     if (!id)  </span><br><span class="line">11         return -ENODEV;  </span><br><span class="line">12   </span><br><span class="line">13     &#x2F;* 这是一根“红线”，虽然你可能觉的是黑色的，但不可否认，他们真的匹配上了 </span><br><span class="line">14          * 调用handler-&gt;connnect函数进行匹配，匹配详细过程后面讲述 </span><br><span class="line">15         *&#x2F;  </span><br><span class="line">16     error &#x3D; handler-&gt;connect(handler, dev, id);  </span><br><span class="line">17     if (error &amp;&amp; error !&#x3D; -ENODEV)  </span><br><span class="line">18         printk(KERN_ERR  </span><br><span class="line">19             &quot;input: failed to attach handler %s to device %s, &quot;  </span><br><span class="line">20             &quot;error: %d\n&quot;,  </span><br><span class="line">21             handler-&gt;name, kobject_name(&amp;dev-&gt;cdev.kobj), error);  </span><br><span class="line">22   </span><br><span class="line">23     return error;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　先来看下<strong>input_match_device()</strong>函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么？</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &#x2F;* 事件处理层中的对应flags如果设置或者driver_info被设置则进行匹配 *&#x2F;  </span><br><span class="line"> 2     for (; id-&gt;flags || id-&gt;driver_info; id++) &#123;  </span><br><span class="line"> 3         &#x2F;* 以下通过flags中设置的位来匹配设备的总线类型、经销商、生产ID和版本ID </span><br><span class="line"> 4           如果没有匹配上将进行MATCH_BIT匹配 *&#x2F;  </span><br><span class="line"> 5         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)  </span><br><span class="line"> 6             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)  </span><br><span class="line"> 7                 continue;  </span><br><span class="line"> 8   </span><br><span class="line"> 9         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)  </span><br><span class="line">10             if (id-&gt;vendor !&#x3D; dev-&gt;id.vendor)  </span><br><span class="line">11                 continue;  </span><br><span class="line">12   </span><br><span class="line">13         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)  </span><br><span class="line">14             if (id-&gt;product !&#x3D; dev-&gt;id.product)  </span><br><span class="line">15                 continue;  </span><br><span class="line">16   </span><br><span class="line">17         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)  </span><br><span class="line">18             if (id-&gt;version !&#x3D; dev-&gt;id.version)  </span><br><span class="line">19                 continue;  </span><br><span class="line">20           </span><br><span class="line">21         &#x2F;* MATCH_BIT用于匹配设备驱动中是否设置了这些为，MATCH_BIT的宏 </span><br><span class="line">22         * 被定义在input.c中，我们在设备驱动中设置的事件类型会与事件链表中的 </span><br><span class="line">23         * 所有事件类型进行比较，匹配成功了将返回id，证明真的很合适，否则NULL </span><br><span class="line">24         *&#x2F;  </span><br><span class="line">25         MATCH_BIT(evbit,  EV_MAX);  </span><br><span class="line">26         MATCH_BIT(keybit, KEY_MAX);  </span><br><span class="line">27         MATCH_BIT(relbit, REL_MAX);  </span><br><span class="line">28         MATCH_BIT(absbit, ABS_MAX);  </span><br><span class="line">29         MATCH_BIT(mscbit, MSC_MAX);  </span><br><span class="line">30         MATCH_BIT(ledbit, LED_MAX);  </span><br><span class="line">31         MATCH_BIT(sndbit, SND_MAX);  </span><br><span class="line">32         MATCH_BIT(ffbit,  FF_MAX);  </span><br><span class="line">33         MATCH_BIT(swbit,  SW_MAX);  </span><br><span class="line">34   </span><br><span class="line">35         return id;  </span><br><span class="line">36     &#125;  </span><br><span class="line">37   </span><br><span class="line">38     return NULL;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　既然证明是合适的，接下来就应该登记注册，并公证了。还记得handler-&gt;connect(handler, dev, id)函数吧。</p>
<p>　　当input_match_device（）找到最合适的事件处理层驱动时，便执行<strong>handler-&gt;connect</strong>函数进行公证了，看下面这部分代码（假如说找到了evdev类型的驱动，在input/evdev.c中）：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct evdev *evdev;  </span><br><span class="line"> 2     struct class_device *cdev;  </span><br><span class="line"> 3     dev_t devt;  </span><br><span class="line"> 4     int minor;  </span><br><span class="line"> 5     int error;  </span><br><span class="line"> 6   </span><br><span class="line"> 7     &#x2F;* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev *&#x2F;  </span><br><span class="line"> 8     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++);  </span><br><span class="line"> 9     &#x2F;* 这说明内核已经没办法再分配这种类型的设备了 *&#x2F;  </span><br><span class="line">10     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  </span><br><span class="line">11         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);  </span><br><span class="line">12         return -ENFILE;  </span><br><span class="line">13     &#125;  </span><br><span class="line">14     &#x2F;* 开始给evdev事件层驱动分配空间了 *&#x2F;  </span><br><span class="line">15     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);  </span><br><span class="line">16     if (!evdev)  </span><br><span class="line">17         return -ENOMEM;  </span><br><span class="line">18   </span><br><span class="line">19     &#x2F;* 初始化client_list列表和evdev_wait队列，后面介绍 *&#x2F;  </span><br><span class="line">20     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);  </span><br><span class="line">21     init_waitqueue_head(&amp;evdev-&gt;wait);  </span><br><span class="line">22   </span><br><span class="line">23     &#x2F;* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 *&#x2F;  </span><br><span class="line">24     evdev-&gt;exist &#x3D; 1;  </span><br><span class="line">25     evdev-&gt;minor &#x3D; minor;  </span><br><span class="line">26     evdev-&gt;handle.dev &#x3D; dev;  </span><br><span class="line">27     evdev-&gt;handle.name &#x3D; evdev-&gt;name;  </span><br><span class="line">28     evdev-&gt;handle.handler &#x3D; handler;  </span><br><span class="line">29     evdev-&gt;handle.private &#x3D; evdev;  </span><br><span class="line">30     sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);  </span><br><span class="line">31   </span><br><span class="line">32     &#x2F;* 重要，上层访问时通过次设备号找到事件处理的接口 *&#x2F;  </span><br><span class="line">33     evdev_table[minor] &#x3D; evdev;  </span><br><span class="line">34   </span><br><span class="line">35     &#x2F;* evdev事件设备的此设备号的基准值INPUT_MAJOR, EVDEV_MINOR_BASE *&#x2F;  </span><br><span class="line">36     devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  </span><br><span class="line">37   </span><br><span class="line">38     &#x2F;* 创建用户事件驱动层设备访问接口&#x2F;dev&#x2F;input&#x2F;event* *&#x2F;  </span><br><span class="line">39     cdev &#x3D; class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,  </span><br><span class="line">40                    dev-&gt;cdev.dev, evdev-&gt;name);  </span><br><span class="line">41     if (IS_ERR(cdev)) &#123;  </span><br><span class="line">42         error &#x3D; PTR_ERR(cdev);  </span><br><span class="line">43         goto err_free_evdev;  </span><br><span class="line">44     &#125;  </span><br><span class="line">45   </span><br><span class="line">46     &#x2F;* 提供&#x2F;sys目录的用户空间接口 *&#x2F;  </span><br><span class="line">47     error &#x3D; sysfs_create_link(&amp;input_class.subsys.kobj,  </span><br><span class="line">48                   &amp;cdev-&gt;kobj, evdev-&gt;name);  </span><br><span class="line">49     if (error)  </span><br><span class="line">50         goto err_cdev_destroy;  </span><br><span class="line">51   </span><br><span class="line">52     &#x2F;* input_dev设备驱动和handler事件处理层的关联，由handle完成 *&#x2F;  </span><br><span class="line">53     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　通过上述代码的执行，最终，输入设备在<strong>input_register_handle()</strong>的关联下与已经匹配上的handler结合</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_handler *handler &#x3D; handle-&gt;handler;  </span><br><span class="line"> 2     &#x2F;* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上 </span><br><span class="line"> 3     * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以 </span><br><span class="line"> 4     * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备 </span><br><span class="line"> 5     *&#x2F;  </span><br><span class="line"> 6     list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list);  </span><br><span class="line"> 7     list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);  </span><br><span class="line"> 8   </span><br><span class="line"> 9     &#x2F;* 如果start函数有定义则调用，但是evdev结构体中并未初始化这个函数 *&#x2F;  </span><br><span class="line">10     if (handler-&gt;start)  </span><br><span class="line">11         handler-&gt;start(handle);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　</p>
<p>　　<strong>以上是输入设备驱动注册的全过程</strong>，牵涉的代码比较多，需要从宏观上理顺。</p>
<p>　　<strong>纵观整个过程：</strong></p>
<p>　　<strong>输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件驱动再去处理呢？</strong></p>
<p>　　<strong>知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。</strong></p>
<p>　　由于以上的这些原因，才有了上述代码的关联过程，看一下整个关联注册的过程：</p>
<p>　<br>　　<img src="https://images0.cnblogs.com/blog/536940/201309/01112129-4e175a1a4f82477b8cb262b24359fd1a.png" alt="img"></p>
<p>　　通过上图我们可以看到input输入设备匹配关联的关键过程以及涉及到的关键函数和数据。</p>
<p>　　以上主要是从input设备驱动程序的角度去看输入子系统的注册过程和三层之间的关联。</p>
<p>　　下面将从应用层的角度分析事件的接受过程和处理过程以及三层之间是如何配合处理输入事件的。</p>
<hr>
<h2 id="从应用层的角度出发看input子系统"><a href="#从应用层的角度出发看input子系统" class="headerlink" title="从应用层的角度出发看input子系统"></a>从应用层的角度出发看input子系统</h2><p>　　以上部分已经借助input子系统把input设备驱动层与事件驱动层进行了关联，以s3c2440_ts.c（输入设备层驱动）和evdev.c（事件处理层驱动）为例，来分析这一过程。</p>
<p>由于s3c2440_ts.c中上报的事件类型为按键、绝对值坐标，而evdev事件驱动程序是全匹配的，因此早在s3c2440_ts.c注册的过程中，就会创建设备节点/dev/input/event0（假设内核中没有其他的event类型的输入设备，这里就是event0）</p>
<p>　　我们知道，应用层使用设备的第一步，是open(“/dev/event0”)，因此这里event0的主设备号成为关键，因为主设备号将表明你是什么设备，我们ls -l查看/dev/event0发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crw-r-----1 root root 13, 64 2012-07-26 14:32 &#x2F;dev&#x2F;input&#x2F;event0</span><br></pre></td></tr></table></figure>

<p>　　由此可见主设备是13，输入命令cat /proc/devices查看主设备为13的是input设备，因此可以确定当我们执行open函数打开event0设备的时候，会调用input设备的open驱动函数，这个函数在input.c中，为了说明这一问题，需要<strong>从input驱动注册过程开始</strong>，还是input.c文件：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F;* 输入设备初始化函数 *&#x2F;  </span><br><span class="line">2 static int __init input_init(void)  </span><br><span class="line">3 &#123;  </span><br><span class="line">4        class_register(&amp;input_class);  </span><br><span class="line">5        input_proc_init();  </span><br><span class="line">6        register_chrdev(INPUT_MAJOR,&quot;input&quot;, &amp;input_fops);  </span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　可以看到，输入设备初始化的过程首先建立了input类，初始化input在proc下的节点，然后注册input设备，设备名称为input，操作接口是input_fops，主设备号是INPUT_MAJOR=13。</p>
<p>　　由以上可知，只要是主设备号为13的设备驱动程序，都是用input_fops接口，即当event0设备使用open函数打开时，会调用到input_fops接口中的open驱动函数，这个结构体的初始化为：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static const struct file_operations input_fops &#x3D; &#123;  </span><br><span class="line">2        .owner &#x3D; THIS_MODULE,  </span><br><span class="line">3        .open &#x3D; input_open_file,  </span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　可以看到，只实现了一个open功能字段，再看<strong>input_open_file</strong>的实现：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct input_handler *handler &#x3D;input_table[iminor(inode) &gt;&gt; 5];  </span><br><span class="line"> 4        const struct file_operations *old_fops,*new_fops &#x3D; NULL;  </span><br><span class="line"> 5        if (!handler || !(new_fops &#x3D;fops_get(handler-&gt;fops)))  </span><br><span class="line"> 6               return -ENODEV;  </span><br><span class="line"> 7        old_fops &#x3D; file-&gt;f_op;  </span><br><span class="line"> 8        file-&gt;f_op &#x3D; new_fops;  </span><br><span class="line"> 9        new_fops-&gt;open(inode, file);  </span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　以上代码的功能为找到对应事件驱动层的fops，即进行fops的接口转换，指向对应设备的事件处理接口。</p>
<p>　　其中input_table[iminor(inode)]&gt;&gt;5的input_table是一个全局的input_handler类型的数组，iminor(inode)取得次设备号，并且右移5位索引input_table表中对应的位置，为什么这样做呢？这是因为这个表格中填写的就是事件处理的指针，待会分析。</p>
<p>　　继续查看下面的代码。if中将判断是否为空并且事件处理层中的fops有没有初始化，如果没有就不能进行接口转换，报出设备不存在的错误，如果设备存在则把input设备的f_op驱动接口指向input_table表中存在的接口，并调用其open函数。</p>
<p>　　那么这个<strong>input_table里面到底存放了什么呢？</strong>我们还是拿触摸屏驱动来讲解。由于触摸屏驱动已经完成了和evdev.c事件处理层的匹配，且次设备号为64，设备名称为/dev/event0，这是我们通过分析驱动注册中获得的内容，既然input核心设备注册了，s3c2440触摸屏驱动也注册了，那会不会evdev设备也会注册了呢？答案是肯定的，要想知道input_table里面放了什么，必须要去查看<strong>evdev设备的注册过程</strong>，打开input/evdev.c查看它的注册过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static struct input_handler evdev_handler &#x3D; &#123;  </span><br><span class="line"> 2        .event &#x3D;   evdev_event,                               &#x2F;&#x2F;事件处理  </span><br><span class="line"> 3        .connect &#x3D;      evdev_connect,                    &#x2F;&#x2F;设备连接  </span><br><span class="line"> 4        .disconnect &#x3D;  evdev_disconnect,                &#x2F;&#x2F;注销连接  </span><br><span class="line"> 5        .fops &#x3D;           &amp;evdev_fops,                      &#x2F;&#x2F;驱动功能接口  </span><br><span class="line"> 6        .minor &#x3D;  EVDEV_MINOR_BASE,              &#x2F;&#x2F;evdev的值为64  </span><br><span class="line"> 7        .name &#x3D;          &quot;evdev&quot;,                              &#x2F;&#x2F;设备名称  </span><br><span class="line"> 8        .id_table &#x3D;      evdev_ids,                           &#x2F;&#x2F;用于匹配设备驱动的数组  </span><br><span class="line"> 9 &#125;;  </span><br><span class="line">10    </span><br><span class="line">11 static int __init evdev_init(void)  </span><br><span class="line">12 &#123;  </span><br><span class="line">13        return input_register_handler(&amp;evdev_handler);          &#x2F;&#x2F;evdev设备驱动注册  </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　由以上的内容可以知道evdev_handler也被作为一个设备来操作，但是它属于input handler事件处理设备，然而我们在evdev_handler结构体的.fops字段又发现它的驱动接口为字符设备类型，在input中，如果input_table匹配到了evdev_handler，将会把file-&gt;f_op=&amp;evdev_fops，那么如果使用read、write等函数操作，将会调用到evdev_fops中的read、write。</p>
<p>　　为了进一步查看<strong>input_table表中的内容是如何填充的</strong>，还需要查看这个注册的过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 int input_register_handler(struct input_handler *handler)  </span><br><span class="line">2 &#123;  </span><br><span class="line">3     ……  </span><br><span class="line">4            input_table[handler-&gt;minor&gt;&gt; 5] &#x3D; handler;  </span><br><span class="line">5     ……  </span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　当然这个注册过程并不是只有这么一句话，看到这条语句，相信应该知道什么意思了。</p>
<p>　　在input的open函数执行之前，即我们的open代码打开之前，input_table中的字段已经被事件处理层填充了。</p>
<p>　　由于evdev的次设备号在初始化的时候就设置成了64，因此这里相当于：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_table[2]&#x3D;&amp;evdev_handler；</span><br></pre></td></tr></table></figure>

<p>　　回到input_open_file函数查看new_fops-&gt;open(inode, file)便知道了调用的是:</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evdev_handler.evdev_fops.open（inode, file）；</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　在分析open函数之前，解释一下<strong>为什么要右移5位？</strong></p>
<p>　　这说明一个问题，次设备号的低5位被忽略，这说明evdev的最大支持的输入设备驱动个数为2^5次方等于32个，你可能会看到你的/dev目录下面有event0、event1、event2等设备，他们的次设备号分别为64、65、66等等。但最大是64+32-1，因此input_table为这些输入设备增加的一个统一接口，通过上层打开设备时，只要次设备号在64+32-1之间的设备都会重新定位到evdev_handler中，即event*设备打开后执行的底层函数将被重新定义到evdev_handler中。</p>
<p>　　相信上面的问题已经描述清楚，如果还是不明白，最起码应该知道的是，input设备中的open函数只是一个接口，通过次设备号才找到了真正的事件处理接口。接下来要看新的open接口的实现了，evdev_handler-&gt; fops-&gt;open实现如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &#x2F;*evdev字符设备驱动接口 *&#x2F;  </span><br><span class="line"> 2 static const struct file_operations evdev_fops &#x3D; &#123;  </span><br><span class="line"> 3        .owner &#x3D; THIS_MODULE,  </span><br><span class="line"> 4        .read &#x3D;           evdev_read,  </span><br><span class="line"> 5        .write &#x3D;   evdev_write,  </span><br><span class="line"> 6        .poll &#x3D;            evdev_poll,  </span><br><span class="line"> 7        .open &#x3D;          evdev_open,  </span><br><span class="line"> 8        .release &#x3D; evdev_release,  </span><br><span class="line"> 9        .unlocked_ioctl &#x3D; evdev_ioctl,  </span><br><span class="line">10 #ifdef CONFIG_COMPAT  </span><br><span class="line">11        .compat_ioctl &#x3D;      evdev_ioctl_compat,  </span><br><span class="line">12 #endif  </span><br><span class="line">13        .fasync &#x3D; evdev_fasync,  </span><br><span class="line">14        .flush &#x3D;   evdev_flush  </span><br><span class="line">15 &#125;;  </span><br><span class="line">16 &#x2F;*evdev设备open函数的实现过程 *&#x2F;  </span><br><span class="line">17 static int evdev_open(struct inode *inode, struct file *file)  </span><br><span class="line">18 &#123;  </span><br><span class="line">19        struct evdev_client *client;  </span><br><span class="line">20        struct evdev *evdev;  </span><br><span class="line">21        &#x2F;* 如果是event0，对于evdev设备来说，次设备号当然是0 *&#x2F;  </span><br><span class="line">22        int i &#x3D; iminor(inode) - EVDEV_MINOR_BASE;  </span><br><span class="line">23        int error;  </span><br><span class="line">24        &#x2F;* 如果大于32，说明超出了evdev能够容纳的最大输入设备个数 *&#x2F;  </span><br><span class="line">25        if (i &gt;&#x3D; EVDEV_MINORS)  </span><br><span class="line">26               return -ENODEV;  </span><br><span class="line">27        &#x2F;* 由于evdev中能容纳32个输入设备，因此通过设备号event0中的0定位到是要处理的是哪一个输入设备，evdev_table中的内容在输入设备驱动注册时通过evdev_connect填充 *&#x2F;  </span><br><span class="line">28        evdev &#x3D; evdev_table[i];  </span><br><span class="line">29        &#x2F;* 判断是否设备接口存在，evdev_exist也是在evdev_connect填充为1 *&#x2F;  </span><br><span class="line">30        if (!evdev || !evdev-&gt;exist)  </span><br><span class="line">31               return -ENODEV;  </span><br><span class="line">32        &#x2F;* 存在则分配evdev中的client来处理event* *&#x2F;  </span><br><span class="line">33        client &#x3D; kzalloc(sizeof(struct evdev_client),GFP_KERNEL);  </span><br><span class="line">34        if (!client)  </span><br><span class="line">35               return -ENOMEM;  </span><br><span class="line">36    </span><br><span class="line">37        &#x2F;* 把event*中的接口指向evdev_table中对应项 *&#x2F;  </span><br><span class="line">38        client-&gt;evdev &#x3D; evdev;  </span><br><span class="line">39        &#x2F;* 把client-&gt;node链接到evdev子集中 *&#x2F;  </span><br><span class="line">40        list_add_tail(&amp;client-&gt;node,&amp;evdev-&gt;client_list);  </span><br><span class="line">41        &#x2F;* 如果open是第一个打开，则会执行input_open_device*&#x2F;  </span><br><span class="line">42        if (!evdev-&gt;open++ &amp;&amp;evdev-&gt;exist) &#123;  </span><br><span class="line">43               error &#x3D;input_open_device(&amp;evdev-&gt;handle);  </span><br><span class="line">44               if (error) &#123;  </span><br><span class="line">45                      list_del(&amp;client-&gt;node);  </span><br><span class="line">46                      kfree(client);  </span><br><span class="line">47                      return error;  </span><br><span class="line">48               &#125;  </span><br><span class="line">49        &#125;  </span><br><span class="line">50        &#x2F;* 将file私有指针指向client*&#x2F;  </span><br><span class="line">51        file-&gt;private_data &#x3D; client;  </span><br><span class="line">52        return 0;  </span><br><span class="line">53 &#125;  </span><br><span class="line">54 &#x2F;&#x2F;由上的代码可以看出，最终是要执行input_open_device去执行设备驱动程序中的代码，然而我们在定义设备驱动的时候并没有给input_dev中的open字段填充内容，因此可以看到input_open_device函数的执行过程：  </span><br><span class="line">55 if(!dev-&gt;users++ &amp;&amp; dev-&gt;open)  </span><br><span class="line">56               err &#x3D; dev-&gt;open(dev);  </span><br><span class="line">57    </span><br><span class="line">58        if (err)  </span><br><span class="line">59               handle-&gt;open--;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上面截取了片段，并没有执行到open函数，open进行自减操作，表示没有调用过open，这个值主要是为了close中判断open为0时释放资源使用。</p>
<p>　　不仅如此，我们在触摸屏驱动中也没有定义read、write，那当触摸屏上报事件时，是如何处理的呢？</p>
<p>　　我们需要先到触摸屏驱动程序中找到上报事件的函数再做进一步分析。</p>
<hr>
<h2 id="输入设备上报事件的处理过程"><a href="#输入设备上报事件的处理过程" class="headerlink" title="输入设备上报事件的处理过程"></a>输入设备上报事件的处理过程</h2><p>　　触摸屏驱动程序<strong>上报事件的函数</strong>为：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 input_report_abs(dev,ABS_X, s3c2440_ts-&gt;tc.xp);  </span><br><span class="line">2 input_report_abs(dev,ABS_Y, s3c2440_ts-&gt;tc.yp);  </span><br><span class="line">3 input_report_abs(dev,ABS_PRESSURE, s3c2440_ts-&gt;tc.pressure);  </span><br><span class="line">4 input_report_key(dev,BTN_TOUCH, s3c2440_ts-&gt;pendown);  </span><br><span class="line">5 input_sync(dev);</span><br></pre></td></tr></table></figure>





<p>　　然而他们其实是<strong>input_event</strong>函数的封装，调用的都是input_event函数，这一函数在input.c中实现如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 void input_event(struct input_dev *dev, unsigned int type, unsigned int code, intvalue)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct input_handle *handle;  </span><br><span class="line"> 4    </span><br><span class="line"> 5        if (type &gt; EV_MAX || !test_bit(type,dev-&gt;evbit))  </span><br><span class="line"> 6               return;  </span><br><span class="line"> 7        switch (type) &#123;  </span><br><span class="line"> 8               case EV_SYN:  </span><br><span class="line"> 9                      switch (code) &#123;  </span><br><span class="line">10                             case SYN_CONFIG:  </span><br><span class="line">11                                    if(dev-&gt;event)  </span><br><span class="line">12                                           dev-&gt;event(dev,type, code, value);  </span><br><span class="line">13                                    break;  </span><br><span class="line">14                             case SYN_REPORT:  </span><br><span class="line">15                                    if(dev-&gt;sync)  </span><br><span class="line">16                                           return;  </span><br><span class="line">17                                    dev-&gt;sync&#x3D; 1;  </span><br><span class="line">18                                    break;  </span><br><span class="line">19                      &#125;  </span><br><span class="line">20                      break;  </span><br><span class="line">21               case EV_KEY:  </span><br><span class="line">22               case EV_SW:  </span><br><span class="line">23               case EV_ABS:  </span><br><span class="line">24               case EV_REL:  </span><br><span class="line">25               case EV_MSC:  </span><br><span class="line">26               case EV_LED:  </span><br><span class="line">27               case EV_SND:  </span><br><span class="line">28               case EV_REP:  </span><br><span class="line">29               case EV_FF:  </span><br><span class="line">30        &#125;  </span><br><span class="line">31    </span><br><span class="line">32        if (type !&#x3D; EV_SYN)  </span><br><span class="line">33               dev-&gt;sync &#x3D; 0;  </span><br><span class="line">34    </span><br><span class="line">35        if (dev-&gt;grab)  </span><br><span class="line">36               dev-&gt;grab-&gt;handler-&gt;event(dev-&gt;grab,type, code, value);  </span><br><span class="line">37        else  </span><br><span class="line">38               list_for_each_entry(handle,&amp;dev-&gt;h_list, d_node)  </span><br><span class="line">39                      if (handle-&gt;open)  </span><br><span class="line">40                             handle-&gt;handler-&gt;event(handle,type, code, value);  </span><br><span class="line">41 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　代码被做了精简，其中就是在匹配上报的事件，并根据事件的类型调用驱动程序中相应的函数来完成，但是由于我们并没有定义过这些函数，因此执行最后的<strong>handle_handler_event</strong>函数，由事件处理层evdev_event函数来完成事件的保存工作，具体过程如下：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 list_for_each_entry(client,&amp;evdev-&gt;client_list, node) &#123;  </span><br><span class="line">2     client-&gt;buffer[client-&gt;head].type&#x3D; type;  </span><br><span class="line">3     client-&gt;buffer[client-&gt;head].code&#x3D; code;  </span><br><span class="line">4     client-&gt;buffer[client-&gt;head].value&#x3D; value;  </span><br><span class="line">5     client-&gt;head&#x3D; (client-&gt;head + 1) &amp; (EVDEV_BUFFER_SIZE - 1);  </span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这里列举了关键代码，即上报的事件被保存到了client_buffer中，其中client_buffer是一个循环缓冲区，client-&gt;head表示当前数据的位置，因此每次都写到client-&gt;head的位置，而读数据时需要到client_tail中读取。因为在open的时候，client已经被链入到了evdev-&gt;client_list中，因此通过可以通过list_for_each_entry重evdev-&gt;client_list中找到对应的client。</p>
<p>　　事件的上报都会把数据保存到client-&gt;buffer中，以便上层通过read和write进行读去和写入。</p>
<hr>
<h2 id="通过设备节点读取输入事件"><a href="#通过设备节点读取输入事件" class="headerlink" title="通过设备节点读取输入事件"></a>通过设备节点读取输入事件</h2><p>　　还是以触摸屏驱动程序和evdev事件处理层驱动来分析：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static ssize_t evdev_read(struct file *file, char __user *buffer, size_t count, loff_t*ppos)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        struct evdev_client *client &#x3D;file-&gt;private_data;  </span><br><span class="line"> 4        struct evdev *evdev &#x3D; client-&gt;evdev;  </span><br><span class="line"> 5        int retval;  </span><br><span class="line"> 6    </span><br><span class="line"> 7        &#x2F;* 判断用户给的count是否能够容纳事件数据的大小*&#x2F;  </span><br><span class="line"> 8        if (count &lt; evdev_event_size())  </span><br><span class="line"> 9               return -EINVAL;  </span><br><span class="line">10    </span><br><span class="line">11        &#x2F;* 如果数据不为空并且设备存在并且是阻塞访问方式才能继续执行 *&#x2F;  </span><br><span class="line">12        if (client-&gt;head &#x3D;&#x3D; client-&gt;tail&amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))  </span><br><span class="line">13               return -EAGAIN;  </span><br><span class="line">14    </span><br><span class="line">15        &#x2F;* 如果数据为空，设置进程等待底层驱动层上报事件到client-&gt;buffer中 *&#x2F;  </span><br><span class="line">16        retval &#x3D;wait_event_interruptible(evdev-&gt;wait,  </span><br><span class="line">17               client-&gt;head !&#x3D; client-&gt;tail|| !evdev-&gt;exist);  </span><br><span class="line">18        if (retval)  </span><br><span class="line">19               return retval;  </span><br><span class="line">20    </span><br><span class="line">21        if (!evdev-&gt;exist)  </span><br><span class="line">22               return -ENODEV;  </span><br><span class="line">23    </span><br><span class="line">24        &#x2F;* 循环读取数据 *&#x2F;  </span><br><span class="line">25        while (client-&gt;head !&#x3D; client-&gt;tail&amp;&amp; retval + evdev_event_size() &lt;&#x3D; count) &#123;  </span><br><span class="line">26    </span><br><span class="line">27               struct input_event *event &#x3D;(struct input_event *) client-&gt;buffer + client-&gt;tail;  </span><br><span class="line">28    </span><br><span class="line">29               if (evdev_event_to_user(buffer +retval, event))  </span><br><span class="line">30                      return -EFAULT;  </span><br><span class="line">31    </span><br><span class="line">32               client-&gt;tail &#x3D; (client-&gt;tail+ 1) &amp; (EVDEV_BUFFER_SIZE - 1);  </span><br><span class="line">33               retval +&#x3D; evdev_event_size();  </span><br><span class="line">34        &#125;  </span><br><span class="line">35    </span><br><span class="line">36        return retval;  </span><br><span class="line">37 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这里如果没有数据，进程会睡眠，那由谁来唤醒呢？细心的话可以发现，当设备驱动层调用input_event上报事件调用相应的event函数进行事件写入时，是会唤醒阻塞等待的进程的。</p>
<hr>
<h2 id="通过设备节点写入输入事件"><a href="#通过设备节点写入输入事件" class="headerlink" title="通过设备节点写入输入事件"></a>通过设备节点写入输入事件</h2><p>　　写入过程：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static ssize_t evdev_write(struct file *file, const char __user *buffer, size_t count,loff_t *ppos)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3        &#x2F;* 循环写入，调用input_inject_event函数 *&#x2F;  </span><br><span class="line"> 4        while (retval &lt; count) &#123;  </span><br><span class="line"> 5    </span><br><span class="line"> 6               if (evdev_event_from_user(buffer +retval, &amp;event))  </span><br><span class="line"> 7                      return -EFAULT;  </span><br><span class="line"> 8               input_inject_event(&amp;evdev-&gt;handle,event.type, event.code, event.value);  </span><br><span class="line"> 9               retval +&#x3D; evdev_event_size();  </span><br><span class="line">10        &#125;  </span><br><span class="line">11    </span><br><span class="line">12        return retval;  </span><br><span class="line">13 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　上述代码中的event是input_event数组，包含了事件的类型、键值，通过input_inject_event把数据写入循环数组client-&gt;buffer中，input_inject_event调用的是input_event函数。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　对input子系统的整个过程做了分析，并从两个角度进行考虑.</p>
<p>　　对于写输入设备驱动程序的来说，需要掌握的是设备应该上报事件的类型，这样才能匹配到对应的事件层驱动帮助你保存对应的数据.</p>
<p>　　而对于设备上层开发者来说，应该先使用cat /proc/bus/input/devices查看你操作的设备类型和处理接口，以帮助你更好的对设备操作。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/ielife" target="_blank" rel="noopener">http://blog.csdn.net/ielife</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux之输入子系统分析(详解)</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E4%B9%8B%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E8%AF%A6%E8%A7%A3)/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://www.cnblogs.com/lifexy/" target="_blank" rel="noopener">诺谦</a> 【<a href="https://www.cnblogs.com/lifexy/p/7542989.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7542989.html】</a></p>
<h1 id="12-Linux之输入子系统分析-详解"><a href="#12-Linux之输入子系统分析-详解" class="headerlink" title="12.Linux之输入子系统分析(详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">12.Linux之输入子系统分析(详解)</a></h1><p>在此节之前，我们学的都是简单的字符驱动，涉及的内容有<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>字符驱动的框架</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506387.html" target="_blank" rel="noopener"><strong>自动创建设备节点</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7506718.html" target="_blank" rel="noopener"><strong>linux中断</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508633.html" target="_blank" rel="noopener"><strong>poll机制</strong></a>、<a href="http://www.cnblogs.com/lifexy/p/7508791.html" target="_blank" rel="noopener"><strong>异步通知</strong></a>、<strong><a href="http://www.cnblogs.com/lifexy/p/7515488.html" target="_blank" rel="noopener">同步互斥/非阻塞</a></strong>、<a href="http://www.cnblogs.com/lifexy/p/7522122.html" target="_blank" rel="noopener"><strong>定时器去抖动</strong></a>。</p>
<p>其中<strong>驱动框架</strong>如下:</p>
<p>1)写file_operations结构体的成员函数: .open()、.read()、.write()</p>
<p>2)在入口函数里通过register_chrdev()创建驱动名,生成主设备号,赋入file_operations结构体</p>
<p>3)在出口函数里通过unregister_chrdev() 卸载驱动</p>
<p>若有多个不同的驱动程序时,应用程序就要打开多个不同的驱动设备，由于是自己写肯定会很清楚,如果给别人来使用时是不是很麻烦？</p>
<p>所以需要使用<strong>输入子系统</strong>, 使应用程序无需打开多个不同的驱动设备便能实现</p>
<hr>
<p><strong>1.输入子系统简介</strong></p>
<p>同样的输入子系统也需要输入驱动的框架,好来辨认应用程序要打开的是哪个输入驱动</p>
<p>比如: 鼠标、键盘、游戏手柄等等这些都属于输入设备；这些输入设备的驱动都是通过输入子系统来实现的（当然，这些设备也依赖于usb子系统）</p>
<p>这些输入设备都各有不同，那么输入子系统也就只能实现他们的共性，差异性则由设备驱动来实现。差异性又体现在哪里？</p>
<p>最直观的就表现在这些设备功能上的不同了。对于我们写驱动的人来说在设备驱动中就只要使用输入子系统提供的工具（也就是函数）来完成这些“差异”就行了，其他的则是输入子系统的工作。这个思想不仅存在于输入子系统，其他子系统也是一样(比如:usb子系统、video子系统等)</p>
<p>所以我们先来分析下输入子系统<strong>input.c</strong>的代码,然后怎么来使用输入子系统(在内核中以input来形容输入子系统)</p>
<p><strong>2.打开input.c,位于内核deivers/input</strong></p>
<p>有以下这么两段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsys_initcall(input_init);   &#x2F;&#x2F;修饰入口函数</span><br><span class="line"></span><br><span class="line">module_exit(input_exit);     &#x2F;&#x2F;修饰出口函数</span><br></pre></td></tr></table></figure>



<p><strong>显然输入子系统是作为一个模块存在,我们先来分析下input_int()入口函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int __init input_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3        int err;</span><br><span class="line"> 4        err &#x3D; class_register(&amp;input_class);   &#x2F;&#x2F;(1)注册类,放在&#x2F;sys&#x2F;class</span><br><span class="line"> 5        if (err) &#123;</span><br><span class="line"> 6               printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);</span><br><span class="line"> 7               return err;</span><br><span class="line"> 8        &#125;</span><br><span class="line"> 9  </span><br><span class="line">10        err &#x3D; input_proc_init();    &#x2F;&#x2F;在&#x2F;proc下面建立相关的文件</span><br><span class="line">11        if (err)</span><br><span class="line">12               goto fail1;</span><br><span class="line">13 </span><br><span class="line">14        err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops); &#x2F;&#x2F;(2)注册驱动</span><br><span class="line">15        if (err) &#123;</span><br><span class="line">16               printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">17               goto fail2;</span><br><span class="line">18        &#125;</span><br><span class="line">19 </span><br><span class="line">20  </span><br><span class="line">21 </span><br><span class="line">22        return 0;</span><br><span class="line">23 </span><br><span class="line">24  </span><br><span class="line">25 </span><br><span class="line">26  fail2:     input_proc_exit();</span><br><span class="line">27 </span><br><span class="line">28  fail1:     class_unregister(&amp;input_class);</span><br><span class="line">29 </span><br><span class="line">30        return err;</span><br><span class="line">31 </span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1)<strong>上面第4行”err = class_register(&amp;input_class);”</strong>是在/sys/class 里创建一个 input类, input_class变量如下图:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125656056-1309527087.png" alt="img"></p>
<p>如下图,我们启动内核,再启动一个input子系统的驱动后，也可以看到创建了个”input”类 :</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190208915-1448414250.png" alt="img"></p>
<p>为什么这里代码只创建类，没有使用class_device_create()函数在类下面创建驱动设备？</p>
<p>在下面第8小结会详细讲到,这里简单描述:当注册input子系统的驱动后，才会有驱动设备，此时这里的代码是没有驱动的</p>
<p>(2)<strong>上面第14行</strong>通过register_chrdev创建驱动设备,其中变量INPUT_MAJOR =13,所以创建了一个主设备为13的”input”设备。</p>
<p>然后我们来看看它的操作结构体input_fops,如下图:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125709915-1132827718.png" alt="img"></p>
<p>只有一个.open函数,比如当我们挂载一个新的input驱动,则内核便会调用该.open函数,接下来分析该.open函数</p>
<p><strong>3 然后进入input_open_file函数(drivers/input/input.c)</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line"> 2  &#123;</span><br><span class="line"> 3      struct input_handler *handler &#x3D; input_table[iminor(inode) &gt;&gt; 5]; &#x2F;&#x2F; (1)</span><br><span class="line"> 4      const struct file_operations *old_fops, *new_fops &#x3D; NULL;</span><br><span class="line"> 5      int err;</span><br><span class="line"> 6 </span><br><span class="line"> 7      if (!handler || !(new_fops &#x3D; fops_get(handler-&gt;fops)))  &#x2F;&#x2F;(2)</span><br><span class="line"> 8           return -ENODEV; </span><br><span class="line"> 9 </span><br><span class="line">10     if (!new_fops-&gt;open) &#123;</span><br><span class="line">11            fops_put(new_fops);</span><br><span class="line">12            return -ENODEV;</span><br><span class="line">13     &#125;</span><br><span class="line">14 </span><br><span class="line">15     old_fops &#x3D; file-&gt;f_op;</span><br><span class="line">16     file-&gt;f_op &#x3D; new_fops;     &#x2F;&#x2F;(3)</span><br><span class="line">17 </span><br><span class="line">18     err &#x3D; new_fops-&gt;open(inode, file);   &#x2F;&#x2F;(4)</span><br><span class="line">19     if (err) &#123;</span><br><span class="line">20           fops_put(file-&gt;f_op);</span><br><span class="line">21            file-&gt;f_op &#x3D; fops_get(old_fops);</span><br><span class="line">22    &#125;</span><br><span class="line">23 </span><br><span class="line">24    fops_put(old_fops);</span><br><span class="line">25 </span><br><span class="line">26     return err;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第3行中</strong>,其中iminor (inode)函数调用了MINOR(inode-&gt;i_rdev);读取子设备号,然后将子设备除以32,找到新挂载的input驱动的数组号,然后放在input_handler 驱动处理函数handler中 </p>
<p><strong>(2)第7行中</strong>,若handler有值,说明挂载有这个驱动,就将handler结构体里的成员file_operations * fops赋到新的file_operations *new_fops里面</p>
<p><strong>(3)第16行中</strong>, 再将新的file_operations *new_fops赋到file-&gt; file_operations  *f_op里, 此时input子系统的file_operations就等于新挂载的input驱动的file_operations结构体,实现一个偷天换日的效果.</p>
<p><strong>(4)第18行中</strong>,然后调用新挂载的input驱动的*new_fops里面的成员.open函数</p>
<p><strong>4.上面代码的input_table[]数组在初始时是没有值的,</strong></p>
<p><strong>所以我们来看看input_table数组里面的数据又是在哪个函数里被赋值</strong></p>
<p>在input.c函数(drivers/input/input.c)中搜索input_table,找到它在input_register_handler()函数中被赋值,代码如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 int input_register_handler(struct input_handler *handler)</span><br><span class="line">2 &#123;</span><br><span class="line">3 ... ...</span><br><span class="line">4 input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;   &#x2F;&#x2F;input_table[]被赋值</span><br><span class="line">5 ... ...</span><br><span class="line">6 list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); &#x2F;&#x2F;然后将这个input_handler放到input_handler_list链表中  </span><br><span class="line">7 ... ...</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是将驱动处理程序input_handler注册到input_table[]中，然后放在input_handler_list链表中,后面会讲这个链表</p>
<p><strong>5继续来搜索input_register_handler,看看这个函数被谁来调用</strong></p>
<p>如下图所示,有evdev.c(事件设备)，tsdev.c(触摸屏设备)，joydev.c(joystick操作杆设备)，keyboard.c(键盘设备)，mousedev.c(鼠标设备) 这5个内核自带的设备处理函数注册到input子系统中</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125734228-444718177.png" alt="img"></p>
<p>我们以evdev.c为例,它在evdev_ini()函数中注册:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">       return input_register_handler(&amp;evdev_handler);  &#x2F;&#x2F;注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>6我们来看看这个evdev_handler变量是什么结构体,:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static struct input_handler evdev_handler &#x3D; &#123;</span><br><span class="line">2        .event &#x3D;  evdev_event,    </span><br><span class="line">3        .connect &#x3D;      evdev_connect,  &#x2F;&#x2F;(4)</span><br><span class="line">4        .disconnect &#x3D; evdev_disconnect,</span><br><span class="line">5        .fops &#x3D;           &amp;evdev_fops,    &#x2F;&#x2F;(1)</span><br><span class="line">6        .minor &#x3D;  EVDEV_MINOR_BASE, &#x2F;&#x2F;(2)</span><br><span class="line">7        .name &#x3D;         &quot;evdev&quot;,</span><br><span class="line">8        .id_table &#x3D;      evdev_ids, &#x2F;&#x2F;(3)</span><br><span class="line">9 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>就是我们之前看的input_handler驱动处理结构体</p>
<p>(1) <strong>第5行中.fops:</strong>文件操作结构体,其中evdev_fops函数就是自己的写的操作函数,然后赋到.fops中</p>
<p>(2)<strong>第6行中 .minor:</strong>用来存放次设备号</p>
<p>其中EVDEV_MINOR_BASE=64, 然后调用input_register_handler(&amp;evdev_handler)后,由于EVDEV_MINOR_BASE/32=2,所以存到input_table[2]中</p>
<p> 所以当open打开这个input设备,就会进入 input_open_file()函数,执行evdev_handler-&gt; evdev_fops -&gt; .open函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125751978-2110731647.png" alt="img"></p>
<p>(3)<strong>第8行中.id_table :</strong> 表示能支持哪些输入设备，比如某个驱动设备的input_dev-&gt;的id和某个input_handler的id_table相匹配，就会调用.connect连接函数,如下图</p>
<p>(4)<strong>第3行中.connect:</strong>连接函数，将设备input_dev和某个input_handler建立连接,如下图</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125805775-128197571.png" alt="img"></p>
<p><strong>7我们先来看看上图的input_register_device()函数,如何创建驱动设备的</strong></p>
<p>搜索input_register_device,发现内核自己就已经注册了很多驱动设备</p>
<p><strong>7.1然后进入input_register_device()函数,代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备</span><br><span class="line">2 &#123;</span><br><span class="line">3  ... ...</span><br><span class="line">4        list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中</span><br><span class="line">5  ... ...</span><br><span class="line">6        list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)</span><br><span class="line">7        input_attach_handler(dev, handler); </span><br><span class="line">8  ... ...</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)第4行中,</strong>将要注册的input_dev驱动设备放在input_dev_list链表中</p>
<p><strong>(2)第6行中,</strong>其中input_handler_list在前面讲过,就是存放每个input_handle驱动处理结构体,</p>
<p>然后list_for_each_entry()函数会将每个input_handle从链表中取出,放到handler中</p>
<p>最后会调用input_attach_handler()函数,将每个input_handle的id_table进行判断,若两者支持便进行连接。</p>
<p><strong>7.2然后我们在回过头来看注册input_handler的input_register_handler()函数,如下图所示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125828931-1140237004.png" alt="img"></p>
<p>所以,不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支持, 若两者支持便进行连接。</p>
<p><strong>7.3我们来看看input_attach_handler()如何实现匹配两者id的:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line">id &#x3D; input_match_device(handler-&gt;id_table, dev);  &#x2F;&#x2F;匹配两者</span><br><span class="line"></span><br><span class="line">if (!id)                                     &#x2F;&#x2F;若不匹配,return退出</span><br><span class="line">return -ENODEV; </span><br><span class="line"></span><br><span class="line">error &#x3D; handler-&gt;connect(handler, dev, id);  &#x2F;&#x2F;调用input_handler -&gt;connect函数建立连接</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若两者匹配成功，就会自动进入input_handler 的connect函数建立连接</p>
<p><strong>8我们还是以evdev.c(事件驱动) 的evdev_handler-&gt;connect函数</strong></p>
<p><strong>来分析**</strong>是怎样建立连接的,如下图:**</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125845790-1398162479.png" alt="img"></p>
<p><strong>8.1 evdev_handler的.connect函数是evdev_connect(),代码如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)     </span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3 ... ... </span><br><span class="line"> 4 for (minor &#x3D; 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++); &#x2F;&#x2F;查找驱动设备的子设备号</span><br><span class="line"> 5     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  &#x2F;&#x2F; EVDEV_MINORS&#x3D;32,所以该事件下的驱动设备最多存32个,</span><br><span class="line"> 6         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);</span><br><span class="line"> 7         return -ENFILE;                &#x2F;&#x2F;没找到驱动设备</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9  ... ...</span><br><span class="line">10  evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);   &#x2F;&#x2F;分配一个input_handle全局结构体(没有r)</span><br><span class="line">11  ... ...</span><br><span class="line">12  evdev-&gt;handle.dev &#x3D; dev;              &#x2F;&#x2F;指向参数input_dev驱动设备</span><br><span class="line">13 evdev-&gt;handle.name &#x3D; evdev-&gt;name;</span><br><span class="line">14 evdev-&gt;handle.handler &#x3D; handler;    &#x2F;&#x2F;指向参数 input_handler驱动处理结构体</span><br><span class="line">15 evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line">16 sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);    &#x2F;&#x2F;(1)保存驱动设备名字, event%d</span><br><span class="line">17 ... ...</span><br><span class="line">18 devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  &#x2F;&#x2F;(2) 将主设备号和次设备号转换成dev_t类型</span><br><span class="line">19 cdev &#x3D; class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name);                                                            &#x2F;&#x2F; (3)在input类下创建驱动设备</span><br><span class="line">20 </span><br><span class="line">21 ... ...</span><br><span class="line">22 error &#x3D; input_register_handle(&amp;evdev-&gt;handle); &#x2F;&#x2F;(4)注册这个input_handle结构体</span><br><span class="line">23 </span><br><span class="line">24 ... ...</span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1) 第16行中,是在保存驱动设备名字,名为event%d, 比如下图(键盘驱动)event1: 因为没有设置子设备号，默认从小到大排列,其中event0是表示这个input子系统,所以这个键盘驱动名字就是event1</p>
<p>(2)第18行中,是在保存驱动设备的主次设备号,其中主设备号INPUT_MAJOR=13,因为EVDEV_MINOR_BASE=64,所以此设备号=64+驱动程序本事子设备号, 比如下图(键盘驱动)event1:  主次设备号就是13,65</p>
<p>(3)在之前在2小结里就分析了input_class类结构，所以第19行中,会在/sys/class/input类下创建驱动设备event%d，比如下图(键盘驱动)event1:</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918190616478-260239851.png" alt="img"></p>
<p>(4)最终会进入input_register_handle()函数来注册,代码在下面</p>
<p>8.2 <strong>input_register_handle()函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_handle(struct input_handle *handle)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3       struct input_handler *handler &#x3D; handle-&gt;handler; &#x2F;&#x2F;handler&#x3D; input_handler驱动处理结构体 </span><br><span class="line"> 4 </span><br><span class="line"> 5       list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;(1)</span><br><span class="line"> 6       list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; (2)</span><br><span class="line"> 7  </span><br><span class="line"> 8       if (handler-&gt;start)</span><br><span class="line"> 9              handler-&gt;start(handle);</span><br><span class="line">10       return 0;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>(1)在第5行中,</strong> 因为handle-&gt;dev指向input_dev驱动设备,所以就是将handle-&gt;d_node放入到input_dev驱动设备的h_list链表中,</p>
<p>即input_dev驱动设备的h_list链表就指向handle-&gt;d_node</p>
<p><strong>(2) 在第6行中,</strong> 同样, input_handler驱动处理结构体的h_list也指向了handle-&gt;h_node</p>
<p>最终如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125909525-684596795.png" alt="img"></p>
<p>两者的.h_list都指向了同一个handle结构体，然后通过.h_list 来找到handle的成员.dev和handler,便能找到对方,便建立了连接</p>
<p><strong>9建立了连接后，又如何读取evdev.c(事件驱动) 的evdev_handler-&gt;.fops-&gt;.read函数？</strong></p>
<p>事件驱动的.read函数是evdev_read()函数,我们来分析下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ssize_t evdev_read(struct file *file, char __user *      buffer, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line"> ... ...</span><br><span class="line">&#x2F;*判断应用层要读取的数据是否正确*&#x2F;</span><br><span class="line">if (count &lt; evdev_event_size())</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">&#x2F;*在非阻塞操作情况下,若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),则return返回*&#x2F;</span><br><span class="line"> if (client-&gt;head &#x3D;&#x3D; client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">return -EAGAIN;</span><br><span class="line"> </span><br><span class="line">&#x2F;*若client-&gt;head &#x3D;&#x3D; client-&gt;tail|| evdev-&gt;exist时(没有数据),等待中断进入睡眠状态  *&#x2F;</span><br><span class="line">  retval &#x3D; wait_event_interruptible(evdev-&gt;wait,client-&gt;head !&#x3D; client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">  ... ...           &#x2F;&#x2F;上传数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>10若read函数进入了休眠状态，又是谁来唤醒？</strong></p>
<p>我们搜索这个evdev-&gt;wait这个等待队列变量,找到evdev_event函数里唤醒:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line"> wake_up_interruptible(&amp;evdev-&gt;wait);   &#x2F;&#x2F;有事件触发，便唤醒等待中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中evdev_event()是evdev.c(事件驱动) 的evdev_handler-&gt;.event成员,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125924681-419081807.png" alt="img"></p>
<p>当有事件发生了,比如对于按键驱动,当有按键按下时,就会进入.event函数中处理事件</p>
<p><strong>11分析下,是谁调用evdev_event()这个.event事件驱动函数</strong></p>
<p>应该就是之前分析的input_dev那层调用的</p>
<p>我们来看看内核 gpio_keys_isr()函数代码例子就知道了 (driver/input/keyboard/gpio_key.c)</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static irqreturn_t gpio_keys_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;*获取按键值,赋到state里*&#x2F;</span><br><span class="line"> ... ...</span><br><span class="line"></span><br><span class="line">&#x2F;*上报事件*&#x2F;</span><br><span class="line">input_event(input, type, button-&gt;code, !!state);  </span><br><span class="line">input_sync(input);                        &#x2F;&#x2F;同步信号通知,表示事件发送完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>显然就是通过input_event()来调用.event事件函数,我们来看看:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#123;</span><br><span class="line">struct input_handle *handle;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#x2F;* 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体*&#x2F;</span><br><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)    </span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>若之前驱动input_dev和处理input_handler已经通过input_handler 的.connect函数建立起了连接,那么就调用evdev_event()的.event事件函数，如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170918125942290-1009610213.png" alt="img"></p>
<p><strong>12本节总结分析:</strong></p>
<p><strong>1.**</strong>注册输入子系统<strong><strong>,</strong></strong>进入<strong>**put_init():</strong></p>
<p>1)创建主设备号为13的”input”字符设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br></pre></td></tr></table></figure>



<p><strong>2.open打开**</strong>驱动<strong><strong>,</strong></strong>进入<strong>**input_open_file():</strong></p>
<p>1)更新设备的file_oprations</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file-&gt;f_op&#x3D;fops_get(handler-&gt;fops);</span><br></pre></td></tr></table></figure>



<p>2)执行file_oprations-&gt;open函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err &#x3D; new_fops-&gt;open(inode, file);</span><br></pre></td></tr></table></figure>



<p><strong>3.**</strong>注册<strong><strong>input_handler,</strong></strong>进入<strong>**input_register_handler():</strong></p>
<p>1)添加到input_table[]处理数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;</span><br></pre></td></tr></table></figure>



<p>2）添加到input_handler_list链表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br></pre></td></tr></table></figure>



<p>3)判断input_dev的id,是否有支持这个驱动的设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(dev, &amp;input_dev_list, node)   &#x2F;&#x2F;遍历查找input_dev_list链表里所有input_dev</span><br><span class="line"></span><br><span class="line">input_attach_handler(dev, handler);             &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>

<p><strong>4.**</strong>注册<strong><strong>input_dev</strong></strong>，进入<strong>**input_register_device():</strong></p>
<p>1)放在input_dev_list链表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br></pre></td></tr></table></figure>



<p>2)判断input_handler的id，是否有支持这个设备的驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;遍历查找input_handler_list链表里所有input_handler</span><br><span class="line">input_attach_handler(dev, handler);                      &#x2F;&#x2F;判断两者id,若两者支持便进行连接。</span><br></pre></td></tr></table></figure>



<p><strong>5.**</strong>判断<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的<strong><strong>id,</strong></strong>进入<strong>**input_attach_handler():</strong></p>
<p>1）匹配两者id,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_match_device(handler-&gt;id_table, dev);        &#x2F;&#x2F;匹配input_handler和dev的id,不成功退出函数</span><br></pre></td></tr></table></figure>



<p>2)匹配成功调用input_handler -&gt;connect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handler-&gt;connect(handler, dev, id);              &#x2F;&#x2F;建立连接</span><br></pre></td></tr></table></figure>

<p><strong>6.**</strong>建立<strong><strong>input_handler</strong></strong>和<strong><strong>input_dev</strong></strong>的连接，进入<strong>**input_handler-&gt;connect():</strong></p>
<p>1)创建全局结构体,通过input_handle结构体连接双方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);    &#x2F;&#x2F;创建两者连接的input_handle全局结构体</span><br><span class="line">list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); &#x2F;&#x2F;连接input_dev-&gt;h_list</span><br><span class="line">list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    &#x2F;&#x2F; 连接input_handle-&gt;h_list</span><br></pre></td></tr></table></figure>

<p><strong>7.**</strong>有事件发生时<strong><strong>,</strong></strong>比如按键中断<strong><strong>,</strong></strong>在中断函数中需要进入<strong><strong>input_event()</strong></strong>上报事件<strong>**:</strong></p>
<p>1)找到驱动处理结构体，然后执行input_handler-&gt;event()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)     &#x2F;&#x2F; 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体</span><br><span class="line">if (handle-&gt;open)  &#x2F;&#x2F;如果input_handle之前open 过,那么这个就是我们的驱动处理结构体(有可能一个驱动设备在不同情况下有不同的驱动处理方式)</span><br><span class="line">    handle-&gt;handler-&gt;event(handle, type, code, value); &#x2F;&#x2F;调用evdev_event()的.event事件函数</span><br></pre></td></tr></table></figure>





<p><strong>然后在<a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener">下一节便开始</a></strong><a href="http://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener"><strong>实现**</strong>输入子系统的键盘按键驱动**</a></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】INPUT输入子系统</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91INPUT%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://home.cnblogs.com/u/deng-tao/" target="_blank" rel="noopener">涛少&amp;</a>【<a href="https://www.cnblogs.com/deng-tao/p/6094049.html】" target="_blank" rel="noopener">https://www.cnblogs.com/deng-tao/p/6094049.html】</a></p>
<h1 id="INPUT输入子系统"><a href="#INPUT输入子系统" class="headerlink" title="INPUT输入子系统"></a><a href="https://www.cnblogs.com/deng-tao/p/6094049.html" target="_blank" rel="noopener">INPUT输入子系统</a></h1><p>一、什么是input输入子系统？</p>
<p>1、Linux系统支持的输入设备繁多，例如键盘、鼠标、触摸屏、手柄或者是一些输入设备像体感输入等等，Linux系统是如何管理如此之多的不同类型、不同原理、不同的输入信息的</p>
<p>输入设备的呢？其实就是通过input输入子系统这套软件体系来完成的。从整体上来说，input输入子系统分为3层：上层（输入事件驱动层）、中层（输入核心层）、</p>
<p>下层（输入设备驱动层），如下图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161123160655378-1206222144.png" alt="img"></p>
<p>联系之前学过的驱动框架做对比，input输入子系统其实就是input输入设备的驱动框架，与之前的学过的驱动框架不同的是，input输入子系统分为3层：上、中、下，所以他的复杂度</p>
<p>要高于之前讲的lcd、misc、fb等的驱动框架。</p>
<p>2、图中Drivers对应的就是下层设备驱动层，对应各种各样不同的输入设备，Input Core对应的就是中层核心层，Handlers对应的就是上层输入事件驱动层，最右边的代表的是用户空间。</p>
<p>(1)从图中可以看出，系统中可以注册多个输入设备，每个输入设备的可以是不同的，例如一台电脑上可以带有鼠标，键盘….。</p>
<p>(2)上层中的各个handler（Keyboard/Mouse/Joystick/Event）是属于平行关系，他们都是属于上层。不同的handler下对应的输入设备在应用层中的接口命名方式不一样，例如</p>
<p>Mouse下的输入设备在应用层的接口是 /dev/input/mousen （n代表0、1、2…），Joystick下的输入设备在应用层的接口是 /dev/input/jsn（n代表0、1、2…），</p>
<p>Event下的输入设备在应用层的接口是 /dev/input/eventn（n代表0、1、2…），这个是在input输入子系统中实现的，下面会分析其中的原由。</p>
<p>(3)输入核心层其实是负责协调上层和下层，使得上层和下层之间能够完成数据传递。当下层发生输入事件的时候，整个系统就被激活了，事件就会通过核心层传递到上层对应的一个/多个</p>
<p>handler中，最终会传递到应用空间。</p>
<p>3、输入子系统解决了什么问题？</p>
<p>(1)在GUI界面中，用户的自由度太大了，可以做的事情太多了，可以响应不同的输入类设备，而且还能够对不同的输入类设备的输入做出不同的动作。例如window中的一个软</p>
<p>件既可以响应鼠标输入事件，也可以相应键盘输入事件，而且这些事件都是预先不知道的。</p>
<p>(2)input子系统解决了不同的输入类设备的输入事件与应用层之间的数据传输，使得应用层能够获取到各种不同的输入设备的输入事件，input输入子系统能够囊括所有的不同种</p>
<p>类的输入设备，在应用层都能够感知到所有发生的输入事件。</p>
<p>4、input输入子系统如何工作？</p>
<p>例如以一次鼠标按下事件为例子来说明我们的input输入子系统的工作过程：</p>
<p>当我们按下鼠标左键的时候就会触发中断（中断是早就注册好的），就会去执行中断所绑定的处理函数，在函数中就会去读取硬件寄存器来判断按下的是哪个按键和状态 —-&gt;</p>
<p>将按键信息上报给input core层  —&gt; input core层处理好了之后就会上报给input event层，在这里会将我们的输入事件封装成一个input_event结构体放入一个缓冲区中 —&gt;  </p>
<p>应用层read就会将缓冲区中的数据读取出去。</p>
<p>5、相关的数据结构</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_dev &#123;</span><br><span class="line"> 2     const char *name;             &#x2F;&#x2F;  input设备的名字</span><br><span class="line"> 3     const char *phys;              &#x2F;&#x2F;  </span><br><span class="line"> 4     const char *uniq;              &#x2F;&#x2F;</span><br><span class="line"> 5     struct input_id id;             &#x2F;&#x2F;  </span><br><span class="line"> 6 </span><br><span class="line"> 7 &#x2F;&#x2F;  这些是用来表示该input设备能够上报的事件类型有哪些   是用位的方式来表示的</span><br><span class="line"> 8     unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line"> 9     unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">10     unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line">11     unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line">12     unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">13     unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">14     unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">15     unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">16     unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">17 </span><br><span class="line">18     unsigned int keycodemax;</span><br><span class="line">19     unsigned int keycodesize;</span><br><span class="line">20     void *keycode;</span><br><span class="line">21     int (*setkeycode)(struct input_dev *dev,</span><br><span class="line">22               unsigned int scancode, unsigned int keycode);</span><br><span class="line">23     int (*getkeycode)(struct input_dev *dev,</span><br><span class="line">24               unsigned int scancode, unsigned int *keycode);</span><br><span class="line">25 </span><br><span class="line">26     struct ff_device *ff;</span><br><span class="line">27 </span><br><span class="line">28     unsigned int repeat_key;</span><br><span class="line">29     struct timer_list timer;</span><br><span class="line">30 </span><br><span class="line">31     int sync;</span><br><span class="line">32 </span><br><span class="line">33     int abs[ABS_CNT];</span><br><span class="line">34     int rep[REP_MAX + 1];</span><br><span class="line">35 </span><br><span class="line">36     unsigned long key[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line">37     unsigned long led[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">38     unsigned long snd[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">39     unsigned long sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line">40 </span><br><span class="line">41     int absmax[ABS_CNT];</span><br><span class="line">42     int absmin[ABS_CNT];</span><br><span class="line">43     int absfuzz[ABS_CNT];</span><br><span class="line">44     int absflat[ABS_CNT];</span><br><span class="line">45     int absres[ABS_CNT];</span><br><span class="line">46 </span><br><span class="line">47     int (*open)(struct input_dev *dev);              &#x2F;&#x2F;    设备的open函数</span><br><span class="line">48     void (*close)(struct input_dev *dev);          </span><br><span class="line">49     int (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">50     int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);     &#x2F;&#x2F;  上报事件</span><br><span class="line">51 </span><br><span class="line">52     struct input_handle *grab;</span><br><span class="line">53 </span><br><span class="line">54     spinlock_t event_lock;</span><br><span class="line">55     struct mutex mutex;</span><br><span class="line">56 </span><br><span class="line">57     unsigned int users;</span><br><span class="line">58     bool going_away;</span><br><span class="line">59 </span><br><span class="line">60     struct device dev;                 &#x2F;&#x2F;  内置的device结构体变量</span><br><span class="line">61 </span><br><span class="line">62     struct list_head    h_list;    &#x2F;&#x2F;  用来挂接input_dev 设备连接的所有handle 的一个链表头</span><br><span class="line">63     struct list_head    node;    &#x2F;&#x2F;  作为链表节点挂接到  input_dev_list 链表上  (input_dev_list链表是input核心层维护的一个用来挂接所有input设备的一个链表头)</span><br><span class="line">64 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_handler &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     void *private;            &#x2F;&#x2F;  私有数据</span><br><span class="line"> 4 </span><br><span class="line"> 5     void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);   &#x2F;&#x2F;  handler用于向上层上报输入事件的函数</span><br><span class="line"> 6     bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line"> 7     bool (*match)(struct input_handler *handler, struct input_dev *dev);            &#x2F;&#x2F;   match 函数用来匹配handler 与 input_dev 设备</span><br><span class="line"> 8     int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);   &#x2F;&#x2F;  当handler 与 input_dev 匹配成功之后用来连接</span><br><span class="line"> 9     void (*disconnect)(struct input_handle *handle);          &#x2F;&#x2F;  断开handler 与 input_dev 之间的连接</span><br><span class="line">10     void (*start)(struct input_handle *handle);                    </span><br><span class="line">11 </span><br><span class="line">12     const struct file_operations *fops;             &#x2F;&#x2F;  一个file_operations 指针</span><br><span class="line">13     int minor;                                      &#x2F;&#x2F;  该handler 的编号 (在input_table 数组中用来计算数组下标) input_table数组就是input子系统用来管理注册的handler的一个数据结构</span><br><span class="line">14     const char *name;                               &#x2F;&#x2F;  handler的名字</span><br><span class="line">15 </span><br><span class="line">16     const struct input_device_id *id_table;      &#x2F;&#x2F;  指向一个 input_device_id  类型的数组，用来进行与input设备匹配时用到的信息</span><br><span class="line">17  </span><br><span class="line">18     struct list_head    h_list;       &#x2F;&#x2F;  用来挂接handler 上连接的所有handle 的一个链表头</span><br><span class="line">19     struct list_head    node;        &#x2F;&#x2F;  作为一个链表节点挂接到 input_handler_list 链表上(input_handler_list 链表是一个由上层handler参维护的一个用来挂接所有注册的handler的链表头)</span><br><span class="line">20 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_handle &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     void *private;               &#x2F;&#x2F;   handle  的私有数据</span><br><span class="line"> 4 </span><br><span class="line"> 5     int open;                     &#x2F;&#x2F;  这个也是用来做打开计数的</span><br><span class="line"> 6     const char *name;       &#x2F;&#x2F;   该handle 的名字</span><br><span class="line"> 7 </span><br><span class="line"> 8     struct input_dev *dev;                &#x2F;&#x2F;  用来指向该handle 绑定的input_dev 结构体</span><br><span class="line"> 9     struct input_handler *handler;    &#x2F;&#x2F;  用来指向该handle 绑定的 handler 结构体</span><br><span class="line">10 </span><br><span class="line">11     struct list_head    d_node;      &#x2F;&#x2F;  作为一个链表节点挂接到与他绑定的input_dev -&gt;hlist 链表上</span><br><span class="line">12     struct list_head    h_node;      &#x2F;&#x2F;  作为一个链表节点挂接到与他绑定的handler-&gt;hlist 链表上</span><br><span class="line">13 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_device_id &#123;</span><br><span class="line"> 2 </span><br><span class="line"> 3     kernel_ulong_t flags;    &#x2F;&#x2F;  这个flag 表示我们的这个 input_device_id 是用来匹配下面的4个情况的哪一项</span><br><span class="line"> 4                                     &#x2F;&#x2F;  flag &#x3D;&#x3D; 1表示匹配总线  2表示匹配供应商   4表示匹配产品  8表示匹配版本</span><br><span class="line"> 5     __u16 bustype;</span><br><span class="line"> 6     __u16 vendor;</span><br><span class="line"> 7     __u16 product;</span><br><span class="line"> 8     __u16 version;</span><br><span class="line"> 9 </span><br><span class="line">10     kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">11     kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">12     kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">13     kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">14     kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">15     kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">16     kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">17     kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">18     kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX &#x2F; BITS_PER_LONG + 1];</span><br><span class="line">19 </span><br><span class="line">20     kernel_ulong_t driver_info;</span><br><span class="line">21 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>二、输入核心层源码分析（内核版本：2.6.35.7）</p>
<p>input输入子系统中的所有源码都放在 drivers\input 这个目录中，input.c文件就是核心层的源代码文件。在input目录中还可以看到一些文件夹，例如gameport、joystick</p>
<p>keyboard、misc、mouse….，这些文件夹里面存放的就是属于这类的input输入设备的设备驱动源代码，可以理解为input输入子系统的下层。</p>
<p>input目录下的evdev.c、joydev.c、mousedev.c..分别对应上层的各个不同的handler的源代码。</p>
<p>1、输入核心层模块注册函数input_init</p>
<p>在Linux中实现为一个模块的方法，所以可以在内核配置的进行动态的加载和卸载，这样做的原由是，存在有些系统中不需要任何</p>
<p>的输入类设备，这样就可以将input输入子系统这个模块去掉（上层也是实现为模块的），使得内核尽量变得更小。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int __init input_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int err;</span><br><span class="line"> 4 </span><br><span class="line"> 5     input_init_abs_bypass();</span><br><span class="line"> 6 </span><br><span class="line"> 7     err &#x3D; class_register(&amp;input_class);                &#x2F;&#x2F;  创建设备类    &#x2F;sys&#x2F;class&#x2F;input</span><br><span class="line"> 8     if (err) &#123;</span><br><span class="line"> 9         printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);</span><br><span class="line">10         return err;</span><br><span class="line">11     &#125;</span><br><span class="line">12 </span><br><span class="line">13     err &#x3D; input_proc_init();           &#x2F;&#x2F;    proc文件系统相关的初始化</span><br><span class="line">14     if (err)</span><br><span class="line">15         goto fail1;</span><br><span class="line">16 </span><br><span class="line">17     err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);       &#x2F;&#x2F;   注册字符设备驱动   主设备号13   input_fops 中只实现了open函数，所以他的原理其实和misc其实是一样的</span><br><span class="line">18     if (err) &#123;</span><br><span class="line">19         printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);</span><br><span class="line">20         goto fail2;</span><br><span class="line">21     &#125;</span><br><span class="line">22 </span><br><span class="line">23     return 0;</span><br><span class="line">24 </span><br><span class="line">25  fail2:    input_proc_exit();</span><br><span class="line">26  fail1:    class_unregister(&amp;input_class);</span><br><span class="line">27     return err;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(1)input_proc_init函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int __init input_proc_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct proc_dir_entry *entry;</span><br><span class="line"> 4 </span><br><span class="line"> 5     proc_bus_input_dir &#x3D; proc_mkdir(&quot;bus&#x2F;input&quot;, NULL);    &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;目录下创建input目录 *&#x2F;</span><br><span class="line"> 6     if (!proc_bus_input_dir)</span><br><span class="line"> 7         return -ENOMEM;</span><br><span class="line"> 8 </span><br><span class="line"> 9     entry &#x3D; proc_create(&quot;devices&quot;, 0, proc_bus_input_dir,  &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;input&#x2F;目录下创建devices文件 *&#x2F;</span><br><span class="line">10                 &amp;input_devices_fileops);</span><br><span class="line">11     if (!entry)</span><br><span class="line">12         goto fail1;</span><br><span class="line">13 </span><br><span class="line">14     entry &#x3D; proc_create(&quot;handlers&quot;, 0, proc_bus_input_dir, &#x2F;* 在&#x2F;proc&#x2F;bus&#x2F;input&#x2F;目录下创建handlers文件 *&#x2F;</span><br><span class="line">15                 &amp;input_handlers_fileops);</span><br><span class="line">16     if (!entry)</span><br><span class="line">17         goto fail2;</span><br><span class="line">18 </span><br><span class="line">19     return 0;</span><br><span class="line">20 </span><br><span class="line">21  fail2:    remove_proc_entry(&quot;devices&quot;, proc_bus_input_dir);</span><br><span class="line">22  fail1: remove_proc_entry(&quot;bus&#x2F;input&quot;, NULL);</span><br><span class="line">23     return -ENOMEM;</span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当我们启动系统之后进入到proc文件系统中，确实可以看到在/proc/bus/input/目录下有两个文件devices和handlers，这两个文件就是在这里被创建的。我们cat devices 和 cat handlers</p>
<p>时对应的操作方法(show)就被封装在input_devices_fileops和input_handlers_fileops结构体中。</p>
<p>(2)input_fops变量</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124094104690-937210902.png" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_handler *handler;                                                &#x2F;&#x2F;  定义一个input_handler指针</span><br><span class="line"> 4     const struct file_operations *old_fops, *new_fops &#x3D; NULL;   &#x2F;&#x2F;  定义两个file_operations指针</span><br><span class="line"> 5     int err;</span><br><span class="line"> 6 </span><br><span class="line"> 7     err &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"> 8     if (err)</span><br><span class="line"> 9         return err;</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* No load-on-demand here? *&#x2F;</span><br><span class="line">12     handler &#x3D; input_table[iminor(inode) &gt;&gt; 5];         &#x2F;&#x2F;  通过次设备号在 input_table  数组中找到对应的 handler </span><br><span class="line">13     if (handler)</span><br><span class="line">14         new_fops &#x3D; fops_get(handler-&gt;fops);           &#x2F;&#x2F;  将handler 中的fops 指针赋值给 new_fops</span><br><span class="line">15 </span><br><span class="line">16     mutex_unlock(&amp;input_mutex);</span><br><span class="line">17 </span><br><span class="line">18     &#x2F;*</span><br><span class="line">19      * That&#39;s _really_ odd. Usually NULL -&gt;open means &quot;nothing special&quot;,</span><br><span class="line">20      * not &quot;no device&quot;. Oh, well...</span><br><span class="line">21      *&#x2F;</span><br><span class="line">22     if (!new_fops || !new_fops-&gt;open) &#123;</span><br><span class="line">23         fops_put(new_fops);</span><br><span class="line">24         err &#x3D; -ENODEV;</span><br><span class="line">25         goto out;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     old_fops &#x3D; file-&gt;f_op;           &#x2F;&#x2F;   将 file-&gt;fops 先保存到 old_fops 中，以便出错时能够恢复</span><br><span class="line">29     file-&gt;f_op &#x3D; new_fops;          &#x2F;&#x2F;   用new_fops 替换 file 中 fops </span><br><span class="line">30 </span><br><span class="line">31     err &#x3D; new_fops-&gt;open(inode, file);       &#x2F;&#x2F;  执行 file-&gt;open  函数</span><br><span class="line">32     if (err) &#123;</span><br><span class="line">33         fops_put(file-&gt;f_op);</span><br><span class="line">34         file-&gt;f_op &#x3D; fops_get(old_fops);</span><br><span class="line">35     &#125;</span><br><span class="line">36     fops_put(old_fops);</span><br><span class="line">37 out:</span><br><span class="line">38     return err;</span><br><span class="line">39 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>2、核心层提供给设备驱动层的接口函数</p>
<p>input设备驱动框架留给设备驱动层的接口函数主要有3个：</p>
<p>   input_allocate_device。分配一块input_dev结构体类型大小的内存</p>
<p>   input_set_capability。设置输入设备可以上报哪些输入事件</p>
<p>   input_register_device。向input核心层注册设备</p>
<p>(1)input_allocate_device函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct input_dev *input_allocate_device(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_dev *dev;                 &#x2F;&#x2F;   定义一个 input_dev  指针</span><br><span class="line"> 4 </span><br><span class="line"> 5     dev &#x3D; kzalloc(sizeof(struct input_dev), GFP_KERNEL);   &#x2F;&#x2F;  申请分配内存</span><br><span class="line"> 6     if (dev) &#123;</span><br><span class="line"> 7         dev-&gt;dev.type &#x3D; &amp;input_dev_type;          &#x2F;&#x2F;  确定input设备的 设备类型     input_dev_type</span><br><span class="line"> 8         dev-&gt;dev.class &#x3D; &amp;input_class;                &#x2F;&#x2F;  确定input设备所属的设备类   class</span><br><span class="line"> 9         device_initialize(&amp;dev-&gt;dev);                   &#x2F;&#x2F;  input设备的初始化</span><br><span class="line">10         mutex_init(&amp;dev-&gt;mutex);                        &#x2F;&#x2F;  互斥锁初始化</span><br><span class="line">11         spin_lock_init(&amp;dev-&gt;event_lock);            &#x2F;&#x2F;  自旋锁初始化</span><br><span class="line">12         INIT_LIST_HEAD(&amp;dev-&gt;h_list);                 &#x2F;&#x2F;  input_dev -&gt; h_list 链表初始化</span><br><span class="line">13         INIT_LIST_HEAD(&amp;dev-&gt;node);                 &#x2F;&#x2F;  input_dev -&gt; node 链表初始化</span><br><span class="line">14 </span><br><span class="line">15         __module_get(THIS_MODULE);</span><br><span class="line">16     &#125;</span><br><span class="line">17 </span><br><span class="line">18     return dev;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(2)input_set_capability函数：</p>
<p>函数原型：input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)</p>
<p>参数：dev就是设备的input_dev结构体变量</p>
<p>​    type表示设备可以上报的事件类型</p>
<p>​    code表示上报这类事件中的那个事件</p>
<p>注意：input_set_capability函数一次只能设置一个具体事件，如果设备可以上报多个事件，则需要重复调用这个函数来进行设置，例如：</p>
<p>input_set_capability(dev, EV_KEY, KEY_Q);     // 至于函数内部是怎么设置的，将会在后面进行分析。</p>
<p>input_set_capability(dev, EV_KEY, KEY_W);</p>
<p>input_set_capability(dev, EV_KEY, KEY_E);</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161124145255815-1134348827.png" alt="img"></p>
<p>具体的这些类下面有哪些具体的输入事件，请看 drivers\input\input.h 这个文件。</p>
<p>(3)input_register_device函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)      &#x2F;&#x2F;  注册input输入设备</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     static atomic_t input_no &#x3D; ATOMIC_INIT(0);</span><br><span class="line"> 4     struct input_handler *handler;                          &#x2F;&#x2F;  定义一个  input_handler 结构体指针</span><br><span class="line"> 5     const char *path;</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     &#x2F;* Every input device generates EV_SYN&#x2F;SYN_REPORT events. *&#x2F;</span><br><span class="line"> 9     __set_bit(EV_SYN, dev-&gt;evbit);                  &#x2F;&#x2F;   每一个input输入设备都会发生这个事件</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* KEY_RESERVED is not supposed to be transmitted to userspace. *&#x2F;</span><br><span class="line">12     __clear_bit(KEY_RESERVED, dev-&gt;keybit);  &#x2F;&#x2F;  清除KEY_RESERVED 事件对应的bit位，也就是不传输这种类型的事件</span><br><span class="line">13 </span><br><span class="line">14     &#x2F;* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. *&#x2F;</span><br><span class="line">15     input_cleanse_bitmasks(dev);           &#x2F;&#x2F;   确保input_dev中的用来记录事件的变量中没有提到的位掩码是干净的。</span><br><span class="line">16 </span><br><span class="line">17     &#x2F;*</span><br><span class="line">18      * If delay and period are pre-set by the driver, then autorepeating</span><br><span class="line">19      * is handled by the driver itself and we don&#39;t do it in input.c.</span><br><span class="line">20      *&#x2F;</span><br><span class="line">21     init_timer(&amp;dev-&gt;timer);</span><br><span class="line">22     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">23         dev-&gt;timer.data &#x3D; (long) dev;</span><br><span class="line">24         dev-&gt;timer.function &#x3D; input_repeat_key;</span><br><span class="line">25         dev-&gt;rep[REP_DELAY] &#x3D; 250;</span><br><span class="line">26         dev-&gt;rep[REP_PERIOD] &#x3D; 33;</span><br><span class="line">27     &#125;</span><br><span class="line">28 </span><br><span class="line">29     if (!dev-&gt;getkeycode)</span><br><span class="line">30         dev-&gt;getkeycode &#x3D; input_default_getkeycode;</span><br><span class="line">31 </span><br><span class="line">32     if (!dev-&gt;setkeycode)</span><br><span class="line">33         dev-&gt;setkeycode &#x3D; input_default_setkeycode;</span><br><span class="line">34 </span><br><span class="line">35     dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,                                  &#x2F;&#x2F;   设置input设备对象的名字    input+数字</span><br><span class="line">36              (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line">37 </span><br><span class="line">38     error &#x3D; device_add(&amp;dev-&gt;dev);         &#x2F;&#x2F;   添加设备       例如:          &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0     </span><br><span class="line">39     if (error)</span><br><span class="line">40         return error;</span><br><span class="line">41 </span><br><span class="line">42     path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);  &#x2F;&#x2F;  获取input设备对象所在的路径      &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input_xxx   </span><br><span class="line">43     printk(KERN_INFO &quot;input: %s as %s\n&quot;,</span><br><span class="line">44         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);</span><br><span class="line">45     kfree(path);</span><br><span class="line">46 </span><br><span class="line">47     error &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">48     if (error) &#123;</span><br><span class="line">49         device_del(&amp;dev-&gt;dev);</span><br><span class="line">50         return error;</span><br><span class="line">51     &#125;</span><br><span class="line">52 </span><br><span class="line">53     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);             &#x2F;&#x2F;   链表挂接:    将 input_dev-&gt;node 作为节点挂接到 input_dev_list  链表上</span><br><span class="line">54 </span><br><span class="line">55     list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;  遍历input_handler_list 链表上的所有handler</span><br><span class="line">56         input_attach_handler(dev, handler);                        &#x2F;&#x2F;  将handler与input设备进行匹配</span><br><span class="line">57 </span><br><span class="line">58     input_wakeup_procfs_readers();                &#x2F;&#x2F;  更新proc 文件系统</span><br><span class="line">59 </span><br><span class="line">60     mutex_unlock(&amp;input_mutex);</span><br><span class="line">61 </span><br><span class="line">62     return 0;</span><br><span class="line">63 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>(4)input_attach_handler函数：</p>
<p>input_attach_handler就是input_register_device函数中用来对下层的设备驱动和上层的handler进行匹配的一个函数，只有匹配成功之后就会调用上层handler中的connect函数</p>
<p>进行连接绑定。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     const struct input_device_id *id;                &#x2F;&#x2F;   定义一个input_device_id 的指针</span><br><span class="line"> 4     int error;</span><br><span class="line"> 5 </span><br><span class="line"> 6     id &#x3D; input_match_device(handler, dev);   &#x2F;&#x2F;  通过这个函数进行handler与input设备的匹配工作</span><br><span class="line"> 7     if (!id)</span><br><span class="line"> 8         return -ENODEV;</span><br><span class="line"> 9 </span><br><span class="line">10     error &#x3D; handler-&gt;connect(handler, dev, id);  &#x2F;&#x2F;  匹配成功则调用 handler 中的 connect 函数进行连接</span><br><span class="line">11     if (error &amp;&amp; error !&#x3D; -ENODEV)</span><br><span class="line">12         printk(KERN_ERR</span><br><span class="line">13             &quot;input: failed to attach handler %s to device %s, &quot;</span><br><span class="line">14             &quot;error: %d\n&quot;,</span><br><span class="line">15             handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line">16 </span><br><span class="line">17     return error;</span><br><span class="line">18 &#125;</span><br><span class="line">19 </span><br><span class="line">20 </span><br><span class="line">21 </span><br><span class="line">22 static const struct input_device_id *input_match_device(struct input_handler *handler,</span><br><span class="line">23                             struct input_dev *dev)</span><br><span class="line">24 &#123;</span><br><span class="line">25     const struct input_device_id *id;            &#x2F;&#x2F;   定义一个 input_device_id  指针</span><br><span class="line">26     int i;</span><br><span class="line">27 </span><br><span class="line">28     for (id &#x3D; handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;  &#x2F;&#x2F;  依次遍历handler-&gt;id_table 所指向的input_device_id 数组中的各个元素</span><br><span class="line">29                                                                                                                     &#x2F;&#x2F;  依次进行下面的匹配过程</span><br><span class="line">30         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)         &#x2F;&#x2F;    匹配总线</span><br><span class="line">31             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)</span><br><span class="line">32                 continue;</span><br><span class="line">33 </span><br><span class="line">34         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)  &#x2F;&#x2F;  匹配供应商</span><br><span class="line">35             if (id-&gt;vendor !&#x3D; dev-&gt;id.vendor)</span><br><span class="line">36                 continue;</span><br><span class="line">37 </span><br><span class="line">38         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)  &#x2F;&#x2F;  匹配产品</span><br><span class="line">39             if (id-&gt;product !&#x3D; dev-&gt;id.product)</span><br><span class="line">40                 continue;</span><br><span class="line">41 </span><br><span class="line">42         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)  &#x2F;&#x2F;  匹配版本</span><br><span class="line">43             if (id-&gt;version !&#x3D; dev-&gt;id.version)</span><br><span class="line">44                 continue;</span><br><span class="line">45 </span><br><span class="line">46     &#x2F;&#x2F;    下面的这些是匹配我们上传的事件是否属实</span><br><span class="line">47         MATCH_BIT(evbit,  EV_MAX);</span><br><span class="line">48         MATCH_BIT(keybit, KEY_MAX);</span><br><span class="line">49         MATCH_BIT(relbit, REL_MAX);</span><br><span class="line">50         MATCH_BIT(absbit, ABS_MAX);</span><br><span class="line">51         MATCH_BIT(mscbit, MSC_MAX);</span><br><span class="line">52         MATCH_BIT(ledbit, LED_MAX);</span><br><span class="line">53         MATCH_BIT(sndbit, SND_MAX);</span><br><span class="line">54         MATCH_BIT(ffbit,  FF_MAX);</span><br><span class="line">55         MATCH_BIT(swbit,  SW_MAX);</span><br><span class="line">56 </span><br><span class="line">57         if (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">58             return id;        &#x2F;&#x2F;    如果数组中的某个匹配成功了就返回他的地址</span><br><span class="line">59     &#125;</span><br><span class="line">60 </span><br><span class="line">61     return NULL;</span><br><span class="line">62 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_attach_handler函数做的事情有两件：调用input_match_device函数进行设备与handler的匹配、匹配成功调用handler的连接函数进行连接（至于如何连接将会在后面说到）。</p>
<p>3、核心层提供给事件驱动层的接口函数</p>
<p>在input输入核心层向事件驱动层提供的接口主要有两个：</p>
<p>  input_register_handler。事件驱动层向核心层注册handler</p>
<p>  input_register_handle。事件驱动层向核心层注册handle。  注意上面的是handler，这里是handle，不一样，后面会说到。</p>
<p>(1)input_register_handler函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_handler(struct input_handler *handler)    &#x2F;&#x2F;  向核心层注册handler</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct input_dev *dev;          &#x2F;&#x2F;  定义一个input_dev 指针</span><br><span class="line"> 4     int retval; </span><br><span class="line"> 5 </span><br><span class="line"> 6     retval &#x3D; mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"> 7     if (retval)</span><br><span class="line"> 8         return retval;</span><br><span class="line"> 9 </span><br><span class="line">10     INIT_LIST_HEAD(&amp;handler-&gt;h_list);      &#x2F;&#x2F;  初始化 handler-&gt;h_list 链表</span><br><span class="line">11 </span><br><span class="line">12     if (handler-&gt;fops !&#x3D; NULL) &#123;          &#x2F;&#x2F;  如果 handler -&gt; fops 存在</span><br><span class="line">13         if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;  &#x2F;&#x2F;  如果input_table 数组中没有该handler  的位置了 则返回</span><br><span class="line">14             retval &#x3D; -EBUSY;</span><br><span class="line">15             goto out;</span><br><span class="line">16         &#125;</span><br><span class="line">17         input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;  &#x2F;&#x2F;  将 handler 指针存放在input_table 数组中去</span><br><span class="line">18     &#125;</span><br><span class="line">19 </span><br><span class="line">20     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);   &#x2F;&#x2F;  将 handler 通过 handler -&gt; node 节点 挂接到 input_handler_list 链表上</span><br><span class="line">21 </span><br><span class="line">22     list_for_each_entry(dev, &amp;input_dev_list, node)     &#x2F;&#x2F;  遍历 input_dev_list 链表下挂接的所有的 input_dev 设备</span><br><span class="line">23         input_attach_handler(dev, handler);          &#x2F;&#x2F;  然后进行匹配</span><br><span class="line">24 </span><br><span class="line">25     input_wakeup_procfs_readers();             &#x2F;&#x2F;  更新proc 文件系统</span><br><span class="line">26 </span><br><span class="line">27  out:</span><br><span class="line">28     mutex_unlock(&amp;input_mutex);</span><br><span class="line">29     return retval;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过分析了上面的input_register_device和这里的input_register_handler函数可以知道：注册设备的时候，不一定是先注册了handler才能够注册设备。当注册设备时，会先将</p>
<p>设备挂接到设备管理链表(input_dev_list)上，然后再去遍历input_handler_list链表匹配hander。同样对于handler注册的时候，也会先将handler挂接到handler管理链表</p>
<p>(input_handler_list)上，然后再去遍历input_dev_list链表匹配设备。所以从这里可以看出来，这种机制好像之前说过的platform总线下设备和驱动的匹配过程。</p>
<p>而且一个input_dev可以与多个handler匹配成功，从而可以在sysfs中创建多个设备文件，也可以在/dev/目录下创建多个设备节点，并且他们的次设备号是不一样的，这个很好理解。</p>
<p>所以就是导致一个设备对应多个次设备号，那这样有没有错呢？当然是没有错的。例如在我们的Ubuntu中，/dev/input/event3 和 </p>
<p>/dev/input/mouse1 都是对应鼠标这个设备。</p>
<p>(2)input_register_handle函数</p>
<p>这个函数的作用就是注册一个handle，也就是实现上图中的将各个handle连接起来构成一个环形的结构，再调用这个函数之前已经将handle中的dev和handler已经是填充好了的，</p>
<p>具体的这个函数代码就不去分析了。</p>
<p>其实handler、input_dev、handle3这之间的关系，在之前就已经接触过了，讲Linux设备驱动模型底层架构的时候遇到过，下面用一副关系图来描述他们之间的一个关系：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125165556721-1160519994.png" alt="img"></p>
<p>从本质上讲，input_dev与handler是多对多的关系，从上图可以看出来，一个input_dev可以对应多个handler，一个handler也可以对应多个input_dev。因为在匹配的时候，</p>
<p>一个input_dev会与所有的handler都进行匹配的，并不是匹配成功一次就退出。</p>
<p>从图中可以看出来，一个handle就是用来记录系统中一对匹配成功的handler和device，我们可以从这个handle出发得到handler的信息，还可以得到device的信息。所以正因为有这样的</p>
<p>功能，所以可以由handler经过handle最终获取到device的信息，同理也可以从device从发经过handle最终获取到handler的信息。这种运用方法将会在后面的分析中看到。</p>
<p>4、总结：</p>
<p>核心层（其实就是驱动框架）提供的服务有哪些：</p>
<p>(1)创建设备类、注册字符设备</p>
<p>(2)向设备驱动层提供注册接口</p>
<p>(3)提供上层handler和下层device之间的匹配函数</p>
<p>(4)向上层提供注册handler的接口</p>
<p>二、输入事件驱动层源码分析</p>
<p>input输入子系统的输入事件驱动层（上层）其实是由各个handler构成的，各个handler之间是属于平行关系，不存在相互调用的现象。目前用的最多是event，今天就以这个handler</p>
<p>为例分析他的源代码，以便对handler的实现有一定的了解，前面说到过，input输入子系统的源代码都在 drivers\input\这个目录下，其中 drivers\input\evdev.c就是event</p>
<p>的源代码文件。</p>
<p>从evdev.c文件的末尾可以看到使用了module_init、module_exit这些宏，说明内核中将这部分实现为模块的方式，这其实很好理解，因为input核心层都是实现为模块的方式，而</p>
<p>上层是要依赖于核心层才能够注册、才能够工作的，而核心层都已经实现为模块了，那么上层不更得需要这样做吗。好了，废话不多说开始分析代码。</p>
<p>1、模块注册函数：</p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125175018409-1907320882.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/944893/201611/944893-20161125204019940-91391068.png" alt="img"></p>
<p>evdev_handler变量就是本次分析的handler对应的结构体变量，变量中填充最重要的有3个：</p>
<p>evdev_event函数：</p>
<p>evdev_connect函数：</p>
<p>evdev_fops变量：</p>
<p>2、相关的数据结构</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct evdev &#123;     </span><br><span class="line"> 2     int exist;</span><br><span class="line"> 3     int open;                                &#x2F;&#x2F;  这个是用来作为设备被打开的计数</span><br><span class="line"> 4     int minor;                               &#x2F;&#x2F;   handler 与 input设备匹配成功之后创建的设备对应的device的次设备号相对于基准次设备号的偏移量</span><br><span class="line"> 5     struct input_handle handle;   &#x2F;&#x2F;   内置的一个  handle ，里面记录了匹配成功的input_dev 和 handler            </span><br><span class="line"> 6     wait_queue_head_t wait;</span><br><span class="line"> 7     struct evdev_client *grab;</span><br><span class="line"> 8     struct list_head client_list;       &#x2F;&#x2F;   用来挂接与 evdev 匹配成功的evdev_client 的一个链表头 </span><br><span class="line"> 9     spinlock_t client_lock; &#x2F;* protects client_list *&#x2F;</span><br><span class="line">10     struct mutex mutex;             &#x2F;&#x2F;  互斥锁</span><br><span class="line">11     struct device dev;                 &#x2F;&#x2F;  这个是handler 与 input设备匹配成功之后创建的设备对应的device</span><br><span class="line">12 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct evdev_client &#123;</span><br><span class="line"> 2     struct input_event buffer[EVDEV_BUFFER_SIZE];    &#x2F;&#x2F;  用来存放input_dev 事件的缓冲区</span><br><span class="line"> 3     int head;</span><br><span class="line"> 4     int tail;</span><br><span class="line"> 5     spinlock_t buffer_lock; &#x2F;* protects access to buffer, head and tail *&#x2F;</span><br><span class="line"> 6     struct fasync_struct *fasync;</span><br><span class="line"> 7     struct evdev *evdev;              &#x2F;&#x2F;   evdev 指针</span><br><span class="line"> 8     struct list_head node;            &#x2F;&#x2F;  作为一个链表节点挂接到相应的 evdev-&gt;client_list 链表上</span><br><span class="line"> 9     struct wake_lock wake_lock;</span><br><span class="line">10     char name[28];            &#x2F;&#x2F;  名字</span><br><span class="line">11 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 struct input_event &#123;</span><br><span class="line">2     struct timeval time;        &#x2F;&#x2F;  事件发生的事件</span><br><span class="line">3     __u16 type;                    &#x2F;&#x2F;  事件的类型</span><br><span class="line">4     __u16 code;                   &#x2F;&#x2F;   事件的码值</span><br><span class="line">5     __s32 value;                   &#x2F;&#x2F;  事件的状态</span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>



<p>3、函数详解</p>
<p>(1)evdev_connect函数分析：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line"> 2              const struct input_device_id *id)</span><br><span class="line"> 3 &#123;</span><br><span class="line"> 4     struct evdev *evdev;                 &#x2F;&#x2F;  定义一个 evdev 指针</span><br><span class="line"> 5     int minor;</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)  &#x2F;&#x2F;  从evdev_table 数组中找到一个没有被使用的最小的数组项  最大值32</span><br><span class="line"> 9         if (!evdev_table[minor])</span><br><span class="line">10             break;</span><br><span class="line">11 </span><br><span class="line">12     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;</span><br><span class="line">13         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);</span><br><span class="line">14         return -ENFILE;</span><br><span class="line">15     &#125;</span><br><span class="line">16 </span><br><span class="line">17     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);   &#x2F;&#x2F;  给evdev 申请分配内存</span><br><span class="line">18     if (!evdev)</span><br><span class="line">19         return -ENOMEM;</span><br><span class="line">20 </span><br><span class="line">21     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);            &#x2F;&#x2F;  初始化 evdev-&gt;client_list 链表</span><br><span class="line">22     spin_lock_init(&amp;evdev-&gt;client_lock);              &#x2F;&#x2F;  初始化自旋锁 evdev-&gt;client_lock</span><br><span class="line">23     mutex_init(&amp;evdev-&gt;mutex);                          &#x2F;&#x2F;  初始化互斥锁 evdev-&gt;mutex</span><br><span class="line">24     init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">25 </span><br><span class="line">26     dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);  &#x2F;&#x2F; 设置input设备的名字</span><br><span class="line">27     evdev-&gt;exist &#x3D; 1;</span><br><span class="line">28     evdev-&gt;minor &#x3D; minor;                                     &#x2F;&#x2F;  input设备的次设备号的偏移量 </span><br><span class="line">29 </span><br><span class="line">30     evdev-&gt;handle.dev &#x3D; input_get_device(dev);              &#x2F;&#x2F;  将我们传进来的 input_dev 指针存放在 evdev-&gt;handle.dev 中</span><br><span class="line">31     evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);     &#x2F;&#x2F;  设置 evdev -&gt; dev 对象的名字，并且把名字赋值给 evdev-&gt;handle.name</span><br><span class="line">32     evdev-&gt;handle.handler &#x3D; handler;          &#x2F;&#x2F;  将我们传进来的 handler 指针存放在 handle.handler 中</span><br><span class="line">33     evdev-&gt;handle.private &#x3D; evdev;             &#x2F;&#x2F;  把evdev 作为handle 的私有数据</span><br><span class="line">34 </span><br><span class="line">35     evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);        &#x2F;&#x2F;  设置 evdev-&gt;device 设备的设备号</span><br><span class="line">36     evdev-&gt;dev.class &#x3D; &amp;input_class;                                                  &#x2F;&#x2F;  将 input_class 作为 evdev-&gt;device 的设备类</span><br><span class="line">37     evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;                                                &#x2F;&#x2F; 将input_dev  -&gt; device 作为evdev-&gt;device 的父设备</span><br><span class="line">38     evdev-&gt;dev.release &#x3D; evdev_free;                   &#x2F;&#x2F;  evdev -&gt; device 设备的卸载函数</span><br><span class="line">39     device_initialize(&amp;evdev-&gt;dev);                      &#x2F;&#x2F;  设备初始化</span><br><span class="line">40 </span><br><span class="line">41     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);       &#x2F;&#x2F;  注册handle </span><br><span class="line">42     if (error)</span><br><span class="line">43         goto err_free_evdev;</span><br><span class="line">44 </span><br><span class="line">45     error &#x3D; evdev_install_chrdev(evdev);       &#x2F;&#x2F; 安装evdev   其实就是将evdev 结构体指针存放在evdev_table数组当中  下标就是evdev-&gt;minor</span><br><span class="line">46     if (error)</span><br><span class="line">47         goto err_unregister_handle;</span><br><span class="line">48 </span><br><span class="line">49     error &#x3D; device_add(&amp;evdev-&gt;dev);     &#x2F;&#x2F;  添加设备到系统          &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input0&#x2F;event0        event0就是表示建立的设备文件</span><br><span class="line">50     if (error)</span><br><span class="line">51         goto err_cleanup_evdev;</span><br><span class="line">52 </span><br><span class="line">53     return 0;</span><br><span class="line">54 </span><br><span class="line">55  err_cleanup_evdev:</span><br><span class="line">56     evdev_cleanup(evdev);</span><br><span class="line">57  err_unregister_handle:</span><br><span class="line">58     input_unregister_handle(&amp;evdev-&gt;handle);</span><br><span class="line">59  err_free_evdev:</span><br><span class="line">60     put_device(&amp;evdev-&gt;dev);</span><br><span class="line">61     return error;</span><br><span class="line">62 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>这里搞清楚:  /sys/devices/virtual/input/input0  这个设备是在注册input_dev时创建的，而input0/event0就是在handler和input_dev匹配成功之后创建的，也会在/dev/目录</p>
<p>下创建设备节点。 </p>
<p>(2)evdev_open分析</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int evdev_open(struct inode *inode, struct file *file)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct evdev *evdev;                       &#x2F;&#x2F;  定义一个 evdev 结构体指针</span><br><span class="line"> 4     struct evdev_client *client;             &#x2F;&#x2F;   定义一个evdev_client 指针</span><br><span class="line"> 5     int i &#x3D; iminor(inode) - EVDEV_MINOR_BASE;   &#x2F;&#x2F;  通过inode 获取 需要打开的设备对应的evdev_table 数组中的下标变量</span><br><span class="line"> 6     int error;</span><br><span class="line"> 7 </span><br><span class="line"> 8     if (i &gt;&#x3D; EVDEV_MINORS)</span><br><span class="line"> 9         return -ENODEV;</span><br><span class="line">10 </span><br><span class="line">11     error &#x3D; mutex_lock_interruptible(&amp;evdev_table_mutex);</span><br><span class="line">12     if (error)</span><br><span class="line">13         return error;</span><br><span class="line">14     evdev &#x3D; evdev_table[i];             &#x2F;&#x2F;  从evdev_table  数组中找到evdev </span><br><span class="line">15     if (evdev)</span><br><span class="line">16         get_device(&amp;evdev-&gt;dev);</span><br><span class="line">17     mutex_unlock(&amp;evdev_table_mutex);</span><br><span class="line">18 </span><br><span class="line">19     if (!evdev)</span><br><span class="line">20         return -ENODEV;</span><br><span class="line">21 </span><br><span class="line">22     client &#x3D; kzalloc(sizeof(struct evdev_client), GFP_KERNEL);      &#x2F;&#x2F;  给 client 申请分配内存</span><br><span class="line">23     if (!client) &#123;</span><br><span class="line">24         error &#x3D; -ENOMEM;</span><br><span class="line">25         goto err_put_evdev;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">29     snprintf(client-&gt;name, sizeof(client-&gt;name), &quot;%s-%d&quot;,</span><br><span class="line">30             dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">31     wake_lock_init(&amp;client-&gt;wake_lock, WAKE_LOCK_SUSPEND, client-&gt;name);</span><br><span class="line">32     client-&gt;evdev &#x3D; evdev;                          &#x2F;&#x2F;  通过client-&gt;evdev 指针指向 evdev</span><br><span class="line">33     evdev_attach_client(evdev, client);   &#x2F;&#x2F;  其实这个函数就是做了一个链表挂接:  client-&gt;node  挂接到 evdev-&gt;client_list</span><br><span class="line">34 </span><br><span class="line">35     error &#x3D; evdev_open_device(evdev); &#x2F;&#x2F;  打开 evdev 设备   最终就会打开 input_dev -&gt; open 函数</span><br><span class="line">36     if (error)</span><br><span class="line">37         goto err_free_client;</span><br><span class="line">38 </span><br><span class="line">39     file-&gt;private_data &#x3D; client;              &#x2F;&#x2F;   将evdev_client 作为file 的私有数据存在</span><br><span class="line">40     nonseekable_open(inode, file);</span><br><span class="line">41 </span><br><span class="line">42     return 0;</span><br><span class="line">43 </span><br><span class="line">44  err_free_client:</span><br><span class="line">45     evdev_detach_client(evdev, client);</span><br><span class="line">46     kfree(client);</span><br><span class="line">47  err_put_evdev:</span><br><span class="line">48     put_device(&amp;evdev-&gt;dev);</span><br><span class="line">49     return error;</span><br><span class="line">50 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>4、总结：</p>
<p>(1)其实下层可以上报的事件都在我们的内核中是定义好的，我们都可以上报这些事，但是input子系统的上层输入事件驱动层的各个handler只能够处理某一些事件（event除外），</p>
<p>例如joy handler只能处理摇杆类型的事件，key handler只能处理键盘，内部实现的原理就是会在核心层做handler和device匹配的过程。如果我们的上报的事件与多个handler都</p>
<p>能够匹配成功，那么绑定之后核心层会向这多个handler都上报事件，再由handler上报给应用层。</p>
<p>(2)input设备注册的流程:</p>
<p>下层通过调用核心层的函数来向子系统注册input输入设备</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_device</p>
<p>  device_add:  /sys/devices/virtual/input/input0</p>
<p>  链表挂接: input_dev-&gt;node   ——-&gt;  input_dev_list</p>
<p>  input_attach_handler              //  进行input_dev和handler之间的匹配</p>
<p>​    调用handler-&gt;connect进行连接</p>
<p>​      构建evdev结构体，加入evdev_table数组</p>
<p>​      input_register_handle</p>
<p>​      device_add:  /sys/devices/virtual/input/input0/event0</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(3)handler注册流程</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>input_register_handler</p>
<p>  input_table[handler-&gt;minor &gt;&gt; 5] = handler</p>
<p>  链表挂接:  handler-&gt;node  —–&gt;  input_handler_list</p>
<p>  input_attach_handler</p>
<p>​    handler-&gt;connect          // 调用handler的connect函数进行连接</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>(4)事件如何传递到应用层</p>
<p>input子系统下层通过调用input_event函数项核心层上报数据</p>
<p>input_event</p>
<p>  input_handle_event</p>
<p>​    input_pass_event</p>
<p>​      handler-&gt;event()       //  最终会调用到handler 中的event函数</p>
<p>​        evdev_pass_event</p>
<p>​          client-&gt;buffer[client-&gt;head++] = *event;   //  会将input输入事件数据存放在evdev_client结构体中的缓冲去中</p>
<p>当我们的应用层通过open打开event0这个设备节点时最终会调用到input_init函数中注册的字符设备input时注册的file_operations-&gt;open() 函数</p>
<p>input_open_file</p>
<p>  handler = input_table[iminor(inode) &gt;&gt; 5]</p>
<p>  handler-&gt;fops-&gt;open()      </p>
<p>​    evdev = evdev_table[i];</p>
<p>​    evdev_open_device</p>
<p>​      input_open_device</p>
<p>​        input_dev-&gt;open()     //  最终就是执行input设备中的open函数</p>
<p>​    file-&gt;private_data = evdev_client; </p>
<p>所以当我们在应用层调用read函数时，最终会调用到handler-&gt;fops-&gt;read函数</p>
<p>evdev_read</p>
<p>  evdev_fetch_next_event</p>
<p>​    *event = client-&gt;buffer[client-&gt;tail++]    //  将evdev_client-&gt;buffer中的数据取走</p>
<p>  input_event_to_user</p>
<p>​    copy_to_user          //  拷贝到用户空间</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>到此为止，input输入子系统中还有设备驱动层没有说到，将会在下一篇博文中补充。。。。。。。。。。。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】电容触摸屏驱动</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://home.cnblogs.com/u/Lioker/" target="_blank" rel="noopener">Lioker</a>【<a href="https://www.cnblogs.com/Lioker/p/10990633.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/10990633.html】</a></p>
<p>在读者学习本章以及后续章节之前，最好拥有ADC和触摸屏裸机基础，可以参考：<a href="http://wiki.100ask.org/第018课_ADC和触摸屏" target="_blank" rel="noopener">ADC和触摸屏编程</a>。</p>
<p>和按键驱动类似，触摸屏也是通过电平来体现按下或松开。因此如果想要写出通用的触摸屏驱动，需要使用<a href="https://www.cnblogs.com/Lioker/p/10871151.html" target="_blank" rel="noopener">输入子系统</a>完成。</p>
<h1 id="一、电容触摸屏检测原理"><a href="#一、电容触摸屏检测原理" class="headerlink" title="一、电容触摸屏检测原理"></a>一、电容触摸屏检测原理</h1><p>此段来源于百度百科，读者可查看：<a href="https://baike.baidu.com/item/电容式触摸屏/7533199?fr=aladdin" target="_blank" rel="noopener">电容式触摸屏</a>。</p>
<p>电容式触摸屏技术是利用人体的电流感应进行工作的。</p>
<p>电容式触摸屏是一块四层复合玻璃屏，玻璃屏的内表面和夹层各涂有一层ITO（导电玻璃），最外层是一薄层矽土玻璃保护层，夹层ITO涂层作为工作面，四个角上引出四个电极，内层ITO为屏蔽层以保证良好的工作环境。</p>
<p>当用户触摸电容屏时，由于人体电场，用户手指和工作面形成一个耦合电容，因为工作面上接有高频信号，于是手指吸收走一个很小的电流，这个电流分别从屏的四个角上的电极中流出，且理论上流经四个电极的电流与手指头到四角的距离成比例，控制器通过对四个电流比例的精密计算得出位置。可以达到99%的精确度，具备小于3ms的响应速度。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190608142517953-2146917656.png" alt="img"></p>
<h1 id="二、电容触摸屏控制芯片驱动分析"><a href="#二、电容触摸屏控制芯片驱动分析" class="headerlink" title="二、电容触摸屏控制芯片驱动分析"></a>二、电容触摸屏控制芯片驱动分析</h1><p>我使用的开发板iTOP4412的触摸屏IC为ft5406，对应的驱动文件是drivers/input/touchscreen/ft5x06_ts.c。下面来分析此文件。</p>
<p>首先从init()函数分析：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int __init ft5x0x_ts_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int ret;</span><br><span class="line"> 4     int type;</span><br><span class="line"> 5 </span><br><span class="line"> 6     type &#x3D; get_lcd_type();</span><br><span class="line"> 7 </span><br><span class="line"> 8     &#x2F;* 设置GPIO引脚 *&#x2F;</span><br><span class="line"> 9     ret &#x3D; gpio_request(EXYNOS4_GPL0(2), &quot;TP1_EN&quot;);</span><br><span class="line">10 ...</span><br><span class="line">11     gpio_direction_output(EXYNOS4_GPL0(2), 1);</span><br><span class="line">12 </span><br><span class="line">13     s3c_gpio_cfgpin(EXYNOS4_GPL0(2), S3C_GPIO_OUTPUT);</span><br><span class="line">14     gpio_free(EXYNOS4_GPL0(2));</span><br><span class="line">15 </span><br><span class="line">16     mdelay(5);</span><br><span class="line">17 </span><br><span class="line">18     printk(&quot;&#x3D;&#x3D;%s: reset&#x3D;&#x3D;\n&quot;, __FUNCTION__);</span><br><span class="line">19     ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">20 ...</span><br><span class="line">21     gpio_direction_output(EXYNOS4_GPX0(3), 0);</span><br><span class="line">22     mdelay(200);</span><br><span class="line">23     &#x2F;* 给触摸芯片复位 *&#x2F;</span><br><span class="line">24     gpio_direction_output(EXYNOS4_GPX0(3), 1);</span><br><span class="line">25 </span><br><span class="line">26     s3c_gpio_cfgpin(EXYNOS4_GPX0(3), S3C_GPIO_OUTPUT);</span><br><span class="line">27     gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">28     msleep(300);</span><br><span class="line">29 ...</span><br><span class="line">30     &#x2F;* 注册I2C驱动 *&#x2F;</span><br><span class="line">31     return i2c_add_driver(&amp;ft5x0x_ts_driver);</span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>此触摸屏使用的是i2c驱动，我们来看看此驱动结构体定义了什么。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static struct i2c_driver ft5x0x_ts_driver &#x3D; &#123;</span><br><span class="line">2     .probe        &#x3D; ft5x0x_ts_probe,</span><br><span class="line">3     .remove        &#x3D; __devexit_p(ft5x0x_ts_remove),</span><br><span class="line">4     .id_table    &#x3D; ft5x0x_ts_id,</span><br><span class="line">5     .driver    &#x3D; &#123;</span><br><span class="line">6         .name    &#x3D; FT5X0X_NAME,    &#x2F;&#x2F; #define FT5X0X_NAME &quot;ft5x0x_ts&quot;</span><br><span class="line">7         .owner    &#x3D; THIS_MODULE,</span><br><span class="line">8     &#125;,</span><br><span class="line">9 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>接下来，我们来查看probe()函数：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">  2 &#123;</span><br><span class="line">  3     struct ft5x0x_i2c_platform_data *pdata;</span><br><span class="line">  4     struct ft5x0x_ts_data *ts;</span><br><span class="line">  5     struct input_dev *input_dev;</span><br><span class="line">  6     unsigned char val;</span><br><span class="line">  7     int err &#x3D; -EINVAL;</span><br><span class="line">  8     &#x2F;* 判断是否为i2c设备 *&#x2F;</span><br><span class="line">  9     if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) &#123;</span><br><span class="line"> 10 ...</span><br><span class="line"> 11     &#125;</span><br><span class="line"> 12     &#x2F;* 分配空间，此结构体用于存储坐标, 压力值, 事件 *&#x2F;</span><br><span class="line"> 13     ts &#x3D; kzalloc(sizeof(*ts), GFP_KERNEL);</span><br><span class="line"> 14 ...</span><br><span class="line"> 15     &#x2F;* 获取dev的平台数据 *&#x2F;</span><br><span class="line"> 16     pdata &#x3D; client-&gt;dev.platform_data;</span><br><span class="line"> 17 </span><br><span class="line"> 18     ts-&gt;screen_max_x &#x3D; pdata-&gt;screen_max_x;</span><br><span class="line"> 19     ts-&gt;screen_max_y &#x3D; pdata-&gt;screen_max_y;</span><br><span class="line"> 20     ts-&gt;pressure_max &#x3D; pdata-&gt;pressure_max;</span><br><span class="line"> 21     &#x2F;* 设置引脚为中断模式 *&#x2F;</span><br><span class="line"> 22     ts-&gt;gpio_irq &#x3D; pdata-&gt;gpio_irq;</span><br><span class="line"> 23     if (ts-&gt;gpio_irq !&#x3D; -EINVAL) &#123;</span><br><span class="line"> 24         client-&gt;irq &#x3D; gpio_to_irq(ts-&gt;gpio_irq);</span><br><span class="line"> 25     &#125; else &#123;</span><br><span class="line"> 26         goto exit_no_pdata;</span><br><span class="line"> 27     &#125;</span><br><span class="line"> 28     if (pdata-&gt;irq_cfg) &#123;</span><br><span class="line"> 29         s3c_gpio_cfgpin(ts-&gt;gpio_irq, pdata-&gt;irq_cfg);</span><br><span class="line"> 30         s3c_gpio_setpull(ts-&gt;gpio_irq, S3C_GPIO_PULL_NONE);</span><br><span class="line"> 31     &#125;</span><br><span class="line"> 32 </span><br><span class="line"> 33     ts-&gt;gpio_wakeup &#x3D; pdata-&gt;gpio_wakeup;</span><br><span class="line"> 34     ts-&gt;gpio_reset &#x3D; pdata-&gt;gpio_reset;</span><br><span class="line"> 35     &#x2F;* 创建工作队列 *&#x2F;</span><br><span class="line"> 36     INIT_WORK(&amp;ts-&gt;work, ft5x0x_ts_pen_irq_work);</span><br><span class="line"> 37     this_client &#x3D; client;</span><br><span class="line"> 38     i2c_set_clientdata(client, ts);</span><br><span class="line"> 39 </span><br><span class="line"> 40     ts-&gt;queue &#x3D; create_singlethread_workqueue(dev_name(&amp;client-&gt;dev));</span><br><span class="line"> 41 ...</span><br><span class="line"> 42     &#x2F;* 分配设置注册输入子系统 *&#x2F;</span><br><span class="line"> 43     input_dev &#x3D; input_allocate_device();</span><br><span class="line"> 44     ts-&gt;input_dev &#x3D; input_dev;</span><br><span class="line"> 45 </span><br><span class="line"> 46     set_bit(EV_SYN, input_dev-&gt;evbit);    &#x2F;* 同步事件 *&#x2F;</span><br><span class="line"> 47     set_bit(EV_ABS, input_dev-&gt;evbit);    &#x2F;* 绝对位移事件，存储坐标 *&#x2F;</span><br><span class="line"> 48     set_bit(EV_KEY, input_dev-&gt;evbit);    &#x2F;* 按键事件 *&#x2F;</span><br><span class="line"> 49 </span><br><span class="line"> 50 #ifdef CONFIG_FT5X0X_MULTITOUCH</span><br><span class="line"> 51     set_bit(ABS_MT_TRACKING_ID, input_dev-&gt;absbit);</span><br><span class="line"> 52     set_bit(ABS_MT_TOUCH_MAJOR, input_dev-&gt;absbit);</span><br><span class="line"> 53     set_bit(ABS_MT_WIDTH_MAJOR, input_dev-&gt;absbit);</span><br><span class="line"> 54     set_bit(ABS_MT_POSITION_X, input_dev-&gt;absbit);</span><br><span class="line"> 55     set_bit(ABS_MT_POSITION_Y, input_dev-&gt;absbit);</span><br><span class="line"> 56 </span><br><span class="line"> 57     input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, ts-&gt;screen_max_x, 0, 0);</span><br><span class="line"> 58     input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, ts-&gt;screen_max_y, 0, 0);</span><br><span class="line"> 59     input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, ts-&gt;pressure_max, 0, 0);</span><br><span class="line"> 60     input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);</span><br><span class="line"> 61     input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, FT5X0X_PT_MAX, 0, 0);</span><br><span class="line"> 62 #else</span><br><span class="line"> 63     set_bit(ABS_X, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的x坐标 *&#x2F;</span><br><span class="line"> 64     set_bit(ABS_Y, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的y坐标 *&#x2F;</span><br><span class="line"> 65     set_bit(ABS_PRESSURE, input_dev-&gt;absbit);    &#x2F;* 绝对位移事件中的压力值 *&#x2F;</span><br><span class="line"> 66     set_bit(BTN_TOUCH, input_dev-&gt;keybit);        &#x2F;* 按键事件中的触摸屏事件 *&#x2F;</span><br><span class="line"> 67     &#x2F;* 设置x, y, 压力值的范围和初始值 *&#x2F;</span><br><span class="line"> 68     input_set_abs_params(input_dev, ABS_X, 0, ts-&gt;screen_max_x, 0, 0);</span><br><span class="line"> 69     input_set_abs_params(input_dev, ABS_Y, 0, ts-&gt;screen_max_y, 0, 0);</span><br><span class="line"> 70     input_set_abs_params(input_dev, ABS_PRESSURE, 0, ts-&gt;pressure_max, 0 , 0);</span><br><span class="line"> 71 #endif</span><br><span class="line"> 72 </span><br><span class="line"> 73     input_dev-&gt;name &#x3D; FT5X0X_NAME;</span><br><span class="line"> 74     input_dev-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line"> 75     input_dev-&gt;id.vendor &#x3D; 0x12FA;</span><br><span class="line"> 76     input_dev-&gt;id.product &#x3D; 0x2143;</span><br><span class="line"> 77     input_dev-&gt;id.version &#x3D; 0x0100;</span><br><span class="line"> 78 </span><br><span class="line"> 79     err &#x3D; input_register_device(input_dev);</span><br><span class="line"> 80 ...</span><br><span class="line"> 81     &#x2F;* 读取芯片硬件信息 *&#x2F;</span><br><span class="line"> 82     msleep(3);</span><br><span class="line"> 83     err &#x3D; ft5x0x_read_fw_ver(&amp;val);</span><br><span class="line"> 84 </span><br><span class="line"> 85     err &#x3D; request_irq(client-&gt;irq, ft5x0x_ts_interrupt, IRQ_TYPE_EDGE_FALLING, &quot;ft5x0x_ts&quot;, ts);</span><br><span class="line"> 86     disable_irq(client-&gt;irq);</span><br><span class="line"> 87     dev_info(&amp;client-&gt;dev, &quot;Firmware version 0x%02x\n&quot;, val);</span><br><span class="line"> 88     &#x2F;* 支持休眠功能 *&#x2F;</span><br><span class="line"> 89 #ifdef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line"> 90     ts-&gt;early_suspend.level &#x3D; EARLY_SUSPEND_LEVEL_BLANK_SCREEN;&#x2F;&#x2F;EARLY_SUSPEND_LEVEL_DISABLE_FB + 1;</span><br><span class="line"> 91     ts-&gt;early_suspend.suspend &#x3D; ft5x0x_ts_suspend;</span><br><span class="line"> 92     ts-&gt;early_suspend.resume &#x3D; ft5x0x_ts_resume;</span><br><span class="line"> 93     register_early_suspend(&amp;ts-&gt;early_suspend);</span><br><span class="line"> 94 #endif</span><br><span class="line"> 95 </span><br><span class="line"> 96     enable_irq(client-&gt;irq);</span><br><span class="line"> 97 </span><br><span class="line"> 98     dev_info(&amp;client-&gt;dev, &quot;FocalTech ft5x0x TouchScreen initialized\n&quot;);</span><br><span class="line"> 99 </span><br><span class="line">100     return err;</span><br><span class="line">101 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>probe()函数所做的事情主要有：</strong></p>
<p>\1. 判断是否为i2c设备</p>
<p>\2. 分配并设置struct ft5x0x_ts_data，此结构体中存储有最大y坐标，最大压力值，工作队列等。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct ft5x0x_ts_data &#123;</span><br><span class="line"> 2     struct input_dev *input_dev;</span><br><span class="line"> 3     struct ft5x0x_event event;</span><br><span class="line"> 4 </span><br><span class="line"> 5     uint32_t gpio_irq;</span><br><span class="line"> 6     uint32_t gpio_wakeup;</span><br><span class="line"> 7     uint32_t gpio_reset;</span><br><span class="line"> 8 </span><br><span class="line"> 9     int screen_max_x;</span><br><span class="line">10     int screen_max_y;</span><br><span class="line">11     int pressure_max;</span><br><span class="line">12 </span><br><span class="line">13     struct work_struct work;</span><br><span class="line">14     struct workqueue_struct *queue;</span><br><span class="line">15 </span><br><span class="line">16 #ifdef CONFIG_HAS_EARLYSUSPEND</span><br><span class="line">17     struct early_suspend early_suspend;</span><br><span class="line">18 #endif</span><br><span class="line">19 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>\3. 设置中断</p>
<p>\4. 初始化工作队列（工作队列可以休眠）</p>
<p>\5. 分配、设置并注册input_device</p>
<p>当有触摸屏事件发生时，会跳转到probe()函数中注册的中断处理函数ft5x0x_ts_interrupt()中执行，由于在probe()函数中设置了工作队列，因此中断函数会跳转至工作队列函数ft5x0x_ts_pen_irq_work()：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static irqreturn_t ft5x0x_ts_interrupt(int irq, void *dev_id) &#123;</span><br><span class="line"> 2     struct ft5x0x_ts_data *ts &#x3D; dev_id;</span><br><span class="line"> 3 </span><br><span class="line"> 4     disable_irq_nosync(this_client-&gt;irq);</span><br><span class="line"> 5 </span><br><span class="line"> 6     if (!work_pending(&amp;ts-&gt;work)) &#123;</span><br><span class="line"> 7         queue_work(ts-&gt;queue, &amp;ts-&gt;work);</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9 </span><br><span class="line">10     return IRQ_HANDLED;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由于i2c读取函数底层可能拥有休眠操作，但是中断中并不允许休眠，因此需要设置工作队列。</p>
<p>在工作队列函数中，首先完成读取x，y和压力值等参数的工作，之后完成参数的上报工作。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 static int ft5x0x_read_data(struct ft5x0x_ts_data *ts) &#123;</span><br><span class="line">  2     struct ft5x0x_event *event &#x3D; &amp;ts-&gt;event;</span><br><span class="line">  3     u8 buf[64] &#x3D; &#123; 0 &#125;;</span><br><span class="line">  4     int ret;</span><br><span class="line">  5 ...</span><br><span class="line">  6     ret &#x3D; ft5x0x_i2c_rxdata(buf, 7);</span><br><span class="line">  7 ...</span><br><span class="line">  8     memset(event, 0, sizeof(struct ft5x0x_event));</span><br><span class="line">  9     event-&gt;touch_point &#x3D; buf[2] &amp; 0x0F;</span><br><span class="line"> 10 </span><br><span class="line"> 11     if (!event-&gt;touch_point) &#123;</span><br><span class="line"> 12         ft5x0x_ts_release(ts);</span><br><span class="line"> 13         return 1;</span><br><span class="line"> 14     &#125;</span><br><span class="line"> 15     &#x2F;* 判断有几个点按下，也就是支持多指触控 *&#x2F;</span><br><span class="line"> 16 #ifdef CONFIG_FT5X0X_MULTITOUCH</span><br><span class="line"> 17     switch (event-&gt;touch_point) &#123;</span><br><span class="line"> 18         case 10:</span><br><span class="line"> 19             event-&gt;x[9] &#x3D; (s16)(buf[57] &amp; 0x0F)&lt;&lt;8 | (s16)buf[58];</span><br><span class="line"> 20             event-&gt;y[9] &#x3D; (s16)(buf[59] &amp; 0x0F)&lt;&lt;8 | (s16)buf[60];</span><br><span class="line"> 21         case 9:</span><br><span class="line"> 22             event-&gt;x[8] &#x3D; (s16)(buf[51] &amp; 0x0F)&lt;&lt;8 | (s16)buf[52];</span><br><span class="line"> 23             event-&gt;y[8] &#x3D; (s16)(buf[53] &amp; 0x0F)&lt;&lt;8 | (s16)buf[54];</span><br><span class="line"> 24         case 8:</span><br><span class="line"> 25             event-&gt;x[7] &#x3D; (s16)(buf[45] &amp; 0x0F)&lt;&lt;8 | (s16)buf[46];</span><br><span class="line"> 26             event-&gt;y[7] &#x3D; (s16)(buf[47] &amp; 0x0F)&lt;&lt;8 | (s16)buf[48];</span><br><span class="line"> 27         case 7:</span><br><span class="line"> 28             event-&gt;x[6] &#x3D; (s16)(buf[39] &amp; 0x0F)&lt;&lt;8 | (s16)buf[40];</span><br><span class="line"> 29             event-&gt;y[6] &#x3D; (s16)(buf[41] &amp; 0x0F)&lt;&lt;8 | (s16)buf[42];</span><br><span class="line"> 30         case 6:</span><br><span class="line"> 31             event-&gt;x[5] &#x3D; (s16)(buf[33] &amp; 0x0F)&lt;&lt;8 | (s16)buf[34];</span><br><span class="line"> 32             event-&gt;y[5] &#x3D; (s16)(buf[35] &amp; 0x0F)&lt;&lt;8 | (s16)buf[36];</span><br><span class="line"> 33         case 5:</span><br><span class="line"> 34             event-&gt;x[4] &#x3D; (s16)(buf[0x1b] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x1c];</span><br><span class="line"> 35             event-&gt;y[4] &#x3D; (s16)(buf[0x1d] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x1e];</span><br><span class="line"> 36         case 4:</span><br><span class="line"> 37             event-&gt;x[3] &#x3D; (s16)(buf[0x15] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x16];</span><br><span class="line"> 38             event-&gt;y[3] &#x3D; (s16)(buf[0x17] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x18];</span><br><span class="line"> 39             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[3], event-&gt;y[3]);</span><br><span class="line"> 40         case 3:</span><br><span class="line"> 41             event-&gt;x[2] &#x3D; (s16)(buf[0x0f] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x10];</span><br><span class="line"> 42             event-&gt;y[2] &#x3D; (s16)(buf[0x11] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x12];</span><br><span class="line"> 43             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[2], event-&gt;y[2]);</span><br><span class="line"> 44         case 2:</span><br><span class="line"> 45             event-&gt;x[1] &#x3D; (s16)(buf[0x09] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x0a];</span><br><span class="line"> 46             event-&gt;y[1] &#x3D; (s16)(buf[0x0b] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x0c];</span><br><span class="line"> 47             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[1], event-&gt;y[1]);</span><br><span class="line"> 48         case 1:</span><br><span class="line"> 49             event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line"> 50             event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line"> 51             &#x2F;&#x2F;printk(&quot;x:%d, y:%d\n&quot;, event-&gt;x[0], event-&gt;y[0]);</span><br><span class="line"> 52             break;</span><br><span class="line"> 53         default:</span><br><span class="line"> 54             printk(&quot;%s: invalid touch data, %d\n&quot;, __func__, event-&gt;touch_point);</span><br><span class="line"> 55             return -1;</span><br><span class="line"> 56     &#125;</span><br><span class="line"> 57 #else</span><br><span class="line"> 58     if (event-&gt;touch_point &#x3D;&#x3D; 1) &#123;</span><br><span class="line"> 59         event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line"> 60         event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line"> 61     &#125;</span><br><span class="line"> 62 #endif</span><br><span class="line"> 63 </span><br><span class="line"> 64     event-&gt;pressure &#x3D; 200;</span><br><span class="line"> 65 </span><br><span class="line"> 66     return 0;</span><br><span class="line"> 67 &#125;</span><br><span class="line"> 68 </span><br><span class="line"> 69 static void ft5x0x_ts_report(struct ft5x0x_ts_data *ts) &#123;</span><br><span class="line"> 70     struct ft5x0x_event *event &#x3D; &amp;ts-&gt;event;</span><br><span class="line"> 71     int x, y;</span><br><span class="line"> 72     int i &#x3D; 0;</span><br><span class="line"> 73     &#x2F;* 上报事件 *&#x2F;</span><br><span class="line"> 74     if (event-&gt;touch_point &#x3D;&#x3D; 1) &#123;</span><br><span class="line"> 75         if (swap_xy) &#123;</span><br><span class="line"> 76             x &#x3D; event-&gt;y[i];</span><br><span class="line"> 77             y &#x3D; event-&gt;x[i];</span><br><span class="line"> 78         &#125; else &#123;</span><br><span class="line"> 79             x &#x3D; event-&gt;x[i];</span><br><span class="line"> 80             y &#x3D; event-&gt;y[i];</span><br><span class="line"> 81         &#125;</span><br><span class="line"> 82 </span><br><span class="line"> 83         if (scal_xy) &#123;</span><br><span class="line"> 84             x &#x3D; (x * ts-&gt;screen_max_x) &#x2F; TOUCH_MAX_X;</span><br><span class="line"> 85             y &#x3D; (y * ts-&gt;screen_max_y) &#x2F; TOUCH_MAX_Y;</span><br><span class="line"> 86         &#125;</span><br><span class="line"> 87 </span><br><span class="line"> 88         input_report_abs(ts-&gt;input_dev, ABS_X, x);</span><br><span class="line"> 89         input_report_abs(ts-&gt;input_dev, ABS_Y, y);</span><br><span class="line"> 90         input_report_abs(ts-&gt;input_dev, ABS_PRESSURE, event-&gt;pressure);</span><br><span class="line"> 91     &#125;</span><br><span class="line"> 92 </span><br><span class="line"> 93     input_report_key(ts-&gt;input_dev, BTN_TOUCH, 1);</span><br><span class="line"> 94 </span><br><span class="line"> 95     input_sync(ts-&gt;input_dev);</span><br><span class="line"> 96 &#125;</span><br><span class="line"> 97 </span><br><span class="line"> 98 static void ft5x0x_ts_pen_irq_work(struct work_struct *work) &#123;</span><br><span class="line"> 99     struct ft5x0x_ts_data *ts &#x3D; container_of(work, struct ft5x0x_ts_data, work);</span><br><span class="line">100 </span><br><span class="line">101     if (!ft5x0x_read_data(ts)) &#123;</span><br><span class="line">102         ft5x0x_ts_report(ts);</span><br><span class="line">103     &#125;</span><br><span class="line">104 </span><br><span class="line">105     enable_irq(this_client-&gt;irq);</span><br><span class="line">106 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面我们来总结一下整体过程：</p>
<p>\1. 设置GPIO引脚</p>
<p>\2. 注册i2c设备驱动</p>
<p>\3. 分配、设置和注册struct input_dev</p>
<p>\4. 设置、注册触摸屏中断，注册触摸屏中断函数底半部函数</p>
<p>\5. 中断函数中调用工作队列</p>
<p>\6. 工作队列中读取数据后上报数据</p>
<p>下一章我们根据分析的文件来自己实现触摸屏驱动。</p>
<h1 id="三、自己实现触摸屏驱动"><a href="#三、自己实现触摸屏驱动" class="headerlink" title="三、自己实现触摸屏驱动"></a>三、自己实现触摸屏驱动</h1><p>触摸屏驱动源代码：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 #include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">  2 #include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">  3 #include &lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">  4 #include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">  5 #include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">  6 #include &lt;linux&#x2F;input.h&gt;</span><br><span class="line">  7 #include &lt;linux&#x2F;delay.h&gt;</span><br><span class="line">  8 #include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">  9 #include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line"> 10 #include &lt;linux&#x2F;workqueue.h&gt;</span><br><span class="line"> 11 #include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line"> 12 #include &lt;linux&#x2F;mod_devicetable.h&gt;</span><br><span class="line"> 13 #include &lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line"> 14 #include &lt;linux&#x2F;regulator&#x2F;consumer.h&gt;</span><br><span class="line"> 15 </span><br><span class="line"> 16 #include &lt;asm&#x2F;io.h&gt;</span><br><span class="line"> 17 #include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"> 18 </span><br><span class="line"> 19 #include &lt;mach&#x2F;gpio.h&gt;</span><br><span class="line"> 20 #include &lt;mach&#x2F;regs-gpio.h&gt;</span><br><span class="line"> 21 </span><br><span class="line"> 22 #include &lt;plat&#x2F;gpio-cfg.h&gt;</span><br><span class="line"> 23 </span><br><span class="line"> 24 static struct work_struct wq;</span><br><span class="line"> 25 </span><br><span class="line"> 26 struct ft5x0x_event &#123;</span><br><span class="line"> 27     int touch_point;</span><br><span class="line"> 28     u16 x[2];</span><br><span class="line"> 29     u16 y[2];</span><br><span class="line"> 30     u16 pressure;</span><br><span class="line"> 31 &#125;;</span><br><span class="line"> 32 </span><br><span class="line"> 33 int TOUCH_MAX_X &#x3D; 1024;</span><br><span class="line"> 34 int TOUCH_MAX_Y &#x3D; 768;</span><br><span class="line"> 35 </span><br><span class="line"> 36 static struct input_dev *ftinput;</span><br><span class="line"> 37 </span><br><span class="line"> 38 static struct i2c_client *ft5x0x_client;</span><br><span class="line"> 39 </span><br><span class="line"> 40 static int swap_xy;</span><br><span class="line"> 41 static int touch_size;</span><br><span class="line"> 42 </span><br><span class="line"> 43 static void ft5x0x_release(void)</span><br><span class="line"> 44 &#123;</span><br><span class="line"> 45     input_report_abs(ftinput, ABS_PRESSURE, 0);</span><br><span class="line"> 46     input_report_key(ftinput, BTN_TOUCH, 0);</span><br><span class="line"> 47     input_sync(ftinput);</span><br><span class="line"> 48 &#125;</span><br><span class="line"> 49 </span><br><span class="line"> 50 static void ft5x0x_report(struct ft5x0x_event *event)</span><br><span class="line"> 51 &#123;</span><br><span class="line"> 52     int x, y;</span><br><span class="line"> 53     int i &#x3D; 0;</span><br><span class="line"> 54 </span><br><span class="line"> 55     if (swap_xy) &#123;</span><br><span class="line"> 56         x &#x3D; event-&gt;y[i];</span><br><span class="line"> 57         y &#x3D; event-&gt;x[i];</span><br><span class="line"> 58     &#125;</span><br><span class="line"> 59     else &#123;</span><br><span class="line"> 60         x &#x3D; event-&gt;x[i];</span><br><span class="line"> 61         y &#x3D; event-&gt;y[i];</span><br><span class="line"> 62     &#125;</span><br><span class="line"> 63 </span><br><span class="line"> 64     input_report_abs(ftinput, ABS_X, x);</span><br><span class="line"> 65     input_report_abs(ftinput, ABS_Y, y);</span><br><span class="line"> 66     input_report_abs(ftinput, ABS_PRESSURE, event-&gt;pressure);</span><br><span class="line"> 67 </span><br><span class="line"> 68     input_report_key(ftinput, BTN_TOUCH, 1);</span><br><span class="line"> 69 </span><br><span class="line"> 70     input_sync(ftinput);</span><br><span class="line"> 71 &#125;</span><br><span class="line"> 72 </span><br><span class="line"> 73 </span><br><span class="line"> 74 static int master_rx(char *rxdata, int length) &#123;</span><br><span class="line"> 75     int ret;</span><br><span class="line"> 76     struct i2c_msg msgs[] &#x3D; &#123;</span><br><span class="line"> 77         &#123;</span><br><span class="line"> 78             .addr    &#x3D; ft5x0x_client-&gt;addr,</span><br><span class="line"> 79             .flags    &#x3D; 0,</span><br><span class="line"> 80             .len    &#x3D; 1,</span><br><span class="line"> 81             .buf    &#x3D; rxdata,</span><br><span class="line"> 82         &#125;,</span><br><span class="line"> 83         &#123;</span><br><span class="line"> 84             .addr    &#x3D; ft5x0x_client-&gt;addr,</span><br><span class="line"> 85             .flags    &#x3D; I2C_M_RD,</span><br><span class="line"> 86             .len    &#x3D; length,</span><br><span class="line"> 87             .buf    &#x3D; rxdata,</span><br><span class="line"> 88         &#125;,</span><br><span class="line"> 89     &#125;;</span><br><span class="line"> 90 </span><br><span class="line"> 91     ret &#x3D; i2c_transfer(ft5x0x_client-&gt;adapter, msgs, 2);</span><br><span class="line"> 92     if (ret &lt; 0)</span><br><span class="line"> 93         printk(KERN_ERR &quot;i2c_transfer error\n&quot;);</span><br><span class="line"> 94 </span><br><span class="line"> 95     return ret;</span><br><span class="line"> 96 &#125;</span><br><span class="line"> 97 </span><br><span class="line"> 98 static int ft5x0x_read_data(struct ft5x0x_event *event)</span><br><span class="line"> 99 &#123;</span><br><span class="line">100     int ret;</span><br><span class="line">101     u8 buf[64] &#x3D; &#123; 0 &#125;;</span><br><span class="line">102 </span><br><span class="line">103     ret &#x3D; master_rx(buf, 7);</span><br><span class="line">104 </span><br><span class="line">105     memset(event, 0, sizeof(struct ft5x0x_event));</span><br><span class="line">106 </span><br><span class="line">107     event-&gt;touch_point &#x3D; buf[2] &amp; 0x0F;</span><br><span class="line">108     if (!event-&gt;touch_point) &#123;</span><br><span class="line">109         ft5x0x_release();</span><br><span class="line">110         return 1;</span><br><span class="line">111     &#125;</span><br><span class="line">112 </span><br><span class="line">113     event-&gt;x[0] &#x3D; (s16)(buf[0x03] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x04];</span><br><span class="line">114     event-&gt;y[0] &#x3D; (s16)(buf[0x05] &amp; 0x0F)&lt;&lt;8 | (s16)buf[0x06];</span><br><span class="line">115 </span><br><span class="line">116     event-&gt;pressure &#x3D; 200;</span><br><span class="line">117 </span><br><span class="line">118     return 0;</span><br><span class="line">119 &#125;</span><br><span class="line">120 </span><br><span class="line">121 static void i2c_wq_irq(unsigned long arg)</span><br><span class="line">122 &#123;</span><br><span class="line">123     struct ft5x0x_event event;</span><br><span class="line">124     </span><br><span class="line">125     if (!ft5x0x_read_data(&amp;event)) &#123;</span><br><span class="line">126         ft5x0x_report(&amp;event);</span><br><span class="line">127     &#125;</span><br><span class="line">128     </span><br><span class="line">129     printk(&quot;(%d, %d)\n&quot;, event.x[0], event.y[0]);</span><br><span class="line">130 &#125;</span><br><span class="line">131 </span><br><span class="line">132 static irqreturn_t ft5x0x_irq(int irq, void *arg)</span><br><span class="line">133 &#123;</span><br><span class="line">134     schedule_work(&amp;wq);</span><br><span class="line">135     return IRQ_HANDLED;</span><br><span class="line">136 &#125;</span><br><span class="line">137 </span><br><span class="line">138 static int read_device_info(u8 addr, u8 *val) </span><br><span class="line">139 &#123;</span><br><span class="line">140     int ret;</span><br><span class="line">141     u8 buf &#x3D; &#123; 0 &#125;;</span><br><span class="line">142     struct i2c_msg msgs[2];</span><br><span class="line">143 </span><br><span class="line">144     msgs[0].addr  &#x3D; ft5x0x_client-&gt;addr;</span><br><span class="line">145     msgs[0].buf      &#x3D; &amp;buf;</span><br><span class="line">146     msgs[0].flags &#x3D; 0;</span><br><span class="line">147     msgs[0].len   &#x3D; 1;</span><br><span class="line">148 </span><br><span class="line">149     msgs[1].addr  &#x3D; ft5x0x_client-&gt;addr;</span><br><span class="line">150     msgs[1].buf      &#x3D; &amp;buf;</span><br><span class="line">151     msgs[1].flags &#x3D; 1;</span><br><span class="line">152     msgs[1].len   &#x3D; 1;</span><br><span class="line">153 </span><br><span class="line">154     buf &#x3D; addr;</span><br><span class="line">155     ret &#x3D; i2c_transfer(ft5x0x_client-&gt;adapter, msgs, 2);</span><br><span class="line">156     if (ret &lt; 0)</span><br><span class="line">157         printk(KERN_ERR &quot;i2c_transfer addr 0x%02x error!&quot;, buf);</span><br><span class="line">158     else</span><br><span class="line">159         *val &#x3D; buf;</span><br><span class="line">160 </span><br><span class="line">161     return ret;</span><br><span class="line">162 &#125;</span><br><span class="line">163 </span><br><span class="line">164 static int device_info(unsigned char *val)</span><br><span class="line">165 &#123;</span><br><span class="line">166     int ret;</span><br><span class="line">167 </span><br><span class="line">168     ret &#x3D; read_device_info(0xA6, val);</span><br><span class="line">169 </span><br><span class="line">170     printk(&quot;device_info: %d\n&quot;,*val);</span><br><span class="line">171 </span><br><span class="line">172     return ret;</span><br><span class="line">173 &#125;</span><br><span class="line">174 </span><br><span class="line">175 static int ft5x0x_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">176 &#123;</span><br><span class="line">177     int ret;</span><br><span class="line">178     ft5x0x_client &#x3D; client;</span><br><span class="line">179     unsigned char val &#x3D; 0;</span><br><span class="line">180 </span><br><span class="line">181     &#x2F;* 设置中断引脚 *&#x2F;</span><br><span class="line">182     client-&gt;irq &#x3D; gpio_to_irq(EXYNOS4_GPX0(4));</span><br><span class="line">183     s3c_gpio_cfgpin(client-&gt;irq, S3C_GPIO_SFN(0xf));</span><br><span class="line">184     s3c_gpio_setpull(client-&gt;irq, S3C_GPIO_PULL_NONE);</span><br><span class="line">185 </span><br><span class="line">186     &#x2F;* 分配设置input_device *&#x2F;</span><br><span class="line">187     ftinput &#x3D; input_allocate_device();</span><br><span class="line">188 </span><br><span class="line">189     set_bit(EV_ABS, ftinput-&gt;evbit);</span><br><span class="line">190     set_bit(EV_KEY, ftinput-&gt;evbit);</span><br><span class="line">191     set_bit(EV_SYN, ftinput-&gt;evbit);</span><br><span class="line">192     </span><br><span class="line">193     set_bit(ABS_X, ftinput-&gt;absbit);</span><br><span class="line">194     set_bit(ABS_Y, ftinput-&gt;absbit);</span><br><span class="line">195     set_bit(ABS_PRESSURE, ftinput-&gt;absbit);</span><br><span class="line">196     set_bit(BTN_TOUCH, ftinput-&gt;keybit);</span><br><span class="line">197 </span><br><span class="line">198     input_set_abs_params(ftinput, ABS_X, 0, 768, 0, 0);</span><br><span class="line">199     input_set_abs_params(ftinput, ABS_Y, 0, 1024, 0, 0);</span><br><span class="line">200     input_set_abs_params(ftinput, ABS_PRESSURE, 0, 255, 0 , 0);</span><br><span class="line">201 </span><br><span class="line">202     ftinput-&gt;name &#x3D; &quot;ft5x0x&quot;;</span><br><span class="line">203     ftinput-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">204 </span><br><span class="line">205     ret &#x3D; input_register_device(ftinput);</span><br><span class="line">206     if (ret) &#123;</span><br><span class="line">207         printk(KERN_ERR &quot;input_register_device error\n&quot;);</span><br><span class="line">208         input_free_device(ftinput);</span><br><span class="line">209     &#125;</span><br><span class="line">210 </span><br><span class="line">211     ret &#x3D; request_irq(client-&gt;irq, ft5x0x_irq, IRQ_TYPE_EDGE_FALLING, &quot;ft5x0x&quot;, NULL);</span><br><span class="line">212     if (ret &lt; 0) &#123;</span><br><span class="line">213         printk(KERN_ERR &quot;request_irq %d error\n&quot;, client-&gt;irq);</span><br><span class="line">214         goto exit_irq_request_failed;</span><br><span class="line">215     &#125;</span><br><span class="line">216 </span><br><span class="line">217     &#x2F;* 注册中断底半部 *&#x2F;</span><br><span class="line">218     INIT_WORK(&amp;wq, i2c_wq_irq);</span><br><span class="line">219     </span><br><span class="line">220     device_info(&amp;val);</span><br><span class="line">221     </span><br><span class="line">222     return 0;</span><br><span class="line">223 </span><br><span class="line">224 exit_irq_request_failed:</span><br><span class="line">225     input_unregister_device(ftinput);</span><br><span class="line">226 </span><br><span class="line">227     return ret;</span><br><span class="line">228 &#125;</span><br><span class="line">229 </span><br><span class="line">230 static int ft5x0x_remove(struct i2c_client *client)</span><br><span class="line">231 &#123;</span><br><span class="line">232     &#x2F;* 镜像注销 *&#x2F;</span><br><span class="line">233     input_unregister_device(ftinput);</span><br><span class="line">234     cancel_work_sync(&amp;wq);</span><br><span class="line">235     client-&gt;irq &#x3D; gpio_to_irq(EXYNOS4_GPX0(4));</span><br><span class="line">236     free_irq(client-&gt;irq, NULL);</span><br><span class="line">237     </span><br><span class="line">238     return 0;</span><br><span class="line">239 &#125;</span><br><span class="line">240 </span><br><span class="line">241 static const struct i2c_device_id ft5x0x_table[] &#x3D; &#123;</span><br><span class="line">242     &#123; &quot;ft5x0x&quot;, 0 &#125;,</span><br><span class="line">243     &#123; &#125;,</span><br><span class="line">244 &#125;;</span><br><span class="line">245 </span><br><span class="line">246 static struct i2c_driver ft5x0x_driver &#x3D; &#123;</span><br><span class="line">247     .driver &#x3D; &#123;</span><br><span class="line">248         .name    &#x3D; &quot;ft5x0x&quot;,</span><br><span class="line">249         .owner    &#x3D; THIS_MODULE,</span><br><span class="line">250     &#125;,</span><br><span class="line">251     .probe        &#x3D; ft5x0x_probe,</span><br><span class="line">252     .remove        &#x3D; __devexit_p(ft5x0x_remove),</span><br><span class="line">253     .id_table    &#x3D; ft5x0x_table,</span><br><span class="line">254 &#125;;</span><br><span class="line">255 </span><br><span class="line">256 static int ft5x0x_init(void)</span><br><span class="line">257 &#123;</span><br><span class="line">258     int ret;</span><br><span class="line">259     ret &#x3D; gpio_request(EXYNOS4_GPL0(2), &quot;TP1_EN&quot;);</span><br><span class="line">260     if (ret)</span><br><span class="line">261         printk(KERN_ERR &quot;failed to request TP1_EN for I2C control\n&quot;);</span><br><span class="line">262     </span><br><span class="line">263     gpio_direction_output(EXYNOS4_GPL0(2), 1);</span><br><span class="line">264 </span><br><span class="line">265     s3c_gpio_cfgpin(EXYNOS4_GPL0(2), S3C_GPIO_OUTPUT);</span><br><span class="line">266     gpio_free(EXYNOS4_GPL0(2));</span><br><span class="line">267 </span><br><span class="line">268     mdelay(5);</span><br><span class="line">269     </span><br><span class="line">270     ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">271     if (ret) &#123;</span><br><span class="line">272         gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">273         ret &#x3D; gpio_request(EXYNOS4_GPX0(3), &quot;GPX0_3&quot;);</span><br><span class="line">274         if (ret) &#123;</span><br><span class="line">275             printk(KERN_ERR &quot;failed to request GPX0_3 \n&quot;);</span><br><span class="line">276         &#125;</span><br><span class="line">277     &#125;</span><br><span class="line">278     gpio_direction_output(EXYNOS4_GPX0(3), 0);</span><br><span class="line">279     mdelay(200);</span><br><span class="line">280 </span><br><span class="line">281     gpio_direction_output(EXYNOS4_GPX0(3), 1);</span><br><span class="line">282 </span><br><span class="line">283     s3c_gpio_cfgpin(EXYNOS4_GPX0(3), S3C_GPIO_OUTPUT);</span><br><span class="line">284     gpio_free(EXYNOS4_GPX0(3));</span><br><span class="line">285     msleep(300);</span><br><span class="line">286 </span><br><span class="line">287     touch_size &#x3D; 1;</span><br><span class="line">288     swap_xy &#x3D; 1;</span><br><span class="line">289     </span><br><span class="line">290     return i2c_add_driver(&amp;ft5x0x_driver);</span><br><span class="line">291 &#125;</span><br><span class="line">292 </span><br><span class="line">293 static void ft5x0x_exit(void)</span><br><span class="line">294 &#123;</span><br><span class="line">295     i2c_del_driver(&amp;ft5x0x_driver);</span><br><span class="line">296 &#125;</span><br><span class="line">297 </span><br><span class="line">298 module_init(ft5x0x_init);</span><br><span class="line">299 module_exit(ft5x0x_exit);</span><br><span class="line">300 </span><br><span class="line">301 MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Makefile：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 KERN_DIR &#x3D; &#x2F;work&#x2F;itop4412&#x2F;tools&#x2F;linux-3.5</span><br><span class="line"> 2 </span><br><span class="line"> 3 all:</span><br><span class="line"> 4     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules </span><br><span class="line"> 5 </span><br><span class="line"> 6 clean:</span><br><span class="line"> 7     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules clean</span><br><span class="line"> 8     rm -rf modules.order</span><br><span class="line"> 9 </span><br><span class="line">10 obj-m    +&#x3D; ts.o</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由于触摸屏驱动已经被编译到了内核，我们要先取消它：</p>
<p>$ make menuconfig</p>
<p>Device Drivers —&gt;</p>
<p>Input device support —&gt;</p>
<p>Touchscreens —&gt;</p>
<p>去掉FT5X0X based touchscreens</p>
<p>我并没有编写i2c_client层，而是在mach-itop4412.c中进行更改：</p>
<p>在第2078行代码的基础上，加入#else内容：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if defined(CONFIG_TOUCHSCREEN_FT5X0X)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;ft5x0x_ts&quot;, 0x70&gt;&gt;1),</span><br><span class="line">        .irq &#x3D; IRQ_EINT(4),</span><br><span class="line">        .platform_data &#x3D; &amp;ft5x0x_pdata,</span><br><span class="line">    &#125;,</span><br><span class="line">&#x2F;* 加入的代码 *&#x2F;</span><br><span class="line">#else</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;ft5x0x&quot;, 0x70 &gt;&gt; 1),</span><br><span class="line">    &#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在重新编译烧写内核后，insmod自己的触摸屏驱动，点击屏幕可发现如下现象：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190618112327792-1691058261.png" alt="img"></p>
<p>下一章  <a href="https://www.cnblogs.com/Lioker/p/10933171.html" target="_blank" rel="noopener">16、USB驱动</a></p>
<p>作者：<a href="https://www.cnblogs.com/Lioker/" target="_blank" rel="noopener">Lioker</a></p>
<p>邮箱：<a href="mailto:lioker@outlook.com">lioker@outlook.com</a></p>
<p>作者水平有限，欢迎拍砖。转载请注明出处。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux键盘按键驱动 (详解)</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%20(%E8%AF%A6%E8%A7%A3)/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://www.cnblogs.com/lifexy/" target="_blank" rel="noopener">诺谦</a> 【<a href="https://www.cnblogs.com/lifexy/p/7553861.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7553861.html】</a></p>
<h1 id="13-Linux键盘按键驱动-详解"><a href="#13-Linux键盘按键驱动-详解" class="headerlink" title="13.Linux键盘按键驱动 (详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7553861.html" target="_blank" rel="noopener">13.Linux键盘按键驱动 (详解)</a></h1><p>在<strong><a href="http://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">上一节分析输入子系统</a></strong>内的intput_handler软件处理部分后,接下来我们开始写input_dev驱动</p>
<p><strong>本节目标:</strong></p>
<p>​    实现键盘驱动,让开发板的4个按键代表键盘中的L、S、空格键、回车键</p>
<hr>
<p><strong>1.先来介绍以下几个结构体使用和函数,下面代码中会用到</strong></p>
<p><strong>1)input_dev驱动设备结构体中常用成员如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_dev &#123;      </span><br><span class="line"></span><br><span class="line">       void *private;</span><br><span class="line">       const char *name;  &#x2F;&#x2F;设备名字</span><br><span class="line">       const char *phys;  &#x2F;&#x2F;文件路径,比如 input&#x2F;buttons</span><br><span class="line">       const char *uniq;   </span><br><span class="line">       struct input_id id;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">       unsigned long evbit[NBITS(EV_MAX)];  &#x2F;&#x2F;表示支持哪类事件,常用有以下几种事件(可以多选)</span><br><span class="line">       &#x2F;&#x2F;EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件</span><br><span class="line">       &#x2F;&#x2F;EV_KEY       键盘事件</span><br><span class="line">       &#x2F;&#x2F;EV_REL       (relative)相对坐标事件，比如鼠标</span><br><span class="line">       &#x2F;&#x2F;EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应</span><br><span class="line">       &#x2F;&#x2F;EV_MSC      其他事件,功能</span><br><span class="line">       &#x2F;&#x2F;EV_LED       LED灯事件</span><br><span class="line">       &#x2F;&#x2F;EV_SND      (sound)声音事件</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_REP       重复键盘按键事件</span><br><span class="line">  &#x2F;&#x2F;(内部会定义一个定时器,若有键盘按键事件一直按下&#x2F;松开,就重复定时,时间一到就上报事件)   </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;EV_FF         受力事件</span><br><span class="line">       &#x2F;&#x2F;EV_PWR      电源事件</span><br><span class="line">       &#x2F;&#x2F;EV_FF_STATUS  受力状态事件</span><br><span class="line"></span><br><span class="line">       unsigned long keybit[NBITS(KEY_MAX)];   &#x2F;&#x2F;存放支持的键盘按键值</span><br><span class="line">                                    &#x2F;&#x2F;键盘变量定义在:include&#x2F;linux&#x2F;input.h, 比如: KEY_L(按键L)</span><br><span class="line"></span><br><span class="line">       unsigned long relbit[NBITS(REL_MAX)];    &#x2F;&#x2F;存放支持的相对坐标值</span><br><span class="line">       unsigned long absbit[NBITS(ABS_MAX)];   &#x2F;&#x2F;存放支持的绝对坐标值</span><br><span class="line">       unsigned long mscbit[NBITS(MSC_MAX)];   &#x2F;&#x2F;存放支持的其它事件,也就是功能</span><br><span class="line">       unsigned long ledbit[NBITS(LED_MAX)];    &#x2F;&#x2F;存放支持的各种状态LED</span><br><span class="line">       unsigned long sndbit[NBITS(SND_MAX)];    &#x2F;&#x2F;存放支持的各种声音</span><br><span class="line">       unsigned long ffbit[NBITS(FF_MAX)];       &#x2F;&#x2F;存放支持的受力设备</span><br><span class="line">       unsigned long swbit[NBITS(SW_MAX)];     &#x2F;&#x2F;存放支持的开关功能</span><br><span class="line"></span><br><span class="line"> ... ...</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>2)函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void);  &#x2F;&#x2F;向内核中申请一个input_dev设备,然后返回这个设备</span><br><span class="line">  </span><br><span class="line">input_unregister_device(struct input_dev *dev);   &#x2F;&#x2F;卸载&#x2F;sys&#x2F;class&#x2F;input目录下的input_dev这个类设备, 一般在驱动出口函数写</span><br><span class="line"> </span><br><span class="line">input_free_device(struct input_dev *dev);   &#x2F;&#x2F;释放input_dev这个结构体, 一般在驱动出口函数写</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_bit(nr,p);                  &#x2F;&#x2F;设置某个结构体成员p里面的某位等于nr,支持这个功能</span><br><span class="line">&#x2F;* 比如:</span><br><span class="line">set_bit(EV_KEY,buttons_dev-&gt;evbit);   &#x2F;&#x2F;设置input_dev结构体buttons_dev-&gt;evbit支持EV_KEY</span><br><span class="line">set_bit(KEY_S,buttons_dev-&gt;keybit);  &#x2F;&#x2F;设置input_dev结构体buttons_dev-&gt;keybit支持按键”S”</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);  &#x2F;&#x2F;上报事件</span><br><span class="line"> &#x2F;&#x2F; input_dev *dev :要上报哪个input_dev驱动设备的事件</span><br><span class="line"> &#x2F;&#x2F; type : 要上报哪类事件, 比如按键事件,则填入: EV_KEY</span><br><span class="line"> &#x2F;&#x2F; code: 对应的事件里支持的哪个变量，比如按下按键L则填入: KEY_L</span><br><span class="line"> &#x2F;&#x2F;value:对应的变量里的数值,比如松开按键则填入1,松开按键则填入0</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_sync(struct input_dev *dev); &#x2F;&#x2F;同步事件通知</span><br></pre></td></tr></table></figure>

<p>为什么使用了input_event()上报事件函数,就要使用这个函数？</p>
<p>因为input_event()函数只是个事件函数,所以需要这个input_sync()同步事件函数来通知系统,然后系统才会知道</p>
<p>input_sync()代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void input_sync(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">input_event(dev, EV_SYN, SYN_REPORT, 0); &#x2F;&#x2F;就是上报同步事件,告诉内核:input_event()事件执行完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.然后开始写代码</strong></p>
<p>1)向内核申请input_dev结构体</p>
<p>2)设置input_dev的成员</p>
<p>3)注册input_dev 驱动设备</p>
<p>4)初始化定时器和中断</p>
<p>5)写中断服务函数</p>
<p>6)写定时器超时函数</p>
<p>7)在出口函数中 释放中断函数,删除定时器,卸载释放驱动</p>
<p>具体代码如下(都加了注释):</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;version.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sched.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;pm.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sysctl.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;proc_fs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;delay.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;gpio_keys.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;gpio.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">struct input_dev *buttons_dev;            &#x2F;&#x2F;  定义一个input_dev结构体  </span><br><span class="line">static struct ping_desc *buttons_id;          &#x2F;&#x2F;保存dev_id,在定时器中用</span><br><span class="line">static struct timer_list buttons_timer;    &#x2F;&#x2F;定时器结构体  </span><br><span class="line"></span><br><span class="line">struct  ping_desc&#123;</span><br><span class="line"></span><br><span class="line">       unsigned  char  *name;          &#x2F;&#x2F;中断设备名称</span><br><span class="line">       int            pin_irq;          &#x2F;&#x2F;按键的外部中断标志位</span><br><span class="line">       unsigned  int    pin;                &#x2F;&#x2F;引脚</span><br><span class="line">       unsigned int  irq_ctl;           &#x2F;&#x2F;触发中断状态:   IRQ_TYPE_EDGE_BOTH</span><br><span class="line">       unsigned  int    button;         &#x2F;&#x2F;dev_id,对应键盘的 L ,  S,  空格,  enter      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; KEY1 -&gt; L</span><br><span class="line">        &#x2F;&#x2F; KEY2 -&gt; S</span><br><span class="line">        &#x2F;&#x2F; KEY3 -&gt; 空格</span><br><span class="line">        &#x2F;&#x2F; KEY4 -&gt; enter</span><br><span class="line">static  struct ping_desc   buttons_desc[5]&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">       &#123;&quot;s1&quot;, IRQ_EINT0,   S3C2410_GPF0,  IRQ_TYPE_EDGE_BOTH,KEY_L&#125;,</span><br><span class="line">       &#123;&quot;s2&quot;, IRQ_EINT2,   S3C2410_GPF2,  IRQ_TYPE_EDGE_BOTH,KEY_S&#125;,</span><br><span class="line">       &#123;&quot;s3&quot;, IRQ_EINT11, S3C2410_GPG3 , IRQ_TYPE_EDGE_BOTH,KEY_SPACE&#125;,</span><br><span class="line">       &#123;&quot;s4&quot;, IRQ_EINT19, S3C2410_GPG11,IRQ_TYPE_EDGE_BOTH,KEY_ENTER&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;*5. 写中断服务函数*&#x2F;</span><br><span class="line">static irqreturn_t  buttons_irq (int irq, void *dev_id)       &#x2F;&#x2F;中断服务函数</span><br><span class="line">&#123;</span><br><span class="line">       buttons_id&#x3D;(struct ping_desc *)dev_id;             &#x2F;&#x2F;保存当前的dev_id</span><br><span class="line">       mod_timer(&amp;buttons_timer, jiffies+HZ&#x2F;100 );   &#x2F;&#x2F;更新定时器值 10ms </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;*6.写定时器超时函数*&#x2F;</span><br><span class="line">void buttons_timer_function(unsigned long i)</span><br><span class="line">&#123;</span><br><span class="line">   int val;</span><br><span class="line">   val&#x3D;s3c2410_gpio_getpin(buttons_id-&gt;pin);             &#x2F;&#x2F;获取是什么电平 </span><br><span class="line">  if(val)         &#x2F;&#x2F;高电平,松开</span><br><span class="line">       &#123;</span><br><span class="line">         &#x2F;*上报事件*&#x2F;</span><br><span class="line">         input_event(buttons_dev,EV_KEY,buttons_id-&gt;button, 0);  &#x2F;&#x2F;上报EV_KEY类型,button按键,0(没按下)</span><br><span class="line">         input_sync(buttons_dev);         &#x2F;&#x2F; 上传同步事件,告诉系统有事件出现                       </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  else      &#x2F;&#x2F;低电平，按下</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;*上报事件*&#x2F;</span><br><span class="line">         input_event(buttons_dev, EV_KEY, buttons_id-&gt;button, 1);  &#x2F;&#x2F;上报EV_KEY类型,button按键,1(按下)</span><br><span class="line">         input_sync(buttons_dev);       &#x2F;&#x2F; 上传同步事件,告诉系统有事件出现</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int buttons_init(void)   &#x2F;&#x2F;入口函数</span><br><span class="line">&#123;</span><br><span class="line">       int i;      </span><br><span class="line">       buttons_dev&#x3D;input_allocate_device();  &#x2F;&#x2F;1.向内核 申请input_dev结构体</span><br><span class="line">       &#x2F;*2.设置input_dev ,  *&#x2F;</span><br><span class="line">       set_bit(EV_KEY,buttons_dev-&gt;evbit);       &#x2F;&#x2F;支持键盘事件</span><br><span class="line">       set_bit(EV_REP,buttons_dev-&gt;evbit);       &#x2F;&#x2F;支持键盘重复按事件</span><br><span class="line">    </span><br><span class="line">       set_bit(KEY_L,buttons_dev-&gt;keybit);                  &#x2F;&#x2F;支持按键 L</span><br><span class="line">       set_bit(KEY_S,buttons_dev-&gt;keybit);                &#x2F;&#x2F;支持按键 S</span><br><span class="line">       set_bit(KEY_SPACE,buttons_dev-&gt;keybit);      &#x2F;&#x2F;支持按键 空格</span><br><span class="line">       set_bit(KEY_ENTER,buttons_dev-&gt;keybit);     &#x2F;&#x2F;支持按键 enter</span><br><span class="line"></span><br><span class="line">       &#x2F;*3.注册input_dev *&#x2F;</span><br><span class="line">       input_register_device(buttons_dev);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       &#x2F;*4. 初始化硬件:初始化定时器和中断*&#x2F;      </span><br><span class="line">       &#x2F;&#x2F; KEY1 -&gt; L</span><br><span class="line">       &#x2F;&#x2F; KEY2 -&gt; S</span><br><span class="line">       &#x2F;&#x2F; KEY3 -&gt; 空格</span><br><span class="line">       &#x2F;&#x2F; KEY4 -&gt; enter</span><br><span class="line">       init_timer(&amp;buttons_timer);</span><br><span class="line">       buttons_timer.function&#x3D;buttons_timer_function;</span><br><span class="line">       add_timer(&amp;buttons_timer);</span><br><span class="line"></span><br><span class="line">       for(i&#x3D;0;i&lt;4;i++)</span><br><span class="line">       request_irq(buttons_desc[i].pin_irq, buttons_irq, buttons_desc[i].irq_ctl, buttons_desc[i].name, &amp;buttons_desc[i]);</span><br><span class="line"></span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int buttons_exit(void)  &#x2F;&#x2F;出口函数</span><br><span class="line">&#123;</span><br><span class="line">       &#x2F;*7.释放中断函数,删除定时器,卸载释放驱动*&#x2F;</span><br><span class="line">       int i;</span><br><span class="line">       for(i&#x3D;0;i&lt;4;i++)</span><br><span class="line">              free_irq(buttons_desc[i].pin_irq,&amp;buttons_desc[i]);    &#x2F;&#x2F;释放中断函数</span><br><span class="line"></span><br><span class="line">       del_timer(&amp;buttons_timer);   &#x2F;&#x2F;删除定时器</span><br><span class="line"></span><br><span class="line">       input_unregister_device(buttons_dev);     &#x2F;&#x2F;卸载类下的驱动设备</span><br><span class="line">       input_free_device(buttons_dev);                &#x2F;&#x2F;释放驱动结构体</span><br><span class="line">       return 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(buttons_init);</span><br><span class="line">module_exit(buttons_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>3.测试运行:</strong></p>
<p>挂载键盘驱动后, 如下图,可以通过 ls -l /dev/event*  命令查看已挂载的设备节点:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201709/1182576-20170929163002590-1100491904.png" alt="img"></p>
<p>在<strong><a href="http://www.cnblogs.com/lifexy/p/7542989.html" target="_blank" rel="noopener">上一节输入子系统里分析</a></strong>到:输入子系统的主设备号为13,其中event驱动本身的此设备号是从64开始的,如上图,内核启动时,会加载自带触摸屏驱动,所以我们的键盘驱动的次设备号=64+1</p>
<p><strong>3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令</strong></p>
<p>(exec命令详解入口地址: <strong><a href="http://www.cnblogs.com/lifexy/p/7553228.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7553228.html</a></strong>)</p>
<p>方法1:</p>
<p>cat /dev/tty1   //tty1:LCD终端,就会通过tty_io.c来访问键盘驱动,然后打印在tty1终端上</p>
<p>方法2:</p>
<p>exec 0&lt;/dev/tty1   //将/dev/tty1挂载到-sh进程描述符0下,此时的键盘驱动就会直接打印在tty1终端上</p>
<p><strong>3.2 调试:</strong></p>
<p><strong>若测试不成功,板子又在QT下进行的:</strong></p>
<p>1)可以使用vi命令,在记事本中按按键试</p>
<p>2)或者删除/etc/init.d/rcS 里面有关QT自启动的命令,然后重启</p>
<p><strong>若板子没在QT下进行,也无法测试成功:</strong></p>
<p>1)可以使用hexdump命令来调试代码</p>
<p>(hexdump命令调试代码详解地址:<strong><a href="http://www.cnblogs.com/lifexy/p/7553550.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7553550.html</a></strong>)</p>
<p>接下来开始学习:</p>
<h1 id="14-linux-platform机制实现驱动层分离-详解"><a href="#14-linux-platform机制实现驱动层分离-详解" class="headerlink" title="14.linux-platform机制实现驱动层分离(详解)"></a><a href="https://www.cnblogs.com/lifexy/p/7569371.html" target="_blank" rel="noopener">14.linux-platform机制实现驱动层分离(详解)</a></h1><hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>
<hr>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】I2C驱动框架分析</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3802629.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3802629.html】</a></p>
<h1 id="【Linux高级驱动】I2C驱动框架分析"><a href="#【Linux高级驱动】I2C驱动框架分析" class="headerlink" title="【Linux高级驱动】I2C驱动框架分析"></a><a href="https://www.cnblogs.com/lcw/p/3802629.html" target="_blank" rel="noopener">【Linux高级驱动】I2C驱动框架分析</a></h1><h2 id="1-i2c-dev-c-i2c设备驱动组件层"><a href="#1-i2c-dev-c-i2c设备驱动组件层" class="headerlink" title="1.i2c-dev.c(i2c设备驱动组件层)"></a>1.i2c-dev.c(i2c设备驱动组件层)</h2><p>  <strong>功能</strong>:1)给用户提供接口</p>
<p>i2c_dev_init //入口函数<br> /<em>申请主设备号</em>/</p>
<p>register_chrdev(I2C_MAJOR(89), “i2c”, &amp;i2cdev_fops);<br> /<em>创建一个设备类</em>/<br> i2c_dev_class = class_create(THIS_MODULE, “i2c-dev”);<br> /<em>注册一个i2c驱动</em>/<br> i2c_add_driver(&amp;i2cdev_driver);<br> i2c_register_driver(THIS_MODULE, driver);<br>  /<em>指定总线类型</em>/<br>  driver-&gt;driver.bus = &i2c_bus_type;<br>  /<em>驱动注册<br>  *1.将i2c驱动加入i2c总线的驱动链表<br>  *2.搜索设备链表,实现匹配,根据i2c总线的匹配原理:必须要求i2c驱动结构体中实现id_table<br>  \</em> 但是,i2c驱动结构体中并没有实现id_table,所以永远都匹配失败<br>  */<br>  driver_register(&amp;driver-&gt;driver);</p>
<p>  /<em>搜索适配器链表,每搜索一个适配器,都会调用__process_new_driver函数<br>  <em>在此函数中,又会调用i2c驱动中的,attach_adapter函数<br>  */<br>  bus_for_each_dev(&amp;i2c_bus_type, NULL, driver, __process_new_driver);<br>  __process_new_driver //此函数可能会被调用多次<br>  i2c_do_add_adapter(data, to_i2c_adapter(dev));<br>   *</em>if** (driver-&gt;attach_adapter) {<br>   /</em> We ignore the return code; if it fails, too bad */<br>   driver-&gt;attach_adapter(adap);  //i2cdev_attach_adapter<br>   }</p>
<p><strong>static</strong> <strong>const</strong> <strong>struct</strong> file_operations i2cdev_fops = {<br> .owner = THIS_MODULE,<br> .llseek = no_llseek,<br> .read = i2cdev_read,<br> .write = i2cdev_write,<br> .unlocked_ioctl = i2cdev_ioctl,<br> .open = i2cdev_open,<br> .release = i2cdev_release,<br>};<br><strong>static</strong> <strong>struct</strong> i2c_driver i2cdev_driver = {<br> .driver = {<br> .name = “dev_driver”,<br> },<br> .attach_adapter = i2cdev_attach_adapter,<br> .detach_adapter = i2cdev_detach_adapter,<br>};</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-i2c-core-c-i2c核心层组件"><a href="#2-i2c-core-c-i2c核心层组件" class="headerlink" title="2.i2c-core.c(i2c核心层组件)"></a>2.i2c-core.c(i2c核心层组件)</h2><p>  <strong>功能</strong>:1)注册一条i2c总线<br>     2)提供基本的接口函数,用来建立上层与下层的连接</p>
<p>i2c_init //入口函数<br> /<em>注册I2C总线</em>/<br> bus_register(&amp;i2c_bus_type);</p>
<p><strong>struct</strong> bus_type i2c_bus_type = { //实际的物理总线,I2C总线<br> .name = “i2c”,<br> .match = i2c_device_match, //匹配函数<br> .probe = i2c_device_probe,<br> .remove = i2c_device_remove,<br> .shutdown = i2c_device_shutdown,<br> .pm = &amp;i2c_device_pm_ops,<br>};<br><strong>static</strong> <strong>int</strong> i2c_device_match(<strong>struct</strong> device <em>dev, <strong>struct</strong> device_driver <em>drv)<br>{<br> *</em>struct** i2c_client <em>client = i2c_verify_client(dev);<br> *</em>struct** i2c_driver <em>driver;<br> *</em>if** (!client)<br> <strong>return</strong> 0;<br> driver = to_i2c_driver(drv);<br> /</em> match on an id table if there is one <em>/<br> *</em>if** (driver-&gt;id_table)<br> <strong>return</strong> i2c_match_id(driver-&gt;id_table, client) != NULL;<br>  <strong>while</strong> (id-&gt;name[0]) {<br>   <strong>if</strong> (strcmp(client-&gt;name, id-&gt;name) == 0)<br>   <strong>return</strong> id;<br>   id++;<br>  }<br> <strong>return</strong> 0;<br>}</p>
<h3 id="涉及的重要结构体"><a href="#涉及的重要结构体" class="headerlink" title="涉及的重要结构体:"></a>涉及的重要结构体:</h3><p><strong>struct</strong> i2c_client {   //表示一个i2c设备<br> <strong>unsigned</strong> <strong>short</strong> flags;  /* div., see below <em>/<br> <strong>unsigned</strong> <strong>short</strong> addr;  /*器件地址</em>/<br> <strong>char</strong> name[I2C_NAME_SIZE]; /<em>名字</em>/<br> <strong>struct</strong> i2c_adapter <em>adapter; /*所属适配器,所属控制器</em>/<br> <strong>struct</strong> i2c_driver <em>driver; /*设备驱动</em>/<br> <strong>struct</strong> device dev;  /* the device structure <em>/<br> <strong>int</strong> irq;   /</em> irq issued by device <em>/<br> <strong>struct</strong> list_head detected;<br>};<br><strong>struct</strong> i2c_driver {   //用来表示i2c驱动<br> <strong>unsigned</strong> <strong>int</strong> <strong>class</strong>;<br> /</em> Notifies the driver that a new bus has appeared or is about to be<br> * removed. You should avoid using this if you can, it will probably<br> * be removed in a near future.<br> <em>/<br> <strong>int</strong> (<em>attach_adapter)(*</em>struct** i2c_adapter <em>);<br> *</em>int** (<em>detach_adapter)(*</em>struct** i2c_adapter <em>);<br> /</em>probe函数:初始化工作,设备检测,</em>/<br> <strong>int</strong> (<em>probe)(<strong>struct</strong> i2c_client <em>, *</em>const** <strong>struct</strong> i2c_device_id <em>);<br> *</em>int** (<em>remove)(*</em>struct** i2c_client <em>);<br> *</em>struct** device_driver driver;  //设备驱动<br> <strong>const</strong> <strong>struct</strong> i2c_device_id <em>id_table; //指定此驱动能为哪些设备服务<br> …<br> …<br>};<br>*</em>struct** i2c_adapter {  //表示一个i2c适配器/i2c控制器<br> <strong>const</strong> <strong>struct</strong> i2c_algorithm *algo; /</em> the algorithm to access the bus <em>/<br> /*操作方法</em>/<br> <strong>int</strong> (<em>master_xfer)(<strong>struct</strong> i2c_adapter <em>adap, *</em>struct** i2c_msg <em>msgs,*</em>int** num);<br> <strong>int</strong> nr;   /*适配器的号码</em>/<br> …<br> …<br>};<br><strong>struct</strong> i2c_msg {   //表示一个i2c数据包<br> __u16 addr;   /<em>设备地址</em>/<br> __u16 flags;   /<em>表示:1-表示读包 0-表示写包</em>/<br> __u16 len;   /<em>数据包的长度</em>/<br> __u8 <em>buf;   /*真正的数据</em>/<br> …<br> …<br>};</p>
<h3 id="涉及的重要函数接口"><a href="#涉及的重要函数接口" class="headerlink" title="涉及的重要函数接口:"></a>涉及的重要函数接口:</h3><p>/<em>注册一个i2c控制器</em>/<br><strong>int</strong> i2c_add_adapter(<strong>struct</strong> i2c_adapter <em>adapter)<br><strong>int</strong> i2c_del_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>/</em>注册i2c驱动</em>/<br><strong>int</strong> i2c_add_driver(<strong>struct</strong> i2c_driver <em>driver)<br><strong>int</strong> i2c_add_numbered_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>*</em>int** i2c_del_numbered_adapter(<strong>struct</strong> i2c_adapter <em>adap)<br>*</em>extern** <strong>int</strong> i2c_del_driver(<strong>struct</strong> i2c_driver <em>driver);<br>/</em>接收i2c数据包</em>/<br><strong>int</strong> i2c_master_recv(<strong>struct</strong> i2c_client <em>client, <strong>char</strong> <em>buf, *</em>int** count)<br>/*发送i2c数据包</em>/<br><strong>int</strong> i2c_master_send(<strong>struct</strong> i2c_client <em>client, <strong>const</strong> <strong>char</strong> <em>buf, *</em>int** count)<br>/*提交i2c数据包到总线驱动层</em>/<br><strong>int</strong> i2c_transfer(<strong>struct</strong> i2c_adapter <em>adap, *</em>struct** i2c_msg <em>msgs, *</em>int** num)</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-busses目录-i2c总线驱动-i2c控制器驱动-i2c适配器驱动"><a href="#3-busses目录-i2c总线驱动-i2c控制器驱动-i2c适配器驱动" class="headerlink" title="3.busses目录:i2c总线驱动/i2c控制器驱动/i2c适配器驱动"></a>3.busses目录:i2c总线驱动/i2c控制器驱动/i2c适配器驱动</h2><p>  i2c-s3c2410.c</p>
<p>  <strong>功能</strong>:1)实现对i2c控制器的初始化<br>     2)实现操作方法(实现i2c协议,完成数据的发送)</p>
<h2 id="如何用通用接口驱动来操作i2c设备"><a href="#如何用通用接口驱动来操作i2c设备" class="headerlink" title="如何用通用接口驱动来操作i2c设备"></a>如何用通用接口驱动来操作i2c设备</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h1 id="app-open-“-dev-i2c-0”-O-RDWR"><a href="#app-open-“-dev-i2c-0”-O-RDWR" class="headerlink" title="app: open(“/dev/i2c-0”, O_RDWR);"></a>app: open(“/dev/i2c-0”, O_RDWR);</h1><p>sys: sys_open<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .open = i2cdev_open,<br>   /<em>构建一个i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client;<br>   <strong>struct</strong> i2c_adapter <em>adap;<br>   /</em>获取适配器</em>/<br>   adap = i2c_get_adapter(i2c_dev-&gt;adap-&gt;nr);<br>   client = kzalloc(<strong>sizeof</strong>(*client), GFP_KERNEL);<br>   client-&gt;driver = &i2cdev_driver; //指定i2c设备驱动<br>   client-&gt;adapter = adap;   //指定适配器<br>   file-&gt;private_data = client;</p>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><h1 id="app-ioctl-fd-I2C-SLAVE-0x48"><a href="#app-ioctl-fd-I2C-SLAVE-0x48" class="headerlink" title="app: ioctl(fd, I2C_SLAVE, 0x48)"></a>app: ioctl(fd, I2C_SLAVE, 0x48)</h1><p>sys: sys_ioctl<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .unlocked_ioctl = i2cdev_ioctl,<br>   /<em>获取i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client = file-&gt;private_data;<br>   *</em>switch** (cmd) {<br>   <strong>case</strong> I2C_SLAVE:  I2C_M_TEN:是否为10位寻址的设备<br>    <strong>if</strong> ((arg &gt; 0x3ff) ||(((client-&gt;flags &amp; I2C_M_TEN) == 0) &amp;&amp; arg &gt; 0x7f))<br>    <strong>return</strong> -EINVAL;<br>    client-&gt;addr = arg; //0x48<br>   }</p>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h1 id="app-write-fd-wbuf-1"><a href="#app-write-fd-wbuf-1" class="headerlink" title="app: write(fd, wbuf, 1)"></a>app: write(fd, wbuf, 1)</h1><p>sys: sys_write<br>  …<br>  …<br>i2c-dev.c <strong>struct</strong> file_operations i2cdev_fops<br>  .write = i2cdev_write,<br>   /<em>获取i2c_client</em>/<br>   <strong>struct</strong> i2c_client <em>client = file-&gt;private_data;<br>   *</em>char** *tmp;<br>   tmp = kmalloc(count, GFP_KERNEL);<br>   copy_from_user(tmp, buf, count)</p>
<p>   /<em>发送数据到核心层</em>/<br>i2c-core.c  i2c_master_send(client, tmp, count);<br>   <strong>struct</strong> i2c_msg msg;  //表示i2c数据包<br>   /<em>填充数据包</em>/<br>   msg.addr = client-&gt;addr;  //0x48<br>   msg.flags = client-&gt;flags &amp; I2C_M_TEN; //写<br>   msg.len = count;   //1<br>   msg.buf = (<strong>char</strong> <em>)buf;   //wbuf 0x0<br>   /*提交数据给总线驱动层</em>/<br>   i2c_transfer(adap, &amp;msg, 1);<br>    <strong>if</strong> (adap-&gt;algo-&gt;master_xfer)<br>i2c_s3c2410.c   adap-&gt;algo-&gt;master_xfer(adap, msgs, num);  //s3c24xx_i2c_xfer<br>     s3c24xx_i2c_xfer</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux 触摸屏驱动分析</title>
    <url>/2021/01/12/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文转载<a href="https://blog.csdn.net/bingxx11/article/details/7905364" target="_blank" rel="noopener">https://blog.csdn.net/bingxx11/article/details/7905364</a></p>
<p>一.、前提知识</p>
<p>1、Linux输入子系统(Input Subsystem)：</p>
<p>   在Linux中，输入子系统是由输入子系统设备驱动层、输入子系统核心层(Input Core)和输入子系统事件处理层(Event Handler)组成。其中设备驱动层提供对硬件各寄存器的读写访问和将底层硬件对用户输入访问的响应转换为标准的输入事件，再通过核心层提交给事件处理层；而核心层对下提供了设备驱动层的编程接口，对上又提供了事件处理层的编程接口；而事件处理层就为我们用户空间的应用程序提供了统一访问设备的接口和驱动层提交来的事件处理。所以这使得我们输入设备的驱动部分不在用关心对设备文件的操作，而是要关心对各硬件寄存器的操作和提交的输入事件。下面用图形来描述一下这三者的关系吧！<br>另外，又找了另一幅图来说明Linux输入子系统的结构，可能更加形象容易理解。如下：</p>
<p>2、输入子系统设备驱动层实现原理：</p>
<p>   在Linux中，Input设备用input_dev结构体描述，定义在input.h中。设备的驱动只需按照如下步骤就可实现了。<br>①、在驱动模块加载函数中设置Input设备支持input子系统的哪些事件；<br>②、将Input设备注册到input子系统中；<br>③、在Input设备发生输入操作时(如：键盘被按下/抬起、触摸屏被触摸/抬起/移动、鼠标被移动/单击/抬起时等)，提交所发生的事件及对应的键值/坐标等状态。</p>
<p>Linux中输入设备的事件类型有(这里只列出了常用的一些，更多请看linux/input.h中)：</p>
<p>EV_SYN     0x00     同步事件<br>       EV_KEY     0x01     按键事件<br>       EV_REL     0x02     相对坐标(如：鼠标移动，报告的是相对最后一次位置的偏移)<br>       EV_ABS     0x03     绝对坐标(如：触摸屏和操作杆，报告的是绝对的坐标位置)<br>       EV_MSC     0x04     其它<br>      EV_LED     0x11     LED<br>      EV_SND     0x12     声音<br>      EV_REP     0x14     Repeat<br>      EV_FF      0x15     力反馈</p>
<p>用于提交较常用的事件类型给输入子系统的函数有：</p>
<p>void input_report_key(struct input_dev *dev, unsigned int code, int value); //提交按键事件的函数<br>void input_report_rel(struct input_dev *dev, unsigned int code, int value); //提交相对坐标事件的函数<br>void input_report_abs(struct input_dev *dev, unsigned int code, int value); //提交绝对坐标事件的函数</p>
<p>注意，在提交输入设备的事件后必须用下列方法使事件同步，让它告知input系统，设备驱动已经发出了一个完整的报告：</p>
<p>void input_sync(struct input_dev *dev)</p>
<p>二、触摸屏驱动的实现步骤</p>
<p>1、硬件原理图分析：</p>
<p>   S3c2440芯片内部触摸屏接口与ADC接口是集成在一起的，硬件结构原理图请看：S3C2440上ADC驱动实例开发讲解中的图，其中通道7(XP或AIN7)作为触摸屏接口的X坐标输入，通道5(YP或AIN5)作为触摸屏接口的Y坐标输入。在”S3C2440上ADC驱动实例开发讲解”中，AD转换的模拟信号是由开发板上的一个电位器产生并通过通道1(AIN0)输入的，而这里的模拟信号则是由点触触摸屏所产生的X坐标和Y坐标两个模拟信号，并分别通过通道7和通道5输入。S3c2440提供的触摸屏接口有4种处理模式，分别是：正常转换模式、单独的X/Y位置转换模式、自动X/Y位置转换模式和等待中断模式，对于在每种模式下工作的要求，请详细查看数据手册的描述。本驱动实例将采用自动X/Y位置转换模式和等待中断模式。</p>
<p>注意：在每步中，为了让代码逻辑更加有条理和容易理解，就没有考虑代码的顺序，比如函数要先定义后调用。如果要编译此代码，请严格按照C语言的规范来调整代码的顺序。</p>
<p>2、建立触摸屏驱动程序my2440_ts.c，首先实现加载和卸载部分，在驱动加载部分，我们主要做的事情是：启用ADC所需要的时钟、映射IO口、初始化寄存器、申请中断、初始化输入设备、将输入设备注册到输入子系统。代码如下：</p>
<p>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/clk.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/input.h&gt;<br>#include &lt;linux/serio.h&gt;<br>#include &lt;plat/regs-adc.h&gt;<br>#include &lt;asm/irq.h&gt;<br>#include &lt;asm/io.h&gt;</p>
<p>/<em>用于保存从平台时钟列表中获取的ADC时钟</em>/<br>static struct clk <em>adc_clk;<br>/*定义了一个用来保存经过虚拟映射后的内存地址</em>/<br>static void __iomem <em>adc_base;<br>/*定义一个输入设备来表示我们的触摸屏设备</em>/<br>static struct input_dev <em>ts_dev;<br>/*设备名称</em>/<br>#define DEVICE_NAME    “my2440_TouchScreen”<br>/<em>定义一个WAIT4INT宏，该宏将对ADC触摸屏控制寄存器进行操作<br>S3C2410_ADCTSC_YM_SEN这些宏都定义在regs-adc.h中</em>/<br>#define WAIT4INT(x)    (((x)&lt;&lt;8) | S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | <br>                    S3C2410_ADCTSC_XP_SEN | S3C2410_ADCTSC_XY_PST(3))<br>static int __init ts_init(void)<br>{<br>    int ret;<br>    /<em>从平台时钟队列中获取ADC的时钟，这里为什么要取得这个时钟，因为ADC的转换频率跟时钟有关。<br>    系统的一些时钟定义在arch/arm/plat-s3c24xx/s3c2410-clock.c中</em>/<br>    adc_clk = clk_get(NULL, “adc”);<br>    if(!adc_clk)<br>    {<br>        /<em>错误处理</em>/<br>        printk(KERN_ERR “falied to find adc clock source\n”);<br>        return -ENOENT;<br>    }<br>    /<em>时钟获取后要使能后才可以使用，clk_enable定义在arch/arm/plat-s3c/clock.c中</em>/<br>    clk_enable(adc_clk);<br>    /<em>将ADC的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中。<br>     注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作,<br>     S3C2410_PA_ADC是ADC控制器的基地址，定义在mach-s3c2410/include/mach/map.h中，0x20是虚拟地址长度大小</em>/<br>    adc_base = ioremap(S3C2410_PA_ADC, 0x20);<br>    if(adc_base == NULL)<br>    {<br>        /<em>错误处理</em>/<br>        printk(KERN_ERR “failed to remap register block\n”);<br>        ret = -EINVAL;<br>        goto err_noclk;<br>    }<br>    /<em>初始化ADC控制寄存器和ADC触摸屏控制寄存器</em>/<br>    adc_initialize();<br>    /<em>申请ADC中断，AD转换完成后触发。这里使用共享中断IRQF_SHARED是因为该中断号在ADC驱动中也使用了，<br>    最后一个参数1是随便给的一个值，因为如果不给值设为NULL的话，中断就申请不成功</em>/<br>    ret = request_irq(IRQ_ADC, adc_irq, IRQF_SHARED | IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);<br>    if(ret)<br>    {<br>        printk(KERN_ERR “IRQ%d error %d\n”, IRQ_ADC, ret);<br>        ret = -EINVAL;<br>        goto err_nomap;<br>    }<br>    /<em>申请触摸屏中断，对触摸屏按下或提笔时触发</em>/<br>    ret = request_irq(IRQ_TC, tc_irq, IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);<br>    if(ret)<br>    {<br>        printk(KERN_ERR “IRQ%d error %d\n”, IRQ_TC, ret);<br>        ret = -EINVAL;<br>        goto err_noirq;<br>    }<br>    /<em>给输入设备申请空间，input_allocate_device定义在input.h中</em>/<br>    ts_dev = input_allocate_device();<br>    /<em>下面初始化输入设备，即给输入设备结构体input_dev的成员设置值。<br>    evbit字段用于描述支持的事件，这里支持同步事件、按键事件、绝对坐标事件，<br>    BIT宏实际就是对1进行位操作，定义在linux/bitops.h中</em>/<br>    ts_dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);</p>
<pre><code>/*keybit字段用于描述按键的类型，在input.h中定义了很多，这里用BTN_TOUCH类型来表示触摸屏的点击*/
ts_dev-&gt;keybit[BITS_TO_LONGS(BTN_TOUCH)] = BIT(BTN_TOUCH);
/*对于触摸屏来说，使用的是绝对坐标系统。这里设置该坐标系统中X和Y坐标的最小值和最大值(0-1023范围)
ABS_X和ABS_Y就表示X坐标和Y坐标，ABS_PRESSURE就表示触摸屏是按下还是抬起状态*/
input_set_abs_params(ts_dev, ABS_X, 0, 0x3FF, 0, 0);
input_set_abs_params(ts_dev, ABS_Y, 0, 0x3FF, 0, 0);
input_set_abs_params(ts_dev, ABS_PRESSURE, 0, 1, 0, 0);
/*以下是设置触摸屏输入设备的身份信息，直接在这里写死。
这些信息可以在驱动挂载后在/proc/bus/input/devices中查看到*/
ts_dev-&gt;name          = DEVICE_NAME;   /*设备名称*/
ts_dev-&gt;id.bustype    = BUS_RS232;     /*总线类型*/    
ts_dev-&gt;id.vendor     = 0xDEAD;        /*经销商ID号*/
ts_dev-&gt;id.product    = 0xBEEF;        /*产品ID号*/
ts_dev-&gt;id.version    = 0x0101;        /*版本ID号*/
/*好了，一些都准备就绪，现在就把ts_dev触摸屏设备注册到输入子系统中*/
input_register_device(ts_dev);
return 0;</code></pre><p>/<em>下面是错误跳转处理</em>/<br>err_noclk:<br>    clk_disable(adc_clk);<br>    clk_put(adc_clk);<br>err_nomap:<br>    iounmap(adc_base);<br>err_noirq:<br>    free_irq(IRQ_ADC, 1);<br>    return ret;<br>}<br>/<em>初始化ADC控制寄存器和ADC触摸屏控制寄存器</em>/<br>static void adc_initialize(void)<br>{<br>    /<em>计算结果为(二进制)：111111111000000，再根据数据手册得知<br>    此处是将AD转换预定标器值设为255、AD转换预定标器使能有效</em>/<br>    writel(S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(0xFF), adc_base + S3C2410_ADCCON);<br>    /<em>对ADC开始延时寄存器进行设置，延时值为0xffff</em>/<br>    writel(0xffff, adc_base + S3C2410_ADCDLY);<br>    /<em>WAIT4INT宏计算结果为(二进制)：11010011，再根据数据手册得知<br>    此处是将ADC触摸屏控制寄存器设置成等待中断模式</em>/<br>    writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);<br>}<br>static void __exit ts_exit(void)<br>{<br>    /<em>屏蔽和释放中断</em>/<br>    disable_irq(IRQ_ADC);<br>    disable_irq(IRQ_TC);<br>    free_irq(IRQ_ADC, 1);<br>    free_irq(IRQ_TC, 1);<br>    /<em>释放虚拟地址映射空间</em>/<br>    iounmap(adc_base);<br>    /<em>屏蔽和销毁时钟</em>/<br>    if(adc_clk)<br>    {<br>        clk_disable(adc_clk);<br>        clk_put(adc_clk);<br>        adc_clk = NULL;<br>    }<br>    /<em>将触摸屏设备从输入子系统中注销</em>/<br>    input_unregister_device(ts_dev);<br>}<br>module_init(ts_init);<br>module_exit(ts_exit);<br>MODULE_LICENSE(“GPL”);<br>MODULE_AUTHOR(“Huang Gang”);<br>MODULE_DESCRIPTION(“My2440 Touch Screen Driver”);</p>
<p>3、接下来要做的是，在两个中断服务程序中实现触摸屏状态和坐标的转换。先看代码，如下：</p>
<p>/<em>定义一个外部的信号量ADC_LOCK，因为ADC_LOCK在ADC驱动程序中已申明<br>这样就能保证ADC资源在ADC驱动和触摸屏驱动中进行互斥访问</em>/<br>extern struct semaphore ADC_LOCK;<br>/<em>做为一个标签，只有对触摸屏操作后才对X和Y坐标进行转换</em>/<br>static int OwnADC = 0;<br>/<em>用于记录转换后的X坐标值和Y坐标值</em>/<br>static long xp;<br>static long yp;<br>/<em>用于计数对触摸屏压下或抬起时模拟输入转换的次数</em>/<br>static int count;<br>/<em>定义一个AUTOPST宏，将ADC触摸屏控制寄存器设置成自动转换模式</em>/<br>#define AUTOPST    (S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | <br>                S3C2410_ADCTSC_AUTO_PST | S3C2410_ADCTSC_XY_PST(0))<br>/<em>触摸屏中断服务程序，对触摸屏按下或提笔时触发执行</em>/<br>static irqreturn_t tc_irq(int irq, void <em>dev_id)<br>{<br>    /*用于记录这一次AD转换后的值</em>/<br>    unsigned long data0;<br>    unsigned long data1;<br>    /<em>用于记录触摸屏操作状态是按下还是抬起</em>/<br>    int updown;<br>    /<em>ADC资源可以获取，即上锁</em>/<br>    if (down_trylock(&amp;ADC_LOCK) == 0)<br>    {<br>        /<em>标识对触摸屏进行了操作</em>/<br>        OwnADC = 1;<br>        /<em>读取这一次AD转换后的值，注意这次主要读的是状态</em>/<br>        data0 = readl(adc_base + S3C2410_ADCDAT0);<br>        data1 = readl(adc_base + S3C2410_ADCDAT1);<br>        /<em>记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN</em>/<br>        updown = (!(data0 &amp; S3C2410_ADCDAT0_UPDOWN)) &amp;&amp; (!(data1 &amp; S3C2410_ADCDAT0_UPDOWN));<br>        /<em>判断触摸屏的操作状态</em>/<br>        if (updown)<br>        {<br>            /<em>如果是按下状态，则调用touch_timer_fire函数来启动ADC转换，该函数定义后面再讲</em>/<br>            touch_timer_fire(0);<br>        }<br>        else<br>        {<br>            /<em>如果是抬起状态，就结束了这一次的操作，所以就释放ADC资源的占有</em>/<br>            OwnADC = 0;<br>            up(&amp;ADC_LOCK);<br>        }<br>    }<br>    return IRQ_HANDLED;<br>}<br>static void touch_timer_fire(unsigned long data)<br>{<br>    /<em>用于记录这一次AD转换后的值</em>/<br>      unsigned long data0;<br>      unsigned long data1;<br>    /<em>用于记录触摸屏操作状态是按下还是抬起</em>/<br>    int updown;<br>    /<em>读取这一次AD转换后的值，注意这次主要读的是状态</em>/<br>      data0 = readl(adc_base + S3C2410_ADCDAT0);<br>    data1 = readl(adc_base + S3C2410_ADCDAT1);<br>    /<em>记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN</em>/<br>     updown = (!(data0 &amp; S3C2410_ADCDAT0_UPDOWN)) &amp;&amp; (!(data1 &amp; S3C2410_ADCDAT0_UPDOWN));<br>    /<em>判断触摸屏的操作状态</em>/<br>     if (updown)<br>    {<br>        /<em>如果状态是按下，并且ADC已经转换了就报告事件和数据</em>/<br>         if (count != 0)<br>        {<br>            long tmp;</p>
<pre><code>tmp = xp;
xp = yp;
yp = tmp;

xp &gt;&gt;= 2;
yp &gt;&gt;= 2;</code></pre><p>#ifdef CONFIG_TOUCHSCREEN_MY2440_DEBUG<br>            /<em>触摸屏调试信息，编译内核时选上此项后，点击触摸屏会在终端上打印出坐标信息</em>/<br>            struct timeval tv;<br>            do_gettimeofday(&amp;tv);<br>            printk(KERN_DEBUG “T: %06d, X: %03ld, Y: %03ld\n”, (int)tv.tv_usec, xp, yp);<br>#endif<br>            /<em>报告X、Y的绝对坐标值</em>/<br>             input_report_abs(ts_dev, ABS_X, xp);<br>             input_report_abs(ts_dev, ABS_Y, yp);<br>            /<em>报告触摸屏的状态，1表明触摸屏被按下</em>/<br>            input_report_abs(ts_dev, ABS_PRESSURE, 1);<br>            /<em>报告按键事件，键值为1(代表触摸屏对应的按键被按下)</em>/<br>             input_report_key(ts_dev, BTN_TOUCH, 1);<br>            /<em>等待接收方受到数据后回复确认，用于同步</em>/<br>             input_sync(ts_dev);<br>         }<br>        /<em>如果状态是按下，并且ADC还没有开始转换就启动ADC进行转换</em>/<br>         xp = 0;<br>         yp = 0;<br>         count = 0;<br>        /<em>设置触摸屏的模式为自动转换模式</em>/<br>         writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);<br>        /<em>启动ADC转换</em>/<br>         writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);<br>     }<br>    else<br>    {<br>        /<em>否则是抬起状态</em>/<br>         count = 0;<br>        /<em>报告按键事件，键值为0(代表触摸屏对应的按键被释放)</em>/<br>         input_report_key(ts_dev, BTN_TOUCH, 0);<br>        /<em>报告触摸屏的状态，0表明触摸屏没被按下</em>/<br>         input_report_abs(ts_dev, ABS_PRESSURE, 0);<br>        /<em>等待接收方受到数据后回复确认，用于同步</em>/<br>         input_sync(ts_dev);<br>        /<em>将触摸屏重新设置为等待中断状态</em>/<br>         writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);<br>        /<em>如果触摸屏抬起，就意味着这一次的操作结束，所以就释放ADC资源的占有</em>/<br>        if (OwnADC)<br>        {<br>            OwnADC = 0;<br>            up(&amp;ADC_LOCK);<br>        }<br>     }<br>}<br>/<em>定义并初始化了一个定时器touch_timer，定时器服务程序为touch_timer_fire</em>/<br>static struct timer_list touch_timer = TIMER_INITIALIZER(touch_timer_fire, 0, 0);<br>/<em>ADC中断服务程序，AD转换完成后触发执行</em>/<br>static irqreturn_t adc_irq(int irq, void <em>dev_id)<br>{<br>    /*用于记录这一次AD转换后的值</em>/<br>    unsigned long data0;<br>    unsigned long data1;<br>    if(OwnADC)<br>    {<br>        /<em>读取这一次AD转换后的值，注意这次主要读的是坐标</em>/<br>        data0 = readl(adc_base + S3C2410_ADCDAT0);<br>        data1 = readl(adc_base + S3C2410_ADCDAT1);<br>        /<em>记录这一次通过AD转换后的X坐标值和Y坐标值，根据数据手册可知，X和Y坐标转换数值<br>        分别保存在数据寄存器0和1的第0-9位，所以这里与上S3C2410_ADCDAT0_XPDATA_MASK就是取0-9位的值</em>/<br>        xp += data0 &amp; S3C2410_ADCDAT0_XPDATA_MASK;<br>        yp += data1 &amp; S3C2410_ADCDAT1_YPDATA_MASK;<br>        /<em>计数这一次AD转换的次数</em>/<br>        count++;<br>        if (count &lt; (1&lt;&lt;2))<br>        {<br>            /<em>如果转换的次数小于4，则重新启动ADC转换</em>/<br>            writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);<br>            writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);<br>        }<br>        else<br>        {<br>            /<em>否则，启动1个时间滴答的定时器，这是就会去执行定时器服务程序上报事件和数据</em>/<br>            mod_timer(&amp;touch_timer, jiffies + 1);<br>            writel(WAIT4INT(1), adc_base + S3C2410_ADCTSC);<br>        }<br>    }<br>    return IRQ_HANDLED;<br>}</p>
<p>我们从整体上描述转换这个的过程：<br>(1)如果触摸屏感觉到触摸，则触发触摸屏中断即进入tc_irq，获取ADC_LOCK后判断触摸屏状态为按下，则调用touch_timer_fire启动ADC转换；<br>(2)当ADC转换启动后，触发ADC中断即进入adc_irq，如果这一次转换的次数小于4，则重新启动ADC进行转换，如果4次完毕后，启动1个时间滴答的定时器，停止ADC转换，也就是说在这个时间滴答内，ADC转换是停止的；<br>(3)这里为什么要在1个时间滴答到来之前停止ADC的转换呢？这是为了防止屏幕抖动。<br>(4)如果1个时间滴答到来则进入定时器服务程序touch_timer_fire，判断触摸屏仍然处于按下状态则上报事件和转换的数据，并重启ADC转换，重复第(2)步；<br>(5)如果触摸抬起了，则上报释放事件，并将触摸屏重新设置为等待中断状态。</p>
<p>四、移植和测试触摸屏驱动程序</p>
<pre><code>移植和测试请看Linux-2.6.30.4在2440上的移植之触摸屏驱动</code></pre><p>移植和测试请看<a href="http://blog.chinaunix.net/u3/101649/showart_2085414.html" target="_blank" rel="noopener">Linux-2.6.30.4在2440上的移植之触摸屏驱动</a></p>
]]></content>
  </entry>
  <entry>
    <title>【转载】I2C的前生今世</title>
    <url>/2021/01/25/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91I2C%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/</url>
    <content><![CDATA[<p>本文转自：【<a href="http://zjunweihit.github.io/】" target="_blank" rel="noopener">http://zjunweihit.github.io/】</a></p>
<h1 id="I2C的前生今世"><a href="#I2C的前生今世" class="headerlink" title="I2C的前生今世"></a><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/" target="_blank" rel="noopener">I2C的前生今世</a></h1><p>By <a href="http://zjunweihit.github.io/about" target="_blank" rel="noopener">zjunweihit</a></p>
<p> Published 2016-10-27</p>
<p><strong>Contents</strong></p>
<ol>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#Abstract" target="_blank" rel="noopener">1. Abstract</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#Overview" target="_blank" rel="noopener">2. Overview</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#I2C驱动结构" target="_blank" rel="noopener">3. I2C驱动结构</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#I2C核心" target="_blank" rel="noopener">4. I2C核心</a></li>
<li>\5. I2C 主控制器（adapter）<ol>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#i2c-adapter" target="_blank" rel="noopener">5.1. i2c_adapter</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#i2c-algorithm" target="_blank" rel="noopener">5.2. i2c_algorithm</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#i2c-adapter-注册" target="_blank" rel="noopener">5.3. i2c_adapter 注册</a></li>
</ol>
</li>
<li>\6. i2c slave<ol>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#Register-slave-device" target="_blank" rel="noopener">6.1. Register slave device</a></li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#Register-slave-driver" target="_blank" rel="noopener">6.2. Register slave driver</a></li>
</ol>
</li>
<li><a href="http://zjunweihit.github.io/2016/10/27/linux-dev-i2c/#Reference" target="_blank" rel="noopener">7. Reference</a></li>
</ol>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>I2C是常用的总线，关于什么是I2C以及I2C怎么传输数据的（时序）这里就不再赘余，可以在百度里google一下。</li>
<li>I2C传输并不很复杂，但是在Linux的驱动框架中，为了有更好的扩展性，出现了很多相对独立的模块。下面一一介绍。</li>
<li>以下内容基于：linux-3.4, i.MX6 SABRESD platform, RTC(rs5c372) driver.</li>
<li>Referring to <a href="http://blog.csdn.net/w2baby1314/article/details/8081993" target="_blank" rel="noopener">http://blog.csdn.net/w2baby1314/article/details/8081993</a></li>
</ul>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><ul>
<li><p>I2C是一个独立的总线，其类型为i2c_bus_type，类似于platform_device一样。所以先要有I2C总线设备</p>
<ul>
<li><p>注册I2C总线设备, 对应的driver为dummy_driver</p>
</li>
<li><p>注册I2C主控制器（i2c_adapter）到I2C总线上，在注册过程中，依据板级代码(board-mx6q_sabresd.c)中初始化的i2c_board_info（devinfo）创建i2c_client。i2c_client的父设备为i2c_adapter。</p>
<ul>
<li>i2c_adapter与i2c_client为一对多的关系。</li>
<li>在i2c-imx.c中，先注册platform_driver i2c_imx_driver到platform总线上，如果找到of_match_table中的”fsl,imx6q-i2c”则，调用i2c_imx_probe()，其中，创建i2c_imx-&gt;adapter设备，并注册到I2C总线上（使用i2c_add_numbered_adapter()）。</li>
</ul>
</li>
<li><p>注册i2c_driver到I2C总线上，遍历i2c_adapter的i2c_client，如果有name一致的。则match成功，调用probe函数（rs5c372_probe())</p>
</li>
<li><p>至此，形成如下结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device:</span><br><span class="line">              i2c_bus_type       i2c_adapter  &lt;--- i2c_client</span><br><span class="line">                    |               |                  |</span><br><span class="line">I2C bus             V               V                  V</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Driver:             A               A                  A</span><br><span class="line">                    |               |                  |</span><br><span class="line">                    |               +------------------|</span><br><span class="line">                    |               |</span><br><span class="line">               dummy_driver    i2c_driver(find i2c_adapter&#39;s i2c_client according to .id_table)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="I2C驱动结构"><a href="#I2C驱动结构" class="headerlink" title="I2C驱动结构"></a>I2C驱动结构</h1><ul>
<li>主要包括：I2C核心，I2C主控制器（adapter），I2C slave（从设备）</li>
<li>I2C核心(drivers/i2c/i2c-core.c)：<ul>
<li>主控制器与从设备使用的函数与数据结构，由Linux完成，主要依据I2C通信协议（支持I2C标准协议和SMBus协议）</li>
</ul>
</li>
<li>I2C主控制器(drivers/i2c/busses/i2c-imx.c)：<ul>
<li>一般集成在主芯片中，通常由CPU厂商完成代码。依据芯片的User Manual，操作I2C数据的流程。</li>
</ul>
</li>
<li>I2C slave(drivers/rtc/rtc-rs5c372.c):<ul>
<li>挂载到I2C主控制器上的外设（如触摸屏，eeprom，rtc，传感器等）。从设备做为client与主控制器adapter通信。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user space       user app                        i2c user mode</span><br><span class="line">                 (update rtc)</span><br><span class="line">                    |                                  |</span><br><span class="line">--------------------|----------------------------------|---------</span><br><span class="line">kernel space        |                                  |</span><br><span class="line">                    |                                  |</span><br><span class="line">                &#x2F;dev &#x2F;sys                           i2c-dev</span><br><span class="line">                (&#x2F;dev&#x2F;rtc)                             |</span><br><span class="line">                    |                                  |</span><br><span class="line">                    |                                  |</span><br><span class="line">                 slave driver                          |</span><br><span class="line">                 (rtc driver) ----|    |---------------|</span><br><span class="line">               (2)  |             |    |</span><br><span class="line">          only for  | device init |    |</span><br><span class="line">                    |            i2c-core</span><br><span class="line">                    |               |</span><br><span class="line">                    |          主控制器驱动</span><br><span class="line">                    |          (i2c-adapter)</span><br><span class="line">                    |               | (3)</span><br><span class="line">                    |               |------------------|</span><br><span class="line">                    |                                  |</span><br><span class="line">                    |                                  |</span><br><span class="line">--------------------|----------------------------------|---------</span><br><span class="line">hardware device     |                                  |</span><br><span class="line">                    |                                  |</span><br><span class="line">                i2c slave device  &lt;------------&gt;   i2c 主控制器</span><br><span class="line">                (rtc device)</span><br><span class="line"></span><br><span class="line">(1) 如果app通过&#x2F;dev&#x2F;rtc读&#x2F;写rtc的设置,那么就会走(1)路线.</span><br><span class="line">    rtc_set_time (rtc driver)</span><br><span class="line">      i2c_smbus_write_i2c_block_data (i2c-corc.c)</span><br><span class="line">        i2c_smbus_xfer</span><br><span class="line">          i2c_smbus_xfer_emulated (如果不支持smbus的话,模拟smbus)</span><br><span class="line">            i2c_transfer</span><br><span class="line">              adp-&gt;algo-&gt;master_xfer (调用具体i2c adapter的xfer函数)</span><br><span class="line">                i2c_imx_xfer</span><br><span class="line">                  根据msg.flags</span><br><span class="line">                  if (msg.flags &amp; I2C_M_RD)</span><br><span class="line">                    i2c_imx_read</span><br><span class="line">                  else</span><br><span class="line">                    i2c_imx_write</span><br><span class="line"></span><br><span class="line">(2) 一般只有在设备初始化时走(2)路线,之后user对rtc设备的操作都要经过(1),即i2c进行读&#x2F;写控制.</span><br><span class="line">(3) 在i2c读&#x2F;写过程中,信息的载体就是i2c_msg,它在slave driver和i2c-dev中会实例化.</span><br><span class="line">    主要包括,读写标志,读&#x2F;写buf,size等.</span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">        __u16 addr;     &#x2F;* slave address                        *&#x2F;</span><br><span class="line">        __u16 flags;</span><br><span class="line">#define I2C_M_TEN               0x0010  &#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">#define I2C_M_RD                0x0001  &#x2F;* read data, from slave to master *&#x2F;</span><br><span class="line">#define I2C_M_NOSTART           0x4000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_REV_DIR_ADDR      0x2000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_IGNORE_NAK        0x1000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_NO_RD_ACK         0x0800  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_RECV_LEN          0x0400  &#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">        __u16 len;              &#x2F;* msg length                           *&#x2F;</span><br><span class="line">        __u8 *buf;              &#x2F;* pointer to msg data                  *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="I2C核心"><a href="#I2C核心" class="headerlink" title="I2C核心"></a>I2C核心</h1><ul>
<li><p>一般Linux驱动的核心层做两件事情：</p>
<ul>
<li>为了方便管理与归类，注册总线或class。</li>
<li>为相关的设备驱动提供统一的接口。</li>
</ul>
</li>
<li><p>I2C core先要创建I2C bus的设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c-core.c</span><br><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        int retval;</span><br><span class="line"></span><br><span class="line">        retval &#x3D; bus_register(&amp;i2c_bus_type);</span><br><span class="line">        if (retval)</span><br><span class="line">                return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">        i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">        if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">                retval &#x3D; -ENOMEM;</span><br><span class="line">                goto bus_err;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        retval &#x3D; i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">        if (retval)</span><br><span class="line">                goto class_err;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">        class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line">#endif</span><br><span class="line">        bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">        return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里创建了bus_type类型的I2C总线i2c_bus_type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c-core.c</span><br><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">        .name           &#x3D; &quot;i2c&quot;,</span><br><span class="line">        .match          &#x3D; i2c_device_match,</span><br><span class="line">        .probe          &#x3D; i2c_device_probe,</span><br><span class="line">        .remove         &#x3D; i2c_device_remove,</span><br><span class="line">        .shutdown       &#x3D; i2c_device_shutdown,</span><br><span class="line">        .pm             &#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当向I2C总线注册driver时，总终会调用到bus-&gt;match(dev,drv)来匹配slave device和slave driver。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_i2c_driver(rs5c372_driver)</span><br><span class="line">  module_driver</span><br><span class="line">    i2c_add_driver(rs5c372_driver)</span><br><span class="line">      i2c_register_driver(THIS_MODULE, rs5c372_driver) &lt;i2c-core.c&gt;</span><br><span class="line">        driver_register() &lt;drivers&#x2F;base&#x2F;driver.c&gt;</span><br><span class="line">          bus_add_driver() &lt;drivers&#x2F;base&#x2F;bus.c&gt;</span><br><span class="line">            driver_attach() &lt;drivers&#x2F;base&#x2F;dd.c&gt;</span><br><span class="line">              __driver_attach() &lt;drivers&#x2F;base&#x2F;dd.c&gt;</span><br><span class="line">                driver_match_device(drv, dev) &lt;drivers&#x2F;base&#x2F;base.h&gt;</span><br><span class="line">                static inline int driver_match_device(struct device_driver *drv,</span><br><span class="line">                                                      struct device *dev)</span><br><span class="line">                &#123;</span><br><span class="line">                        return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于有些注册名字与实际名字不一样的情况，我们可以设置driver的id_table来描述设备的名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c-core.c</span><br><span class="line">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">        struct i2c_client       *client &#x3D; i2c_verify_client(dev);</span><br><span class="line">        struct i2c_driver       *driver;</span><br><span class="line"></span><br><span class="line">        if (!client)</span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Attempt an OF style match *&#x2F;</span><br><span class="line">        if (of_driver_match_device(dev, drv))</span><br><span class="line">                return 1;</span><br><span class="line"></span><br><span class="line">        driver &#x3D; to_i2c_driver(drv);</span><br><span class="line">        &#x2F;* match on an id table if there is one *&#x2F;</span><br><span class="line">        if (driver-&gt;id_table)</span><br><span class="line">                return i2c_match_id(driver-&gt;id_table, client) !&#x3D; NULL;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>i2c_init 流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c_init --&gt; bus_register(&amp;i2c_bus_type) --&gt; create &#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="I2C-主控制器（adapter）"><a href="#I2C-主控制器（adapter）" class="headerlink" title="I2C 主控制器（adapter）"></a>I2C 主控制器（adapter）</h1><ul>
<li><p>I2C主控制器驱动，即由adapter来表示。它必须要带有algorithm，实现访问从设备的方法。不同的CPU I2C主控制器，具体实现的传输方法细节也不完全一样，虽然都是依据I2C的协议。</p>
<h2 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a>i2c_adapter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">&#x2F;*</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">        struct module *owner;</span><br><span class="line">        unsigned int class;               &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">        const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class="line">        void *algo_data;</span><br><span class="line"></span><br><span class="line">        &#x2F;* data fields that are valid for all devices   *&#x2F;</span><br><span class="line">        struct rt_mutex bus_lock;</span><br><span class="line"></span><br><span class="line">        int timeout;                    &#x2F;* in jiffies *&#x2F;</span><br><span class="line">        int retries;</span><br><span class="line">        struct device dev;              &#x2F;* the adapter device *&#x2F;</span><br><span class="line"></span><br><span class="line">        int nr;</span><br><span class="line">        char name[48];</span><br><span class="line">        struct completion dev_released;</span><br><span class="line"></span><br><span class="line">        struct mutex userspace_clients_lock;</span><br><span class="line">        struct list_head userspace_clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>algo_data: 保存其算法的私有数据，在i2c_algorithm的方法中使用。i2c-imx.c没有使用。i2c-s3c2410.c使用了。</p>
</li>
<li><p>timeout: 传递数据超时时间，单位jiffies。如果没有初始化，默认值为HZ，即1秒。</p>
</li>
<li><p>retires: 传输一次消息重试的次数。传输失败，返回-EAGAIN，然后重试retires - 1次，即一共传输retires次。</p>
</li>
<li><p>nr: I2C总线的编号，从0开始。如i.MX6 sabresd dual lite 有4个I2C。0，1，2，3。</p>
</li>
<li><p>name: I2C 从设备的名字。</p>
</li>
<li><p>dev_released: 释放i2c_adapter的completion。</p>
<h2 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a>i2c_algorithm</h2></li>
</ul>
</li>
<li><p>i2c_algorithm提供了主从设备通信方法。支持SMBus和标准I2C协议。如果从设备和adapter支持SMBus的话，推荐使用SMBus，它更加灵活方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">        &#x2F;* If an adapter algorithm can&#39;t do I2C-level access, set master_xfer</span><br><span class="line">           to NULL. If an adapter algorithm can do SMBus access, set</span><br><span class="line">           smbus_xfer. If set to NULL, the SMBus protocol is simulated</span><br><span class="line">           using common I2C messages *&#x2F;</span><br><span class="line">        &#x2F;* master_xfer should return the number of messages successfully</span><br><span class="line">           processed, or a negative value on error *&#x2F;</span><br><span class="line">        int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">                           int num);</span><br><span class="line">        int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">                           unsigned short flags, char read_write,</span><br><span class="line">                           u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">        &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">        u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>master_xfer和smbus_xfer分别表示I2C和SMBus的传输方法，它们的不同细节，参考以下。这里主要说明master_xfer</p>
<ul>
<li><a href="https://i2c.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener">https://i2c.wiki.kernel.org/index.php/Main_Page</a></li>
<li><a href="http://blog.csdn.net/wenlifu71022/article/details/4465339" target="_blank" rel="noopener">http://blog.csdn.net/wenlifu71022/article/details/4465339</a></li>
</ul>
</li>
<li><p>num表示每次传输数据的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-imx.c</span><br><span class="line">static int i2c_imx_xfer(struct i2c_adapter *adapter,</span><br><span class="line">                                                struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">        &lt;snip&gt;</span><br><span class="line">        for (i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">                &lt;snip&gt;</span><br><span class="line">                if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">                        result &#x3D; i2c_imx_read(i2c_imx, &amp;msgs[i]);</span><br><span class="line">                else</span><br><span class="line">                        result &#x3D; i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">                &lt;snip&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次传输的数据用i2c_msg表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">        __u16 addr;     &#x2F;* slave address                        *&#x2F;</span><br><span class="line">        __u16 flags;</span><br><span class="line">#define I2C_M_TEN               0x0010  &#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">#define I2C_M_RD                0x0001  &#x2F;* read data, from slave to master *&#x2F;</span><br><span class="line">#define I2C_M_NOSTART           0x4000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_REV_DIR_ADDR      0x2000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_IGNORE_NAK        0x1000  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_NO_RD_ACK         0x0800  &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_RECV_LEN          0x0400  &#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">        __u16 len;              &#x2F;* msg length                           *&#x2F;</span><br><span class="line">        __u8 *buf;              &#x2F;* pointer to msg data                  *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>addr: 从设备地址，可以是7（通常）或10位。传输地址时，要记得右移一位。</p>
<ul>
<li><p>可以使用I2C_BOARD_INFO(“ov564x”, 0x3c)来写入slave adress。ov564x的地址为0x78，右移后为0x3c。</p>
</li>
<li><p>这是因为在传输时，会有左移的操作，并将最低位写为R/W位。无论是read/write。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)</span><br><span class="line">&#123;</span><br><span class="line">&lt;snip&gt;</span><br><span class="line">        &#x2F;* write slave address *&#x2F;</span><br><span class="line">        writeb((msgs-&gt;addr &lt;&lt; 1) | 0x01, i2c_imx-&gt;base + IMX_I2C_I2DR);</span><br><span class="line">               ^^^^^^^^^^^^^^^^^</span><br><span class="line">&lt;snip&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是10位，flag必须设置为I2C_M_TEN，adapter也必须支持I2C_FUNC_10BIT_ADDR</p>
</li>
</ul>
</li>
<li><p>I2C_M_RD: 表示读操作，主设备从从设备中读数据。注，如果I2C主控制器工作在slave mode的话，则表示外设（主设备）从主控制器（从设备）读数据。</p>
</li>
<li><p>其他详细内容再补充</p>
</li>
</ul>
</li>
<li><p>总结一下master_xfer: 一般主控制器里有一个字节大小的寄存器（其实就是移位器）来循环发传输数据。通常是将要发送的数据保存到i2c_msg-&gt;buf中，然后初始化I2C总线信号（产生start信号），发送第一个字节数据（从设备地址与R/W位）到数据寄存器，等待I2c主控制器的中断到来，在中断中判断发送完数据（一般情况下，中断到来时，数据发送完，判断是为了保护及确认数据发送完成），然后唤醒写数据的进程，继续写下一下数据，再次wait in queue等待中断的I2C主控制器的中断到来。</p>
</li>
<li><p>functionality: I2C主控制器支持的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">#define I2C_FUNC_I2C                    0x00000001</span><br><span class="line">#define I2C_FUNC_10BIT_ADDR             0x00000002</span><br><span class="line">#define I2C_FUNC_PROTOCOL_MANGLING      0x00000004 &#x2F;* I2C_M_NOSTART etc. *&#x2F;</span><br><span class="line">#define I2C_FUNC_SMBUS_PEC              0x00000008</span><br><span class="line">#define I2C_FUNC_SMBUS_BLOCK_PROC_CALL  0x00008000 &#x2F;* SMBus 2.0 *&#x2F;</span><br><span class="line">#define I2C_FUNC_SMBUS_QUICK            0x00010000</span><br><span class="line">#define I2C_FUNC_SMBUS_READ_BYTE        0x00020000</span><br><span class="line">#define I2C_FUNC_SMBUS_WRITE_BYTE       0x00040000</span><br><span class="line">#define I2C_FUNC_SMBUS_READ_BYTE_DATA   0x00080000</span><br><span class="line">#define I2C_FUNC_SMBUS_WRITE_BYTE_DATA  0x00100000</span><br><span class="line">#define I2C_FUNC_SMBUS_READ_WORD_DATA   0x00200000</span><br><span class="line">#define I2C_FUNC_SMBUS_WRITE_WORD_DATA  0x00400000</span><br><span class="line">#define I2C_FUNC_SMBUS_PROC_CALL        0x00800000</span><br><span class="line">#define I2C_FUNC_SMBUS_READ_BLOCK_DATA  0x01000000</span><br><span class="line">#define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span><br><span class="line">#define I2C_FUNC_SMBUS_READ_I2C_BLOCK   0x04000000 &#x2F;* I2C-like block xfer  *&#x2F;</span><br><span class="line">#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK  0x08000000 &#x2F;* w&#x2F; 1-byte reg. addr. *&#x2F;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="i2c-adapter-注册"><a href="#i2c-adapter-注册" class="headerlink" title="i2c_adapter 注册"></a>i2c_adapter 注册</h2><ul>
<li><p>i2c adapter device通过以下某一个函数完成：</p>
<ul>
<li>i2c_add_adapter()：用于动态分配的bus号，即adap-&gt;nr。</li>
<li>i2c_add_numbered_adapter()：用于静态分配的bus号。多数情况下，用这个函数。</li>
</ul>
</li>
<li><p>这两个函数操作是类似的，都是先确定bus的号（IDR分配），然后调用i2c_register_adapter()进行注册。</p>
</li>
<li><p>在i2c_register_adapter()中，把adapter当成device注册到i2c bus总线上。使用i2c bus的match函数进行匹配，如果匹配成功，则调用i2c bus的probe函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i2c_register_adapter()</span><br><span class="line">  device_register() &lt;drivers&#x2F;base&#x2F;core.c&gt;</span><br><span class="line">    device_add() &lt;drivers&#x2F;base&#x2F;core.c&gt;</span><br><span class="line">      bus_probe_device() &lt;drivers&#x2F;base&#x2F;core.c&gt;</span><br><span class="line">        device_attach() &lt;drivers&#x2F;base&#x2F;bus.c&gt;</span><br><span class="line">          bus_for_each_drv() &lt;drivers&#x2F;base&#x2F;dd.c&gt;</span><br><span class="line">            __device_attach() &lt;drivers&#x2F;base&#x2F;dd.c&gt;</span><br><span class="line">              driver_match_device(drv, dev) &lt;drivers&#x2F;base&#x2F;base.h&gt;</span><br><span class="line">              static inline int driver_match_device(struct device_driver *drv,</span><br><span class="line">                                                    struct device *dev)</span><br><span class="line">              &#123;</span><br><span class="line">                      return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>i2c_register_adapter()详细代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">        &#x2F;* 判断i2c_bus_type的driver是否注册，因为需要将adapter device 注册到其上 *&#x2F;</span><br><span class="line">        if (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">                res &#x3D; -EAGAIN;</span><br><span class="line">                goto out_list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Sanity checks *&#x2F;</span><br><span class="line">        if (unlikely(adap-&gt;name[0] &#x3D;&#x3D; &#39;\0&#39;)) &#123;</span><br><span class="line">                pr_err(&quot;i2c-core: Attempt to register an adapter with &quot;</span><br><span class="line">                       &quot;no name!\n&quot;);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        if (unlikely(!adap-&gt;algo)) &#123;</span><br><span class="line">                pr_err(&quot;i2c-core: Attempt to register adapter &#39;%s&#39; with &quot;</span><br><span class="line">                       &quot;no algo!\n&quot;, adap-&gt;name);</span><br><span class="line">                return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">        mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">        INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">        &#x2F;* Set default timeout to 1 second if not already set *&#x2F;</span><br><span class="line">        if (adap-&gt;timeout &#x3D;&#x3D; 0)</span><br><span class="line">                adap-&gt;timeout &#x3D; HZ;</span><br><span class="line"></span><br><span class="line">        &#x2F;* 注册主设备device设备模型, &#x2F;sys&#x2F;bus&#x2F;devices&#x2F;下出现&quot;i2c-%d&quot;的主设备</span><br><span class="line">         * 即i2c主控制器设备 *&#x2F;</span><br><span class="line">        dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">        adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line">        adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type;</span><br><span class="line">        res &#x3D; device_register(&amp;adap-&gt;dev);</span><br><span class="line">        if (res)</span><br><span class="line">                goto out_list;</span><br><span class="line"></span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">        res &#x3D; class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">                                       adap-&gt;dev.parent);</span><br><span class="line">        if (res)</span><br><span class="line">                dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">                         &quot;Failed to create compatibility class link\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#x2F;* create pre-declared device nodes *&#x2F;</span><br><span class="line">        &#x2F;* 如果为真，就是说明使用的是静态注册的i2c_adapter</span><br><span class="line">         * 当使用i2c_register_board_info注册从设备时，其参数busnum指定的总线的i2c_adapter必须要静态注册。*&#x2F;</span><br><span class="line">        if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">                i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">        &#x2F;* Notify drivers *&#x2F;</span><br><span class="line">        mutex_lock(&amp;core_lock);</span><br><span class="line">        bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">        mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">        mutex_lock(&amp;core_lock);</span><br><span class="line">        idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">        mutex_unlock(&amp;core_lock);</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>i2c_scan_static_board_info()遍历__i2c_board_list链表，找到与主控制器adapter相同busnum的从设备i2c_devinfo结构。然后调用i2c_new_device()创建i2c_client结构并注册到i2c bus。i2c_board_list与i2c_devinfo会在slave driver中再次阐明。</li>
<li>创建完i2c_client，遍历i2c bus的驱动，调用__process_new_adapter()。完成从设备的侦测。</li>
</ul>
</li>
<li><p>注册流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  define i2c_adapter</span><br><span class="line">                         |</span><br><span class="line">                         |</span><br><span class="line">                  i2c_register_adapter</span><br><span class="line">                         |</span><br><span class="line">      |------------------|-----------------------------|</span><br><span class="line">      |                  |                             |</span><br><span class="line">      |                  |                             |</span><br><span class="line">device_register    i2c_scan_static_board_info    bus_for_each_drv</span><br><span class="line"> (&amp;adap-&gt;dev)         (adap)                     (&amp;i2c_bus_type, NULL,</span><br><span class="line">                                                  adap, __process_new_adapter);</span><br><span class="line">                         |                             |</span><br><span class="line">                         |                             |</span><br><span class="line">                   list_for_each_entry          __process_new_adapter</span><br><span class="line">                         |                             |</span><br><span class="line">                         |                             |</span><br><span class="line">                     i2c_new_device                i2c_do_add_adapter</span><br><span class="line">                         |</span><br><span class="line">                         |</span><br><span class="line">                  malloc and initialize</span><br><span class="line">                     i2c_client</span><br></pre></td></tr></table></figure>
</li>
<li><p>i2c-imx.c中将i2c_imx_driver注册成为platform driver，然后在i2c_imx_probe()函数中创建并初始化adapter，然后将adapter注册到i2c bus上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Add I2C adapter *&#x2F;</span><br><span class="line">ret &#x3D; i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="i2c-slave"><a href="#i2c-slave" class="headerlink" title="i2c slave"></a>i2c slave</h1><h2 id="Register-slave-device"><a href="#Register-slave-device" class="headerlink" title="Register slave device"></a>Register slave device</h2><ul>
<li><p>一个slave device用i2c_client描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">struct i2c_client &#123;</span><br><span class="line">        unsigned short flags;           &#x2F;* div., see below              *&#x2F;</span><br><span class="line">        unsigned short addr;            &#x2F;* chip address - NOTE: 7bit    *&#x2F;</span><br><span class="line">                                        &#x2F;* addresses are stored in the  *&#x2F;</span><br><span class="line">                                        &#x2F;* _LOWER_ 7 bits               *&#x2F;</span><br><span class="line">        char name[I2C_NAME_SIZE];</span><br><span class="line">        struct i2c_adapter *adapter;    &#x2F;* the adapter we sit on        *&#x2F;</span><br><span class="line">        struct i2c_driver *driver;      &#x2F;* and our access routines      *&#x2F;</span><br><span class="line">        struct device dev;              &#x2F;* the device structure         *&#x2F;</span><br><span class="line">        int irq;                        &#x2F;* irq issued by device         *&#x2F;</span><br><span class="line">        struct list_head detected;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flag:</p>
<ul>
<li><p>I2C_CLIENT_TEN: 地址为十位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">S | Slave addr 1st part r&#x2F;w | A | Slave addr 2nd part | A | Data | A | P |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">   1 1 1 1 0 x x                  x x x x x x x x</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个字节为1110b+addr高2位，第二个字节为低8位addr</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一般向bus注册i2c从设备的时候是在板级代码中加入的，其是在arch_initcall()时调用的。而主控制器adapter驱动使用的是module_init()或subsys_initcall()，总之都是会晚于arch_initcall()。初始化i2c_client需要指定其主控制器i2c_adapter，而i2c_adapter晚于i2c_client。所以，在板极程序中，还不能直接注册i2c_client，而只是保存在一个全局的链表__i2c_board_list中，格式为i2c_devinfo。</p>
<ul>
<li><p>在板级代码中，使用i2c_board_info数据结构定义从设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">struct i2c_board_info &#123;</span><br><span class="line">        char            type[I2C_NAME_SIZE];</span><br><span class="line">        unsigned short  flags;</span><br><span class="line">        unsigned short  addr;</span><br><span class="line">        void            *platform_data;</span><br><span class="line">        struct dev_archdata     *archdata;</span><br><span class="line">        struct device_node *of_node;</span><br><span class="line">        int             irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>type: i2c_client的name。设备的名字。</li>
<li>flag与addr对应为i2c_client的flag与addr。</li>
<li>platform_data: 私有数据。</li>
<li>irq: 使用的irq号。</li>
</ul>
</li>
<li><p>可以使用宏定义来简单定义i2c_board_info</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&#x2F;linux&#x2F;i2c.h</span><br><span class="line">#define I2C_BOARD_INFO(dev_type, dev_addr) \</span><br><span class="line">        .type &#x3D; dev_type, .addr &#x3D; (dev_addr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一个i2c主控制器挂载的从设备，都保存在相应i2c_board_info的数组里。如：I2C0的所有从设备list。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct i2c_board_info mxc_i2c0_board_info[] __initdata &#x3D; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                I2C_BOARD_INFO(&quot;wm89**&quot;, 0x1a),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                I2C_BOARD_INFO(&quot;ov564x&quot;, 0x3c),</span><br><span class="line">                .platform_data &#x3D; (void *)&amp;camera_data,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                I2C_BOARD_INFO(&quot;mma8451&quot;, 0x1c),</span><br><span class="line">                .platform_data &#x3D; (void *)&amp;mma8451_position,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义完从设备，就可以向i2c bus注册了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;i2c&#x2F;i2c-boardinfo.c</span><br><span class="line">int</span><br><span class="line">i2c_register_board_info(int busnum, struct i2c_board_info const *info,</span><br><span class="line">                        unsigned n);</span><br></pre></td></tr></table></figure>

<ul>
<li>busnum: 指定要向哪个i2c bus(i2c adapter)加入该设备</li>
<li>info: 上面定义的设备list</li>
<li>n: 为设备list的个数</li>
</ul>
</li>
<li><p>i2c_register_board_info()为每一个i2c_board_info创建一个i2c_devinfo结构，然后添加到<strong>i2c_board_list中。所有设备都可以在</strong>i2c_board_list中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;i2c&#x2F;i2c-boardinfo.c</span><br><span class="line">int __init</span><br><span class="line">i2c_register_board_info(int busnum,</span><br><span class="line">        struct i2c_board_info const *info, unsigned len)</span><br><span class="line">&#123;</span><br><span class="line">        int status;</span><br><span class="line"></span><br><span class="line">        down_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">        &#x2F;* dynamic bus numbers will be assigned after the last static one *&#x2F;</span><br><span class="line">        if (busnum &gt;&#x3D; __i2c_first_dynamic_bus_num)</span><br><span class="line">                __i2c_first_dynamic_bus_num &#x3D; busnum + 1;</span><br><span class="line"></span><br><span class="line">        for (status &#x3D; 0; len; len--, info++) &#123;</span><br><span class="line">                struct i2c_devinfo      *devinfo;</span><br><span class="line"></span><br><span class="line">                devinfo &#x3D; kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">                if (!devinfo) &#123;</span><br><span class="line">                        pr_debug(&quot;i2c-core: can&#39;t register boardinfo!\n&quot;);</span><br><span class="line">                        status &#x3D; -ENOMEM;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                devinfo-&gt;busnum &#x3D; busnum;</span><br><span class="line">                devinfo-&gt;board_info &#x3D; *info;</span><br><span class="line">                list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        up_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">        return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>i2c_register_board_info的流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define i2c_board_info</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">i2c_register_board_info</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">malloc and initialize</span><br><span class="line">    i2c_devinfo</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">add i2c_devinfo to</span><br><span class="line">   __i2c_board_list</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候，从设备才会真正地注册到i2c bus上呢？在主控制器注册到i2c bus时，使用了i2c_register_adapter()。</p>
<ul>
<li>i2c_register_adapter() –&gt; i2c_scan_static_board_info()遍历__i2c_board_list</li>
<li>这时，adapter与i2c device匹配完成。</li>
</ul>
</li>
</ul>
</li>
<li><p>以上提到的都是i2c从设备的静态注册，即使用i2c_register_board_info()。另外，还有一种方法，侦测从设备。下面进行说明。</p>
<h2 id="Register-slave-driver"><a href="#Register-slave-driver" class="headerlink" title="Register slave driver"></a>Register slave driver</h2></li>
<li><p>slave driver使用的是i2c_driver数据结构。其结构与platform_driver类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_driver &#123;</span><br><span class="line">        &#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class="line">        int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>probe 函数中的i2c_device_id为device的id table，即i2c_driver-&gt;id_table。</p>
</li>
<li><p>device id有两个功能：一个是用于slave driver与slave device匹配，当name相同的时候，匹配成功，触发probe函数。另一个作用是传递给probe函数，作为私有数据，使device driver可以支持多个device的情况。</p>
</li>
<li><p>device id使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum rtc_type &#123;</span><br><span class="line">        rtc_undef &#x3D; 0,</span><br><span class="line">        rtc_r2025sd,</span><br><span class="line">        rtc_rs5c372a,</span><br><span class="line">        rtc_rs5c372b,</span><br><span class="line">        rtc_rv5c386,</span><br><span class="line">        rtc_rv5c387a,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct i2c_device_id rs5c372_id[] &#x3D; &#123;</span><br><span class="line">        &#123; &quot;r2025sd&quot;, rtc_r2025sd &#125;,</span><br><span class="line">        &#123; &quot;rs5c372a&quot;, rtc_rs5c372a &#125;,</span><br><span class="line">        &#123; &quot;rs5c372b&quot;, rtc_rs5c372b &#125;,</span><br><span class="line">        &#123; &quot;rv5c386&quot;, rtc_rv5c386 &#125;,</span><br><span class="line">        &#123; &quot;rv5c387a&quot;, rtc_rv5c387a &#125;,</span><br><span class="line">        &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>i2c_driver是通过i2c_add_driver()注册到i2c bus上的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_i2c_driver(rs5c372_driver)</span><br><span class="line">  module_driver</span><br><span class="line">    i2c_add_driver(rs5c372_driver)</span><br><span class="line">      i2c_register_driver(THIS_MODULE, rs5c372_driver) &lt;i2c-core.c&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在i2c_register_driver()中，主要做了两件事。</p>
<ul>
<li><p>driver_register()注册device_driver()</p>
</li>
<li><p>遍历i2c bus上的所有设备，执行__process_new_driver()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;i2c&#x2F;i2c-core.c</span><br><span class="line">static int __process_new_driver(struct device *dev, void *data)</span><br><span class="line">&#123;</span><br><span class="line">        if (dev-&gt;type !&#x3D; &amp;i2c_adapter_type)</span><br><span class="line">                return 0;</span><br><span class="line">        return i2c_do_add_adapter(data, to_i2c_adapter(dev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果device是adapter，则i2c_do_add_adapter()，这个就是动态侦测函数。</p>
</li>
<li><p>这里判断的是i2c_adpater，因为我们要在i2c_driver驱动中侦测所有i2c_adapter上的符合该驱动的i2c_client。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在i2c bus上有两种设备：i2c_adapter和i2c_board_info静态注册的从设备。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://blog.csdn.net/w2baby1314/article/details/8081993" target="_blank" rel="noopener">Linux I2c Driver的整体分析</a></li>
<li><a href="http://blog.chinaunix.net/uid-26993600-id-3266678.html" target="_blank" rel="noopener">linux设备驱动那点事儿之I2C驱动理论篇</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】 i2c驱动架构</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%20i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【<a href="https://blog.csdn.net/ghostyu/article/details/8094049】" target="_blank" rel="noopener">https://blog.csdn.net/ghostyu/article/details/8094049】</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h1><p><strong>在阅读本文最好先熟悉一种i2c设备的驱动程序，并且浏览一下i2c-core.c以及芯片提供商的提供的i2c总线驱动（i2c-davinci.c）。标题党请见谅！</strong></p>
<p>其实i2c接口非常的简单，即使用51单片的gpio来模拟i2c，编写一个e2prom或者其他i2c接口的驱动程序，也不是什么难事，几百行代码就能搞定。</p>
<p>但是Linux的i2c驱动体系结构却有相当的复杂度，不管是叫linux i2c驱动还是单片机i2c驱动，其根本还是操作soc芯片内部的i2c模块（也叫i2c adapter）（读写i2c相关的寄存器）来产生start、stop还有ack信号而已。</p>
<h1 id="linux设备驱动到底复杂在什么地方？"><a href="#linux设备驱动到底复杂在什么地方？" class="headerlink" title="linux设备驱动到底复杂在什么地方？"></a><strong>linux设备驱动到底复杂在什么地方？</strong></h1><p>假设soc芯片dm368有两个i2c adapter（368内部真正只有一个i2c模块）：i2c_adapter1，i2c_adapter1；然后外部有三个i2c接口的设备i2c_device1，i2c_device2，i2c_device3。</p>
<p>现在要求在裸机下写出他们的驱动函数。那么肯定要写出6个不同的驱动函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i2c_adapter1_ReadWrite_i2c_device1();</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter1_ReadWrite_i2c_device3()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device1()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device2()</span><br><span class="line"></span><br><span class="line">i2c_adapter2_ReadWrite_i2c_device3()</span><br></pre></td></tr></table></figure>

<p>设想一共有m个i2c adapter和n个外设i2c device，那么将需要m<em>n个驱动。并且这m</em>n个驱动程序必要会有很大部分重复的代码，而且不利于驱动程序的移植。</p>
<p>如果采用adapter和device分离的思想来写这样的驱动会是怎样呢？</p>
<p><img src="http://jiali.clouddn.com/20210115_001.png" alt=""></p>
<p>​                                                                                                                                   图1</p>
<p>这样分离之后，只需要m+n个驱动，而且Adapter和Device的几乎没有耦合性，增加一个Adapter或者device并不会影响其余的驱动。</p>
<p><strong>这就是分离思想带来的好处。除此之外，linux虽然是C写的，但是大量使用了面向对象的变成方法（可以理解为分层的思想），仅仅分离细想和分层思想的引入，就大大增加了linux设备驱动的复杂度。</strong></p>
<h1 id="linux驱动中-i2c驱动架构"><a href="#linux驱动中-i2c驱动架构" class="headerlink" title="linux驱动中 i2c驱动架构"></a><strong>linux驱动中 i2c驱动架构</strong></h1><p><img src="http://jiali.clouddn.com/20210115_002.png" alt=""></p>
<p>​                                                                                                                 图2</p>
<p><strong><em>\</em>上图完整的描述了linux i2c驱动架构，虽然I2C硬件体系结构比较简单，但是i2c体系结构在linux中的实现却相当复杂。那么我们如何编写特定i2c接口器件（比如，ov2715，需要i2c来配置寄存器）的驱动程序？就是说上述架构中的那些部分需要我们完成，而哪些是linux内核已经完善的或者是芯片提供商（TI davinci平台已经做好的）已经提供的？**</strong></p>
<h1 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h1><p><strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。<strong>覆盖图中的硬件实现层</strong></p>
<p><strong>第二层</strong>：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。<strong>覆盖图中的访问抽象层、i2c核心层</strong></p>
<p><strong>第三层</strong>：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第四层</strong>：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。<strong>覆盖图中的driver驱动层</strong></p>
<p><strong>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c</strong></p>
<p><strong>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</strong></p>
<p><strong>明确了方向后，**</strong>再来具体分析。**</p>
<h1 id="具体分析"><a href="#具体分析" class="headerlink" title="\具体分析**"></a><strong><em>\</em>具体分析**</strong></h1><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>
<p>现在，我们就来看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>
<h2 id="1、i2c-driver"><a href="#1、i2c-driver" class="headerlink" title="1、i2c_driver"></a><strong>1、i2c_driver</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detach_client)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*command)(struct i2c_client *client,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、i2c-client"><a href="#2、i2c-client" class="headerlink" title="2、i2c_client"></a><strong>2、i2c_client</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> short addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit 	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* and our access routines	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> usage_count;		<span class="comment">/* How many accesses currently  */</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* to the client		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">released</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、i2c-adapter"><a href="#3、i2c-adapter" class="headerlink" title="3、i2c_adapter"></a><strong>3、i2c_adapter</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span><span class="comment">/* the algorithm to access the bus	*/</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line">	<span class="comment">/* --- administration stuff. */</span></span><br><span class="line">	<span class="keyword">int</span> (*client_register)(struct i2c_client *);</span><br><span class="line">	<span class="keyword">int</span> (*client_unregister)(struct i2c_client *);</span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">clist_lock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> timeout;</span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">class_dev</span>;</span>	<span class="comment">/* the class device */</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">class_dev_released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4、i2c-algorithm"><a href="#4、i2c-algorithm" class="headerlink" title="4、i2c_algorithm"></a><strong>4、i2c_algorithm</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, </span><br><span class="line">	                   <span class="keyword">int</span> num);</span><br><span class="line">	<span class="keyword">int</span> (*slave_send)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*slave_recv)(struct i2c_adapter *,<span class="keyword">char</span>*,<span class="keyword">int</span>);</span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>【i2c_adapter与i2c_algorithm】</strong></p>
<p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I2C Message - used for pure i2c transaction, also from /dev interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line"> 	__u16 flags;		</span><br><span class="line"> 	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line"> 	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【i2c_driver和i2c_client】</strong></p>
<p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<p><strong>【i2c_adapter和i2c_client】</strong></p>
<p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class="line">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>



<p>如果看过i2c设备驱动程序的人一定对上面几个函数比较熟悉。</p>
<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(struct i2c_adapter * adap, struct i2c_msg *msgs, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class="comment">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_attach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	device_register(&amp;client-&gt;dev);</span><br><span class="line">	device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_detach_client</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line"></span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用，稍后分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class="line"><span class="comment"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class="line"><span class="comment"> * available for clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	device_register(&amp;adap-&gt;dev);</span><br><span class="line">	device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* inform drivers of new adapters */</span></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;attach_adapter)</span><br><span class="line">			<span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">			driver-&gt;attach_adapter(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_del_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;detach_adapter)</span><br><span class="line">			<span class="keyword">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class="line">		client = list_entry(item, struct i2c_client, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">davinci_i2c_driver</span> = &#123;</span></span><br><span class="line">	.probe		= davinci_i2c_probe,</span><br><span class="line">	.remove		= davinci_i2c_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">"i2c_davinci"</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* I2C may be needed to bring up other drivers */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">davinci_i2c_init_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">subsys_initcall(davinci_i2c_init_driver);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">davinci_i2c_exit_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	platform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_davinci_algo</span> = &#123;</span></span><br><span class="line">	.master_xfer	= i2c_davinci_xfer,</span><br><span class="line">	.functionality	= i2c_davinci_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>

<h1 id="梳理图"><a href="#梳理图" class="headerlink" title="梳理图"></a>梳理图</h1><p><strong><em>\</em>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容，请看图3。**</strong></p>
<p> <img src="http://jiali.clouddn.com/20210115_003.png" alt=""></p>
<p>​                                                                  图3</p>
<p>好了，上面这些代码的展示是告诉我们，linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Android/Linux I2C 驱动架构分析</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android%20Linux%20I2C%20%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【<a href="http://huaqianlee.github.io/2017/12/03/Android/Android-Linux-i2c-driver-arch/】" target="_blank" rel="noopener">http://huaqianlee.github.io/2017/12/03/Android/Android-Linux-i2c-driver-arch/】</a></p>
<h1 id="Android-Linux-I2C-驱动架构分析"><a href="#Android-Linux-I2C-驱动架构分析" class="headerlink" title="Android/Linux I2C 驱动架构分析"></a>Android/Linux I2C 驱动架构分析</h1><p> Posted on Dec 3 2017  Edited on Apr 6 2019  In <a href="http://huaqianlee.github.io/categories/Android/" target="_blank" rel="noopener">Android</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析传感器源码的时候，发现对 I2C 的驱动也有些忘记了，所以就再分析一下并形成这篇博文。</p>
<h1 id="驱动架构"><a href="#驱动架构" class="headerlink" title="驱动架构"></a>驱动架构</h1><h2 id="I2C-驱动架构"><a href="#I2C-驱动架构" class="headerlink" title="I2C 驱动架构"></a>I2C 驱动架构</h2><p><img src="https://andylee-1258982386.cos.ap-chengdu.myqcloud.com/android/mtk/i2c_arch.jpg" alt="i2c-arch"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\i2c</span><br></pre></td></tr></table></figure>

<h2 id="重要的结构体"><a href="#重要的结构体" class="headerlink" title="重要的结构体"></a>重要的结构体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\include\linux\i2c.h</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 表示一个 i2c 适配器，即挂接在 i2c 总线上的 i2c 控制器</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_adapter &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	unsigned int class;		  &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">	const struct i2c_algorithm *algo; &#x2F;* the algorithm to access the bus *&#x2F;</span><br><span class="line">	struct device dev;		&#x2F;* the adapter device *&#x2F;</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 表示一个 i2c 设备驱动</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_driver &#123;</span><br><span class="line">	unsigned int class;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Standard driver model interfaces *&#x2F;</span><br><span class="line">	int (*probe)(struct i2c_client *, const struct i2c_device_id *); &#x2F;&#x2F; 匹配 i2c 设备（i2c_client）</span><br><span class="line">	int (*remove)(struct i2c_client *);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	struct device_driver driver;   </span><br><span class="line">	const struct i2c_device_id *id_table; &#x2F;&#x2F; 此设备驱动服务的设备 ID</span><br><span class="line"></span><br><span class="line">	int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">	const unsigned short *address_list; &#x2F;&#x2F; 此设备驱动支持的设备地址</span><br><span class="line">	struct list_head clients;  &#x2F;&#x2F; 挂接此设备驱动匹配成功 i2c_client</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 表示一个 i2c 设备</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_client &#123;</span><br><span class="line">	unsigned short flags;		&#x2F;* div., see below		*&#x2F;</span><br><span class="line">	unsigned short addr;		&#x2F;* chip address - NOTE: 7bit	*&#x2F;</span><br><span class="line">					&#x2F;* addresses are stored in the	*&#x2F;</span><br><span class="line">					&#x2F;* _LOWER_ 7 bits		*&#x2F;</span><br><span class="line">	char name[I2C_NAME_SIZE];</span><br><span class="line">	struct i2c_adapter *adapter;	&#x2F;* the adapter we sit on	*&#x2F;</span><br><span class="line">	struct device dev;		&#x2F;* the device structure		*&#x2F;</span><br><span class="line">	int irq;			&#x2F;* irq issued by device		*&#x2F;</span><br><span class="line">	struct list_head detected;</span><br><span class="line">#ifdef CONFIG_MTK_I2C_EXTENSION</span><br><span class="line">	__u32 timing;			&#x2F;* parameters of timings		*&#x2F;</span><br><span class="line">	__u32 ext_flag;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 描述 i2c 设备信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_board_info &#123;</span><br><span class="line">	char		type[I2C_NAME_SIZE];</span><br><span class="line">	unsigned short	flags;</span><br><span class="line">	unsigned short	addr;</span><br><span class="line">	void		*platform_data;</span><br><span class="line">	struct dev_archdata	*archdata;</span><br><span class="line">	struct device_node *of_node;</span><br><span class="line">	struct acpi_dev_node acpi_node;</span><br><span class="line">	int		irq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\include\uapi\linux\i2c.h</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 表示一个 i2c 数据包</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct i2c_msg &#123;</span><br><span class="line">	__u16 addr;	     &#x2F;* slave address *&#x2F;</span><br><span class="line">	__u16 flags;</span><br><span class="line">#define I2C_M_TEN		0x0010	&#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">...</span><br><span class="line">#define I2C_M_RECV_LEN		0x0400	&#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">	__u16 len;		&#x2F;* msg length				*&#x2F;</span><br><span class="line">	__u8 *buf;		&#x2F;* pointer to msg data			*&#x2F;</span><br><span class="line">#ifdef CONFIG_MTK_I2C_EXTENSION</span><br><span class="line">	__u32 timing;	&#x2F;* parameters of timings		*&#x2F;</span><br><span class="line">	__u32 ext_flag;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\arch\arm64\boot\dts\mt6797.dtsi</span><br><span class="line"># alps\kernel-3.18\arch\arm64\boot\dts\aeon6797_6m_n.dts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\drivers\i2c</span><br><span class="line">i2c-core.c：i2c核心层，设备驱动和总线驱动的桥梁</span><br><span class="line">i2c-dev.c：通用 i2c 设备驱动</span><br><span class="line">busses：开源的 adapter </span><br><span class="line">algos：i2c 通信算法</span><br><span class="line"></span><br><span class="line"># alps\kernel-3.18\include\linux\i2c.h</span><br><span class="line"># alps\kernel-3.18\include\uapi\linux\i2c.h</span><br></pre></td></tr></table></figure>

<h2 id="总线驱动层"><a href="#总线驱动层" class="headerlink" title="总线驱动层"></a>总线驱动层</h2><p>总线驱动层主要实现外设驱动部分，初始化硬件（i2c控制器）和提供操作硬件的方法，与 i2c-dev 相对应，其负责的部分通俗点讲就是：知道怎么发数据，但不知道发什么数据。<br>其关键流程如下：</p>
<ol>
<li><p>获取资源</p>
</li>
<li><p>注册中断、使能时钟等初始化工作</p>
</li>
<li><p>构建 i2c_adapter</p>
</li>
<li><p>设置 i2c_adapter</p>
</li>
<li><p>注册 i2c_adapter</p>
<blockquote>
<p>这部分源码就不在此文分析了，感兴趣的朋友可以参考外设系列</p>
</blockquote>
</li>
</ol>
<h2 id="核心层（i2c-core）"><a href="#核心层（i2c-core）" class="headerlink" title="核心层（i2c-core）"></a>核心层（i2c-core）</h2><p>构建一个 i2c 总线结构体,并且提供匹配方法和驱动用的结构体 ，如总线驱动层和设备驱动层的注册、注销等方法。此部分存在两个匹配过程：</p>
<ol>
<li><p>i2c 总线下的设备（i2c_client）与设备驱动（i2c_driver）之间的匹配。</p>
</li>
<li><p>i2c控制器（i2c_adapter）与设备之间的匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\i2c\i2c-core.c</span><br><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;i2c&quot;,  &#x2F;&#x2F; 总线名</span><br><span class="line">	.match		&#x3D; i2c_device_match, &#x2F;&#x2F; 匹配设备（i2c_client）与设备驱动（i2c_driver）</span><br><span class="line">	.probe		&#x3D; i2c_device_probe,  &#x2F;&#x2F; 注册挂载 i2c</span><br><span class="line">	.remove		&#x3D; i2c_device_remove,</span><br><span class="line">	.shutdown	&#x3D; i2c_device_shutdown,</span><br><span class="line">	.pm		&#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> __init i2c_init() &#x2F;&#x2F; init 函数</span><br><span class="line">    # kernel-3.18&#x2F;drivers&#x2F;base&#x2F;bus.c</span><br><span class="line">    bus_register(&amp;i2c_bus_type) &#x2F;&#x2F; 注册i2c总线  &quot;&#x2F;sys&#x2F;bus&#x2F;i2c&quot;</span><br><span class="line">    i2c_add_driver(&amp;dummy_driver) &#x2F;&#x2F; &#x2F;&#x2F; 注册 i2c 驱动创建“&#x2F;sys&#x2F;bus&#x2F;i2c&#x2F;driver&#x2F;dummy” </span><br><span class="line">        i2c_register_driver() &#x2F;&#x2F; 注册 i2c 驱动</span><br><span class="line">            driver_register(&amp;driver-&gt;driver); &#x2F;&#x2F; 注册设备驱动，创建上面的“dummy”设备文件</span><br><span class="line">            INIT_LIST_HEAD(&amp;driver-&gt;clients)</span><br><span class="line">        </span><br><span class="line">i2c_device_probe()</span><br><span class="line">    i2c_verify_client(dev) &#x2F;&#x2F; 获取 i2c_client</span><br><span class="line">    to_i2c_driver(dev-&gt;driver) &#x2F;&#x2F; 获取 i2c_driver</span><br><span class="line">    driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table,client)) &#x2F;&#x2F; 调用设备驱动层 probe，查询外设（client）对应的 id</span><br><span class="line">        </span><br><span class="line">i2c_device_match()</span><br><span class="line">	client &#x3D; i2c_verify_client(dev)&#x2F;&#x2F; 通过 dev 获取 i2c_client</span><br><span class="line">	of_driver_match_device(dev, drv) &#x2F;&#x2F; 通过 of 方式匹配</span><br><span class="line">	acpi_driver_match_device(dev, drv) &#x2F;&#x2F; acpi 方式匹配</span><br><span class="line">	&#x2F;* if 上述两种方式皆未成功 *&#x2F;	</span><br><span class="line">	driver &#x3D; to_i2c_driver(drv); &#x2F;&#x2F;通过 drv 获取 i2c_driver</span><br><span class="line">	i2c_match_id(driver-&gt;id_table, client) &#x2F;&#x2F; 通过查询 id_table 匹配</span><br><span class="line"></span><br><span class="line">i2c_master_send() &#x2F;&#x2F; 发送一个 i2c 数据包</span><br><span class="line">    &#x2F;&#x2F; 构建 i2c_msg</span><br><span class="line">    i2c_transfer()</span><br><span class="line">        __i2c_transfer()  &#x2F;&#x2F; 发送数据包到总线驱动层</span><br><span class="line">i2c_master_recv()        </span><br><span class="line"></span><br><span class="line">&#x2F;* 通过动态获取|指定 bus number 注册 i2c 控制器 *&#x2F;</span><br><span class="line">i2c_add_adapter()|i2c_add_numbered_adapter() </span><br><span class="line">    i2c_register_adapter(adapter)</span><br><span class="line">    	dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr); &#x2F;&#x2F; 设置 adapter 名字 “i2c-%d”</span><br><span class="line">	    adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line">	    adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type;</span><br><span class="line">	    &#x2F;*</span><br><span class="line">	     * 注册设备,  默认创建的设备文件是: &#x2F;sys&#x2F;devices&#x2F;i2c-%d </span><br><span class="line">	     * 若注册 adapter 时指定了父设备，则为：&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;xxx&#x2F;i2c-%d </span><br><span class="line">	     *&#x2F;</span><br><span class="line">	    device_register(&amp;adap-&gt;dev);</span><br><span class="line">	    &#x2F;*</span><br><span class="line">	     * 扫描 __i2c_board_list 匹配 adapter 与 i2c 次设备信息，匹配成功则创建 i2c 设备 （i2c_client）</span><br><span class="line">	     *&#x2F;</span><br><span class="line">	    i2c_scan_static_board_info() </span><br><span class="line">	        i2c_new_device() &#x2F;&#x2F; 注册 i2c 设备</span><br><span class="line">	            i2c_dev_set_name(adap, client) &#x2F;&#x2F;  设置次设备名&quot; %d-%04x&quot;</span><br><span class="line">	            device_register(&amp;client-&gt;dev) &#x2F;&#x2F;  注册次设备&quot;&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;xxx&#x2F;i2c-%d&#x2F;%d-%04x“ </span><br><span class="line"> </span><br><span class="line"># alps\kernel-3.18\include\linux\i2c.h</span><br><span class="line">i2c_add_driver(driver) </span><br><span class="line">    i2c_register_driver(THIS_MODULE, driver)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：主设备表示特定的驱动程序；次设备表示使用该设备驱动的设备</p>
</blockquote>
</li>
</ol>
<h2 id="设备驱动层（i2c-dev）"><a href="#设备驱动层（i2c-dev）" class="headerlink" title="设备驱动层（i2c-dev）"></a>设备驱动层（i2c-dev）</h2><p>设备驱动层主要是封装主机 i2c 的基本操作，给上层提供接口，与总线驱动层相对应，其：知道发什么数据，但不知道怎么发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alps\kernel-3.18\drivers\i2c\i2c-dev.c （也可以是其他设备驱动文件，如：ov9650.c等。）</span><br><span class="line">static const struct file_operations i2cdev_fops &#x3D; &#123;</span><br><span class="line">	.owner		&#x3D; THIS_MODULE,</span><br><span class="line">	.llseek		&#x3D; no_llseek,</span><br><span class="line">	.read		&#x3D; i2cdev_read,</span><br><span class="line">	.write		&#x3D; i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	&#x3D; i2cdev_ioctl,</span><br><span class="line">	.open		&#x3D; i2cdev_open,</span><br><span class="line">	.release	&#x3D; i2cdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2cdev_read()</span><br><span class="line">    i2c_master_recv()</span><br><span class="line">    copy_to_user()</span><br><span class="line">i2cdev_write()</span><br><span class="line">    memdup_user()  &#x2F;&#x2F; 分配内核空间，用户态到内核态的拷贝</span><br><span class="line">        copy_from_user()</span><br><span class="line">    i2c_master_send()</span><br><span class="line">...</span><br><span class="line">i2cdev_open()</span><br><span class="line">    i2c_dev_get_by_minor()</span><br><span class="line">    i2c_get_adapter()</span><br><span class="line">    &#x2F;&#x2F; 设置 i2c client</span><br><span class="line"></span><br><span class="line">i2c_dev_init()</span><br><span class="line">    register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops)</span><br><span class="line">    i2cdev_attach_adapter() &#x2F;&#x2F; 绑定存在的 i2c 控制器（adapter）</span><br><span class="line">        adap &#x3D; to_i2c_adapter(dev);</span><br><span class="line">	    i2c_dev &#x3D; get_free_i2c_dev(adap);</span><br><span class="line">	    &#x2F;* register this i2c device with the driver core *&#x2F;</span><br><span class="line">	    i2c_dev-&gt;dev &#x3D; device_create(...&quot;i2c-%d&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h1><p>这里只看一种通用的通过 JNI 操作 i2c 设备的方案，i2c-dev 提供的接口通过 JNI 给 APP 使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># jni</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_open()</span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_read()</span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_write()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># app</span><br><span class="line">I2c.open(“&#x2F;dev&#x2F;i2c-x”)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public static class I2c &#123;  </span><br><span class="line">        ...</span><br><span class="line">        public native int open(); </span><br><span class="line">        public native int read(); </span><br><span class="line">        public native int write();  </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】IIC接口下的24C02 驱动分析</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IIC%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%8424C02%20%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.cnblogs.com/lifexy/p/7793686.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7793686.html】</a></p>
<p>本节来学习IIC接口下的24C02 驱动分析,本节学完后,再来学习Linux下如何使用IIC操作24C02</p>
<hr>
<p><strong>1.I2C通信介绍</strong></p>
<p>它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据,是一个多主机的半双工通信方式</p>
<p>每个挂接在总线上的器件都有个唯一的地址</p>
<p>位速在标准模式下可达 100kbit/s,在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。</p>
<p><strong>2. I2C总线系统结构,如下所示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160056575-1544374794.png" alt="img"></p>
<p>其中SCL时钟线的频率由主机提供,且从机不能主动来引起数据传输,必须等待主机先发信号才行</p>
<p>两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</p>
<p><strong>3.I2C时序介绍</strong></p>
<p><strong>1)空闲状态</strong></p>
<p>当总线上的SDA和SCL两条信号线同时处于高电平,便是空闲状态,如上面的硬件图所示,当我们不传输数据时, SDA和SCL被上拉电阻拉高,即进入空闲状态</p>
<p><strong>2)**</strong>起始信号**</p>
<p>当SCL为高期间，SDA由高到低的跳变；便是总线的启动信号,只能由主机发起,且在空闲状态下才能启动该信号,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160104794-1546406489.png" alt="img"></p>
<p><strong>3)**</strong>停止信号**</p>
<p>当SCL为高期间，SDA由低到高的跳变；便是总线的停止信号,表示数据已传输完成,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160108247-2041083640.png" alt="img"></p>
<p><strong>4)**</strong>传输数据格式**</p>
<p>当发了起始信号后,就开始传输数据,传输的数据格式如下图所示:</p>
<p>当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的(若SDA不稳定就会变成起始/停止信号)</p>
<p>当SCL为低电平时,便是SDA的电平变化状态</p>
<p>若主从机在传输数据期间,需要完成其它功能(例如一个中断),可以主动拉低SCL,使I2C进入等待状态,直到处理结束再释放SCL,数据传输会继续</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160112700-1908810180.png" alt="img"></p>
<p><strong>5)**</strong>应答信号ACK**</p>
<p>I2C总线上的数据都是以8位数据(字节)进行的,当发送了8个数据后,发送方会在第9个时钟脉冲期间释放SDA数据,当接收方接收该字节成功,便会输出一个ACK应答信号,当SDA为高电平,表示为非应答信号NACK,当SDA为低电平,表示为有效应答信号ACK</p>
<p><strong>PS:</strong>当<strong>主机为接收方</strong>时,收到最后一个字节后,主机可以不发送ACK,直接发送停止信号来结束传输。</p>
<p>当<strong>从机为接收方</strong>时,没有发送ACK,则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送,主机可以发送停止信号再次发送起始信号启动新的传输</p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160125278-134312409.png" alt="img"></p>
<p><strong>6)**</strong>完整的数据传输**</p>
<p>如下图所示, 发送起始信号后,便发送一个8位的设备地址,其中第8位是对设备的读写标志,后面紧跟着的就是数据了,直到发送停止信号终止</p>
<p><strong>PS:</strong>当我们第一次是读操作,然后想换成写操作时,可以再次发送一个起始信号,然后发送读的设备地址,不需要停止信号便能实现不同的地址转换</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160141888-898822484.png" alt="img"></p>
<p><strong>4. AT24C02**</strong>介绍**</p>
<p>AT24C02是通过I2C实现通讯的,是一个存储芯片,能够存储2Kb(256KB)数据</p>
<p><strong>4.1**</strong>它的的硬件图如下:**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160159731-872248298.png" alt="img"></p>
<p>其中A2~A0,是这个24C02设备的硬件地址,接GND表示硬件地址都为0</p>
<p><strong>4.2**</strong>其中AT24C02<strong>**的数据格式如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160208825-938746051.png" alt="img"></p>
<p><strong>4.3**</strong>打开AT24C02<strong><strong>数据手册,</strong></strong>它的设备地址如下图所示:**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160235434-519181103.png" alt="img"></p>
<p>其中A2<del>A1表示硬件地址,P2</del>P0表示page页地址</p>
<p>bit[0]地址:表示读/写状态,1:读,0:写 (所有I2C器件都是这样,最低位表示方向位)</p>
<p><strong>4.3.1 为什么需要page**</strong>页地址？**</p>
<p>因为I2C的数据位是8位,而AT24CXX的读写地址值最大可以为2048(2^11),超过了I2C的数据位</p>
<p>而page页地址就是用来解决这个问题的</p>
<p><strong>比如AT24C16:</strong></p>
<p>当发送:0XA2(设备地址P[2:0]=0x01) ,0x00(读地址)时:</p>
<p>表示要读的真正地址=0x01(页地址)*256+0(读地址)=0x100,转化为二进制= 1 0000 0000</p>
<p>当发送:0XA0(设备地址), 0x00(读地址)时:</p>
<p>表示要读的真正地址=0x00*256+0xFF=0xFF，转化为二进制= 0 1111 1111</p>
<p><strong>4.3.2 如上图所示,对于AT240C02来讲:</strong></p>
<ul>
<li>芯片的容量小于等于2^8(256)字节,那么读写地址就用8bit来表示,所以设备地址里没有P2~P0</li>
<li>读操作时,发送的设备地址等于0XA1</li>
<li>写操作时,发送的设备地址等于0XA0</li>
</ul>
<p><strong>5. AT24C02**</strong>时序图介绍**</p>
<p><strong>5.1**</strong>写时序介绍**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160251747-176931382.png" alt="img"></p>
<p>当随机写一个字节时,只需要先发送一个起始信号,然后跟上0XA0设备地址,以及要写的起始地址值,后面便是要写入地址的data,如果需要连续写数据,只需要连续写入data,地址会自动加1,直到发送停止信号结束</p>
<p><strong>5.2**</strong>读时序介绍**</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171106160301450-1538334264.png" alt="img"></p>
<p>当随机读一个字节时,先发送第一个起始信号,然后写入0XA0设备地址和要读的地址值,</p>
<p>接着发送第二个起始信号,然后写入0XA1设备地址,接着就是要读的data,如果需要连续读数据,只需要连续读出data,地址会自动加1,直到发送停止信号结束</p>
<p><strong>接下来,下节开始学习:</strong></p>
<p>Linux下如何利用linux下I2C驱动体系结构来操作24C02  <a href="http://www.cnblogs.com/lifexy/p/7816324.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7816324.html</a></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】i2c子系统</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91i2c%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.cnblogs.com/Lioker/p/11002962.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/11002962.html】</a></p>
<p>由于之后的触摸屏驱动分析中使用到了GPIO子系统和i2c子系统，因此在分析触摸屏驱动之前我准备把这两个子系统进行简单分析。</p>
<p>在读者学习本章以及后续i2c相关章节之前，最好了解i2c通信方式，可以参考：<a href="http://wiki.100ask.org/第019课_I2C" target="_blank" rel="noopener">i2c编程</a>。</p>
<h1 id="一、i2c框架分析"><a href="#一、i2c框架分析" class="headerlink" title="一、i2c框架分析"></a>一、i2c框架分析</h1><p>和总线设备驱动模型类似，<strong>i2c分为核心层、总线驱动层和设备驱动层。总线驱动层向核心层提供统一接口，设备驱动层实现底层设备操作。</strong></p>
<p>核心层：drivers/i2c/i2c-core.c文件</p>
<p>总线驱动层：i2c总线驱动是i2c适配器的软件实现，让i2c适配器与从设备间完成数据通信</p>
<p>设备驱动层：用于实现设备的注册和设备驱动的注册</p>
<p>由于i2c也是使用总线，在此不再分析核心层框架，对于总线核心层读者可以查看：<a href="https://www.cnblogs.com/Lioker/p/10893768.html" target="_blank" rel="noopener">总线设备驱动模型</a>第三节。i2c核心层主要实现的有：</p>
<p>\1. 注册总线i2c_bus_type</p>
<p>\2. 提供总线match()等函数。其中总线probe()会调用i2c_driver的probe()，这是因为之前说的：总线驱动层向核心层提供统一接口，设备驱动层实现底层设备操作</p>
<p>\3. 向底层提供注册函数</p>
<p>i2c框架如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190611152214816-1876040712.png" alt="img"></p>
<p>在上图中除去之前介绍的总线驱动和设备驱动，接下来我会分别介绍其余结构体。</p>
<p>\1. i2c_client表示一个i2c设备</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_client &#123;</span><br><span class="line"> 2     unsigned short flags;        &#x2F;* i2c设备标志位 *&#x2F;</span><br><span class="line"> 3     unsigned short addr;         &#x2F;* i2c设备地址 *&#x2F;</span><br><span class="line"> 4     char name[I2C_NAME_SIZE];    &#x2F;* 名字 *&#x2F;</span><br><span class="line"> 5     struct i2c_adapter *adapter; &#x2F;* 指向与其对应的适配器 *&#x2F;</span><br><span class="line"> 6     struct i2c_driver *driver;   &#x2F;* 指向与其对应的设备驱动 *&#x2F;</span><br><span class="line"> 7     struct device dev;           &#x2F;* the device structure *&#x2F;</span><br><span class="line"> 8     int irq;                     &#x2F;* irq issued by device *&#x2F;</span><br><span class="line"> 9     struct list_head detected;   &#x2F;* 作为节点挂接到i2c_driver链表中 *&#x2F;</span><br><span class="line">10 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>\2. i2c_driver表示i2c设备驱动</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_driver &#123;</span><br><span class="line"> 2     unsigned int class;</span><br><span class="line"> 3 </span><br><span class="line"> 4     &#x2F;* attach_adapter()用于匹配适配器 *&#x2F;</span><br><span class="line"> 5     int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"> 6     int (*detach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"> 7 </span><br><span class="line"> 8     &#x2F;* 设备驱动层的probe()和注销函数 *&#x2F;</span><br><span class="line"> 9     int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">10     int (*remove)(struct i2c_client *);</span><br><span class="line">11 </span><br><span class="line">12     &#x2F;* 电源管理相关，暂时用不到 *&#x2F;</span><br><span class="line">13     &#x2F;* driver model interfaces that don&#39;t relate to enumeration  *&#x2F;</span><br><span class="line">14     void (*shutdown)(struct i2c_client *);</span><br><span class="line">15     int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br><span class="line">16     int (*resume)(struct i2c_client *);</span><br><span class="line">17 </span><br><span class="line">18     &#x2F;* Alert callback, for example for the SMBus alert protocol.</span><br><span class="line">19      * The format and meaning of the data value depends on the protocol.</span><br><span class="line">20      * For the SMBus alert protocol, there is a single bit of data passed</span><br><span class="line">21      * as the alert response&#39;s low bit (&quot;event flag&quot;).</span><br><span class="line">22      *&#x2F;</span><br><span class="line">23     void (*alert)(struct i2c_client *, unsigned int data);</span><br><span class="line">24 </span><br><span class="line">25     &#x2F;* a ioctl like command that can be used to perform specific functions</span><br><span class="line">26      * with the device.</span><br><span class="line">27      *&#x2F;</span><br><span class="line">28     int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br><span class="line">29 </span><br><span class="line">30     struct device_driver driver;          &#x2F;* 设备驱动对应的device_driver *&#x2F;</span><br><span class="line">31     const struct i2c_device_id *id_table; &#x2F;* 匹配设备驱动和设备的id_table *&#x2F;</span><br><span class="line">32 </span><br><span class="line">33     &#x2F;* Device detection callback for automatic device creation *&#x2F;</span><br><span class="line">34     int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">35     const unsigned short *address_list;  &#x2F;* 设备驱动支持的所有i2c设备的地址数组 *&#x2F;</span><br><span class="line">36     struct list_head clients;            &#x2F;* 用于挂接匹配成功的i2c_client的链表头 *&#x2F;</span><br><span class="line">37 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>\3. i2c_adapter表示i2c适配器，可以理解为是一个i2c主机</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_adapter &#123;</span><br><span class="line"> 2     struct module *owner;</span><br><span class="line"> 3     unsigned int class;          &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line"> 4     const struct i2c_algorithm *algo; &#x2F;* 适配器与设备的通信算法 *&#x2F;</span><br><span class="line"> 5     void *algo_data;</span><br><span class="line"> 6 </span><br><span class="line"> 7     &#x2F;* data fields that are valid for all devices    *&#x2F;</span><br><span class="line"> 8     struct rt_mutex bus_lock;</span><br><span class="line"> 9 </span><br><span class="line">10     int timeout;        &#x2F;* 超时时间，使用jiffies表示 *&#x2F;</span><br><span class="line">11     int retries;</span><br><span class="line">12     struct device dev;  &#x2F;* 适配器对应的device *&#x2F;</span><br><span class="line">13 </span><br><span class="line">14     int nr;             &#x2F;* 适配器的编号 *&#x2F;</span><br><span class="line">15     char name[48];      &#x2F;* 适配器名字 *&#x2F;</span><br><span class="line">16     struct completion dev_released;</span><br><span class="line">17 </span><br><span class="line">18     struct mutex userspace_clients_lock;</span><br><span class="line">19     struct list_head userspace_clients;    &#x2F;* 用于挂接i2c_client的链表头 *&#x2F;</span><br><span class="line">20 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>\4. i2c_algorithm是i2c数据通信的算法</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_algorithm &#123;</span><br><span class="line"> 2     &#x2F;* 数据传输函数 *&#x2F;</span><br><span class="line"> 3     int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line"> 4                int num);</span><br><span class="line"> 5     &#x2F;* smbus协议传输函数，在i2c中使用不上 *&#x2F;</span><br><span class="line"> 6     int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line"> 7                unsigned short flags, char read_write,</span><br><span class="line"> 8                u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"> 9 </span><br><span class="line">10     &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">11     u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">12 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>代码中第3行：struct i2c_msg定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    __u16 addr;    &#x2F;* i2c设备地址 *&#x2F;</span><br><span class="line">    __u16 flags;     &#x2F;* 读&#x2F;写。一般1为读，也就是I2C_M_RD，0为写 *&#x2F;</span><br><span class="line">#define I2C_M_TEN        0x0010    &#x2F;* this is a ten bit chip address *&#x2F;</span><br><span class="line">#define I2C_M_RD        0x0001    &#x2F;* read data, from slave to master *&#x2F;</span><br><span class="line">#define I2C_M_NOSTART        0x4000    &#x2F;* if I2C_FUNC_NOSTART *&#x2F;</span><br><span class="line">#define I2C_M_REV_DIR_ADDR    0x2000    &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_IGNORE_NAK    0x1000    &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_NO_RD_ACK        0x0800    &#x2F;* if I2C_FUNC_PROTOCOL_MANGLING *&#x2F;</span><br><span class="line">#define I2C_M_RECV_LEN        0x0400    &#x2F;* length will be first received byte *&#x2F;</span><br><span class="line">    __u16 len;        &#x2F;* msg length                *&#x2F;</span><br><span class="line">    __u8 *buf;        &#x2F;* pointer to msg data            *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由于适配器的参数根据芯片不同有所不同。因此<strong>i2c_adapter的初始化一般会在会在平台驱动初始化或probe()函数中配置。</strong></p>
<p><strong>i2c_algorithm在i2c_adapter中有指针定义，因此我们需要在配置i2c_adapter之前配置i2c_algorithm。</strong></p>
<p><strong>i2c_client由我们实现，主要需要设置它的地址。</strong></p>
<p><strong>i2c_driver也由我们实现，格式与platform_driver类似。</strong></p>
<h1 id="二、核心层提供的注册函数"><a href="#二、核心层提供的注册函数" class="headerlink" title="二、核心层提供的注册函数"></a>二、核心层提供的注册函数</h1><p><strong>1. i2c_add_adapter()和i2c_add_numbered_adapter()用于注册i2c_adapter</strong></p>
<p>i2c_add_adapter()由系统给设备分配编号，i2c_add_numbered_adapter()由我们指定设备编号，如果设备编号被使用，会返回错误。</p>
<p>两函数底层调用的都是i2_register_adapter()：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int res &#x3D; 0;</span><br><span class="line"> 4 ...</span><br><span class="line"> 5     rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line"> 6     mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"> 7     </span><br><span class="line"> 8     &#x2F;* 初始化i2c_adapteruserspace_clients链表 *&#x2F;</span><br><span class="line"> 9     INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* Set default timeout to 1 second if not already set *&#x2F;</span><br><span class="line">12     if (adap-&gt;timeout &#x3D;&#x3D; 0)</span><br><span class="line">13         adap-&gt;timeout &#x3D; HZ;</span><br><span class="line">14 </span><br><span class="line">15     dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr);    &#x2F;* 设置adapter名字 *&#x2F;</span><br><span class="line">16     adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;                   &#x2F;* 设置设备的总线类型 *&#x2F;</span><br><span class="line">17     adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type;              &#x2F;* 设置设备的设备类型 *&#x2F;</span><br><span class="line">18     res &#x3D; device_register(&amp;adap-&gt;dev);               &#x2F;* 注册设备&#x2F;sys&#x2F;devices&#x2F;i2c-%d *&#x2F;</span><br><span class="line">19 ...</span><br><span class="line">20     &#x2F;* create pre-declared device nodes *&#x2F;</span><br><span class="line">21     if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">22         i2c_scan_static_board_info(adap);    &#x2F;* 扫描并创建i2c设备 *&#x2F;</span><br><span class="line">23 </span><br><span class="line">24     &#x2F;* Notify drivers *&#x2F;</span><br><span class="line">25     mutex_lock(&amp;core_lock);</span><br><span class="line">26     bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">27     mutex_unlock(&amp;core_lock);</span><br><span class="line">28 ...</span><br><span class="line">29     return res;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>现在我们继续分析上面代码中的第22行：i2c_scan_static_board_info(adap)，它调用了i2c_new_device()函数来添加一个i2c设备。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct i2c_devinfo    *devinfo;</span><br><span class="line"> 4 </span><br><span class="line"> 5     down_read(&amp;__i2c_board_lock);</span><br><span class="line"> 6     list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class="line"> 7         if (devinfo-&gt;busnum &#x3D;&#x3D; adapter-&gt;nr</span><br><span class="line"> 8                 &amp;&amp; !i2c_new_device(adapter,</span><br><span class="line"> 9                         &amp;devinfo-&gt;board_info))</span><br><span class="line">10             dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">11                 &quot;Can&#39;t create device at 0x%02x\n&quot;,</span><br><span class="line">12                 devinfo-&gt;board_info.addr);</span><br><span class="line">13     &#125;</span><br><span class="line">14     up_read(&amp;__i2c_board_lock);</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>2. i2c_new_device()用于注册i2c_client</strong></p>
<p>i2c_new_device()调用了device_register()来添加一个设备。关于device的注册过程可以查看<a href="https://www.cnblogs.com/Lioker/p/10834377.html" target="_blank" rel="noopener">Linux驱动函数解读</a>第二节</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_client *i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct i2c_client    *client;</span><br><span class="line"> 4     int            status;</span><br><span class="line"> 5     &#x2F;* 设置i2c_client成员 *&#x2F;</span><br><span class="line"> 6     client &#x3D; kzalloc(sizeof *client, GFP_KERNEL);</span><br><span class="line"> 7 ...</span><br><span class="line"> 8     client-&gt;adapter &#x3D; adap;</span><br><span class="line"> 9 </span><br><span class="line">10     client-&gt;dev.platform_data &#x3D; info-&gt;platform_data;</span><br><span class="line">11 </span><br><span class="line">12     if (info-&gt;archdata)</span><br><span class="line">13         client-&gt;dev.archdata &#x3D; *info-&gt;archdata;</span><br><span class="line">14 </span><br><span class="line">15     client-&gt;flags &#x3D; info-&gt;flags;</span><br><span class="line">16     client-&gt;addr &#x3D; info-&gt;addr;</span><br><span class="line">17     client-&gt;irq &#x3D; info-&gt;irq;</span><br><span class="line">18 </span><br><span class="line">19     strlcpy(client-&gt;name, info-&gt;type, sizeof(client-&gt;name));</span><br><span class="line">20 </span><br><span class="line">21     &#x2F;* 判断地址的有效性 *&#x2F;</span><br><span class="line">22     status &#x3D; i2c_check_client_addr_validity(client);</span><br><span class="line">23 ...</span><br><span class="line">24     &#x2F;* Check for address business *&#x2F;</span><br><span class="line">25     status &#x3D; i2c_check_addr_busy(adap, client-&gt;addr);</span><br><span class="line">26 ...</span><br><span class="line">27     client-&gt;dev.parent &#x3D; &amp;client-&gt;adapter-&gt;dev; &#x2F;* 设置设备的适配器 *&#x2F;</span><br><span class="line">28     client-&gt;dev.bus &#x3D; &amp;i2c_bus_type;            &#x2F;* 设置所属总线 *&#x2F;</span><br><span class="line">29     client-&gt;dev.type &#x3D; &amp;i2c_client_type;        &#x2F;* 设置设备类型 *&#x2F;</span><br><span class="line">30     client-&gt;dev.of_node &#x3D; info-&gt;of_node;</span><br><span class="line">31 </span><br><span class="line">32     &#x2F;* For 10-bit clients, add an arbitrary offset to avoid collisions *&#x2F;</span><br><span class="line">33     dev_set_name(&amp;client-&gt;dev, &quot;%d-%04x&quot;, i2c_adapter_id(adap),</span><br><span class="line">34              client-&gt;addr | ((client-&gt;flags &amp; I2C_CLIENT_TEN)</span><br><span class="line">35                      ? 0xa000 : 0));</span><br><span class="line">36     &#x2F;* 注册设备 *&#x2F;</span><br><span class="line">37     status &#x3D; device_register(&amp;client-&gt;dev);</span><br><span class="line">38 ...</span><br><span class="line">39 </span><br><span class="line">40     return client;</span><br><span class="line">41 ...</span><br><span class="line">42 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>i2c_new_device()函数的第二个传入参数struct i2c_board_info涉及了i2_client的设置。该参数应该是我们注册设备时传入的，我们可以在内核中搜索static struct i2c_board_info来看看它的格式是什么：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static struct i2c_board_info i2c_board_info[] &#x3D; &#123;</span><br><span class="line">2     &#123;</span><br><span class="line">3         &#x2F;* &quot;uda1380&quot;为名字，0x18为设备地址 *&#x2F;</span><br><span class="line">4         I2C_BOARD_INFO(&quot;uda1380&quot;, 0x18),</span><br><span class="line">5         &#x2F;* 自己定义的结构体，在此不需要关心 *&#x2F;</span><br><span class="line">6         .platform_data &#x3D; &amp;uda1380_info,</span><br><span class="line">7     &#125;,</span><br><span class="line">8 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>此处我们需要特别注意设备地址的定义。在uda1380的数据手册中可以确定其i2c设备地址如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1542940/202002/1542940-20200222163713137-674311889.png" alt="img"> </p>
<p>由于最后一位为读写位，因此地址为0x18而不是0x30。</p>
<p><strong>3. i2c_add_driver()用于注册i2c_device driver</strong></p>
<p>i2c_add_driver()调用了i2c_register_driver()来注册一个设备驱动。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     int res;</span><br><span class="line"> 4 </span><br><span class="line"> 5     &#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line"> 6     if (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line"> 7         return -EAGAIN;</span><br><span class="line"> 8 </span><br><span class="line"> 9     &#x2F;* add the driver to the list of i2c drivers in the driver core *&#x2F;</span><br><span class="line">10     driver-&gt;driver.owner &#x3D; owner;</span><br><span class="line">11     driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line">12 </span><br><span class="line">13     &#x2F;* 注册设备驱动 *&#x2F;</span><br><span class="line">14     res &#x3D; driver_register(&amp;driver-&gt;driver);</span><br><span class="line">15 ...</span><br><span class="line">16     &#x2F;* 初始化 i2c_driver-&gt;clients 链表 *&#x2F;</span><br><span class="line">17     INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">18     &#x2F;* Walk the adapters that are already present *&#x2F;</span><br><span class="line">19     i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line">20 </span><br><span class="line">21     return 0;</span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>代码中第14行：driver_register()函数调用过程和platform_driver_register()的driver_register()函数调用过程是一样的。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver_register(&amp;drv-&gt;driver);</span><br><span class="line">  -&gt; bus_add_driver(drv);            &#x2F;&#x2F; 添加驱动到链表中</span><br><span class="line">    -&gt; driver_attach(drv);</span><br><span class="line">      -&gt; bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);</span><br><span class="line">        -&gt; __driver_attach()</span><br><span class="line">          -&gt; driver_match_device(drv, dev);</span><br><span class="line">              &#x2F;&#x2F; 调用driver的match()</span><br><span class="line">              -&gt; return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;</span><br><span class="line">        -&gt; driver_probe_device(drv, dev);</span><br><span class="line">          -&gt; really_probe(dev, drv);</span><br><span class="line">            -&gt; drv-&gt;probe(dev);    &#x2F;&#x2F; 调用i2c_driver的probe()函数</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过前3点分析，可知i2c子系统内部存在着两个匹配过程：</p>
<p>\1. <strong>i2c_adapter与i2c_client</strong>之间，两者通过适配器编号进行匹配</p>
<p>\2. i2c总线下的<strong>i2c_client与i2c_driver</strong>之间，两者通过设备驱动的id_table进行匹配</p>
<p>在第一节末尾，我提到了四个结构体的实现位置。在第三节，我会根据具体平台进行分析。</p>
<h1 id="三、i2c-s3c2410-c文件分析"><a href="#三、i2c-s3c2410-c文件分析" class="headerlink" title="三、i2c-s3c2410.c文件分析"></a>三、i2c-s3c2410.c文件分析</h1><p>首先我们来查看probe()函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct s3c24xx_i2c *i2c;</span><br><span class="line"> 4     struct s3c2410_platform_i2c *pdata &#x3D; NULL;</span><br><span class="line"> 5     struct resource *res;</span><br><span class="line"> 6     int ret;</span><br><span class="line"> 7 ...</span><br><span class="line"> 8     i2c &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct s3c24xx_i2c), GFP_KERNEL);</span><br><span class="line"> 9 ...</span><br><span class="line">10     i2c-&gt;pdata &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*pdata), GFP_KERNEL);</span><br><span class="line">11 ...</span><br><span class="line">12     i2c-&gt;quirks &#x3D; s3c24xx_get_device_quirks(pdev);</span><br><span class="line">13     if (pdata)</span><br><span class="line">14         memcpy(i2c-&gt;pdata, pdata, sizeof(*pdata));</span><br><span class="line">15     else</span><br><span class="line">16         s3c24xx_i2c_parse_dt(pdev-&gt;dev.of_node, i2c);</span><br><span class="line">17     &#x2F;* 设置i2c_adapter *&#x2F;</span><br><span class="line">18     strlcpy(i2c-&gt;adap.name, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;adap.name));</span><br><span class="line">19     i2c-&gt;adap.owner   &#x3D; THIS_MODULE;</span><br><span class="line">20     i2c-&gt;adap.algo    &#x3D; &amp;s3c24xx_i2c_algorithm;    &#x2F;* 通信算法 *&#x2F;</span><br><span class="line">21     i2c-&gt;adap.retries &#x3D; 2;</span><br><span class="line">22     i2c-&gt;adap.class   &#x3D; I2C_CLASS_HWMON | I2C_CLASS_SPD;</span><br><span class="line">23     i2c-&gt;tx_setup     &#x3D; 50;</span><br><span class="line">24 </span><br><span class="line">25     init_waitqueue_head(&amp;i2c-&gt;wait);</span><br><span class="line">26 </span><br><span class="line">27     &#x2F;* find the clock and enable it *&#x2F;</span><br><span class="line">28 </span><br><span class="line">29     i2c-&gt;dev &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">30     i2c-&gt;clk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);    &#x2F;* 获取并使能时钟 *&#x2F;</span><br><span class="line">31 ...</span><br><span class="line">32     clk_enable(i2c-&gt;clk);</span><br><span class="line">33 </span><br><span class="line">34     &#x2F;* map the registers *&#x2F;</span><br><span class="line">35 </span><br><span class="line">36     res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">37 ...</span><br><span class="line">38     i2c-&gt;ioarea &#x3D; request_mem_region(res-&gt;start, resource_size(res), pdev-&gt;name);</span><br><span class="line">39 ...</span><br><span class="line">40     i2c-&gt;regs &#x3D; ioremap(res-&gt;start, resource_size(res));</span><br><span class="line">41 ...</span><br><span class="line">42     i2c-&gt;adap.algo_data &#x3D; i2c;</span><br><span class="line">43     i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">44 </span><br><span class="line">45     &#x2F;* inititalise the i2c gpio lines *&#x2F;</span><br><span class="line">46 </span><br><span class="line">47     if (i2c-&gt;pdata-&gt;cfg_gpio) &#123;</span><br><span class="line">48         i2c-&gt;pdata-&gt;cfg_gpio(to_platform_device(i2c-&gt;dev));</span><br><span class="line">49     &#125;</span><br><span class="line">50 ...</span><br><span class="line">51     ret &#x3D; s3c24xx_i2c_init(i2c);    &#x2F;* 硬件初始化 *&#x2F;</span><br><span class="line">52 ...</span><br><span class="line">53     i2c-&gt;irq &#x3D; ret &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">54 ...</span><br><span class="line">55     ret &#x3D; request_irq(i2c-&gt;irq, s3c24xx_i2c_irq, 0,</span><br><span class="line">56               dev_name(&amp;pdev-&gt;dev), i2c);</span><br><span class="line">57 ...</span><br><span class="line">58     ret &#x3D; s3c24xx_i2c_register_cpufreq(i2c);</span><br><span class="line">59 ...</span><br><span class="line">60     i2c-&gt;adap.nr &#x3D; i2c-&gt;pdata-&gt;bus_num;</span><br><span class="line">61     i2c-&gt;adap.dev.of_node &#x3D; pdev-&gt;dev.of_node;</span><br><span class="line">62 </span><br><span class="line">63     ret &#x3D; i2c_add_numbered_adapter(&amp;i2c-&gt;adap);        &#x2F;* 注册i2c_adapter *&#x2F;</span><br><span class="line">64 ...</span><br><span class="line">65     of_i2c_register_devices(&amp;i2c-&gt;adap);</span><br><span class="line">66     platform_set_drvdata(pdev, i2c);</span><br><span class="line">67 ...</span><br><span class="line">68     clk_disable(i2c-&gt;clk);</span><br><span class="line">69 ...</span><br><span class="line">70     return ret;</span><br><span class="line">71 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>和我们预想的一致，probe()函数初始化并注册了i2c_adapter和i2c_algorithm。</p>
<p>看完i2c_adapter之后，我们来看一下i2c_algorithm是如何定义的。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 &#x2F;* 底层寄存器操作 *&#x2F;</span><br><span class="line">  2 static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c, struct i2c_msg *msg)</span><br><span class="line">  3 &#123;</span><br><span class="line">  4     unsigned int addr &#x3D; (msg-&gt;addr &amp; 0x7f) &lt;&lt; 1;</span><br><span class="line">  5     unsigned long stat;</span><br><span class="line">  6     unsigned long iiccon;</span><br><span class="line">  7 </span><br><span class="line">  8     stat &#x3D; 0;</span><br><span class="line">  9     stat |&#x3D;  S3C2410_IICSTAT_TXRXEN;</span><br><span class="line"> 10 </span><br><span class="line"> 11     if (msg-&gt;flags &amp; I2C_M_RD) &#123;</span><br><span class="line"> 12         stat |&#x3D; S3C2410_IICSTAT_MASTER_RX;</span><br><span class="line"> 13         addr |&#x3D; 1;</span><br><span class="line"> 14     &#125; else</span><br><span class="line"> 15         stat |&#x3D; S3C2410_IICSTAT_MASTER_TX;</span><br><span class="line"> 16 </span><br><span class="line"> 17     if (msg-&gt;flags &amp; I2C_M_REV_DIR_ADDR)</span><br><span class="line"> 18         addr ^&#x3D; 1;</span><br><span class="line"> 19 </span><br><span class="line"> 20     &#x2F;* todo - check for whether ack wanted or not *&#x2F;</span><br><span class="line"> 21     s3c24xx_i2c_enable_ack(i2c);</span><br><span class="line"> 22 </span><br><span class="line"> 23     iiccon &#x3D; readl(i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line"> 24     writel(stat, i2c-&gt;regs + S3C2410_IICSTAT);</span><br><span class="line"> 25 </span><br><span class="line"> 26     dev_dbg(i2c-&gt;dev, &quot;START: %08lx to IICSTAT, %02x to DS\n&quot;, stat, addr);</span><br><span class="line"> 27     writeb(addr, i2c-&gt;regs + S3C2410_IICDS);</span><br><span class="line"> 28 </span><br><span class="line"> 29     &#x2F;* delay here to ensure the data byte has gotten onto the bus</span><br><span class="line"> 30      * before the transaction is started *&#x2F;</span><br><span class="line"> 31 </span><br><span class="line"> 32     ndelay(i2c-&gt;tx_setup);</span><br><span class="line"> 33 </span><br><span class="line"> 34     dev_dbg(i2c-&gt;dev, &quot;iiccon, %08lx\n&quot;, iiccon);</span><br><span class="line"> 35     writel(iiccon, i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line"> 36 </span><br><span class="line"> 37     stat |&#x3D; S3C2410_IICSTAT_START;</span><br><span class="line"> 38     writel(stat, i2c-&gt;regs + S3C2410_IICSTAT);</span><br><span class="line"> 39 &#125;</span><br><span class="line"> 40 </span><br><span class="line"> 41 static int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c,</span><br><span class="line"> 42                   struct i2c_msg *msgs, int num)</span><br><span class="line"> 43 &#123;</span><br><span class="line"> 44     unsigned long timeout;</span><br><span class="line"> 45     int ret;</span><br><span class="line"> 46 ...</span><br><span class="line"> 47     ret &#x3D; s3c24xx_i2c_set_master(i2c);</span><br><span class="line"> 48 ...</span><br><span class="line"> 49     i2c-&gt;msg     &#x3D; msgs;</span><br><span class="line"> 50     i2c-&gt;msg_num &#x3D; num;</span><br><span class="line"> 51     i2c-&gt;msg_ptr &#x3D; 0;</span><br><span class="line"> 52     i2c-&gt;msg_idx &#x3D; 0;</span><br><span class="line"> 53     i2c-&gt;state   &#x3D; STATE_START;</span><br><span class="line"> 54 </span><br><span class="line"> 55     s3c24xx_i2c_enable_irq(i2c);</span><br><span class="line"> 56     s3c24xx_i2c_message_start(i2c, msgs);</span><br><span class="line"> 57 </span><br><span class="line"> 58     timeout &#x3D; wait_event_timeout(i2c-&gt;wait, i2c-&gt;msg_num &#x3D;&#x3D; 0, HZ * 5);</span><br><span class="line"> 59 </span><br><span class="line"> 60     ret &#x3D; i2c-&gt;msg_idx;</span><br><span class="line"> 61 ...</span><br><span class="line"> 62     s3c24xx_i2c_wait_idle(i2c);</span><br><span class="line"> 63     return ret;</span><br><span class="line"> 64 &#125;</span><br><span class="line"> 65 </span><br><span class="line"> 66 static int s3c24xx_i2c_xfer(struct i2c_adapter *adap,</span><br><span class="line"> 67             struct i2c_msg *msgs, int num)</span><br><span class="line"> 68 &#123;</span><br><span class="line"> 69     struct s3c24xx_i2c *i2c &#x3D; (struct s3c24xx_i2c *)adap-&gt;algo_data;</span><br><span class="line"> 70     int retry;</span><br><span class="line"> 71     int ret;</span><br><span class="line"> 72 </span><br><span class="line"> 73     pm_runtime_get_sync(&amp;adap-&gt;dev);</span><br><span class="line"> 74     clk_enable(i2c-&gt;clk);</span><br><span class="line"> 75 </span><br><span class="line"> 76     for (retry &#x3D; 0; retry &lt; adap-&gt;retries; retry++) &#123;</span><br><span class="line"> 77 </span><br><span class="line"> 78         ret &#x3D; s3c24xx_i2c_doxfer(i2c, msgs, num);</span><br><span class="line"> 79 </span><br><span class="line"> 80         if (ret !&#x3D; -EAGAIN) &#123;</span><br><span class="line"> 81             clk_disable(i2c-&gt;clk);</span><br><span class="line"> 82             pm_runtime_put_sync(&amp;adap-&gt;dev);</span><br><span class="line"> 83             return ret;</span><br><span class="line"> 84         &#125;</span><br><span class="line"> 85 </span><br><span class="line"> 86         dev_dbg(i2c-&gt;dev, &quot;Retrying transmission (%d)\n&quot;, retry);</span><br><span class="line"> 87 </span><br><span class="line"> 88         udelay(100);</span><br><span class="line"> 89     &#125;</span><br><span class="line"> 90 </span><br><span class="line"> 91     clk_disable(i2c-&gt;clk);</span><br><span class="line"> 92     pm_runtime_put_sync(&amp;adap-&gt;dev);</span><br><span class="line"> 93     return -EREMOTEIO;</span><br><span class="line"> 94 &#125;</span><br><span class="line"> 95 </span><br><span class="line"> 96 static u32 s3c24xx_i2c_func(struct i2c_adapter *adap)</span><br><span class="line"> 97 &#123;</span><br><span class="line"> 98     return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART |</span><br><span class="line"> 99         I2C_FUNC_PROTOCOL_MANGLING;</span><br><span class="line">100 &#125;</span><br><span class="line">101 </span><br><span class="line">102 static const struct i2c_algorithm s3c24xx_i2c_algorithm &#x3D; &#123;</span><br><span class="line">103     .master_xfer        &#x3D; s3c24xx_i2c_xfer,</span><br><span class="line">104     .functionality        &#x3D; s3c24xx_i2c_func,</span><br><span class="line">105 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>代码中底层操作是我们可能需要根据用户手册时序的属性更改的部分；i2c_algorithm成员函数functionality定义的是adapter所具有的功能，如是否支持smbus协议。</p>
<h1 id="四、设备驱动层程序编写过程"><a href="#四、设备驱动层程序编写过程" class="headerlink" title="四、设备驱动层程序编写过程"></a>四、设备驱动层程序编写过程</h1><p>我们在写i2c设备驱动层时，需要获取i2c_adapter，此时需要使用的函数是i2c_adapter *i2c_get_adapter(int nr)。</p>
<p>与i2c_get_adapter()对应的注销使用函数是void i2c_put_adapter(struct i2c_adapter *adap)。</p>
<p>消息接收顶层使用的是int i2c_master_send(const struct i2c_client *client, const char *buf, int count)和int i2c_master_recv(const struct i2c_client *client, char *buf, int count)。两函数底层调用都是i2c_transfer()，我们也可以直接调用i2c_transfer()。</p>
<p>i2c_get_adapter()函数参数nr为adapter的编号，如下图，nr有0、1、3等。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190614210801097-88773797.png" alt="img"></p>
<p>除上图之外，我们也可以查看设备地址等信息。</p>
<p>查询i2c设备地址：ls /sys/bus/i2c/devices/</p>
<p>设备和原理图对应关系：3-0038  I2C_3_SCL（addr为0x38）</p>
<p>查询i2c设备名称：cat /sys/bus/i2c/devices/3-0038/name</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201906/1542940-20190614213456018-734703919.png" alt="img"></p>
<p>现在我们来想象一下设备驱动层程序编写过程：</p>
<p>对于i2c_client：</p>
<p>\1. 设置struct i2c_board_info</p>
<p>\2. 在初始化函数中，首先i2c_get_adapter()获取adapter，之后通过i2c_new_device()和传入参数adapter与struct i2c_board_info获取struct i2c_client，最后i2c_put_adapter()释放adapter</p>
<p>\3. 在退出函数中，i2c_unregister_device()</p>
<p>对于i2c_driver：</p>
<p>\1. 定义i2c_driver（定义与platform_driver类似，多个一个用于匹配i2c_client的id_table，也就是struct i2c_device_id）</p>
<p>\2. 由于i2c也属于字符设备，所以我们要在probe()函数中注册cdev、file_operations、class和device</p>
<p>\2. 在write()函数中调用i2c_master_send()</p>
<p>\3. 在read()函数中调用i2c_master_recv()</p>
<p>\4. 在初始化函数中，i2c_add_driver()</p>
<p>\5. 在退出函数中，i2c_del_driver()</p>
<p>下一章我们来实现触摸屏驱动程序。</p>
<p>下一章  <a href="https://www.cnblogs.com/Lioker/p/10990633.html" target="_blank" rel="noopener">15、电容触摸屏驱动</a></p>
<p>作者：<a href="https://www.cnblogs.com/Lioker/" target="_blank" rel="noopener">Lioker</a></p>
<p>邮箱：<a href="mailto:lioker@outlook.com">lioker@outlook.com</a></p>
<p>作者水平有限，欢迎拍砖。转载请注明出处。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux I2C子系统分析：0-整体框架介绍</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%9A0-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【<a href="https://www.cnblogs.com/schips/p/linux-subsystem-i2c-0-about.html】" target="_blank" rel="noopener">https://www.cnblogs.com/schips/p/linux-subsystem-i2c-0-about.html】</a></p>
<p>内核版本：v4.14</p>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>在Linux的I2C架构如图：</p>
<p><a href="https://img2020.cnblogs.com/blog/2120938/202010/2120938-20201013152732525-1054325417.png" target="_blank" rel="noopener"><img src="https://img2020.cnblogs.com/blog/2120938/202010/2120938-20201013152732525-1054325417.png" alt="Linux-i2c子系统框图"></a></p>
<p>Linux-i2c子系统框图</p>
<p>内核空间部分可以分为：i2c设备驱动、i2c核心以及i2c总线驱动。</p>
<ul>
<li><strong>i2c核心</strong>：框架的实现；提供i2c总线驱动和设备驱动的注册、注销方法；i2c通信方法（algorithm）上层的，与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等。这一部分的工作由内核开发者完成。</li>
<li><strong>i2c总线驱动</strong>：具体控制器的实现；i2c总线驱动是对i2c硬件体系结构中适配器端的实现，说白了，就是怎么操作i2c模块工作。适配器可由CPU控制，甚至直接集成到cpu里面（ algorithm driver<br>adapter driver）</li>
<li><strong>i2c设备</strong>：对i2c硬件体系结构中设备端的实现，比如说板上的EEPROM设备等。设备一般挂接在cpu控制的i2c适配器上，通过i2c适配器与cpu交换数据。（ chip drivers, 包括多种类型，如RTC, EEPROM, I/O expander, hardware monitoring, sound, video等）</li>
</ul>
<p>名词解释：</p>
<ul>
<li>i2c-adapter（适配器）：指的是CPU实际的I2C控制器（例如I2C0，I2C1）；</li>
<li>i2c-device（设备）：指的是I2C总线上的从设备（例如某片EEPROM，某个触摸屏）；</li>
<li>i2c algorithm（算法、实现方法）：这里指的是对i2c设备一套对应的通信方法。</li>
</ul>
<p>分层的好处：</p>
<ul>
<li>让工程师们各司其职，只关心自己应该实现的部分</li>
<li>不需要为每一个i2c控制器编写所有从设备的控制代码，只需要分别完成n个控制器的控制接口，m个从设备的访问实现，即可实现任意的控制器访问任意的从设备（假设硬件连接支持）</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>以下原型均定义在<code>include/linux/i2c.h</code>中，随着内核版本的不同有差异，但差异不大。</p>
<h3 id="i2c-设备驱动"><a href="#i2c-设备驱动" class="headerlink" title="i2c 设备驱动"></a>i2c 设备驱动</h3><p><strong>i2c_driver：</strong>代表一个i2c设备驱动；</p>
<p>i2c 设备驱动要使用i2c_driver 和i2c_client数据结构并填充i2c_driver中的成员函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_driver - represent an I2C device driver</span></span><br><span class="line"><span class="comment"> * @class: What kind of i2c device we instantiate (for detect)</span></span><br><span class="line"><span class="comment"> * @attach_adapter: Callback for bus addition (deprecated)</span></span><br><span class="line"><span class="comment"> * @probe: Callback for device binding - soon to be deprecated</span></span><br><span class="line"><span class="comment"> * @probe_new: New callback for device binding</span></span><br><span class="line"><span class="comment"> * @remove: Callback for device unbinding</span></span><br><span class="line"><span class="comment"> * @shutdown: Callback for device shutdown</span></span><br><span class="line"><span class="comment"> * @alert: Alert callback, for example for the SMBus alert protocol</span></span><br><span class="line"><span class="comment"> * @command: Callback for bus-wide signaling (optional)</span></span><br><span class="line"><span class="comment"> * @driver: Device driver model driver</span></span><br><span class="line"><span class="comment"> * @id_table: List of I2C devices supported by this driver</span></span><br><span class="line"><span class="comment"> * @detect: Callback for device detection</span></span><br><span class="line"><span class="comment"> * @address_list: The I2C addresses to probe (for detect)</span></span><br><span class="line"><span class="comment"> * @clients: List of detected clients we created (for i2c-core use only)</span></span><br><span class="line"><span class="comment"> * @disable_i2c_core_irq_mapping: Tell the i2c-core to not do irq-mapping</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver.owner field should be set to the module owner of this driver.</span></span><br><span class="line"><span class="comment"> * The driver.name field should be set to the name of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For automatic device detection, both @detect and @address_list must</span></span><br><span class="line"><span class="comment"> * be defined. @class should also be set, otherwise only devices forced</span></span><br><span class="line"><span class="comment"> * with module parameters will be created. The detect function must</span></span><br><span class="line"><span class="comment"> * fill at least the name field of the i2c_board_info structure it is</span></span><br><span class="line"><span class="comment"> * handed upon successful detection, and possibly also the flags field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @detect is missing, the driver will still work fine for enumerated</span></span><br><span class="line"><span class="comment"> * devices. Detected devices simply won't be supported. This is expected</span></span><br><span class="line"><span class="comment"> * for the many I2C/SMBus devices which can't be detected reliably, and</span></span><br><span class="line"><span class="comment"> * the ones which can always be enumerated in practice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The i2c_client structure which is handed to the @detect callback is</span></span><br><span class="line"><span class="comment"> * not a real i2c_client. It is initialized just enough so that you can</span></span><br><span class="line"><span class="comment"> * call i2c_smbus_read_byte_data and friends on it. Don't do anything</span></span><br><span class="line"><span class="comment"> * else with it. In particular, calling dev_dbg and friends on it is</span></span><br><span class="line"><span class="comment"> * not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">// 表示我们将注册的是那种设备（探测时用）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *) __deprecated; <span class="comment">// 添加总线时，告诉驱动的回调函数（以后可能要弃用）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct i2c_client *, <span class="keyword">const</span> struct i2c_device_id *); <span class="comment">// 绑定设备时的回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">remove</span>)(struct i2c_client *); <span class="comment">// 解除绑定时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()'s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe_new)(struct i2c_client *); <span class="comment">// 新的设备绑定回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don't relate to enumeration  */</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct i2c_client *); <span class="comment">// 设备关闭时调用的回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response's low bit ("event flag").</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> (*alert)(struct i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="keyword">unsigned</span> <span class="keyword">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*command)(struct i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg); <span class="comment">// 类似于ioctl 的命令控制函数</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span> <span class="comment">// 设备驱动模型中的驱动</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="keyword">int</span> (*detect)(struct i2c_client *, struct i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> short *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> <span class="comment">// 我们创建的检测到的clients（仅供i2c核心使用）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如：RTC设备的驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">"rtc-ds1307"</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-客户端"><a href="#i2c-客户端" class="headerlink" title="i2c 客户端"></a>i2c 客户端</h3><p><strong>i2c_client</strong>：代表一个连接到i2c_bus总线上的从设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_client - represent an I2C slave device</span></span><br><span class="line"><span class="comment"> * @flags: </span></span><br><span class="line"><span class="comment"> 	- I2C_CLIENT_TEN ： the device uses a ten bit chip address; 表示i2c从设备使用的芯片地址为10bit</span></span><br><span class="line"><span class="comment">	- I2C_CLIENT_PEC ： it uses SMBus Packet Error Checking；   表示设备使用SMBus错误检查</span></span><br><span class="line"><span class="comment"> * @addr: Address used on the I2C bus connected to the parent adapter.</span></span><br><span class="line"><span class="comment"> * @name: Indicates the type of the device, usually a chip name that's</span></span><br><span class="line"><span class="comment"> *	generic enough to hide second-sourcing and compatible revisions.</span></span><br><span class="line"><span class="comment"> * @adapter: manages the bus segment hosting this I2C device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model device node for the slave.</span></span><br><span class="line"><span class="comment"> * @irq: indicates the IRQ generated by this device (if any)</span></span><br><span class="line"><span class="comment"> * @detected: member of an i2c_driver.clients list or i2c-core's</span></span><br><span class="line"><span class="comment"> *	userspace_devices list</span></span><br><span class="line"><span class="comment"> * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter</span></span><br><span class="line"><span class="comment"> *	calls it to pass on slave events to the slave driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_client identifies a single device (i.e. chip) connected to an</span></span><br><span class="line"><span class="comment"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span></span><br><span class="line"><span class="comment"> * managing the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short flags;	 <span class="comment">// 一个标示，丰富这个设备的特殊细节</span></span><br><span class="line">	<span class="keyword">unsigned</span> short addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit；addresses are stored in the _LOWER_ 7 bits	 */</span> <span class="comment">// 从设备在连接到相应适配器总线上使用的地址；默认使用低七位。</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span> <span class="comment">// 挂接设备的适配器；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span> <span class="comment">// 访问设备的驱动；</span></span><br><span class="line">	<span class="keyword">int</span> irq;			<span class="comment">/* irq issued by device		*/</span> <span class="comment">// 表明由设备产生的中断；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span> <span class="comment">// 一个i2c_driver支持的client的数量或i2c-core的用户空间设备的链表。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="keyword">i2c_slave_cb_t</span> slave_cb;	<span class="comment">/* callback for slave mode	*/</span> <span class="comment">// 从模式下的回调函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_client的信息通常在BSP的板文件中通过i2c_board_info填充， 如下面的代码就定义了一个I2C设备的ID为“wm8580”、 地址为0x1b、 的i2c_client：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">i2c_devs0</span>[] __<span class="title">initdata</span> = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">"wm8580"</span>, <span class="number">0x1b</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		type[I2C_NAME_SIZE];</span><br><span class="line">	<span class="keyword">unsigned</span> short	flags;</span><br><span class="line">	<span class="keyword">unsigned</span> short	addr;</span><br><span class="line">	<span class="keyword">void</span>		*platform_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>	*<span class="title">archdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>		irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c适配器"><a href="#i2c适配器" class="headerlink" title="i2c适配器"></a>i2c适配器</h3><p>i2c_adapter：一个用于标识物理总线（也就是i2c总线）连同访问它必要的算法的一个结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">host_notify_domain</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_algorithm中的关键函数master_xfer() 用于产生I2C访问周期需要的信号， 以i2c_msg（即I2C消息） 为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_msg - an I2C transaction segment beginning with START</span></span><br><span class="line"><span class="comment"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span></span><br><span class="line"><span class="comment"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span></span><br><span class="line"><span class="comment"> *	must support I2C_FUNC_10BIT_ADDR.</span></span><br><span class="line"><span class="comment"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span></span><br><span class="line"><span class="comment"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span></span><br><span class="line"><span class="comment"> *	flags through i2c_check_functionality().</span></span><br><span class="line"><span class="comment"> * @len: Number of data bytes in @buf being read from or written to the</span></span><br><span class="line"><span class="comment"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span></span><br><span class="line"><span class="comment"> *	is set, the caller guarantees that this buffer can hold up to</span></span><br><span class="line"><span class="comment"> *	32 bytes in addition to the initial length byte sent by the</span></span><br><span class="line"><span class="comment"> *	slave (plus, if used, the SMBus PEC); and this value will be</span></span><br><span class="line"><span class="comment"> *	incremented by the number of block data bytes received.</span></span><br><span class="line"><span class="comment"> * @buf: The buffer into which data is read, or from which it's written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_msg is the low level representation of one segment of an I2C</span></span><br><span class="line"><span class="comment"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span></span><br><span class="line"><span class="comment"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span></span><br><span class="line"><span class="comment"> * @i2c_adapter.@master_xfer() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when I2C "protocol mangling" is used, all I2C adapters implement</span></span><br><span class="line"><span class="comment"> * the standard rules for I2C transactions.  Each transaction begins with a</span></span><br><span class="line"><span class="comment"> * START.  That is followed by the slave address, and a bit encoding read</span></span><br><span class="line"><span class="comment"> * versus write.  Then follow all the data bytes, possibly including a byte</span></span><br><span class="line"><span class="comment"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span></span><br><span class="line"><span class="comment"> * bytes have been transferred and ACKed.  If this is the last message in a</span></span><br><span class="line"><span class="comment"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span></span><br><span class="line"><span class="comment"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span></span><br><span class="line"><span class="comment"> * passing certain @flags may have changed those standard protocol behaviors.</span></span><br><span class="line"><span class="comment"> * Those flags are only for use with broken/nonconforming slaves, and with</span></span><br><span class="line"><span class="comment"> * adapters which are known to support the specific mangling options they</span></span><br><span class="line"><span class="comment"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line">	__u16 flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i2c通信方法"><a href="#i2c通信方法" class="headerlink" title="i2c通信方法"></a>i2c通信方法</h3><p>i2c_algorithm是为一类使用相同总线算法寻址的一个接口。</p>
<ul>
<li>当适配器不能使用i2c访问设备时，把master_xfer设置为NULL</li>
<li>如果一个适配器可以做SMBus访问时，设置smbus_xfer；如果把smbus_xfer设置成NULL，SMBus协议使用通用I2C模拟的消息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: </span></span><br><span class="line"><span class="comment">     Issue a set of i2c transactions to the given I2C adapter defined by the </span></span><br><span class="line"><span class="comment">     msgs array, with num messages available to transfer via the adapter </span></span><br><span class="line"><span class="comment">     specified by adap.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: </span></span><br><span class="line"><span class="comment">  	 Issue smbus transactions to the given I2C adapter. If this is not present,</span></span><br><span class="line"><span class="comment">     then the bus layer will try and convert the SMBus calls into I2C transfers</span></span><br><span class="line"><span class="comment">     instead.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the I2C_FUNC_* flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the @master_xfer field should indicate the type of</span></span><br><span class="line"><span class="comment"> * error code that occurred during the transfer, as documented in the kernel</span></span><br><span class="line"><span class="comment"> * Documentation file Documentation/i2c/fault-codes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/* If an adapter algorithm can't do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	   to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	   using common I2C messages */</span></span><br><span class="line">	<span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	   processed, or a negative value on error */</span></span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">			   <span class="keyword">int</span> num); </span><br><span class="line">    <span class="comment">// 向msgs数组定义的给定i2c适配器发出一组i2c事务，其中num条消息可通过adap指定的适配器传输。</span></span><br><span class="line">	<span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">			   <span class="keyword">unsigned</span> short flags, <span class="keyword">char</span> read_write,</span><br><span class="line">			   u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">    <span class="comment">//  向给定的I2C适配器发出smbus事务。如果这不存在，那么总线层将尝试将SMBus调用转换为I2C传输。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line">	<span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><h3 id="i2c-adapter和i2c-algorithm"><a href="#i2c-adapter和i2c-algorithm" class="headerlink" title="i2c_adapter和i2c_algorithm"></a>i2c_adapter和i2c_algorithm</h3><p>由于i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法。</p>
<p>一个i2c适配器需要i2c_algorithm中提供的通信函数来控制适配器上产生特定的访问周期。</p>
<blockquote>
<p>缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
</blockquote>
<h3 id="i2c-driver和i2c-client"><a href="#i2c-driver和i2c-client" class="headerlink" title="i2c_driver和i2c_client"></a>i2c_driver和i2c_client</h3><p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等；</p>
<p>另外， <code>struct i2c_device_id</code>形式的<code>id_table</code>是该驱动所支持的I2C设备的ID表。 i2c_client对应于真实的物理设备， 每个I2C设备都需要一个<code>i2c_client</code>来描述。 <code>i2c_driver</code>与<code>i2c_client</code>的关系是一对多， 一个i2c_driver可以支持多个同类型的<code>i2c_client</code>。</p>
<p>每个探测到的设备通过在client数据结构中得到自己的数据</p>
<p>在I2C总线驱动i2c_bus_type的<code>match()</code>函数<code>i2c_device_match()</code> 中， 会调用<code>i2c_match_id()</code> 函数匹配在板文件中定义的ID和i2c_driver所支持的ID表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_device_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> = <span class="title">i2c_verify_client</span>(<span class="title">dev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    driver = to_i2c_driver(drv);</span><br><span class="line">    <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct i2c_device_id *<span class="title">i2c_match_id</span><span class="params">(<span class="keyword">const</span> struct i2c_device_id *id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-adpater与i2c-client"><a href="#i2c-adpater与i2c-client" class="headerlink" title="i2c_adpater与i2c_client"></a>i2c_adpater与i2c_client</h3><p>i2c_adpater与i2c_client的关系与I2C硬件体系中适配器和设备的关系一致， 即i2c_client依附于i2c_adpater。 由于一个适配器可以连接多个I2C设备， 所以一个i2c_adpater也可以被多个i2c_client依附，i2c_adpater中包括依附于它的i2c_client的链表。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://i2c.wiki.kernel.org/index.php/Driver_Architecture" target="_blank" rel="noopener">https://i2c.wiki.kernel.org/index.php/Driver_Architecture</a><br><a href="https://blog.csdn.net/xie0812/article/details/22942375" target="_blank" rel="noopener">https://blog.csdn.net/xie0812/article/details/22942375</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】linux下I2C驱动架构全面分析</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E4%B8%8BI2C%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3297889.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3297889.html】</a></p>
<h1 id="【驱动】linux下I2C驱动架构全面分析"><a href="#【驱动】linux下I2C驱动架构全面分析" class="headerlink" title="【驱动】linux下I2C驱动架构全面分析"></a><a href="https://www.cnblogs.com/lcw/p/3297889.html" target="_blank" rel="noopener">【驱动】linux下I2C驱动架构全面分析</a></h1><h2 id="I2C-概述"><a href="#I2C-概述" class="headerlink" title="I2C 概述"></a>I2C 概述</h2><p>　　I2C是philips提出的外设总线.</p>
<p>　　I2C只有两条线,一条串行数据线:SDA,一条是时钟线SCL ，使用SCL，SDA这两根信号线就实现了设备之间的数据交互，它方便了工程师的布线。</p>
<p>　　因此，I2C总线被非常广泛地应用在EEPROM，实时钟，小型LCD等设备与CPU的接口中。</p>
<hr>
<h2 id="linux下的驱动思路"><a href="#linux下的驱动思路" class="headerlink" title="linux下的驱动思路"></a>linux下的驱动思路</h2><p>　　在linux系统下编写I2C驱动，目前主要有两种方法，一种是把I2C设备当作一个普通的字符设备来处理，另一种是利用linux下I2C驱动体系结构来完成。下面比较下这两种方法：<br>　　第一种方法：<br>　　　　优点：思路比较直接，不需要花很多时间去了解linux中复杂的I2C子系统的操作方法。<br>　　　　<strong>缺点</strong>：<br>  　　  要求工程师不仅要对I2C设备的操作熟悉，而且要熟悉I2C的适配器(I2C控制器)操作。<br>  　　  要求工程师对I2C的设备器及I2C的设备操作方法都比较熟悉，最重要的是写出的程序可以移植性差。<br>  　　  对内核的资源无法直接使用，因为内核提供的所有I2C设备器以及设备驱动都是基于I2C子系统的格式。</p>
<p>　　第一种方法的优点就是第二种方法的缺点，<br>　　第一种方法的缺点就是第二种方法的优点。</p>
<h2 id="I2C架构概述"><a href="#I2C架构概述" class="headerlink" title="I2C架构概述"></a>I2C架构概述</h2><p>　　Linux的I2C体系结构分为3个组成部分：</p>
<p>　　<strong>I2C核心</strong>：I2C核心提供了I2C总线驱动和设备驱动的注册，注销方法，I2C通信方法(”algorithm”)上层的，与具体适配器无关的代码以及探测设备，检测设备地址的上层代码等。</p>
<p>　　<strong>I2C总线驱动</strong>：I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。</p>
<p>　　<strong>I2C设备驱动</strong>：I2C设备驱动(也称为客户驱动)是对I2C硬件体系结构中设备端的实现，设备一般挂接在受CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。</p>
<h2 id="linux驱动中i2c驱动架构"><a href="#linux驱动中i2c驱动架构" class="headerlink" title="linux驱动中i2c驱动架构"></a><strong>linux驱动中i2c驱动架构</strong></h2><p>　　<strong><img src="https://images0.cnblogs.com/blog/536940/201309/02225054-2c2abb8ed8da431390a03bcbfd6563df.png" alt="img"></strong></p>
<p>　　上图完整的描述了linux i2c驱动架构，虽然I2C硬件体系结构比较简单，但是i2c体系结构在linux中的实现却相当复杂。</p>
<p>　　那么我们<strong>如何编写特定i2c接口器件的驱动程序？就是说上述架构中的那些部分需要我们完成，而哪些是linux内核已经完善的或者是芯片提供商已经提供的？</strong></p>
<hr>
<h2 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h2><p>　　<strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。<strong>覆盖图中的硬件实现层</strong></p>
<p>　　<strong>第二层</strong>：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。<strong>覆盖图中的访问抽象层、i2c核心层</strong></p>
<p>　　<strong>第三层</strong>：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。<strong>覆盖图中的driver驱动层</strong></p>
<p>　　<strong>第四层</strong>：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。<strong>覆盖图中的driver驱动层</strong></p>
<p>　　第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。</p>
<p>　　在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的(与特定硬件相关的代码)已由芯片提供商编写完成，例如三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c</p>
<p>　　第三第四层与特定device相干的就需要驱动工程师来实现了。</p>
<hr>
<h2 id="Linux下I2C体系文件构架"><a href="#Linux下I2C体系文件构架" class="headerlink" title="Linux下I2C体系文件构架"></a>Linux下I2C体系文件构架</h2><p>　　在Linux内核源代码中的driver目录下包含一个i2c目录</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/02230534-eb154ee59ea04c8ca73efd7248b366ac.jpg" alt="img"></p>
<p>　　<strong>i2c-core.c</strong>这个文件实现了I2C核心的功能以及/proc/bus/i2c<em>接口。<br>　  *</em>i2c-dev.c<strong>实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备。通过适配器访设备时的主设备号都为89，次设备号为0-255。I2c-dev.c并没有针对特定的设备而设计，只是提供了通用的read(),write(),和ioctl()等接口，应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器，并控制I2C设备的工作方式。<br>　　**busses</strong>文件夹这个文件中包含了一些I2C总线的驱动，如针对S3C2410，S3C2440，S3C6410等处理器的I2C控制器驱动为i2c-s3c2410.c.<br>　　<strong>algos</strong>文件夹实现了一些I2C总线适配器的algorithm.</p>
<hr>
<h2 id="重要的结构体"><a href="#重要的结构体" class="headerlink" title="重要的结构体"></a><strong>重要的结构体</strong></h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a><strong>i2c_driver</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_driver &#123;</span><br><span class="line"> 2 unsigned int class;</span><br><span class="line"> 3 int (*attach_adapter)(struct i2c_adapter *);&#x2F;&#x2F;依附i2c_adapter函数指针</span><br><span class="line"> 4 int (*detach_adapter)(struct i2c_adapter *);&#x2F;&#x2F;脱离i2c_adapter函数指针</span><br><span class="line"> 5 int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line"> 6 int (*remove)(struct i2c_client *);</span><br><span class="line"> 7 void (*shutdown)(struct i2c_client *);</span><br><span class="line"> 8 int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br><span class="line"> 9 int (*resume)(struct i2c_client *);</span><br><span class="line">10 void (*alert)(struct i2c_client *, unsigned int data);</span><br><span class="line">11 int (*command)(struct i2c_client *client, unsigned int cmd, void*arg);&#x2F;&#x2F;命令列表</span><br><span class="line">12 struct device_driver driver;</span><br><span class="line">13 const struct i2c_device_id *id_table;&#x2F;&#x2F;该驱动所支持的设备ID表</span><br><span class="line">14 int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">15 const unsigned short *address_list;</span><br><span class="line">16 struct list_head clients;</span><br><span class="line">17 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a><strong>i2c_client</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_client &#123;</span><br><span class="line"> 2  unsigned short flags；&#x2F;&#x2F;标志  </span><br><span class="line"> 3  unsigned short addr; &#x2F;&#x2F;低7位为芯片地址  </span><br><span class="line"> 4  char name[I2C_NAME_SIZE];&#x2F;&#x2F;设备名称</span><br><span class="line"> 5  struct i2c_adapter *adapter;&#x2F;&#x2F;依附的i2c_adapter</span><br><span class="line"> 6  struct i2c_driver *driver;&#x2F;&#x2F;依附的i2c_driver </span><br><span class="line"> 7  struct device dev;&#x2F;&#x2F;设备结构体  </span><br><span class="line"> 8  int irq;&#x2F;&#x2F;设备所使用的结构体  </span><br><span class="line"> 9  struct list_head detected;&#x2F;&#x2F;链表头</span><br><span class="line">10  &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a><strong>i2c_adapter</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 struct i2c_adapter &#123;</span><br><span class="line"> 2  struct module *owner;&#x2F;&#x2F;所属模块</span><br><span class="line"> 3  unsigned int id;&#x2F;&#x2F;algorithm的类型，定义于i2c-id.h,</span><br><span class="line"> 4  unsigned int class;    </span><br><span class="line"> 5  const struct i2c_algorithm *algo; &#x2F;&#x2F;总线通信方法结构体指针</span><br><span class="line"> 6  void *algo_data;&#x2F;&#x2F;algorithm数据</span><br><span class="line"> 7  struct rt_mutex bus_lock;&#x2F;&#x2F;控制并发访问的自旋锁</span><br><span class="line"> 8  int timeout;   </span><br><span class="line"> 9  int retries;&#x2F;&#x2F;重试次数</span><br><span class="line">10  struct device dev; &#x2F;&#x2F;适配器设备 </span><br><span class="line">11  int nr;</span><br><span class="line">12  char name[48];&#x2F;&#x2F;适配器名称</span><br><span class="line">13  struct completion dev_released;&#x2F;&#x2F;用于同步</span><br><span class="line">14  struct list_head userspace_clients;&#x2F;&#x2F;client链表头</span><br><span class="line">15 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a><strong>i2c_algorithm</strong></h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 struct i2c_algorithm &#123;</span><br><span class="line">2 int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);&#x2F;&#x2F;I2C传输函数指针</span><br><span class="line">3 int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write,u8 command, int size, union </span><br><span class="line">4 i2c_smbus_data *data);&#x2F;&#x2F;smbus传输函数指针</span><br><span class="line">5 u32 (*functionality) (struct i2c_adapter *);&#x2F;&#x2F;返回适配器支持的功能</span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<hr>
<h2 id="各结构体的作用与它们之间的关系"><a href="#各结构体的作用与它们之间的关系" class="headerlink" title="各结构体的作用与它们之间的关系"></a>各结构体的作用与它们之间的关系</h2><h3 id="i2c-adapter与i2c-algorithm"><a href="#i2c-adapter与i2c-algorithm" class="headerlink" title="i2c_adapter与i2c_algorithm"></a><strong>i2c_adapter与i2c_algorithm</strong></h3><p>　　i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>　　i2c_algorithm中的关键函数<strong>master_xfer()</strong>用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。</p>
<p>　　i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 struct i2c_msg &#123;  </span><br><span class="line">2     __u16 addr; &#x2F;* slave address            *&#x2F;  </span><br><span class="line">3     __u16 flags;          </span><br><span class="line">4     __u16 len;      &#x2F;* msg length               *&#x2F;  </span><br><span class="line">5     __u8 *buf;      &#x2F;* pointer to msg data          *&#x2F;  </span><br><span class="line">6 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="i2c-driver和i2c-client"><a href="#i2c-driver和i2c-client" class="headerlink" title="i2c_driver和i2c_client"></a><strong>i2c_driver和i2c_client</strong></h3><p>　　i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()</p>
<p>　　i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述</p>
<p>　　i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<h3 id="i2c-adapter和i2c-client"><a href="#i2c-adapter和i2c-client" class="headerlink" title="i2c_adapter和i2c_client"></a><strong>i2c_adapter和i2c_client</strong></h3><p>　　i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。</p>
<p>　　</p>
<p>　　从i2c驱动架构图中可以看出，linux内核对i2c架构抽象了一个叫<strong>核心层core</strong>的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件事件提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<hr>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>　　先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为<strong>i2c-core.c</strong>，位于内核目录/driver/i2c/i2c-core.c</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 EXPORT_SYMBOL(i2c_add_adapter);  </span><br><span class="line">2 EXPORT_SYMBOL(i2c_del_adapter);  </span><br><span class="line">3 EXPORT_SYMBOL(i2c_del_driver);  </span><br><span class="line">4 EXPORT_SYMBOL(i2c_attach_client);  </span><br><span class="line">5 EXPORT_SYMBOL(i2c_detach_client);  </span><br><span class="line">6   </span><br><span class="line">7 EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　<strong>i2c_transfer()</strong>函数：i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     int ret;  </span><br><span class="line"> 4     if (adap-&gt;algo-&gt;master_xfer) &#123;&#x2F;&#x2F;如果master_xfer函数存在，则调用，否则返回错误  </span><br><span class="line"> 5         ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap,msgs,num);&#x2F;&#x2F;这个函数在硬件相关的代码中给algorithm赋值  </span><br><span class="line"> 6         return ret;  </span><br><span class="line"> 7     &#125; else &#123;  </span><br><span class="line"> 8         return -ENOSYS;  </span><br><span class="line"> 9     &#125;  </span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。</p>
<p>　　相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员在开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int i2c_attach_client(struct i2c_client *client)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     ...  </span><br><span class="line"> 4     device_register(&amp;client-&gt;dev);  </span><br><span class="line"> 5     device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);  </span><br><span class="line"> 6     ...  </span><br><span class="line"> 7     return 0;  </span><br><span class="line"> 8 &#125;  </span><br><span class="line"> 9 </span><br><span class="line">10 </span><br><span class="line">11 [cpp] view plaincopy</span><br><span class="line">12 int i2c_detach_client(struct i2c_client *client)  </span><br><span class="line">13 &#123;  </span><br><span class="line">14     ...  </span><br><span class="line">15     device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);  </span><br><span class="line">16     device_unregister(&amp;client-&gt;dev);  </span><br><span class="line">17     ...  </span><br><span class="line">18     return res;  </span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　<strong>i2c_add_adapter</strong>()函数和i2c_del_adapter()在i2c-davinci.c中有调用，稍后分析</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int i2c_add_adapter(struct i2c_adapter *adap)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     ...  </span><br><span class="line"> 4     device_register(&amp;adap-&gt;dev);  </span><br><span class="line"> 5     device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);  </span><br><span class="line"> 6     ...  </span><br><span class="line"> 7     &#x2F;* inform drivers of new adapters *&#x2F;  </span><br><span class="line"> 8     list_for_each(item,&amp;drivers) &#123;  </span><br><span class="line"> 9         driver &#x3D; list_entry(item, struct i2c_driver, list);  </span><br><span class="line">10         if (driver-&gt;attach_adapter)  </span><br><span class="line">11             &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;  </span><br><span class="line">12             driver-&gt;attach_adapter(adap);  </span><br><span class="line">13     &#125;  </span><br><span class="line">14     ...  </span><br><span class="line">15 &#125;  </span><br><span class="line">16 </span><br><span class="line">17 </span><br><span class="line">18 </span><br><span class="line">19 int i2c_del_adapter(struct i2c_adapter *adap)  </span><br><span class="line">20 &#123;  </span><br><span class="line">21     ...  </span><br><span class="line">22     list_for_each(item,&amp;drivers) &#123;  </span><br><span class="line">23         driver &#x3D; list_entry(item, struct i2c_driver, list);  </span><br><span class="line">24         if (driver-&gt;detach_adapter)  </span><br><span class="line">25             if ((res &#x3D; driver-&gt;detach_adapter(adap))) &#123;  </span><br><span class="line">26             &#125;  </span><br><span class="line">27     &#125;  </span><br><span class="line">28     ...  </span><br><span class="line">29     list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;  </span><br><span class="line">30         client &#x3D; list_entry(item, struct i2c_client, list);  </span><br><span class="line">31   </span><br><span class="line">32         if ((res&#x3D;client-&gt;driver-&gt;detach_client(client))) &#123;  </span><br><span class="line">33   </span><br><span class="line">34         &#125;  </span><br><span class="line">35     &#125;  </span><br><span class="line">36     ...  </span><br><span class="line">37     device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);  </span><br><span class="line">38     device_unregister(&amp;adap-&gt;dev);  </span><br><span class="line">39   </span><br><span class="line">40 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static struct platform_driver davinci_i2c_driver &#x3D; &#123;  </span><br><span class="line"> 2     .probe      &#x3D; davinci_i2c_probe,  </span><br><span class="line"> 3     .remove     &#x3D; davinci_i2c_remove,  </span><br><span class="line"> 4     .driver     &#x3D; &#123;  </span><br><span class="line"> 5         .name   &#x3D; &quot;i2c_davinci&quot;,  </span><br><span class="line"> 6         .owner  &#x3D; THIS_MODULE,  </span><br><span class="line"> 7     &#125;,  </span><br><span class="line"> 8 &#125;;  </span><br><span class="line"> 9   </span><br><span class="line">10 &#x2F;* I2C may be needed to bring up other drivers *&#x2F;  </span><br><span class="line">11 static int __init davinci_i2c_init_driver(void)  </span><br><span class="line">12 &#123;  </span><br><span class="line">13     return platform_driver_register(&amp;davinci_i2c_driver);  </span><br><span class="line">14 &#125;  </span><br><span class="line">15 subsys_initcall(davinci_i2c_init_driver);  </span><br><span class="line">16   </span><br><span class="line">17 static void __exit davinci_i2c_exit_driver(void)  </span><br><span class="line">18 &#123;  </span><br><span class="line">19     platform_driver_unregister(&amp;davinci_i2c_driver);  </span><br><span class="line">20 &#125;  </span><br><span class="line">21 module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static struct i2c_algorithm i2c_davinci_algo &#x3D; &#123;  </span><br><span class="line">2     .master_xfer    &#x3D; i2c_davinci_xfer,  </span><br><span class="line">3     .functionality  &#x3D; i2c_davinci_func,  </span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 adap-&gt;algo &#x3D; &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="适配器驱动程序分析"><a href="#适配器驱动程序分析" class="headerlink" title="适配器驱动程序分析"></a>适配器驱动程序分析</h2><p>　　在linux系统中，适配器驱动位于linux目录下的\drivers\i2c\busses下，不同的处理器的适配器驱动程序设计有差异，但是总体思路不变。</p>
<p>　　在适配器的驱动中，实现两个结构体非常关键，也是整个适配器驱动的灵魂。</p>
<p>　　下面以某个适配器的驱动程序为例进行说明：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static struct platform_driver tcc_i2c_driver &#x3D; &#123;</span><br><span class="line"> 2  .probe   &#x3D; tcc_i2c_probe,</span><br><span class="line"> 3  .remove   &#x3D; tcc_i2c_remove,</span><br><span class="line"> 4  .suspend  &#x3D; tcc_i2c_suspend_late,</span><br><span class="line"> 5  .resume   &#x3D; tcc_i2c_resume_early,</span><br><span class="line"> 6  .driver   &#x3D; &#123;</span><br><span class="line"> 7   .owner  &#x3D; THIS_MODULE,</span><br><span class="line"> 8   .name  &#x3D; &quot;tcc-i2c&quot;,</span><br><span class="line"> 9  &#125;,</span><br><span class="line">10 &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p> 　以上说明这个驱动是基于平台总线的，这样实现的目的是与CPU紧紧联系起来。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static const struct i2c_algorithm tcc_i2c_algorithm &#x3D; &#123;</span><br><span class="line">2  .master_xfer &#x3D; tcc_i2c_xfer,</span><br><span class="line">3  .functionality &#x3D; tcc_i2c_func,</span><br><span class="line">4 &#125;;</span><br></pre></td></tr></table></figure>

<p>　　这个结构体也是非常的关键，这个结构体里面的函数<strong>tcc_i2c_xfer</strong>是适配器算法的实现，这个函数实现了适配器与I2C CORE的连接。</p>
<p>　　<strong>tcc_i2c_func</strong>是指该适配器所支持的功能。</p>
<p>　　tcc_i2c_xfer这个函数实质是实现I2C数据的发送与接收的处理过程。不同的处理器实现的方法不同，主要表现在寄存器的设置与中断的处理方法上。</p>
<p>　　把握上面的两点去分析适配器程序就简单多了。</p>
<hr>
<h2 id="I2C-core驱动程序分析"><a href="#I2C-core驱动程序分析" class="headerlink" title="I2C-core驱动程序分析"></a>I2C-core驱动程序分析</h2><p>　　在I2C-core.c这个函数中，把握下面的几个关键函数就可以了。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &#x2F;&#x2F;增加&#x2F;删除i2c_adapter</span><br><span class="line"> 2 int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line"> 3 int i2c_del_adapter(struct i2c_adapter *adap)</span><br><span class="line"> 4 </span><br><span class="line"> 5 &#x2F;&#x2F;增加&#x2F;删除i2c_driver</span><br><span class="line"> 6 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line"> 7 void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line"> 8 </span><br><span class="line"> 9 &#x2F;&#x2F;i2c_client依附&#x2F;脱离</span><br><span class="line">10 int i2c_attach_client(struct i2c_client *client)</span><br><span class="line">11 </span><br><span class="line">12 &#x2F;&#x2F;增加&#x2F;删除i2c_driver</span><br><span class="line">13 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">14 void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">15 </span><br><span class="line">16 &#x2F;&#x2F;i2c_client依附&#x2F;脱离</span><br><span class="line">17 int i2c_attach_client(struct i2c_client *client)</span><br><span class="line">18 int i2c_detach_client(struct i2c_client *client)</span><br><span class="line">19 </span><br><span class="line">20 &#x2F;&#x2F;I2C传输,发送和接收</span><br><span class="line">21 int i2c_master_send(struct i2c_client *client,const char *buf ,int count)</span><br><span class="line">22 int i2c_master_recv(struct i2c_client *client, char *buf ,int count)</span><br><span class="line">23 int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　I2c_transfer这个函数实现了core与adapter的联系。</p>
<hr>
<h2 id="代码调用层次图"><a href="#代码调用层次图" class="headerlink" title="代码调用层次图"></a>代码调用层次图</h2><p>　　有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容</p>
<p>　　<img src="https://images0.cnblogs.com/blog/536940/201309/02234128-18be3750dd3a4494bd9d173d40284179.png" alt="img"></p>
<p>　　上面这些代码的展示是告诉我们：linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。</p>
<p>　　剩下的就是针对挂载在i2c两线上的i2c设备了device，而编写的即具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）</p>
<hr>
<h2 id="编写驱动需要完成的工作"><a href="#编写驱动需要完成的工作" class="headerlink" title="编写驱动需要完成的工作"></a>编写驱动需要完成的工作</h2><p>　　编写具体的I2C驱动时，工程师需要处理的主要工作如下：</p>
<p>　　1).提供I2C适配器的硬件驱动，探测，初始化I2C适配器(如申请I2C的I/O地址和中断号)，驱动CPU控制的I2C适配器从硬件上产生。</p>
<p>　　2).提供I2C控制的algorithm, 用具体适配器的xxx_xfer()函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋给i2c_adapter的algo指针。</p>
<p>　　3).实现I2C设备驱动中的i2c_driver接口，用具体yyy的yyy_probe()，yyy_remove()，yyy_suspend(),yyy_resume()函数指针和i2c_device_id设备ID表赋给i2c_driver的probe,remove,suspend,resume和id_table指针。</p>
<p>　　4).实现I2C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接。</p>
<p>　　</p>
<p>　　上面的工作中前两个属于I2C总线驱动，后面两个属于I2C设备驱动。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> <a href="http://blog.csdn.net/ghostyu" target="_blank" rel="noopener">http://blog.csdn.net/ghostyu</a></p>
<p><a href="http://blog.chinaunix.net/uid-25906157-id-3376728.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-25906157-id-3376728.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux驱动之I2C子系统剖析</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【 <a href="https://www.caiyifan.cn/p/8d9c6db2.html】" target="_blank" rel="noopener">https://www.caiyifan.cn/p/8d9c6db2.html】</a></p>
<p>前言</p>
<p>I2C是广泛应用于计算机中的串行总线，用于处理器和其外设之间的通信。</p>
<h2 id="I2C硬件基本概念"><a href="#I2C硬件基本概念" class="headerlink" title="I2C硬件基本概念"></a>I2C硬件基本概念</h2><ul>
<li><p>I2C总线由两根传递数据的双向信号线与一根地线组成，半双工、主从方式通信。</p>
<ul>
<li>Serial Clock Line (SCL)</li>
<li>Serial Data Address (SDA)</li>
</ul>
</li>
<li><p>每个设备都有一个唯一设备地址，一次传输8bit，高位在前，低位在后。</p>
</li>
<li><p>一次完整的I2C通信需要经历一个完整的时序，I2C总线通信完整时序如下图。一般在驱动中无需关心具体时序，只需操作SoC中的I2C控制器即可，只有在裸机下需要用GPIO模拟I2C通信时才需用到，所以笔者在本文不阐述I2C时序（其实就是懒 O__O “…）。</p>
</li>
</ul>
<p>  <img src="https://img.caiyifan.cn/I2C%E6%97%B6%E5%BA%8F.png" alt="img"></p>
<ul>
<li><p>总线速度有三种模式</p>
<ul>
<li>标准模式 100kbps</li>
<li>快速模式 400kbps</li>
<li>高速模式 3.4Mbps</li>
</ul>
</li>
</ul>
<h2 id="I2C子系统框架"><a href="#I2C子系统框架" class="headerlink" title="I2C子系统框架"></a>I2C子系统框架</h2><ul>
<li>I2C设备驱动层：drivers/i2c/i2c-dev.c (通用型) 或者为特定设备定制的设备驱动（比如E2PROM驱动）</li>
<li>I2C核心层： drivers/i2c/i2c-coere.c</li>
<li>I2C总线驱动层(主机控制器驱动层)：drivers/i2c/busses/i2c-s3c2410.c</li>
</ul>
<h3 id="I2C设备驱动层"><a href="#I2C设备驱动层" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><ul>
<li>是I2C从机的驱动程序</li>
<li>给用户提供调用接口</li>
<li>内核提供两种方式来实现设备驱动：<ul>
<li>第一种是内核默认实现的<strong>通用型的I2C设备驱动</strong>，位于<code>drivers/i2c/i2c-dev.c</code>中。 这种方式<strong>仅仅只是封装了I2C的基本操作</strong>，相当于<strong>只是封装了I2C的基本时序</strong>，向应用层只提供了I2C基本操作的接口，该接口通用于所有的I2C设备。具体设备相关的操作，需要开发者在应用层根据硬件特性来完成对设备的操作。<strong>该方式的优点就是通用，而缺点也很明显，封装的不够彻底，需要应用开发人员对硬件有一定程度的了解</strong>。</li>
<li>第二种是根据特定设备来编写的<strong>特定的I2C设备驱动</strong>, 该方式<strong>彻底封装了硬件的操作</strong>，提供给应用层的接口<strong>彻底屏蔽I2C的通信细节</strong>。该方式的<strong>优点就是应用开发人员无需关心硬件</strong>。</li>
</ul>
</li>
</ul>
<h3 id="I2C核心层"><a href="#I2C核心层" class="headerlink" title="I2C核心层"></a>I2C核心层</h3><ul>
<li>注册I2C总线</li>
<li>由内核开发人员编写的，不涉及具体硬件</li>
<li>给驱动编程人员提供编程接口</li>
</ul>
<h3 id="I2C总线驱动层"><a href="#I2C总线驱动层" class="headerlink" title="I2C总线驱动层"></a>I2C总线驱动层</h3><ul>
<li>是I2C主机适配器的驱动程序</li>
<li>初始化I2C适配器(控制器)</li>
<li>实现操作方法：根据I2C操作时序进行操作I2C控制器实现收发数据</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码中会涉及到一部分SMBus相关内容，SMBus是Intel在I2C的基础上开发的类似I2C的总线，本文不探讨SMBus相关内容（其实说白了，还是懒QAQ）。笔者会大体上对I2C子系统的源码进行分析，如若分析的有出入，还望指出。</p>
<h3 id="I2C核心层-1"><a href="#I2C核心层-1" class="headerlink" title="I2C核心层"></a>I2C核心层</h3><p>I2C核心层的实现位于<code>drivers/i2c/i2c-core.c</code>中，笔者从<code>i2c_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; bus_register(&amp;i2c_bus_type);     &#x2F;&#x2F; 注册I2C总线 </span><br><span class="line">    if (retval)</span><br><span class="line">        return retval;</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    i2c_adapter_compat_class &#x3D; class_compat_register(&quot;i2c-adapter&quot;);</span><br><span class="line">    if (!i2c_adapter_compat_class) &#123;</span><br><span class="line">        retval &#x3D; -ENOMEM;</span><br><span class="line">        goto bus_err;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    retval &#x3D; i2c_add_driver(&amp;dummy_driver);    &#x2F;&#x2F; 注册了一个虚假的I2C驱动</span><br><span class="line">    if (retval)</span><br><span class="line">        goto class_err;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">    class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line">#endif</span><br><span class="line">    bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数先是调用了<code>bus_register</code>函数注册了I2C总线，随后调用<code>i2c_add_driver</code>函数来注册了一个虚假的I2C驱动。</p>
<p>先对注册的I2C总线<code>i2c_bus_type</code>进行分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">    .name       &#x3D; &quot;i2c&quot;,</span><br><span class="line">    .match      &#x3D; i2c_device_match,</span><br><span class="line">    .probe      &#x3D; i2c_device_probe,</span><br><span class="line">    .remove     &#x3D; i2c_device_remove,</span><br><span class="line">    .shutdown   &#x3D; i2c_device_shutdown,</span><br><span class="line">    .pm     &#x3D; &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据Linux设备驱动模型的原理，I2C总线下会挂载两条链表，分别为设备链和驱动链，只要其中一个链表有结点插入，即会通过<code>i2c_device_match</code>函数来遍历另一条链表去匹配设备与驱动，一旦匹配上则会调用<code>i2c_device_probe</code>函数，而<code>i2c_device_probe</code>函数又会调用i2c_driver的<code>probe</code>函数。进到<code>i2c_device_match</code>和<code>i2c_device_probe</code>进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_device_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client   *client &#x3D; i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver   *driver;</span><br><span class="line"></span><br><span class="line">    if (!client)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; to_i2c_driver(drv);</span><br><span class="line">    &#x2F;* match on an id table if there is one *&#x2F;</span><br><span class="line">    if (driver-&gt;id_table)</span><br><span class="line">        return i2c_match_id(driver-&gt;id_table, client) !&#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, <code>i2c_device_match</code>函数调用的是<code>i2c_match_id</code>函数来进行匹配。从源码中可见，<strong>需要注意的是I2C总线匹配方式不同于Platform总线，I2C总线只匹配<code>id_table</code>中的name，并不会去匹配driver中的name</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_device_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client  *client &#x3D; i2c_verify_client(dev);</span><br><span class="line">    struct i2c_driver  *driver;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    if (!client)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; to_i2c_driver(dev-&gt;driver);</span><br><span class="line">    if (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">        return -ENODEV;</span><br><span class="line">    client-&gt;driver &#x3D; driver;</span><br><span class="line">    if (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">        device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">                    client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">    dev_dbg(dev, &quot;probe\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 调用driver中的probe函数 *&#x2F;</span><br><span class="line">    status &#x3D; driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">    if (status) &#123;</span><br><span class="line">        client-&gt;driver &#x3D; NULL;</span><br><span class="line">        i2c_set_clientdata(client, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，的确是调用<code>driver-&gt;probe</code>来进行真正的probe。<strong>需要注意的是<code>if (!driver-&gt;probe || !driver-&gt;id_table) return -ENODEV;</code>中对<code>id_table</code>进行了非空判断，所以如果采用设备树方式进行匹配也需要对<code>.id_table</code>进行有效赋值，否则会出现match上了但probe函数不会调用的奇怪现象</strong>，个人感觉这应该是个bug，毕竟这个核心层在设备树出现之前就已经存在了。</p>
<p>回到<code>i2c_init</code>函数，然后注册了一个空的名为<code>dummy</code>的i2c_driver。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int dummy_probe(struct i2c_client *client,</span><br><span class="line">               const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int dummy_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct i2c_driver dummy_driver &#x3D; &#123;</span><br><span class="line">    .driver.name    &#x3D; &quot;dummy&quot;,</span><br><span class="line">    .probe      &#x3D; dummy_probe,</span><br><span class="line">    .remove     &#x3D; dummy_remove,</span><br><span class="line">    .id_table   &#x3D; dummy_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个完全空的虚假驱动，而I2C核心层为何要注册一个假的驱动不得而知，笔者查阅了网上资料也没法得知，但是<code>/sys/bus/i2c/drivers/dummy</code>确实存在，所以笔者猜测应该纯粹是开发该层次调试用的。</p>
<p>核心层还提供了一系列函数接口供驱动开发者注册和注销驱动：</p>
<ul>
<li>i2c_add_adapter 注册I2C主机适配器驱动 (动态分配总线号)</li>
<li>i2c_add_numbered_adapter 注册I2C主机适配器驱动 (静态指定总线号)</li>
<li>i2c_del_adapter 注销I2C主机适配器驱动</li>
<li>i2c_add_driver 注册I2C从机设备驱动</li>
<li>i2c_del_driver 注销I2C从机设备驱动</li>
</ul>
<p>其他函数暂不分析，在分析其他层的时候调用时再进行分析。</p>
<h3 id="I2C设备驱动层-1"><a href="#I2C设备驱动层-1" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><p>笔者先从内核提供的通用驱动开始分析，最后在文末给出特定驱动的分析。内核提供了一个通用于所有设备的I2C设备驱动，用户可以在应用层实现对I2C的驱动，其实现位于<code>drivers/i2c/i2c-dev.c</code>中。同样从init函数开始，笔者从<code>i2c_dev_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init i2c_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;i2c &#x2F;dev entries driver\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 将通用驱动注册为字符设备驱动，并提供file_operations 操作方法 *&#x2F;</span><br><span class="line">    res &#x3D; register_chrdev(I2C_MAJOR, &quot;i2c&quot;, &amp;i2cdev_fops);</span><br><span class="line">    if (res)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建类 *&#x2F;</span><br><span class="line">    i2c_dev_class &#x3D; class_create(THIS_MODULE, &quot;i2c-dev&quot;);</span><br><span class="line">    if (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">        res &#x3D; PTR_ERR(i2c_dev_class);</span><br><span class="line">        goto out_unreg_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册I2C从机设备驱动 *&#x2F;</span><br><span class="line">    res &#x3D; i2c_add_driver(&amp;i2cdev_driver);</span><br><span class="line">    if (res)</span><br><span class="line">        goto out_unreg_class;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">    class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">    unregister_chrdev(I2C_MAJOR, &quot;i2c&quot;);</span><br><span class="line">out:</span><br><span class="line">    printk(KERN_ERR &quot;%s: Driver Initialisation failed\n&quot;, __FILE__);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i2c_dev_init</code>函数先是调用了<code>register_chrdev</code>函数注册了一个字符设备驱动，并提供了一个file_operations。由此可见，是将通用驱动实现为字符设备驱动，并由其file_operations结构体的方法为应用层提供通用接口。然后调用<code>class_create</code>创建了一个类，但是可以看到并没有调用<code>device_create</code>在该类下创建设备，所以注意在这里并没有生成设备节点。最后调用<code>i2c_add_driver</code>注册了一个I2C从机设备驱动<code>i2cdev_driver</code>。<code>i2cdev_driver</code>定义如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct i2c_driver i2cdev_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name   &#x3D; &quot;dev_driver&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    .attach_adapter &#x3D; i2cdev_attach_adapter,</span><br><span class="line">    .detach_adapter &#x3D; i2cdev_detach_adapter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上可以看到并没有对<code>id_table</code>进行赋值，从上文在I2C核心层分析可知，I2C总线是根据<code>id_table</code>进行匹配，所以这里并不会按照常规的Linux驱动模型进行match后probe，况且这个驱动里也没有probe方法。所以这到底是什么情况？别慌，虽然没有id_table和probe，但是它单独提供了两个方法<code>attach_adapter</code>和<code>detach_adapter</code>。这里先埋个伏笔，不做分析，到I2C总线驱动层分析后自然会柳暗花明。</p>
<h3 id="I2C总线驱动层-1"><a href="#I2C总线驱动层-1" class="headerlink" title="I2C总线驱动层"></a>I2C总线驱动层</h3><p>笔者使用的SoC是S5PV210，其控制器跟S3C2410基本一致，所以三星的驱动开发者并没有再去写一份S5PV210的主机适配器驱动，而是使用了S3C2410的主机适配器驱动，其位于<code>drivers/i2c/busses/i2c-s3c2410.c</code>中。</p>
<p>从<code>i2c_adap_s3c_init</code>函数开始分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init i2c_adap_s3c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    return platform_driver_register(&amp;s3c24xx_i2c_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其作为平台设备驱动而实现，注册了<code>s3c24xx_i2c_driver</code>驱动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct platform_device_id s3c24xx_driver_ids[] &#x3D; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name       &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">        .driver_data    &#x3D; TYPE_S3C2410,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .name       &#x3D; &quot;s3c2440-i2c&quot;,</span><br><span class="line">        .driver_data    &#x3D; TYPE_S3C2440,</span><br><span class="line">    &#125;, &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(platform, s3c24xx_driver_ids);</span><br><span class="line"></span><br><span class="line">static struct platform_driver s3c24xx_i2c_driver &#x3D; &#123;</span><br><span class="line">    .probe      &#x3D; s3c24xx_i2c_probe,</span><br><span class="line">    .remove     &#x3D; s3c24xx_i2c_remove,</span><br><span class="line">    .id_table   &#x3D; s3c24xx_driver_ids,</span><br><span class="line">    .driver     &#x3D; &#123;</span><br><span class="line">        .owner  &#x3D; THIS_MODULE,</span><br><span class="line">        .name   &#x3D; &quot;s3c-i2c&quot;,</span><br><span class="line">        .pm &#x3D; S3C24XX_DEV_PM_OPS,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据平台总线的原理，很容易得知在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中对其驱动对应的设备进行了注册，其注册的设备定义位于<code>dev-i2c0.c</code>，这是I2C的资源文件。其定义的资源如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct resource s3c_i2c_resource[] &#x3D; &#123;</span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; S3C_PA_IIC,</span><br><span class="line">        .end   &#x3D; S3C_PA_IIC + SZ_4K - 1,</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; IRQ_IIC,</span><br><span class="line">        .end   &#x3D; IRQ_IIC,</span><br><span class="line">        .flags &#x3D; IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct platform_device s3c_device_i2c0 &#x3D; &#123;</span><br><span class="line">    .name         &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">    .id       &#x3D; 0,</span><br><span class="line">    .num_resources    &#x3D; ARRAY_SIZE(s3c_i2c_resource),</span><br><span class="line">    .resource     &#x3D; s3c_i2c_resource,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由name可知，与<code>s3c24xx_i2c_driver</code>是匹配的。除此之外，还定义了平台数据<code>default_i2c_data0</code>和<code>default_i2c_data0</code>函数。其相关的调用还是在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中进行的，在<code>mach-x210.c</code>中的<code>smdkc110_machine_init</code>函数中进行了如下调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* i2c *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设置I2C平台数据       NULL表示设置默认的平台数据</span><br><span class="line">s3c_i2c0_set_platdata(NULL);</span><br><span class="line">s3c_i2c1_set_platdata(NULL);</span><br><span class="line">s3c_i2c2_set_platdata(NULL);</span><br></pre></td></tr></table></figure>

<p>现在进到<code>s3c_i2c0_set_platdata</code>函数进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct s3c2410_platform_i2c default_i2c_data0 __initdata &#x3D; &#123;</span><br><span class="line">    .flags      &#x3D; 0,</span><br><span class="line">    .slave_addr &#x3D; 0x10,          &#x2F;&#x2F; I2C控制器作为从设备时使用的地址</span><br><span class="line">    .frequency  &#x3D; 400*1000,      &#x2F;&#x2F; 400kbps</span><br><span class="line">    .sda_delay  &#x3D; S3C2410_IICLC_SDA_DELAY15 | S3C2410_IICLC_FILTER_ON,   &#x2F;&#x2F; 间隔时间</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void __init s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *pd)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c2410_platform_i2c *npd;</span><br><span class="line"></span><br><span class="line">    if (!pd)   &#x2F;&#x2F; 参数为NULL则使用该函数上面定义的默认的平台数据</span><br><span class="line">        pd &#x3D; &amp;default_i2c_data0;</span><br><span class="line"></span><br><span class="line">    npd &#x3D; kmemdup(pd, sizeof(struct s3c2410_platform_i2c), GFP_KERNEL);</span><br><span class="line">    if (!npd)</span><br><span class="line">        printk(KERN_ERR &quot;%s: no memory for platform data\n&quot;, __func__);</span><br><span class="line">    else if (!npd-&gt;cfg_gpio)</span><br><span class="line">        npd-&gt;cfg_gpio &#x3D; s3c_i2c0_cfg_gpio;  &#x2F;&#x2F; GPIO初始化方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置为平台数据</span><br><span class="line">    s3c_device_i2c0.dev.platform_data &#x3D; npd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到传递NULL则使用了默认的平台数据, 将<code>s3c_i2c0_cfg_gpio</code>函数设置到了平台数据<code>cfg_gpio</code>方法中，最后将平台数据挂接到<code>s3c_device_i2c0</code>这个设备上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void s3c_i2c0_cfg_gpio(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    s3c_gpio_cfgpin(S5PV210_GPD1(0), S3C_GPIO_SFN(2));      &#x2F;&#x2F; 设置控制寄存器为I2C0_SDA模式</span><br><span class="line">    s3c_gpio_setpull(S5PV210_GPD1(0), S3C_GPIO_PULL_NONE);     </span><br><span class="line">    s3c_gpio_cfgpin(S5PV210_GPD1(1), S3C_GPIO_SFN(2));      &#x2F;&#x2F; 设置控制寄存器为I2C0_SCL模式</span><br><span class="line">    s3c_gpio_setpull(S5PV210_GPD1(1), S3C_GPIO_PULL_NONE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>s3c_i2c0_cfg_gpio</code>函数只是对I2C控制器两根通信线的GPIO初始化。</p>
<p>接下去回到I2C总线驱动层<code>i2c-s3c2410.c</code>中, 进入到<code>s3c24xx_i2c_probe</code>函数进行分析。 probe函数的代码比较多，分段进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct s3c24xx_i2c *i2c;</span><br><span class="line">struct s3c2410_platform_i2c *pdata;</span><br><span class="line">struct resource *res;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取I2C平台数据</span><br><span class="line">pdata &#x3D; pdev-&gt;dev.platform_data;</span><br><span class="line">if (!pdata) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;no platform data\n&quot;);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c &#x3D; kzalloc(sizeof(struct s3c24xx_i2c), GFP_KERNEL);</span><br><span class="line">if (!i2c) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\n&quot;);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strlcpy(i2c-&gt;adap.name, &quot;s3c2410-i2c&quot;, sizeof(i2c-&gt;adap.name));</span><br><span class="line">i2c-&gt;adap.owner   &#x3D; THIS_MODULE;</span><br><span class="line">i2c-&gt;adap.algo    &#x3D; &amp;s3c24xx_i2c_algorithm;      &#x2F;&#x2F; I2C主机控制器的操作方法</span><br><span class="line">i2c-&gt;adap.retries &#x3D; 2;</span><br><span class="line">i2c-&gt;adap.class   &#x3D; I2C_CLASS_HWMON | I2C_CLASS_SPD;</span><br><span class="line">i2c-&gt;tx_setup     &#x3D; 50;</span><br></pre></td></tr></table></figure>

<p>三星采用<code>struct s3c24xx_i2c</code>结构体来对SoC的控制器进行抽象，该结构体继承于<code>struct i2c_adapter</code>。该段代码先是从device中获取了平台数据，该平台数据即是上文调用<code>s3c_i2c0_set_platdata</code>函数时设置的。然后对<code>i2c-&gt;adap</code>进行了相关赋值，关键部分是<code>i2c-&gt;adap.algo = &amp;s3c24xx_i2c_algorithm;</code>，<code>adap.algo</code>表示I2C主机控制器的操作方法，将该SoC的操作方法挂接到了适配器上。<code>s3c24xx_i2c_algorithm</code>定义了两个操作方法，主要是<code>master_xfer</code>方法，用来发送消息。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct i2c_algorithm s3c24xx_i2c_algorithm &#x3D; &#123;</span><br><span class="line">    .master_xfer        &#x3D; s3c24xx_i2c_xfer,</span><br><span class="line">    .functionality      &#x3D; s3c24xx_i2c_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>s3c24xx_i2c_xfer</code>涉及到对具体控制器的操作，不进行展开，但是注意的是其内部调用的是<code>s3c24xx_i2c_doxfer</code>，在<code>s3c24xx_i2c_doxfer</code>函数内部发送完数据后，调用<code>wait_event_timeout</code>函数来进行睡眠等待从机响应。因此可知内核中I2C的等待从机的ACK信号是通过中断实现的，即主机发送完数据后进入睡眠等待从机，从机响应后通过中断通知主机后唤醒。</p>
<p>probe函数接着做了获取时钟和使能时钟，相关代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取时钟</span><br><span class="line">    i2c-&gt;clk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);</span><br><span class="line"></span><br><span class="line">    if (IS_ERR(i2c-&gt;clk)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, &quot;cannot get clock\n&quot;);</span><br><span class="line">        ret &#x3D; -ENOENT;</span><br><span class="line">        goto err_noclk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_dbg(&amp;pdev-&gt;dev, &quot;clock source %p\n&quot;, i2c-&gt;clk);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使能时钟</span><br><span class="line">    clk_enable(i2c-&gt;clk);</span><br></pre></td></tr></table></figure>

<p>紧接着对具体IO和IRQ进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取I2C平台资源（IO内存地址、IRQ）</span><br><span class="line">res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">if (res &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot find IO resource\n&quot;);</span><br><span class="line">    ret &#x3D; -ENOENT;</span><br><span class="line">    goto err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c-&gt;ioarea &#x3D; request_mem_region(res-&gt;start, resource_size(res),</span><br><span class="line">                 pdev-&gt;name);</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;ioarea &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot request IO\n&quot;);</span><br><span class="line">    ret &#x3D; -ENXIO;</span><br><span class="line">    goto err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将物理地址映射为虚拟地址</span><br><span class="line">i2c-&gt;regs &#x3D; ioremap(res-&gt;start, resource_size(res));</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;regs &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot map IO\n&quot;);</span><br><span class="line">    ret &#x3D; -ENXIO;</span><br><span class="line">    goto err_ioarea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;pdev-&gt;dev, &quot;registers %p (%p, %p)\n&quot;,</span><br><span class="line">    i2c-&gt;regs, i2c-&gt;ioarea, res);</span><br><span class="line"></span><br><span class="line">&#x2F;* setup info block for the i2c core *&#x2F;</span><br><span class="line"></span><br><span class="line">i2c-&gt;adap.algo_data &#x3D; i2c;</span><br><span class="line">i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">&#x2F;* initialise the i2c controller *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化I2C控制器</span><br><span class="line">ret &#x3D; s3c24xx_i2c_init(i2c);    </span><br><span class="line">if (ret !&#x3D; 0)</span><br><span class="line">    goto err_iomap;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取IRQ资源</span><br><span class="line">i2c-&gt;irq &#x3D; ret &#x3D; platform_get_irq(pdev, 0);   </span><br><span class="line">if (ret &lt;&#x3D; 0) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;cannot find IRQ\n&quot;);</span><br><span class="line">    goto err_iomap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 申请IRQ (裸机一般使用查询法来判断从机的响应，而内核一般采用中断方式等待从机响应)</span><br><span class="line">ret &#x3D; request_irq(i2c-&gt;irq, s3c24xx_i2c_irq, IRQF_DISABLED,</span><br><span class="line">          dev_name(&amp;pdev-&gt;dev), i2c);</span><br></pre></td></tr></table></figure>

<p>把关注点放在初始化I2C控制器的<code>s3c24xx_i2c_init</code>函数和申请IRQ上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int s3c24xx_i2c_init(struct s3c24xx_i2c *i2c)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long iicon &#x3D; S3C2410_IICCON_IRQEN | S3C2410_IICCON_ACKEN;</span><br><span class="line">    struct s3c2410_platform_i2c *pdata;</span><br><span class="line">    unsigned int freq;</span><br><span class="line"></span><br><span class="line">    &#x2F;* get the plafrom data *&#x2F;</span><br><span class="line"></span><br><span class="line">    pdata &#x3D; i2c-&gt;dev-&gt;platform_data;</span><br><span class="line"></span><br><span class="line">    &#x2F;* inititalise the gpio *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (pdata-&gt;cfg_gpio)</span><br><span class="line">        pdata-&gt;cfg_gpio(to_platform_device(i2c-&gt;dev));      &#x2F;&#x2F; 设置I2C对应的管脚</span><br><span class="line"></span><br><span class="line">    &#x2F;* write slave address *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 设置I2C控制器作为从设备时的地址</span><br><span class="line">    writeb(pdata-&gt;slave_addr, i2c-&gt;regs + S3C2410_IICADD);  </span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;slave address 0x%02x\n&quot;, pdata-&gt;slave_addr);</span><br><span class="line"></span><br><span class="line">    writel(iicon, i2c-&gt;regs + S3C2410_IICCON);        &#x2F;&#x2F; 使能 Tx&#x2F;Rx Interrupt 和 ACK信号</span><br><span class="line"></span><br><span class="line">    &#x2F;* we need to work out the divisors for the clock... *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 配置I2C的时钟频率</span><br><span class="line">    if (s3c24xx_i2c_clockrate(i2c, &amp;freq) !&#x3D; 0) &#123;</span><br><span class="line">        writel(0, i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line">        dev_err(i2c-&gt;dev, &quot;cannot meet bus frequency required\n&quot;);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* todo - check that the i2c lines aren&#39;t being dragged anywhere *&#x2F;</span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;bus frequency set to %d KHz\n&quot;, freq);</span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;S3C2410_IICCON&#x3D;0x%02lx\n&quot;, iicon);</span><br><span class="line"></span><br><span class="line">    dev_dbg(i2c-&gt;dev, &quot;S3C2440_IICLC&#x3D;%08x\n&quot;, pdata-&gt;sda_delay);</span><br><span class="line">    writel(pdata-&gt;sda_delay, i2c-&gt;regs + S3C2440_IICLC);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到设置I2C对应的管脚是调用平台数据中的<code>cfg_gpio</code>，其实看到这里如果还有印象的话就能反应出来这是在调用<code>s3c_i2c0_set_platdata</code>中设置的。该函数还设置了I2C控制器的从地址，该地址用来在控制器作为从地址时使用，但是这种情况的出现微乎其微。除此之外使能Tx/Rx Interrupt和ACK信号，配置了I2C的时钟频率。</p>
<p>注意从前一段分析中得知，内核中I2C采用中断方式等待从机响应，所以probe函数这一段代码中申请了IRQ并绑定了中断处理函数<code>s3c24xx_i2c_irq</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c24xx_i2c *i2c &#x3D; dev_id;</span><br><span class="line">    unsigned long status;</span><br><span class="line">    unsigned long tmp;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取I2CSTAT寄存器的值</span><br><span class="line">    status &#x3D; readl(i2c-&gt;regs + S3C2410_IICSTAT);</span><br><span class="line"></span><br><span class="line">    if (status &amp; S3C2410_IICSTAT_ARBITR) &#123;   &#x2F;&#x2F; I2C总线仲裁失败</span><br><span class="line">        &#x2F;* deal with arbitration loss *&#x2F;</span><br><span class="line">        dev_err(i2c-&gt;dev, &quot;deal with arbitration loss\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (i2c-&gt;state &#x3D;&#x3D; STATE_IDLE) &#123;</span><br><span class="line">        dev_dbg(i2c-&gt;dev, &quot;IRQ: error i2c-&gt;state &#x3D;&#x3D; IDLE\n&quot;);</span><br><span class="line"></span><br><span class="line">        tmp &#x3D; readl(i2c-&gt;regs + S3C2410_IICCON);</span><br><span class="line">        tmp &amp;&#x3D; ~S3C2410_IICCON_IRQPEND;</span><br><span class="line">        writel(tmp, i2c-&gt;regs +  S3C2410_IICCON);</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* pretty much this leaves us with the fact that we&#39;ve</span><br><span class="line">     * transmitted or received whatever byte we last sent *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理I2C的收发数据</span><br><span class="line">    i2c_s3c_irq_nextbyte(i2c, status);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体也不展开分析了，但是要注意的是有这么一条线：该中断处理函数调用了<code>i2c_s3c_irq_nextbyte</code>，然后内部调用了<code>s3c24xx_i2c_stop</code>，再内部调用了<code>s3c24xx_i2c_master_complete</code>，最后再内部执行了一个关键代码<code>wake_up(&amp;i2c-&gt;wait);</code>，这就是通过中断方式唤醒之前在发送数据时进行的睡眠等待。</p>
<p>回到probe函数，最后分析重头戏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret &#x3D; i2c_add_numbered_adapter(&amp;i2c-&gt;adap);</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, &quot;failed to add bus to i2c core\n&quot;);</span><br><span class="line">    goto err_cpufreq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码将I2C适配器注册到了内核中。<code>i2c_add_numbered_adapter</code>函数由核心层提供，其定义位于I2C核心层<code>drivers/i2c/i2c-core.c</code>中，用来注册I2C适配器。其实在内核中提供了两个adapter注册接口,分别为<code>i2c_add_adapter</code>和<code>i2c_add_numbered_adapter</code>由于在系统中可能存在多个adapter, 所以将每一条I2C总线(控制器)对应一个编号，这个总线号（可以称这个编号为总线号码）与PCI中的总线号不同。它和硬件无关, 只是软件上便于区分而已。对于<code>i2c_add_adapter</code>而言, 它使用的是动态总线号, 即由系统给其分配一个总线号, 而<code>i2c_add_numbered_adapter</code>则是自己指定总线号, 如果这个总线号非法或者是被占用, 就会注册失败。不管哪个注册接口，其核心都是调用<code>i2c_register_adapter</code>函数来进行真正的注册。取出<code>i2c_register_adapter</code>函数的关键部分进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x3D; device_register(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">    i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">dummy &#x3D; bus_for_each_drv(&amp;i2c_bus_type, NULL, adap,</span><br><span class="line">             __process_new_adapter);</span><br></pre></td></tr></table></figure>

<p><code>device_register(&amp;adap-&gt;dev);</code>表示主机适配器adapter的注册。</p>
<p><code>i2c_scan_static_board_info(adap);</code>内部先遍历<code>__i2c_board_list</code>取出板卡信息（描述的是板子上的I2C外设的信息，即I2C从机的信息），该链表的生成是在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中进行的，在<code>mach-x210.c</code>中的<code>smdkc110_machine_init</code>函数中进行了除之前分析的调用<code>s3c_i2c0_set_platdata</code>外，还调用了<code>i2c_register_board_info</code>对板卡信息进行了注册。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __init</span><br><span class="line">i2c_register_board_info(int busnum,</span><br><span class="line">    struct i2c_board_info const *info, unsigned len)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    down_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    &#x2F;* dynamic bus numbers will be assigned after the last static one *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; __i2c_first_dynamic_bus_num为全局未显式初始化变量，所以第一次进到这个函数，值为0</span><br><span class="line">    if (busnum &gt;&#x3D; __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num &#x3D; busnum + 1;</span><br><span class="line"></span><br><span class="line">    for (status &#x3D; 0; len; len--, info++) &#123;</span><br><span class="line">        struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">        devinfo &#x3D; kzalloc(sizeof(*devinfo), GFP_KERNEL);</span><br><span class="line">        if (!devinfo) &#123;</span><br><span class="line">            pr_debug(&quot;i2c-core: can&#39;t register boardinfo!\n&quot;);</span><br><span class="line">            status &#x3D; -ENOMEM;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum &#x3D; busnum;</span><br><span class="line">        devinfo-&gt;board_info &#x3D; *info;</span><br><span class="line">        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);    &#x2F;&#x2F; 将board_info用链表管理起来 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>板卡信息的描述，主要对其设备名和从地址进行赋值，示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define I2C_BOARD_INFO(dev_type, dev_addr) \</span><br><span class="line">    .type &#x3D; dev_type, .addr &#x3D; (dev_addr)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TOUCHSCREEN_GSLX680</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_BOARD_INFO(&quot;gslX680&quot;, 0x40),  &#x2F;&#x2F; 主要对其设备名和从地址进行赋值</span><br><span class="line">    &#125;,</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>然后在<code>i2c_scan_static_board_info</code>内部利用板卡信息作为原料调用<code>i2c_new_device</code>来创建了client，表示从机设备，并将adapter挂接到了client结构体内部的指针上。<code>i2c_scan_static_board_info</code>代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void i2c_scan_static_board_info(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_devinfo  *devinfo;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;__i2c_board_lock);</span><br><span class="line">    &#x2F;&#x2F; __i2c_board_list在调用i2c_register_board_info时链接起来的</span><br><span class="line">    list_for_each_entry(devinfo, &amp;__i2c_board_list, list) &#123;</span><br><span class="line">        if (devinfo-&gt;busnum &#x3D;&#x3D; adapter-&gt;nr</span><br><span class="line">                &amp;&amp; !i2c_new_device(adapter,</span><br><span class="line">                        &amp;devinfo-&gt;board_info))</span><br><span class="line">            dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">                &quot;Can&#39;t create device at 0x%02x\n&quot;,</span><br><span class="line">                devinfo-&gt;board_info.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    up_read(&amp;__i2c_board_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完client后，回到<code>i2c_register_adapter</code>函数，最后执行了<code>dummy = bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</code>，<strong>该函数是遍历在I2C总线上已经注册的driver，通过回调<code>__process_new_adapter</code>函数的方式，遍历到i2c-dev这个通用驱动后就会用其<code>i2cdev_attach_adapter</code>方法来挂接到在i2c-dev中注册的字符设备驱动，并使用这个字符设备驱动的主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点，应用层访问这个设备节点后即可调用在i2c-dev中注册的file_operations中的操作方法，从操作方法源码知，最终读写调用的是adapter中的读写方法（即在本平台中为i2c-s3c2410.c中定义的方法）</strong>。下面对其进行验证。</p>
<p><code>__process_new_adapter</code>展开如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_do_add_adapter(struct i2c_driver *driver,</span><br><span class="line">                  struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* Detect supported devices on that bus, and instantiate them *&#x2F;</span><br><span class="line">    i2c_detect(adap, driver);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Let legacy drivers scan this bus for matching devices *&#x2F;</span><br><span class="line">    if (driver-&gt;attach_adapter) &#123;</span><br><span class="line">        &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;</span><br><span class="line">        driver-&gt;attach_adapter(adap);   &#x2F;&#x2F; 调用i2c-dev中的i2cdev_attach_adapter方法</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __process_new_adapter(struct device_driver *d, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    return i2c_do_add_adapter(to_i2c_driver(d), data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>driver-&gt;attach_adapter(adap);</code>，的确是调用I2C总线下的驱动中的<code>attach_adapter</code>方法，到了这里在I2C设备驱动层埋下的悬念终于要水落石出了（不容易啊啊啊啊啊啊），穿越回到I2C设备驱动层进行分析，进入<code>drivers/i2c/i2c-dev.c</code>分析<code>i2cdev_attach_adapter</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2cdev_attach_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_dev *i2c_dev;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    i2c_dev &#x3D; get_free_i2c_dev(adap);</span><br><span class="line">    if (IS_ERR(i2c_dev))</span><br><span class="line">        return PTR_ERR(i2c_dev);</span><br><span class="line"></span><br><span class="line">    &#x2F;* register this i2c device with the driver core *&#x2F;</span><br><span class="line">    &#x2F;* 使用主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点 *&#x2F;</span><br><span class="line">    i2c_dev-&gt;dev &#x3D; device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">                     MKDEV(I2C_MAJOR, adap-&gt;nr), NULL,</span><br><span class="line">                     &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">    if (IS_ERR(i2c_dev-&gt;dev)) &#123;</span><br><span class="line">        res &#x3D; PTR_ERR(i2c_dev-&gt;dev);</span><br><span class="line">        goto error;</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">    if (res)</span><br><span class="line">        goto error_destroy;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;,</span><br><span class="line">         adap-&gt;name, adap-&gt;nr);</span><br><span class="line">    return 0;</span><br><span class="line">error_destroy:</span><br><span class="line">    device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line">error:</span><br><span class="line">    return_i2c_dev(i2c_dev);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev, MKDEV(I2C_MAJOR, adap-&gt;nr), NULL, &quot;i2c-%d&quot;, adap-&gt;nr);</code>使用主设备号和adapter中的总线号（作为次设备号）来创建名为i2c-x的设备节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ssize_t i2cdev_write(struct file *file, const char __user *buf,</span><br><span class="line">        size_t count, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    char *tmp;</span><br><span class="line">    &#x2F;&#x2F; 取出i2c_client</span><br><span class="line">    struct i2c_client *client &#x3D; file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    if (count &gt; 8192)</span><br><span class="line">        count &#x3D; 8192;</span><br><span class="line"></span><br><span class="line">    tmp &#x3D; kmalloc(count, GFP_KERNEL);</span><br><span class="line">    if (tmp &#x3D;&#x3D; NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#x2F;&#x2F; 拷贝用户数据到内核空间</span><br><span class="line">    if (copy_from_user(tmp, buf, count)) &#123;</span><br><span class="line">        kfree(tmp);</span><br><span class="line">        return -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;,</span><br><span class="line">        iminor(file-&gt;f_path.dentry-&gt;d_inode), count);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送I2C数据</span><br><span class="line">    ret &#x3D; i2c_master_send(client, tmp, count);</span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以write函数为例，可以看到写数据通过<code>ret = i2c_master_send(client, tmp, count);</code>完成的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_master_send(struct i2c_client *client, const char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    &#x2F;&#x2F; 获取I2C适配器</span><br><span class="line">    struct i2c_adapter *adap &#x3D; client-&gt;adapter;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 封装I2C数据包</span><br><span class="line">    msg.addr &#x3D; client-&gt;addr;</span><br><span class="line">    msg.flags &#x3D; client-&gt;flags &amp; I2C_M_TEN;   &#x2F;&#x2F; 发送标志位</span><br><span class="line">    msg.len &#x3D; count;</span><br><span class="line">    msg.buf &#x3D; (char *)buf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送I2C数据包</span><br><span class="line">    ret &#x3D; i2c_transfer(adap, &amp;msg, 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;* If everything went ok (i.e. 1 msg transmitted), return #bytes</span><br><span class="line">       transmitted, else error code. *&#x2F;</span><br><span class="line">    return (ret &#x3D;&#x3D; 1) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，经过I2C数据包的封装后，真正的最终写数据通过<code>ret = i2c_transfer(adap, &amp;msg, 1);</code>完成的。进入到<code>i2c_transfer</code>函数，截取关键部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (ret &#x3D; 0, try &#x3D; 0; try &lt;&#x3D; adap-&gt;retries; try++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用具体的SoC的I2C总线驱动的发送方法</span><br><span class="line">    ret &#x3D; adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line">    if (ret !&#x3D; -EAGAIN)</span><br><span class="line">        break;</span><br><span class="line">    if (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</code>终于回到了原点见到了I2C总线驱动层中定义的操作方法。</p>
<p>可以看到过程的确如上文所说，表现为<strong>从I2C总线驱动层自底向上后又由自顶向下的调用流程</strong>，简直一跃千里后又倾泻而下。</p>
<h2 id="I2C特定设备驱动分析"><a href="#I2C特定设备驱动分析" class="headerlink" title="I2C特定设备驱动分析"></a>I2C特定设备驱动分析</h2><p>笔者以S5PV210的E2PROM驱动为例讲解, 源码见<a href="https://github.com/IfanTsai/LinuxDriver/blob/master/i2c/at24c02.c" target="_blank" rel="noopener">github链接</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct e2prom_device &#123;</span><br><span class="line">    struct i2c_client *at24c02_client;   &#x2F;* I2C client(从设备) *&#x2F;</span><br><span class="line">    &#x2F;* class和device用来自动创建设备节点 *&#x2F;</span><br><span class="line">    struct class      *at24c02_class;</span><br><span class="line">    struct device     *at24c02_device;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct e2prom_device *e2prom_dev;</span><br></pre></td></tr></table></figure>

<p>封装一个<code>e2prom_device</code>结构体表示对E2PROM的抽象，其中包含I2C client（用来表示I2C从设备）以及class和device（这两者单纯是用来自动创建设备节点的）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_device_id e2prom_table[] &#x3D; &#123;</span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">        .name         &#x3D; &quot;24c02&quot;,</span><br><span class="line">        .driver_data  &#x3D; 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .name         &#x3D; &quot;24c08&quot;,</span><br><span class="line">        .driver_data  &#x3D; 0,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* I2C设备驱动 *&#x2F;</span><br><span class="line">struct i2c_driver e2prom_driver &#x3D; &#123;</span><br><span class="line">    .probe     &#x3D;  e2prom_probe,</span><br><span class="line">    .remove    &#x3D;  e2prom_remove,</span><br><span class="line">    .id_table  &#x3D;  e2prom_table,</span><br><span class="line">    .driver    &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;e2prom&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init e2prom_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    return i2c_add_driver(&amp;e2prom_driver);   &#x2F;* 注册I2C设备驱动 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是调用<code>i2c_add_driver</code>注册I2C设备驱动。根据上文在I2C核心层的源码分析可知，会通过在核心层中注册的<code>i2c_bus_type</code>下的<code>i2c_device_match</code>函数来匹配设备与驱动，一旦匹配上则会调用其<code>i2c_device_probe</code>函数，而<code>i2c_device_probe</code>函数又会调用i2c_driver的probe函数。注意如上文分析所知，client生成的原料为board_info，所以要使这个驱动成功匹配，需要在<code>arch/arm/mach-s5pv210/mach-x210.c</code>中使用<code>i2c_register_board_info</code>来注册board_info。接下去直奔prob函数进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct file_operations e2prom_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open  &#x3D; e2prom_open,</span><br><span class="line">    .write &#x3D; e2prom_write,</span><br><span class="line">    .read &#x3D;  e2prom_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int e2prom_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;e2prom probe!\n&quot;);</span><br><span class="line">    e2prom_dev &#x3D; kmalloc(sizeof(struct e2prom_device), GFP_KERNEL);</span><br><span class="line">    if (!e2prom_dev) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;malloc failed!\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e2prom_dev-&gt;at24c02_client &#x3D; client;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册为字符设备驱动 *&#x2F;</span><br><span class="line">    ret &#x3D; register_chrdev(E2PROM_MAJOR, &quot;e2prom_module&quot;, &amp;e2prom_fops);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;malloc failed\n&quot;);</span><br><span class="line">        ret &#x3D; -ENOMEM;</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建类  *&#x2F;</span><br><span class="line">    e2prom_dev-&gt;at24c02_class &#x3D; class_create(THIS_MODULE, &quot;e2prom_class&quot;);</span><br><span class="line">    if (IS_ERR(e2prom_dev-&gt;at24c02_class)) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;class create failed!\n&quot;);</span><br><span class="line">        ret &#x3D; PTR_ERR(e2prom_dev-&gt;at24c02_class);</span><br><span class="line">        goto err1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 在类下创建设备 *&#x2F;</span><br><span class="line">    e2prom_dev-&gt;at24c02_device &#x3D; device_create(e2prom_dev-&gt;at24c02_class, NULL, MKDEV(E2PROM_MAJOR, 0), NULL, &quot;at24c08&quot;);</span><br><span class="line">    if (IS_ERR(e2prom_dev-&gt;at24c02_device)) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;class create failed!\n&quot;);</span><br><span class="line">        ret &#x3D; PTR_ERR(e2prom_dev-&gt;at24c02_device);</span><br><span class="line">        goto err1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">err1:</span><br><span class="line">    unregister_chrdev(E2PROM_MAJOR, &quot;e2prom_module&quot;);</span><br><span class="line">err0:</span><br><span class="line">    kfree(e2prom_dev);</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>在probe函数中调用<code>register_chrdev</code>函数来将E2PROM驱动注册为了字符设备驱动，并绑定了fops。然后调用<code>class_create</code>和<code>device_create</code>自动生成设备节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int e2prom_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open方法为空，以write方法为例讲解具体的操作，read方法类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ssize_t e2prom_write(struct file *file, const char __user *buf,</span><br><span class="line">        size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    char *tmp;</span><br><span class="line">    tmp &#x3D; kmalloc(size, GFP_KERNEL);</span><br><span class="line">    if (tmp &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;mallo failed!\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 将用户空间数据拷贝到内核空间 *&#x2F;</span><br><span class="line">    ret &#x3D; copy_from_user(tmp, buf, size);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(&quot;copy data faile!\n&quot;);</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* I2C write *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_write_byte(tmp, size);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;wrtie byte failed!\n&quot;);</span><br><span class="line">        goto err0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return size;</span><br><span class="line"></span><br><span class="line">err0:</span><br><span class="line">    kfree(tmp);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到真正的操作I2C在<code>i2c_write_byte</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_write_byte(char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 封装I2C数据包 *&#x2F;</span><br><span class="line">    msg.addr   &#x3D; e2prom_dev-&gt;at24c02_client-&gt;addr; &#x2F;* I2C从设备地址 *&#x2F;</span><br><span class="line">    msg.flags  &#x3D; 0;                                &#x2F;* write flag *&#x2F;</span><br><span class="line">    msg.len    &#x3D; count;                            &#x2F;* 数据长度 *&#x2F;</span><br><span class="line">    msg.buf    &#x3D; buf;                              &#x2F;* 写入的数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 调用I2C核心层提供的传输函数，其本质还是调用的I2C总线驱动(主机控制器驱动)层下实现的algo-&gt;master_xfe方法 *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_transfer(e2prom_dev-&gt;at24c02_client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;i2c transfer failed!\n&quot;);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是调用在I2C核心层提供的传输函数，其本质还是在传输函数内部调用了跟具体SoC相关的I2C主机控制器操作方法中的传输方法。该函数接口需要提供一个<code>i2c_msg</code>，所以对其进行了创建并填充，注意<code>msg.flags = 0;</code>中0表示写，1表示读。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】input子系统全面分析</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91input%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：博客园–<a href="https://www.cnblogs.com/lcw/" target="_blank" rel="noopener">Leo.cheng</a>【<a href="https://www.cnblogs.com/lcw/p/3293302.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lcw/p/3293302.html】</a></p>
<h1 id="【驱动】input子系统全面分析"><a href="#【驱动】input子系统全面分析" class="headerlink" title="【驱动】input子系统全面分析"></a><a href="https://www.cnblogs.com/lcw/p/3293302.html" target="_blank" rel="noopener">【驱动】input子系统全面分析</a></h1><h2 id="初识linux输入子系统"><a href="#初识linux输入子系统" class="headerlink" title="初识linux输入子系统"></a>初识linux输入子系统</h2><p>　　linux输入子系统（linux input subsystem）从上到下由三层实现，分别为：输入子系统事件处理层（EventHandler）、输入子系统核心层（InputCore）和输入子系统设备驱动层。</p>
<ol>
<li>设备驱动层：主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件转换为核心层定义的规范提交给事件处理层。</li>
<li>核心层：为设备驱动层提供了规范和接口。设备驱动层只要关心如何驱动硬件并获得硬件数据（例如按下的按键数据），然后调用核心层提供的接口，核心层会自动把数据提交给事件处理层。</li>
<li>事件处理层：则是用户编程的接口（设备节点），并处理驱动层提交的数据处理。</li>
</ol>
<hr>
<h2 id="input输入子系统框架分析"><a href="#input输入子系统框架分析" class="headerlink" title="input输入子系统框架分析"></a>input输入子系统框架分析</h2><p>　　输入子系统由输入子系统核心层（ Input Core ），驱动层和事件处理层（Event Handler）三部份组成。</p>
<p>　　一个输入事件，如鼠标移动，键盘按键按下，joystick的移动等等通过 input driver -&gt; Input core -&gt; Event handler -&gt; userspace 到达用户空间传给应用程序。</p>
<p><img src="https://images0.cnblogs.com/blog/536940/201308/31142437-2490ff18237f466a85a3f23cadd89895.jpg" alt="img"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-系统核心层"><a href="#1-系统核心层" class="headerlink" title="1.系统核心层"></a><strong>1.系统核心层</strong></h3><p>　　主要功能</p>
<ol>
<li>注册主设备号</li>
<li>对于swi进入的open函数进行第一层处理，并通过次设备号选择handler进入第二层open，也就是真正的open所在的file_operation,并返回该file_opration的fd</li>
<li>提供input_register_device跟input_register_handler函数分别用于注册device跟handler</li>
</ol>
<h3 id="2-handler层（事件处理层）"><a href="#2-handler层（事件处理层）" class="headerlink" title="2.handler层（事件处理层）"></a><strong>2.handler层（事件处理层）</strong></h3><p>　　handler层是纯软件层，包含不同的解决方案，如键盘，鼠标，游戏手柄等，但是没有设计到硬件方面的操作</p>
<p>　　对于不同的解决方案，都包含一个名为input_handler的结构体，该结构体内含的主要成员如下</p>
<blockquote>
<p>　　　　.id_table　　　一个存放该handler所支持的设备id的表（其实内部存放的是EV_xxx事件,用于判断device是否支持该事件）</p>
<p>　　　　.fops　　　　　该handler的file_operation</p>
<p>　　　　.connect　　　连接该handler跟所支持device的函数</p>
<p>　　　　.disconnect　　断开该连接</p>
<p>　　　　.event　　　　事件处理函数，让device调用</p>
<p>　　　　h_list　　　　也是一个链表，该链表保存着该handler到所支持的所有device的中间站：handle结构体的指针</p>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="3-device层（驱动层）"><a href="#3-device层（驱动层）" class="headerlink" title="3.device层（驱动层）"></a><strong>3.device层（驱动层）</strong></h3><p>　　device是纯硬件操作层，包含不同的硬件接口处理，如gpio等</p>
<p>　　对于每种不同的具体硬件操作，都对应着不同的input_dev结构体</p>
<p>　　该结构体内部也包含着一个h_list</p>
<h3 id="4：input-handler-list和input-device-list"><a href="#4：input-handler-list和input-device-list" class="headerlink" title="4：input_handler_list和input_device_list"></a><strong>4：input_handler_list和input_device_list</strong></h3><p>　　对于handler和device，分别用链表input_handler_list和input_device_list进行维护，</p>
<p>　　当handler或者device增加或减少的时候，分别往这两链表增加或删除节点。</p>
<h3 id="5-input子系统框架图"><a href="#5-input子系统框架图" class="headerlink" title="5.input子系统框架图"></a>5.input子系统框架图</h3><p><img src="https://images0.cnblogs.com/blog/536940/201308/31143339-81be7c9975fe480f9f89449b57b6aab1.jpg" alt="img"></p>
<hr>
<h2 id="input子系统调用过程分析"><a href="#input子系统调用过程分析" class="headerlink" title="input子系统调用过程分析"></a>input子系统调用过程分析</h2><p>　　1.当外部应用程序需要调用输入子系统的open函数时，会先通过主设备号进入到核心层，然后通过次设备号进入handler层，再调用.fops内的open函数返回fd；</p>
<p>　　2.当外部应用程序需要调用输入子系统的read函数时，会通过返回的fd调用.fop内的read函数，然后休眠，等待被.event函数唤醒</p>
<p>　　3.当外部中断到达的时候，会先确定中断事件，然后用input_event上报事件，再通过h_list里面的所有handle调用对应的handler中的.event函数，对read进行唤醒，然后在read中返回（也就是当device有多个对应的handler的时候,input_event会向所有的handler上报事件）</p>
<p>　　4.当需要加入新的handler时，需要先构建handler结构体，然后调用input_register_handler对该handler进行注册</p>
<p>　　input_register_handler的内部实现：往input_handler_list加入新增的handler节点，然后对input_device_list的所有结点（也就是所有的device）进行遍历，通过.id_table查看该device是否支持该handler,对支持的device调用.connect,一一地构建input_handle结构体,连接handler跟device</p>
<p>　　5.当需要加入新的device时，需要先构建input_dev结构体，然后调用input_register_device对该input_dev进行注册</p>
<p>　　</p>
<p>　　<strong>input_register_dev的内部实现</strong>：往input_device_list加入新增的device节点，然后对input_handler_list的所有结点（也就是所有的handler）进行遍历，通过handler　的.id_table查看该handler是否支持该device,对支持的device调用该handler的.connect,一一地构建input_handle结构体,连接handler跟device</p>
<p>　　在输入子系统框架下，我们一般的编写驱动也就是对device部分进行编写（分配input_dev并配置，驱动入口，出口，中断时进行中断判断，然后上报事件等），然后对该device的input_dev进行注册</p>
<hr>
<h2 id="Input输入子系统数据结构分析"><a href="#Input输入子系统数据结构分析" class="headerlink" title="Input输入子系统数据结构分析"></a><strong>Input输入子系统数据结构分析</strong></h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="input-dev"><a href="#input-dev" class="headerlink" title="input_dev"></a>input_dev</h3><p>　　input_dev 这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构，成员比较多 </p>
<p>　　<strong>（1）有以下几个数组：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long evbit[BITS_TO_LONGS(EV_CNT)];   &#x2F;&#x2F;事件支持的类型  </span><br><span class="line"> &#x2F;&#x2F; 下面是每种类型支持的编码  </span><br><span class="line">unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];   &#x2F;&#x2F;按键    </span><br><span class="line">unsigned long relbit[BITS_TO_LONGS(REL_CNT)];     </span><br><span class="line">unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];   &#x2F;&#x2F;绝对坐标，其中触摸屏驱动使用的就是这个  </span><br><span class="line">unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];  </span><br><span class="line">unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];  </span><br><span class="line">unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];  </span><br><span class="line">unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];  </span><br><span class="line">unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evbit[BITS_TO_LONGS(EV_CNT)]; 这个数组以位掩码的形式，代表了这个设备支持的事件的类型。</p>
<p>　　设置方式：<br>　　dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS)<br>　　absbit[BITS_TO_LONGS(ABS_CNT)]; 这个数组也是以位掩码的形式，代表这个类型的事件支持的编码<br>　　触摸屏驱动支持EV_ABS,所以要设置这个数组， 有一个专门设置这个数组的函数input_set_abs_params</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void input_set_abs_params(struct input_dev *dev, int axis, int min, int max, int fuzz, int flat)  </span><br><span class="line">&#123;  </span><br><span class="line">    dev-&gt;absmin[axis] &#x3D; min;  </span><br><span class="line">    dev-&gt;absmax[axis] &#x3D; max;  </span><br><span class="line">    dev-&gt;absfuzz[axis] &#x3D; fuzz;  </span><br><span class="line">    dev-&gt;absflat[axis] &#x3D; flat;  </span><br><span class="line">  </span><br><span class="line">    dev-&gt;absbit[BIT_WORD(axis)] |&#x3D; BIT_MASK(axis);  &#x2F;&#x2F;填充了absbit这个数组  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　触摸屏驱动中是这样调用的</p>
<p>　　input_set_abs_params(dev, ABS_X, 0, 0x3FF, 0, 0)；  //这个是设置ad转换的x坐标<br>　　input_set_abs_params(dev, ABS_Y, 0, 0x3FF, 0, 0);  //这个是设置ad转换的y坐标<br>　　input_set_abs_params(dev, ABS_PRESSURE, 0, 1, 0, 0); //这个是设置触摸屏是否按下的标志<br>　　设置ABS_X编码值范围为0-0x3ff，因为mini2440的AD转换出的数据最大为10位，所以不会超过0x3ff。</p>
<p>　<strong>（2） struct input_id id 成员</strong><br>　　这个是标识设备驱动特征的</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_id &#123;  </span><br><span class="line">    __u16 bustype;   &#x2F;&#x2F;总线类型  </span><br><span class="line">    __u16 vendor;    &#x2F;&#x2F;生产厂商  </span><br><span class="line">    __u16 product;   &#x2F;&#x2F;产品类型  </span><br><span class="line">    __u16 version;   &#x2F;&#x2F;版本  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　如果需要特定的事件处理器来处理这个设备的话，这几个就非常重要，因为子系统核心是通过他们，将设备驱动与事件处理层联系起来的。但是因为触摸屏驱动所用的事件处理器为evdev，匹配所有，所有这个初始化也无关紧要。</p>
<h3 id="input-handler"><a href="#input-handler" class="headerlink" title="input_handler"></a>input_handler</h3><p>　　input_handler 这是事件处理器的数据结构，代表一个事件处理器</p>
<p>　　<strong>（1）几个操作函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">void (*disconnect)(struct input_handle *handle);</span><br><span class="line">void (*start)(struct input_handle *handle);</span><br></pre></td></tr></table></figure>

<p>　　event 函数是当事件处理器接收到了来自input设备传来的事件时调用的处理函数，负责处理事件，<strong>非常重要</strong>。<br>　　connect 函数是当一个input设备模块注册到内核的时候调用的，将事件处理器与输入设备联系起来的函数，也就是将input_dev和input_handler配对的函数。<br>　　disconnect 函数实现connect相反的功能。</p>
<p>　　<strong>（2） 两个id</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　const struct input_device_id *id_table; &#x2F;&#x2F;这个是事件处理器所支持的input设备</span><br><span class="line">　　const struct input_device_id *blacklist; &#x2F;&#x2F;这个是事件处理器应该忽略的input设备</span><br></pre></td></tr></table></figure>

<p>　　这两个数组都会用在connect函数中，input_device_id结构与input_id结构类似，但是input_device_id有一个flag，用来让程序选择比较哪项，如：busytype,vendor还是其他。</p>
<p>　　<strong>（3） 两个链表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct list_headh_list;  &#x2F;&#x2F;这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span><br><span class="line">struct list_headnode;    &#x2F;&#x2F;链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span><br></pre></td></tr></table></figure>



<h3 id="input-handle"><a href="#input-handle" class="headerlink" title="input_handle"></a>input_handle</h3><p>　　input_handle 结构体代表一个成功配对的input_dev和input_handler</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_handle &#123;  </span><br><span class="line">    void *private;   &#x2F;&#x2F;每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。  </span><br><span class="line">    int open;        &#x2F;&#x2F;打开标志，每个input_handle 打开后才能操作，这个一般通过事件处理器的open方法间接设置  </span><br><span class="line">    const char *name;   </span><br><span class="line">    struct input_dev *dev;  &#x2F;&#x2F;关联的input_dev结构  </span><br><span class="line">    struct input_handler *handler; &#x2F;&#x2F;关联的input_handler结构  </span><br><span class="line">    struct list_head    d_node;  &#x2F;&#x2F;input_handle通过d_node连接到了input_dev上的h_list链表上  </span><br><span class="line">    struct list_head    h_node;  &#x2F;&#x2F;input_handle通过h_node连接到了input_handler的h_list链表上  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="三个数据结构之间的关系"><a href="#三个数据结构之间的关系" class="headerlink" title="三个数据结构之间的关系"></a>三个数据结构之间的关系</h3><p>　　input_dev 是硬件驱动层，代表一个input设备<br>　　input_handler 是事件处理层，代表一个事件处理器<br>　　input_handle 属于核心层，代表一个配对的input设备与input事件处理器<br>　　input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。<br>　　input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）</p>
<p>　　input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。</p>
<p>　　通过input_dev 和input_handler就可以找到input_handle 在设备注册和事件处理器， 注册的时候都要进行配对工作，配对后就会实现链接。</p>
<p>　　通过input_handle也可以找到input_dev和input_handler。</p>
<h3 id="补充两个结构体"><a href="#补充两个结构体" class="headerlink" title="补充两个结构体"></a>补充两个结构体</h3><p>　　<strong>（1） evdev设备结构</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct evdev &#123;  </span><br><span class="line">    int exist;  </span><br><span class="line">    int open;           &#x2F;&#x2F;打开标志  </span><br><span class="line">    int minor;          &#x2F;&#x2F;次设备号  </span><br><span class="line">    struct input_handle handle;  &#x2F;&#x2F;关联的input_handle  </span><br><span class="line">    wait_queue_head_t wait;      &#x2F;&#x2F;等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面  </span><br><span class="line">    struct evdev_client *grab;   &#x2F;&#x2F;强制绑定的evdev_client结构，这个结构后面再分析  </span><br><span class="line">    struct list_head client_list;  &#x2F;&#x2F;evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备  </span><br><span class="line">    spinlock_t client_lock; &#x2F;* protects client_list *&#x2F;  </span><br><span class="line">    struct mutex mutex;  </span><br><span class="line">    struct device dev;       &#x2F;&#x2F;device结构，说明这是一个设备结构  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)。</p>
<p>　　如触摸屏驱动的event0，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input0。这个设备结构生成之后保存在evdev_table中，索引值是minor</p>
<p>　　<strong>（2） evdev用户端结构</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct evdev_client &#123;  </span><br><span class="line">    struct input_event buffer[EVDEV_BUFFER_SIZE];    </span><br><span class="line">        &#x2F;&#x2F;这个是一个input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span><br><span class="line">    int head;              &#x2F;&#x2F;针对buffer数组的索引  </span><br><span class="line">    int tail;              &#x2F;&#x2F;针对buffer数组的索引，当head与tail相等的时候，说明没有事件  </span><br><span class="line">    spinlock_t buffer_lock; &#x2F;* protects access to buffer, head and tail *&#x2F;  </span><br><span class="line">    struct fasync_struct *fasync;  &#x2F;&#x2F;异步通知函数  </span><br><span class="line">    struct evdev *evdev;           &#x2F;&#x2F;evdev设备  </span><br><span class="line">    struct list_head node;         &#x2F;&#x2F; evdev_client 链表项  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个结构在进程打开event0设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。</p>
<h3 id="Input输入子系统数据结构关系图"><a href="#Input输入子系统数据结构关系图" class="headerlink" title="Input输入子系统数据结构关系图"></a><strong>Input输入子系统数据结构关系图</strong></h3><p><strong><img src="https://images0.cnblogs.com/blog/536940/201308/31151249-8e3914e534a0414288a29215109f75b9.jpg" alt="img"></strong></p>
<hr>
<h2 id="input输入子系统主要函数分析"><a href="#input输入子系统主要函数分析" class="headerlink" title="input输入子系统主要函数分析"></a>input输入子系统主要函数分析</h2><h3 id="各种注册函数"><a href="#各种注册函数" class="headerlink" title="各种注册函数"></a>各种注册函数</h3><p>　　每种数据结构都代表一类对象，所以每种数据结构都会对应一个注册函数，他们都定义在子系统核心的input.c文件中。</p>
<p>　　主要有三个注册函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_register_device    &#x2F;&#x2F;向内核注册一个input设备</span><br><span class="line">input_register_handle    &#x2F;&#x2F;向内核注册一个handle结构</span><br><span class="line">input_register_handler   &#x2F;&#x2F;注册一个事件处理器</span><br></pre></td></tr></table></figure>





<h4 id="1-input-register-device"><a href="#1-input-register-device" class="headerlink" title="1.input_register_device"></a>1.input_register_device</h4><p>　　input_register_device 注册一个input输入设备，这个注册函数在三个注册函数中是驱动程序唯一调用的。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_device(struct input_dev *dev)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     static atomic_t input_no &#x3D; ATOMIC_INIT(0);    </span><br><span class="line"> 4         &#x2F;&#x2F;这个原子变量，代表总共注册的input设备，每注册一个加1，因为是静态变量，所以每次调用都不会清零的  </span><br><span class="line"> 5     struct input_handler *handler;  </span><br><span class="line"> 6     const char *path;  </span><br><span class="line"> 7     int error;  </span><br><span class="line"> 8   </span><br><span class="line"> 9     __set_bit(EV_SYN, dev-&gt;evbit);  &#x2F;&#x2F;EN_SYN 这个是设备都要支持的事件类型，所以要设置  </span><br><span class="line">10   </span><br><span class="line">11     &#x2F;* </span><br><span class="line">12      * If delay and period are pre-set by the driver, then autorepeating </span><br><span class="line">13      * is handled by the driver itself and we don&#39;t do it in input.c. </span><br><span class="line">14      *&#x2F;  </span><br><span class="line">15         &#x2F;&#x2F; 这个内核定时器是为了重复按键而设置的  </span><br><span class="line">16     init_timer(&amp;dev-&gt;timer);  </span><br><span class="line">17     if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;  </span><br><span class="line">18         dev-&gt;timer.data &#x3D; (long) dev;  </span><br><span class="line">19         dev-&gt;timer.function &#x3D; input_repeat_key;  </span><br><span class="line">20         dev-&gt;rep[REP_DELAY] &#x3D; 250;  </span><br><span class="line">21         dev-&gt;rep[REP_PERIOD] &#x3D; 33;  </span><br><span class="line">22         &#x2F;&#x2F;如果没有定义有关重复按键的相关值，就用内核默认的  </span><br><span class="line">23     &#125;  </span><br><span class="line">24   </span><br><span class="line">25     if (!dev-&gt;getkeycode)  </span><br><span class="line">26         dev-&gt;getkeycode &#x3D; input_default_getkeycode;  </span><br><span class="line">27     if (!dev-&gt;setkeycode)  </span><br><span class="line">28         dev-&gt;setkeycode &#x3D; input_default_setkeycode;  </span><br><span class="line">29         &#x2F;&#x2F;以上设置的默认函数由input核心提供  </span><br><span class="line">30     dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,  </span><br><span class="line">31              (unsigned long) atomic_inc_return(&amp;input_no) - 1);  </span><br><span class="line">32         &#x2F;&#x2F;设置input_dev中device的名字，这个名字会在&#x2F;class&#x2F;input中出现  </span><br><span class="line">33     error &#x3D; device_add(&amp;dev-&gt;dev);  </span><br><span class="line">34         &#x2F;&#x2F;将device加入到linux设备模型中去  </span><br><span class="line">35     if (error)  </span><br><span class="line">36         return error;  </span><br><span class="line">37   </span><br><span class="line">38     path &#x3D; kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);  </span><br><span class="line">39     printk(KERN_INFO &quot;input: %s as %s\n&quot;,  </span><br><span class="line">40         dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N&#x2F;A&quot;);  </span><br><span class="line">41     kfree(path);  </span><br><span class="line">42         &#x2F;&#x2F;这个得到路径名称，并打印出来  </span><br><span class="line">43     error &#x3D; mutex_lock_interruptible(&amp;input_mutex);  </span><br><span class="line">44     if (error) &#123;  </span><br><span class="line">45         device_del(&amp;dev-&gt;dev);  </span><br><span class="line">46         return error;  </span><br><span class="line">47     &#125;  </span><br><span class="line">48   </span><br><span class="line">49     list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);  </span><br><span class="line">50         &#x2F;&#x2F; 将新分配的input设备连接到input_dev_list链表上  </span><br><span class="line">51     list_for_each_entry(handler, &amp;input_handler_list, node)  </span><br><span class="line">52         input_attach_handler(dev, handler);  </span><br><span class="line">53         &#x2F;&#x2F;遍历input_handler_list链表，配对 input_dev 和 input_handler  </span><br><span class="line">54         &#x2F;&#x2F;input_attach_handler 这个函数是配对的关键 </span><br><span class="line">55     input_wakeup_procfs_readers();  </span><br><span class="line">56         &#x2F;&#x2F; 和proc文件系统有关 </span><br><span class="line">57     mutex_unlock(&amp;input_mutex);  </span><br><span class="line">58   </span><br><span class="line">59     return 0;  </span><br><span class="line">60    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　input_register_device完成的主要功能就是：初始化一些默认的值，将自己的device结构添加到linux设备模型当中，将input_dev添加到input_dev_list链表中，然后寻找合适的handler与input_handler配对,配对的核心函数是input_attach_handler。</p>
<p>　　下面看看input_attach_handler函数</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     const struct input_device_id *id;  </span><br><span class="line"> 4     int error;  </span><br><span class="line"> 5   </span><br><span class="line"> 6     if (handler-&gt;blacklist &amp;&amp; input_match_device(handler-&gt;blacklist, dev))  </span><br><span class="line"> 7         return -ENODEV;  </span><br><span class="line"> 8         &#x2F;&#x2F;blacklist是handler因该忽略的input设备类型，如果应该忽略的input设备也配对上了，那就出错了  </span><br><span class="line"> 9     id &#x3D; input_match_device(handler-&gt;id_table, dev);  </span><br><span class="line">10         &#x2F;&#x2F;这个是主要的配对函数，主要比较id中的各项</span><br><span class="line">11     if (!id)  </span><br><span class="line">12         return -ENODEV;  </span><br><span class="line">13   </span><br><span class="line">14     error &#x3D; handler-&gt;connect(handler, dev, id);  </span><br><span class="line">15         &#x2F;&#x2F;配对成功调用handler的connect函数，这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构</span><br><span class="line">16     if (error &amp;&amp; error !&#x3D; -ENODEV)  </span><br><span class="line">17         printk(KERN_ERR  </span><br><span class="line">18             &quot;input: failed to attach handler %s to device %s, &quot;  </span><br><span class="line">19             &quot;error: %d\n&quot;,  </span><br><span class="line">20             handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);  </span><br><span class="line">21         &#x2F;&#x2F;出错处理  </span><br><span class="line">22     return error;  </span><br><span class="line">23  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　input_attach_handler的主要功能就是调用了两个函数，一个input_match_device进行配对，一个connect处理配对成功后续工作。</p>
<p>　　下面看看input_match_device函数</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static const struct input_device_id *input_match_device(const struct input_device_id *id,  </span><br><span class="line"> 2                             struct input_dev *dev)  </span><br><span class="line"> 3 &#123;  </span><br><span class="line"> 4     int i;  </span><br><span class="line"> 5         &#x2F;&#x2F;函数传入的参数是所要配对handler的id_table，下面遍历这个id_table寻找合适的id进行配对  </span><br><span class="line"> 6     for (; id-&gt;flags || id-&gt;driver_info; id++) &#123;  </span><br><span class="line"> 7         if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)  </span><br><span class="line"> 8             if (id-&gt;bustype !&#x3D; dev-&gt;id.bustype)  </span><br><span class="line"> 9                 continue;  </span><br><span class="line">10                 ......  </span><br><span class="line">11                 &#x2F;&#x2F;针对handler-&gt;id-&gt;flag，比较不同的类型  </span><br><span class="line">12                 &#x2F;&#x2F;如果比较成功进入下面的宏，否则进入下一个id  </span><br><span class="line">13                 MATCH_BIT(evbit,  EV_MAX);  </span><br><span class="line">14             ......    </span><br><span class="line">15         MATCH_BIT(swbit,  SW_MAX);  </span><br><span class="line">16   </span><br><span class="line">17   </span><br><span class="line">18         return id;  </span><br><span class="line">19     &#125;  </span><br><span class="line">20  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　此函数主要是比较input_dev中的id和handler支持的id,这个存放在handler的id_table中。</p>
<p>　　首先看id-&gt;driver_info有没有设置，如果设置了说明它匹配所有的id，evdev就是这个样的handler<br>　　然后依据id-&gt;flag来比较内容，如果都比较成功进入MATCH_BIT，这个宏是用来按位进行比较的，功能是比较所支持事件的类型，只有所有的位都匹配才成功返回，否则进行下一个id的比较。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 #define MATCH_BIT(bit, max) \  </span><br><span class="line">2 for (i &#x3D; 0; i &lt; BITS_TO_LONGS(max); i++) \  </span><br><span class="line">3     if ((id-&gt;bit[i] &amp; dev-&gt;bit[i]) !&#x3D; id-&gt;bit[i]) \  </span><br><span class="line">4         break; \  </span><br><span class="line">5 if (i !&#x3D; BITS_TO_LONGS(max)) \  </span><br><span class="line">6     continue;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个宏对于每种事件类型，以及每种事件类型支持的编码所有的位都比较一次，看handler的id是否支持，如果有一个不支持就不会比较成功，进入下一个id进行比较。<br>　　对于connect函数，每种事件处理器的实现都有差异，但原理都相同。</p>
<p>　　因为触摸屏用的事件处理器为evdev，下面看看evdev的connect函数evdev_connect</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int evdev_connect(struct input_handler *handler, struct input_dev *dev,  </span><br><span class="line"> 2              const struct input_device_id *id)  </span><br><span class="line"> 3 &#123;  </span><br><span class="line"> 4         &#x2F;&#x2F;此函数传入三个参数，分别是：handler，dev,id  </span><br><span class="line"> 5     struct evdev *evdev;  </span><br><span class="line"> 6     int minor;  </span><br><span class="line"> 7     int error;  </span><br><span class="line"> 8   </span><br><span class="line"> 9   </span><br><span class="line">10     for (minor &#x3D; 0; minor &lt; EVDEV_MINORS; minor++)  </span><br><span class="line">11         if (!evdev_table[minor])  </span><br><span class="line">12             break;  </span><br><span class="line">13         &#x2F;&#x2F;EVDEV_MINORS为32，说明evdev这个handler可以同时有32个输入设备和他配对，evdev_table中以minor（非次设备号，但是有一个换算关系）存放evdev结构体，后面要详细分析这个结构体  </span><br><span class="line">14     if (minor &#x3D;&#x3D; EVDEV_MINORS) &#123;  </span><br><span class="line">15         printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);  </span><br><span class="line">16         return -ENFILE;  </span><br><span class="line">17     &#125;  </span><br><span class="line">18         &#x2F;&#x2F;这个说明32个位置全都被占用了，连接失败  </span><br><span class="line">19     evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);  </span><br><span class="line">20         &#x2F;&#x2F;分配一个evdev结构体，这个结构体是evdev事件处理器特有的，后面会详细分析  </span><br><span class="line">21     if (!evdev)  </span><br><span class="line">22         return -ENOMEM;  </span><br><span class="line">23   </span><br><span class="line">24   </span><br><span class="line">25     INIT_LIST_HEAD(&amp;evdev-&gt;client_list);  </span><br><span class="line">26     spin_lock_init(&amp;evdev-&gt;client_lock);  </span><br><span class="line">27     mutex_init(&amp;evdev-&gt;mutex);  </span><br><span class="line">28     init_waitqueue_head(&amp;evdev-&gt;wait);  </span><br><span class="line">29         &#x2F;&#x2F;初始化结构体的一些成员  </span><br><span class="line">30     dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);  </span><br><span class="line">31         &#x2F;&#x2F;这个是设置evdev中device的名字，他将出现在&#x2F;class&#x2F;input中。  </span><br><span class="line">32         &#x2F;&#x2F;前面也有一个device是input_dev的，名字是input（n），注意与他的不同  </span><br><span class="line">33         &#x2F;&#x2F;这个结构是配对后的虚拟设备结构，没有对应的硬件，但是通过它可以找到相关的硬件  </span><br><span class="line">34     evdev-&gt;exist &#x3D; 1;  </span><br><span class="line">35     evdev-&gt;minor &#x3D; minor;  </span><br><span class="line">36   </span><br><span class="line">37   </span><br><span class="line">38     evdev-&gt;handle.dev &#x3D; input_get_device(dev);  </span><br><span class="line">39     evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);  </span><br><span class="line">40     evdev-&gt;handle.handler &#x3D; handler;  </span><br><span class="line">41     evdev-&gt;handle.private &#x3D; evdev;  </span><br><span class="line">42         &#x2F;&#x2F;因为evdev中包含handle了，所以初始化它就可以了，这样就连接了input_handler与input_dev  </span><br><span class="line">43     evdev-&gt;dev.devt &#x3D; MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor); &#x2F;&#x2F;注意：这个minor不是真正的次设备号，还要加上EVDEV_MINOR_BASE  </span><br><span class="line">44     evdev-&gt;dev.class &#x3D; &amp;input_class;  </span><br><span class="line">45     evdev-&gt;dev.parent &#x3D; &amp;dev-&gt;dev;  </span><br><span class="line">46         &#x2F;&#x2F;配对生成的device，父设备是与他相关连的input_dev  </span><br><span class="line">47     evdev-&gt;dev.release &#x3D; evdev_free;  </span><br><span class="line">48     device_initialize(&amp;evdev-&gt;dev);  </span><br><span class="line">49   </span><br><span class="line">50   </span><br><span class="line">51     error &#x3D; input_register_handle(&amp;evdev-&gt;handle);  </span><br><span class="line">52         &#x2F;&#x2F;注册handle结构体,这个函数后面详细分析  </span><br><span class="line">53     if (error)  </span><br><span class="line">54         goto err_free_evdev;  </span><br><span class="line">55   </span><br><span class="line">56   </span><br><span class="line">57     error &#x3D; evdev_install_chrdev(evdev);  </span><br><span class="line">58         &#x2F;&#x2F;这个函数只做了一件事，就是把evdev结构保存到evdev_table中，这个数组也minor为索引  </span><br><span class="line">59     if (error)  </span><br><span class="line">60         goto err_unregister_handle;  </span><br><span class="line">61   </span><br><span class="line">62   </span><br><span class="line">63     error &#x3D; device_add(&amp;evdev-&gt;dev);  </span><br><span class="line">64         &#x2F;&#x2F;注册到linux设备模型中  </span><br><span class="line">65     if (error)  </span><br><span class="line">66         goto err_cleanup_evdev;  </span><br><span class="line">67   </span><br><span class="line">68   </span><br><span class="line">69     return 0;  </span><br><span class="line">70   </span><br><span class="line">71   </span><br><span class="line">72   err_cleanup_evdev:  </span><br><span class="line">73     evdev_cleanup(evdev);  </span><br><span class="line">74   err_unregister_handle:  </span><br><span class="line">75     input_unregister_handle(&amp;evdev-&gt;handle);  </span><br><span class="line">76   err_free_evdev:  </span><br><span class="line">77     put_device(&amp;evdev-&gt;dev);  </span><br><span class="line">78     return error;  </span><br><span class="line">79 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　evdev_connect函数做配对后的善后工作，分配一个evdev结构体，并初始化相关成员，evdev结构体中有input_handle结构，初始化并注册之。</p>
<h4 id="2-input-register-handle"><a href="#2-input-register-handle" class="headerlink" title="2.input_register_handle"></a>2.input_register_handle</h4><p>　　input_register_handle 注册一个input_handle结构体，比较简单</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_handle(struct input_handle *handle)  </span><br><span class="line"> 2 &#123;  </span><br><span class="line"> 3     struct input_handler *handler &#x3D; handle-&gt;handler;  </span><br><span class="line"> 4     struct input_dev *dev &#x3D; handle-&gt;dev;  </span><br><span class="line"> 5     int error;  </span><br><span class="line"> 6   </span><br><span class="line"> 7   </span><br><span class="line"> 8     &#x2F;* </span><br><span class="line"> 9      * We take dev-&gt;mutex here to prevent race with </span><br><span class="line">10      * input_release_device(). </span><br><span class="line">11      *&#x2F;  </span><br><span class="line">12     error &#x3D; mutex_lock_interruptible(&amp;dev-&gt;mutex);  </span><br><span class="line">13     if (error)  </span><br><span class="line">14         return error;  </span><br><span class="line">15     list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);  </span><br><span class="line">16         &#x2F;&#x2F;将handle的d_node，链接到其相关的input_dev的h_list链表中  </span><br><span class="line">17     mutex_unlock(&amp;dev-&gt;mutex);  </span><br><span class="line">18   </span><br><span class="line">19   </span><br><span class="line">20     list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);  </span><br><span class="line">21         &#x2F;&#x2F;将handle的h_node，链接到其相关的input_handler的h_list链表中  </span><br><span class="line">22     if (handler-&gt;start)  </span><br><span class="line">23         handler-&gt;start(handle);  </span><br><span class="line">24   </span><br><span class="line">25   </span><br><span class="line">26     return 0;  </span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个函数基本没做什么事，就是把一个handle结构体通过d_node链表项，分别链接到input_dev的h_list,input_handler的h_list上。</p>
<p>　　以后通过这个h_list就可以遍历相关的input_handle了。</p>
<h4 id="3-input-register-handler"><a href="#3-input-register-handler" class="headerlink" title="3. input_register_handler"></a>3. input_register_handler</h4><p> 　input_register_handler 注册一个input_handler结构体</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 int input_register_handler(struct input_handler *handler)  </span><br><span class="line"> 2  &#123;  </span><br><span class="line"> 3     struct input_dev *dev;  </span><br><span class="line"> 4     int retval;  </span><br><span class="line"> 5   </span><br><span class="line"> 6   </span><br><span class="line"> 7     retval &#x3D; mutex_lock_interruptible(&amp;input_mutex);  </span><br><span class="line"> 8     if (retval)  </span><br><span class="line"> 9         return retval;  </span><br><span class="line">10   </span><br><span class="line">11   </span><br><span class="line">12     INIT_LIST_HEAD(&amp;handler-&gt;h_list);  </span><br><span class="line">13   </span><br><span class="line">14   </span><br><span class="line">15     if (handler-&gt;fops !&#x3D; NULL) &#123;  </span><br><span class="line">16         if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;  </span><br><span class="line">17             retval &#x3D; -EBUSY;  </span><br><span class="line">18             goto out;  </span><br><span class="line">19         &#125;  </span><br><span class="line">20         input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;  </span><br><span class="line">21     &#125;  </span><br><span class="line">22         &#x2F;&#x2F;input_table，每个注册的handler都会将自己保存到这里，索引值为handler-&gt;minor右移5为，也就是除以32  </span><br><span class="line">23         &#x2F;&#x2F;为什么会这样呢，因为每个handler都会处理最大32个input_dev，所以要以minor的32为倍数对齐,这个minor是传进来的handler的MINOR_BASE  </span><br><span class="line">24         &#x2F;&#x2F;每一个handler都有一个这一个MINOR_BASE，以evdev为例,EVDEV_MINOR_BASE &#x3D; 64,可以看出系统总共可以注册8个handler  </span><br><span class="line">25     list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);  </span><br><span class="line">26         &#x2F;&#x2F;连接到input_handler_list链表中  </span><br><span class="line">27     list_for_each_entry(dev, &amp;input_dev_list, node)  </span><br><span class="line">28         input_attach_handler(dev, handler);  </span><br><span class="line">29         &#x2F;&#x2F;又是配对，不过这次遍历input_dev，和注册input_dev过程一样的  </span><br><span class="line">30     input_wakeup_procfs_readers();  </span><br><span class="line">31   </span><br><span class="line">32   </span><br><span class="line">33  out:  </span><br><span class="line">34     mutex_unlock(&amp;input_mutex);  </span><br><span class="line">35     return retval;  </span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个函数其实和input_register_device大同小异，都是注册，都要配对。</p>
<h4 id="4-函数调用流程"><a href="#4-函数调用流程" class="headerlink" title="4.函数调用流程"></a>4.函数调用流程</h4><p> <img src="https://images0.cnblogs.com/blog/536940/201309/01010919-d1f3032c7fa24c259b80144a7d409e25.png" alt="img"></p>
<hr>
<h2 id="input输入子系统事件处理机制"><a href="#input输入子系统事件处理机制" class="headerlink" title="input输入子系统事件处理机制"></a>input输入子系统事件处理机制</h2><p><img src="https://images0.cnblogs.com/blog/536940/201308/31170413-da662445d343456eb67d784b342e4ffe.png" alt="img"></p>
<p>　　作为输入设备的驱动开发者，需要做以下几步：</p>
<ol>
<li>在驱动加载模块中，设置你的input设备支持的事件类型，类型参见表1设置</li>
<li>注册中断处理函数，例如键盘设备需要编写按键的抬起、放下，触摸屏设备需要编写按下、抬起、绝对移动，鼠标设备需要编写单击、抬起、相对移动，并且需要在必要的时候提交硬件数据（键值/坐标/状态等等）</li>
<li>将输入设备注册到输入子系统中</li>
</ol>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.chinaunix.net/uid/26620753.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid/26620753.html</a></p>
<p><a href="http://blog.csdn.net/ielife/article/details/7798952" target="_blank" rel="noopener">http://blog.csdn.net/ielife/article/details/7798952</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux-IIC驱动(详解)</title>
    <url>/2021/01/15/Linux/Driver/i2c/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux-IIC%E9%A9%B1%E5%8A%A8(%E8%AF%A6%E8%A7%A3)/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.cnblogs.com/lifexy/p/7816324.html】" target="_blank" rel="noopener">https://www.cnblogs.com/lifexy/p/7816324.html】</a></p>
<p>上一节 我们学习了:  </p>
<p>IIC接口下的24C02 驱动分析: <a href="http://www.cnblogs.com/lifexy/p/7793686.html" target="_blank" rel="noopener">http://www.cnblogs.com/lifexy/p/7793686.html</a></p>
<p>接下来本节, 学习Linux下如何利用linux下I2C驱动体系结构来操作24C02</p>
<hr>
<p><strong>1. I2C体系结构分析</strong></p>
<p><strong>1.1首先进入linux内核的driver/i2c目录下,如下图所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194402075-2024973640.png" alt="img"></p>
<p>其中重要的文件介绍如下:</p>
<p><strong>1)</strong>algos文件夹(algorithms)</p>
<p>里面保存I2C的通信方面的算法</p>
<p><strong>2)</strong>busses文件夹</p>
<p>里面保存I2C总线驱动相关的文件,比如i2c-omap.c、 i2c-versatile.c、 i2c-s3c2410.c等。</p>
<p><strong>3)</strong> chips文件夹</p>
<p>里面保存I2C设备驱动相关的文件,如下图所示,比如m41t00,就是RTC实时钟</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194416216-654621318.png" alt="img"></p>
<p><strong>4)</strong> i2c-core.c<br>这个文件实现了I2C核心的功能(I2C总线的初始化、注册和适配器添加和注销等相关工作)以及/proc/bus/i2c<em>接口。<br>*</em>5)** i2c-dev.c<br>提供了通用的read（ ） 、 write（ ） 和ioctl（ ） 等接口，实现了I2C适配器设备文件的功能，其中I2C设备的主设备号都为89， 次设备号为0~255。<br>应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器， 并控制I2C设备的工作方式</p>
<p>显然,它和前几次驱动类似， I2C也分为总线驱动和设备驱动,总线就是协议相关的，它知道如何收发数据，但不知道数据含义，设备驱动却知道数据含义</p>
<p><strong>1.2 I2C驱动架构,如下图所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194431294-567878229.png" alt="img"></p>
<p>如上图所示,每一条I2C对应一个adapter适配器,在kernel中, adapter适配器是通过struct adapter结构体定义,主要是通过i2c core层将i2c设备与i2c adapter关联起来.</p>
<p>在kernel中提供了两个adapter注册接口,分别为i2c_add_adapter()和i2c_add_numbered_adapter().由于在系统中可能存在多个adapter,因为将每一条I2C总线对应一个编号,下文中称为I2C总线号.这个总线号的PCI中的总线号不同.它和硬件无关,只是软件上便于区分而已.</p>
<p>对于i2c_add_adapter()而言,它使用的是动态总线号,即由系统给其分析一个总线号,而i2c_add_numbered_adapter()则是自己指定总线号,如果这个总线号非法或者是被占用,就会注册失败.</p>
<p><strong>2.接下来便来分析I2C总线驱动</strong></p>
<p>参考 drivers/i2c/busses/i2c-s3c2410.c</p>
<p>先进入init入口函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194447059-1799759547.png" alt="img"></p>
<p>在init函数中,注册了一个 “s3c2440-i2c”的platform_driver平台驱动,我们来看看probe函数做了些什么</p>
<p><strong>3.进入s3c24xx_i2c_probe函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_adapter  adap;</span><br><span class="line"></span><br><span class="line">static int s3c24xx_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">　　　　struct s3c24xx_i2c *i2c &#x3D; &amp;s3c24xx_i2c;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       &#x2F;*获取,使能I2C时钟*&#x2F;</span><br><span class="line">       i2c-&gt;clk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);               &#x2F;&#x2F;获取i2c时钟</span><br><span class="line">       clk_enable(i2c-&gt;clk);                                         &#x2F;&#x2F;使能i2c时钟</span><br><span class="line"></span><br><span class="line">       ... ....</span><br><span class="line">       &#x2F;*获取资源*&#x2F;</span><br><span class="line">       res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">       i2c-&gt;regs &#x3D; ioremap(res-&gt;start, (res-&gt;end-res-&gt;start)+1);</span><br><span class="line"></span><br><span class="line">       ... ....</span><br><span class="line"></span><br><span class="line">       &#x2F;*设置i2c_adapter适配器结构体, 将i2c结构体设为adap的私有数据成员*&#x2F;</span><br><span class="line">　　　　i2c-&gt;adap.algo_data &#x3D; i2c;          &#x2F;&#x2F;i2c_adapter适配器指向s3c24xx_i2c;</span><br><span class="line">       i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">　　　　&#x2F;* initialise the i2c controller *&#x2F;</span><br><span class="line">       &#x2F;*初始化2440的I2C相关的寄存器*&#x2F;</span><br><span class="line">       ret &#x3D; s3c24xx_i2c_init(i2c);</span><br><span class="line">       if (ret !&#x3D; 0)</span><br><span class="line">              goto err_iomap;</span><br><span class="line"></span><br><span class="line">       ... ...</span><br><span class="line">       &#x2F;*注册中断服务函数*&#x2F;</span><br><span class="line">       ret &#x3D; request_irq(res-&gt;start, s3c24xx_i2c_irq, IRQF_DISABLED,pdev-&gt;name, i2c);</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       &#x2F;*注册i2c_adapter适配器结构体*&#x2F;</span><br><span class="line">       ret &#x3D; i2c_add_adapter(&amp;i2c-&gt;adap);</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_adapter结构体是放在s3c24xx_i2c-&gt;adap下,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194502481-835272550.png" alt="img"></p>
<p><strong>4.接下来我们进入i2c_add_adapter()函数看看,到底如何注册的</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">       int   id, res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">       if (idr_pre_get(&amp;i2c_adapter_idr, GFP_KERNEL) &#x3D;&#x3D; 0) &#x2F;&#x2F;调用idr_pre_get()为i2c_adapter预留内存空间</span><br><span class="line">              return -ENOMEM;</span><br><span class="line"></span><br><span class="line">       mutex_lock(&amp;core_lists);</span><br><span class="line"></span><br><span class="line">       &#x2F;* &quot;above&quot; here means &quot;above or equal to&quot;, sigh *&#x2F;</span><br><span class="line">       res &#x3D; idr_get_new_above(&amp;i2c_adapter_idr, adapter,__i2c_first_dynamic_bus_num, &amp;id);</span><br><span class="line">       &#x2F;&#x2F;调用idr_get_new_above()将结构插入i2c_adapter_idr中,并将插入的位置赋给id,以后可以通过id在i2c_adapter_idr中找到相应的i2c_adapter结构体</span><br><span class="line"></span><br><span class="line">       mutex_unlock(&amp;core_lists);</span><br><span class="line"></span><br><span class="line">       if (res &lt; 0) &#123;</span><br><span class="line">              if (res &#x3D;&#x3D; -EAGAIN)</span><br><span class="line">                    goto retry;</span><br><span class="line">              return res;</span><br><span class="line">       &#125;</span><br><span class="line">       adapter-&gt;nr &#x3D; id;</span><br><span class="line">       return i2c_register_adapter(adapter);  &#x2F;&#x2F;调用i2c_register_adapter()函数进一步来注册.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_register_adapter()函数代码如下所示:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">       struct list_head  *item;               &#x2F;&#x2F;链表头,用来存放i2c_driver结构体的表头</span><br><span class="line">       struct i2c_driver *driver;                     &#x2F;&#x2F;i2c_driver,用来描述一个IIC设备驱动</span><br><span class="line">        list_add_tail(&amp;adap-&gt;list, &amp;adapters);       &#x2F;&#x2F;添加到内核的adapter链表中</span><br><span class="line">        ... ...</span><br><span class="line">       list_for_each(item,&amp;drivers) &#123;        &#x2F;&#x2F;for循环,从drivers链表里找到i2c_driver结构体的表头</span><br><span class="line">              driver &#x3D; list_entry(item, struct i2c_driver, list); &#x2F;&#x2F;通过list_head表头,找到i2c_driver结构体</span><br><span class="line">              if (driver-&gt;attach_adapter)  </span><br><span class="line">                     &#x2F;* We ignore the return code; if it fails, too bad *&#x2F;</span><br><span class="line">                     driver-&gt;attach_adapter(adap);    　　　　　　　　　　　　　　　　&#x2F;&#x2F;调用i2c_driver的attach_adapter函数来看看,这个新注册的设配器是否支持i2c_driver &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在i2c_register_adapter()函数里主要执行以下几步:</p>
<p><strong>①</strong>将adapter放入i2c_bus_type的adapter链表<br><strong>②</strong>将所有的i2c设备调出来,执行i2c_driver设备的attach_adapter函数来匹配</p>
<p>其中, i2c_driver结构体会在后面讲述到</p>
<p><strong>而i2c_adapter适配器结构体的成员结构,如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_adapter &#123;  </span><br><span class="line"></span><br><span class="line"> struct module *owner;　　　　　　　　　　　　　　&#x2F;&#x2F;所属模块  </span><br><span class="line"> unsigned int id;　　　　　　　　　　　　　　　　&#x2F;&#x2F;algorithm的类型，定义于i2c-id.h,  </span><br><span class="line"> unsigned int class;      </span><br><span class="line"> const struct i2c_algorithm *algo; 　　　　&#x2F;&#x2F;总线通信方法结构体指针  </span><br><span class="line"> void *algo_data;   　　　　　　　　　　　　&#x2F;&#x2F;algorithm数据  </span><br><span class="line"> struct rt_mutex bus_lock;　　　　　　　　&#x2F;&#x2F;控制并发访问的自旋锁  </span><br><span class="line"> int timeout;     </span><br><span class="line"> int retries;　　　　　　　　　　　　　　　　&#x2F;&#x2F;重试次数  </span><br><span class="line"> struct device dev; 　　　　　　　　　　　　&#x2F;&#x2F;适配器设备   </span><br><span class="line"> int nr;                  　　　　　　　　&#x2F;&#x2F;存放在i2c_adapter_idr里的位置号</span><br><span class="line"> char name[48];　　　　　　　　　　　　　　&#x2F;&#x2F;适配器名称  </span><br><span class="line"> struct completion dev_released;　　　　&#x2F;&#x2F;用于同步  </span><br><span class="line"> struct list_head userspace_clients;   &#x2F;&#x2F;client链表头  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>i2c_adapter表示物理上的一个i2C设备(适配器), 在i2c-s3c2410.c中,是存放在s3c24xx_i2c结构体下的(struct  i2c_adapter  adap)成员中</p>
<p><strong>5.其中s3c24xx_i2c的结构体成员如下所示</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct i2c_algorithm s3c24xx_i2c_algorithm &#x3D; &#123;            </span><br><span class="line">       .master_xfer          &#x3D; s3c24xx_i2c_xfer,  &#x2F;&#x2F;主机传输</span><br><span class="line">       .functionality          &#x3D; s3c24xx_i2c_func,                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct s3c24xx_i2c s3c24xx_i2c &#x3D; &#123;</span><br><span class="line">       .lock              &#x3D; __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),</span><br><span class="line">       .wait              &#x3D; __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),</span><br><span class="line">       .tx_setup &#x3D; 50,                        &#x2F;&#x2F;用来延时,等待SCL被释放</span><br><span class="line">       .adap             &#x3D; &#123;                                             &#x2F;&#x2F; i2c_adapter适配器结构体</span><br><span class="line">              .name                   &#x3D; &quot;s3c2410-i2c&quot;,</span><br><span class="line">              .owner                  &#x3D; THIS_MODULE,</span><br><span class="line">              .algo                     &#x3D; &amp;s3c24xx_i2c_algorithm,           &#x2F;&#x2F;存放i2c_algorithm算法结构体</span><br><span class="line">              .retries           &#x3D; 2,                                       &#x2F;&#x2F;重试次数</span><br><span class="line">              .class                    &#x3D; I2C_CLASS_HWMON,</span><br><span class="line">       &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>显然这里是直接设置了i2c_adapter结构体,所以在s3c24xx_i2c_probe ()函数中没有分配i2c_adapter适配器结构体,</p>
<p>其中, i2c_adapter结构体的名称等于”s3c2410-i2c”,它的通信方式等于s3c24xx_i2c_algorithm,重试次数等于2</p>
<p><strong>PS:如果缺少i2c_algorithm的i2c_adapter什么也做不了，就只是个I2C设备,而没有通信方式</strong></p>
<p>s3c24xx_i2c_algorithm中的关键函数master_xfer()就是用于产生i2c访问周期需要的start stop ack等信号</p>
<p>比如,在s3c24xx_i2c_algorithm中的关键函数master_xfer()里,调用了:</p>
<p>s3c24xx_i2c_xfer -&gt; s3c24xx_i2c_doxfer()-&gt;s3c24xx_i2c_message_start()</p>
<p>来启动传输message信息, 其中s3c24xx_i2c_message_start()函数代码如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c, struct i2c_msg *msg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> unsigned int addr &#x3D; (msg-&gt;addr &amp; 0x7f) &lt;&lt; 1;              &#x2F;&#x2F;IIC从设备地址的最低位为读写标志位</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       stat &#x3D; 0;</span><br><span class="line">       stat |&#x3D;  S3C2410_IICSTAT_TXRXEN;     &#x2F;&#x2F;设置标志位启动IIC收发使能</span><br><span class="line"></span><br><span class="line">       if (msg-&gt;flags &amp; I2C_M_RD) &#123;                     &#x2F;&#x2F;判断是读,还是写</span><br><span class="line">              stat |&#x3D; S3C2410_IICSTAT_MASTER_RX;       </span><br><span class="line">              addr |&#x3D; 1;                                          &#x2F;&#x2F;设置从IIC设备地址为读标志</span><br><span class="line">       &#125; else</span><br><span class="line">              stat |&#x3D; S3C2410_IICSTAT_MASTER_TX;</span><br><span class="line"></span><br><span class="line">       s3c24xx_i2c_enable_ack(i2c);                &#x2F;&#x2F;使能ACK信号</span><br><span class="line"></span><br><span class="line">　　　　iiccon &#x3D; readl(i2c-&gt;regs + S3C2410_IICCON);    &#x2F;&#x2F;读出IICCON寄存器</span><br><span class="line"></span><br><span class="line">       writel(stat, i2c-&gt;regs + S3C2410_IICSTAT);   &#x2F;&#x2F;写入IICSTAT寄存器,使能IIC的读或写标志</span><br><span class="line"></span><br><span class="line">       dev_dbg(i2c-&gt;dev, &quot;START: %08lx to IICSTAT, %02x to DS\n&quot;, stat, addr);</span><br><span class="line"></span><br><span class="line">       writeb(addr, i2c-&gt;regs + S3C2410_IICDS);  &#x2F;&#x2F;将IIC从设备地址写入IICDS寄存器</span><br><span class="line"></span><br><span class="line">       &#x2F;* delay here to ensure the data byte has gotten onto the bus</span><br><span class="line">        * before the transaction is started *&#x2F;</span><br><span class="line"></span><br><span class="line">       ndelay(i2c-&gt;tx_setup);         &#x2F;&#x2F;延时,等待SCL被释放,下面便可以发送起始信号+IIC设备地址值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       dev_dbg(i2c-&gt;dev, &quot;iiccon, %08lx\n&quot;, iiccon);</span><br><span class="line">       writel(iiccon, i2c-&gt;regs + S3C2410_IICCON);            </span><br><span class="line"></span><br><span class="line">       stat |&#x3D;  S3C2410_IICSTAT_START;              </span><br><span class="line">       writel(stat, i2c-&gt;regs + S3C2410_IICSTAT); </span><br><span class="line">　　　　　　　　　　　　&#x2F;&#x2F;设置IICSTAT寄存器的bit5&#x3D;1,开始发送起始信号+IIC从设备地址值,并回应ACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>通过上面的代码和注释,发现主要是写入IIC从设备地址,然后发送起始信号+IIC从设备地址值,并回应ACK</p>
<p>显然IIC总线驱动i2c-s3c2410.c,主要设置适配器adapter,里面帮我们做好了IIC通信的架构,就是不知道发什么内容</p>
<p><strong>我们进入driver/i2c/chips中,看看eeprom设备驱动是如何写的</strong></p>
<p>参考: driver/i2c/chips/eeprom.c</p>
<p><strong>6.还是首先来看它的init入口函数:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194519716-1730511691.png" alt="img"></p>
<p>其中struct  i2c_driver eeprom_driver的成员如下:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct i2c_driver eeprom_driver &#x3D; &#123;</span><br><span class="line">       .driver &#x3D; &#123;</span><br><span class="line">              .name     &#x3D; &quot;eeprom&quot;,                        &#x2F;&#x2F;名称</span><br><span class="line">        &#125;,</span><br><span class="line">       .id           &#x3D; I2C_DRIVERID_EEPROM,           &#x2F;&#x2F;IIC设备标识ID</span><br><span class="line">       .attach_adapter     &#x3D; eeprom_attach_adapter,  &#x2F;&#x2F;用来与总线驱动的适配器匹配,匹配成功添加到适配器adapter中</span><br><span class="line">       .detach_client &#x3D; eeprom_detach_client,      &#x2F;&#x2F;与总线驱动的适配器解绑,分离这个IIC从设备</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>如下图所示, eeprom_driver结构体的ID成员在i2c-id.h中,里面还定义了大部分常用I2C设备驱动的设备ID</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194533466-969534257.png" alt="img"></p>
<p>显然,在init函数中通过i2c_add_driver()注册i2c_driver结构体,然后通过i2c_driver -&gt;attach_adapter来匹配内核中的各个总线驱动的适配器, 发送这个设备地址,若有ACK响应,表示匹配成功</p>
<p><strong>7.接下来,我们进入i2c_add_driver()来看看是不是这样的</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_add_driver(struct module *owner, struct i2c_driver *driver)</span><br><span class="line">&#123;</span><br><span class="line">       driver-&gt;driver.owner &#x3D; owner;</span><br><span class="line">       driver-&gt;driver.bus &#x3D; &amp;i2c_bus_type;    &#x2F;&#x2F;将i2c_driver放在i2c_bus_type链表中   </span><br><span class="line"></span><br><span class="line">       res &#x3D; driver_register(&amp;driver-&gt;driver); &#x2F;&#x2F;注册一个i2c_driver</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       if (driver-&gt;attach_adapter) &#123;</span><br><span class="line">              struct i2c_adapter *adapter;                     &#x2F;&#x2F;定义一个i2c_adapter适配器</span><br><span class="line">          list_for_each_entry(adapter, &amp;adapters, list)  &#x2F;&#x2F;for循环提取出adapters链表中所有的i2c_adapter适配器,放入到adapter结构体中</span><br><span class="line"> 　　　　　&#123;</span><br><span class="line">          driver-&gt;attach_adapter(adapter); &#x2F;&#x2F;来匹配取出来的i2c_adapter适配器</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      ... ...</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在i2c_add_driver ()函数里主要执行以下几步:</p>
<p><strong>①</strong>放入到i2c_bus_type链表</p>
<p><strong>②</strong>取出adapters链表中所有的i2c_adapter,然后执行i2c_driver-&gt;attach_adapter()</p>
<p><strong>所以i2c_adapter适配器和i2c_driver设备驱动注册框架如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194549372-635602878.png" alt="img"></p>
<p> 这里调用了i2c_driver -&gt;attach_adapter(adapter),我们看看里面是不是通过发送IIC设备地址，等待ACK响应来匹配的</p>
<p><strong>8.以struct i2c_driver eeprom_driver 为例,进入i2c_driver -&gt;eeprom_attach_adapter()函数</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194557138-2076450775.png" alt="img"></p>
<p>如下图所示,里面调用了i2c_probe(adapter, &amp;addr_data, eeprom_detect)函数</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194605794-2061351036.png" alt="img"></p>
<p>上图的第1个参数就是i2c_adapter适配器,第2个参数addr_data变量,里面存放了IIC设备地址的信息,第3个参数eeprom_detect就是具体的设备探测回调函数i2c_probe()函数,会通过adapter适配器发送IIC设备地址addr_data,如果收到ACK信号,就调用eeprom_detect()回调函数来注册i2c_client结构体,该结构体对应真实的物理从设备,而i2c_driver对应的是设备驱动,也就是说,只有当适配器支持这个设备驱动,才会注册i2c_client从设备,后面会讲这个回调函数如何注册i2c_client</p>
<p>而在i2c_driver -&gt;detach_client()中,则注销i2c_client结构体</p>
<p>其中addr_data变量是struct i2c_client_address_data<strong>结构体</strong>,它的成员如下所示:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_client_address_data &#123;</span><br><span class="line">       unsigned short *normal_i2c;     &#x2F;&#x2F;存放正常的设备高7位地址数据</span><br><span class="line">       unsigned short *probe;          &#x2F;&#x2F;存放不受*ignore影响的高7位设备地址数据</span><br><span class="line">       unsigned short *ignore;         &#x2F;&#x2F;存放*ignore的高7位设备地址数据</span><br><span class="line">       unsigned short **forces;        &#x2F;&#x2F;forces表示适配器匹配不了该设备,也要将其放入适配器中</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当上面结构体的数组成员以I2C_CLIENT_END结尾,则表示地址已结束,比如at24c02设备为例,看这个结构体如何定义的:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define  AT24C02_ADDR           (0xA0&gt;&gt;1)           &#x2F;&#x2F;AT24C02地址</span><br><span class="line"></span><br><span class="line">static unsigned short  ignore[] &#x3D; &#123; I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short  normal_addr[] &#x3D; &#123; AT24C02_ADDR, I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short   force_addr[] &#x3D; &#123;ANY_I2C_BUS, AT24C02_ADDR ,2C_CLIENT_END&#125;;</span><br><span class="line">static unsigned short   * forces[] &#x3D; &#123;force_addr, NULL&#125;;　　　　　　　　　　　　&#x2F;&#x2F;ANY_I2C_BUS:表示支持所有适配器总线,若填指定的适配器总线ID,则表示该设备只支持指定的那个适配器</span><br><span class="line"></span><br><span class="line">static struct i2c_client_address_data  addr_data &#x3D; &#123;</span><br><span class="line">       .normal_i2c     &#x3D; normal_addr,    &#x2F;&#x2F;存放at24c02地址</span><br><span class="line">       .probe           &#x3D; ignore,        &#x2F;&#x2F;表示无地址</span><br><span class="line">       .ignore           &#x3D; ignore,        &#x2F;&#x2F;表示无地址</span><br><span class="line">       . forces          &#x3D; forces,        &#x2F;&#x2F;存放强制的at24c02地址,表示强制支持</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>一般而言,都不会设置.forces成员,这里只是打个比方</p>
<p><strong>8.1接下来继续进入i2c_probe()函数继续分析,如下所示:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2c_probe(struct i2c_adapter *adapter,struct i2c_client_address_data *address_data,int (*found_proc) (struct i2c_adapter *, int, int))</span><br><span class="line">&#123;</span><br><span class="line">       ... ...</span><br><span class="line">       err &#x3D; i2c_probe_address(adapter,forces[kind][i + 1],kind, found_proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了i2c_probe_address()函数,从名称上来看,显然它就是用来发送起始信号+设备地址,来探测IIC设备地址用的</p>
<p><strong>8.2进入i2c_probe_address()函数:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int i2c_probe_address(struct i2c_adapter *adapter, int addr, int kind,int (*found_proc) (struct i2c_adapter *, int, int))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;*判断设备地址是否有效,addr里存放的是设备地址前7位,比如AT24C02&#x3D;0xA0,那么addr&#x3D;0x50*&#x2F;</span><br><span class="line">       if (addr &lt; 0x03 || addr &gt; 0x77) &#123;</span><br><span class="line">              dev_warn(&amp;adapter-&gt;dev, &quot;Invalid probe address 0x%02x\n&quot;,addr);    &#x2F;&#x2F;打印地址无效,并退出</span><br><span class="line">              return -EINVAL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;*查找链表中其它IIC设备的设备地址,若这个设备地址已经被使用,则return*&#x2F;</span><br><span class="line">       if (i2c_check_addr(adapter, addr))</span><br><span class="line">              return 0; </span><br><span class="line"></span><br><span class="line">       if (kind &lt; 0) &#123;</span><br><span class="line">              if (i2c_smbus_xfer(adapter, addr, 0, 0, 0,I2C_SMBUS_QUICK, NULL) &lt; 0)      &#x2F;&#x2F;进入I2C传输函数</span><br><span class="line">　　　　　　　　 return 0;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>8.3 其中i2c_smbus_xfer()传输函数如下:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s32 i2c_smbus_xfer(struct i2c_adapter * adapter, u16 addr, unsigned short flags,char read_write, u8 command, int size,union i2c_smbus_data * data)</span><br><span class="line">&#123;</span><br><span class="line">       s32 res;</span><br><span class="line"></span><br><span class="line">       flags &amp;&#x3D; I2C_M_TEN | I2C_CLIENT_PEC;</span><br><span class="line"></span><br><span class="line">       if (adapter-&gt;algo-&gt;smbus_xfer) &#123;   &#x2F;&#x2F;如果adapter适配器有smbus_xfer这个函数</span><br><span class="line">              mutex_lock(&amp;adapter-&gt;bus_lock);                            &#x2F;&#x2F;加互斥锁</span><br><span class="line">              res &#x3D; adapter-&gt;algo-&gt;smbus_xfer(adapter,addr,flags,read_write,command,size,data);  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&#x2F;&#x2F;调用adapter适配器里的传输函数</span><br><span class="line">              mutex_unlock(&amp;adapter-&gt;bus_lock);                  &#x2F;&#x2F;解互斥锁</span><br><span class="line">       &#125; else                          &#x2F;&#x2F;否则使用默认函数传输设备地址</span><br><span class="line">              res &#x3D; i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,command,size,data);</span><br><span class="line">       return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>看了上面代码后,显然我们的s3c2410-i2c适配器没有algo-&gt;smbus_xfer函数,而是使用i2c_smbus_xfer_emulated()函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194624247-1622232895.png" alt="img"></p>
<p><strong>PS:通常适配器都是不支持的,使用默认的i2c_smbus_xfer_emulated()函数</strong></p>
<p><strong>8.4 接下来看i2c_smbus_xfer_emulated()函数如何传输的:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,unsigned short flags,char read_write, u8 command, int size, union i2c_smbus_data * data)</span><br><span class="line">&#123;</span><br><span class="line">       unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];              &#x2F;&#x2F;属于 msg[0]的buf成员</span><br><span class="line">       unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];              &#x2F;&#x2F;属于 msg[1]的buf成员</span><br><span class="line">       int num &#x3D; read_write &#x3D;&#x3D; I2C_SMBUS_READ?2:1;              &#x2F;&#x2F;如果为读命令,就等于2,表示要执行两次数据传输</span><br><span class="line">       struct i2c_msg msg[2] &#x3D; &#123; &#123; addr, flags, 1, msgbuf0 &#125;,</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　&#123; addr, flags | I2C_M_RD, 0, msgbuf1 &#125;&#125;;           &#x2F;&#x2F;定义两个i2c_msg结构体,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       msgbuf0[0] &#x3D; command;             &#x2F;&#x2F;IIC设备地址最低位为读写命令</span><br><span class="line">       ... ...</span><br><span class="line">if (i2c_transfer(adapter, msg, num) &lt; 0)</span><br><span class="line">              return -1;</span><br><span class="line"></span><br><span class="line">              &#x2F;*设置i2c_msg结构体成员*&#x2F;</span><br><span class="line">              if (read_write &#x3D;&#x3D; I2C_SMBUS_READ)</span><br><span class="line">              switch(size) &#123;</span><br><span class="line">              ... ...</span><br><span class="line">              case I2C_SMBUS_BYTE_DATA:              &#x2F;&#x2F;如果是读字节</span><br><span class="line">              if (read_write &#x3D;&#x3D; I2C_SMBUS_READ)</span><br><span class="line">                     msg[1].len &#x3D; 1;</span><br><span class="line">              else &#123;</span><br><span class="line">                     msg[0].len &#x3D; 2;</span><br><span class="line">                     msgbuf0[1] &#x3D; data-&gt;byte;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">              ... ...</span><br><span class="line">              &#125;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">       if (i2c_transfer(adapter, msg, num) &lt; 0)             &#x2F;&#x2F;将 i2c_msg结构体的内容发送给I2C设备</span><br><span class="line">              return -1;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中i2c_msg结构体的结构,如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">       __u16 addr;    　　　　　　&#x2F;&#x2F;I2C从机的设备地址</span><br><span class="line">       __u16 flags;     　　    &#x2F;&#x2F;当flags&#x3D;0表示写, flags&#x3D; I2C_M_RD表示读</span><br><span class="line">       __u16 len;              &#x2F;&#x2F;传输的数据长度,等于buf数组里的字节数</span><br><span class="line">       __u8 *buf;              &#x2F;&#x2F;存放数据的数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中之所以读操作需要两个i2c_msg,写操作需要一个i2c_msg,是因为读IIC设备是两个流程</p>
<p>在上一节IIC接口下的24C02 驱动分析:<a href="http://www.cnblogs.com/lifexy/p/7793686.html" target="_blank" rel="noopener"> http://www.cnblogs.com/lifexy/p/7793686.html</a>里就已经分析到了,</p>
<p>只要发送一个S起始信号则就是一个i2c_msg,如下两个读写操作图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194638622-994179422.png" alt="img"></p>
<p><img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194645528-2046926273.png" alt="img"></p>
<p>而在i2c_transfer()函数中,最终又是调用了之前分析的i2c_adapter-&gt;algo-&gt;master_xfer()发送函数,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194708669-885477807.png" alt="img"></p>
<p>其中i2c_transfer()的参数*adap表示通过哪个适配器传输出去,msgs表示I2C消息,num表示msgs的数目</p>
<p>内核每发送一个Msg都会先发出S开始信号和设备地址.直到所有Msg传输完毕，最后发出P停止信号。</p>
<p>当i2c_transfer()返回值为正数,表示已经传输正数个数据,当返回负数,说明I2C传输出错</p>
<p><strong>8.5 所以在i2c_driver -&gt;attach_adapter(adapter)函数里主要执行以下几步:</strong></p>
<p><strong>1)</strong> 调用 i2c_probe(adap, i2c_client_address_data<strong>设备地址结构体</strong>, 回调函数);</p>
<p><strong>2)</strong> 将要发的设备地址结构体打包成i2c_msg,</p>
<p><strong>3)</strong> 然后执行i2c_transfer()来调用i2c_adapter-&gt;algo-&gt;master_xfer()将i2c_msg发出去</p>
<p><strong>4)</strong>若收到ACK回应,便进入回调函数,注册i2c_client从设备,使该设备与适配器联系在一起</p>
<p><strong>所以适配器和iic设备驱动最终注册框架图如下所示:</strong></p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194722247-1723647250.png" alt="img"></p>
<p><strong>9.接下来便来分析回调函数如何注册i2c_client从设备的</strong></p>
<p>先来看看i2c_client结构体:</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_client &#123;  </span><br><span class="line"></span><br><span class="line"> unsigned short flags；&#x2F;&#x2F;标志    </span><br><span class="line"></span><br><span class="line"> unsigned short addr; &#x2F;&#x2F;该i2c从设备的设备地址,存放地址高7位  </span><br><span class="line"></span><br><span class="line"> char name[I2C_NAME_SIZE];   &#x2F;&#x2F;设备名字</span><br><span class="line"></span><br><span class="line"> struct i2c_adapter *adapter;&#x2F;&#x2F;依附的i2c_adapter,表示该IIC设备支持哪个适配器  </span><br><span class="line"></span><br><span class="line"> struct i2c_driver *driver;&#x2F;&#x2F;依附的i2c_driver ,表示该IIC从设备的驱动是哪个</span><br><span class="line"></span><br><span class="line"> struct device dev;&#x2F;&#x2F;设备结构体    </span><br><span class="line"></span><br><span class="line"> int irq;&#x2F;&#x2F;设备所使用的结构体    </span><br><span class="line"></span><br><span class="line"> struct list_head detected;&#x2F;&#x2F;链表头  </span><br><span class="line"></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>还是以driver/i2c/chips/eeprom.c为例,如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194741044-298465589.png" alt="img"></p>
<p><strong>9.1这里的回调函数是eeprom_detect()函数,代码如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int eeprom_detect(struct i2c_adapter *adapter, int address, int kind)</span><br><span class="line">&#123;</span><br><span class="line">struct i2c_client *new_client;        &#x2F;&#x2F;定义一个i2c_client结构体局部变量</span><br><span class="line"></span><br><span class="line">new_client &#x3D;kzalloc(sizeof(struct i2c_client), GFP_KERNEL);      &#x2F;&#x2F;分配i2c_client结构体为全局变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*设置i2c_client结构体*&#x2F;</span><br><span class="line">new_client-&gt;addr &#x3D; address;               &#x2F;&#x2F;设置设备地址</span><br><span class="line">new_client-&gt;adapter &#x3D; adapter;          &#x2F;&#x2F;设置依附的i2c_adapter</span><br><span class="line">new_client-&gt;driver &#x3D; &amp;eeprom_driver;  &#x2F;&#x2F;设置依附的i2c_driver</span><br><span class="line">new_client-&gt;flags &#x3D; 0;                         &#x2F;&#x2F;设置标志位为初始值</span><br><span class="line">strlcpy(new_client-&gt;name, &quot;eeprom&quot;, I2C_NAME_SIZE);     &#x2F;&#x2F;设置名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*注册i2c_client*&#x2F;</span><br><span class="line"> if ((err &#x3D; i2c_attach_client(new_client)))</span><br><span class="line">        goto exit_kfree;    &#x2F;&#x2F;注册失败,便释放i2c_client这个全局变量</span><br><span class="line"> ... ...</span><br><span class="line">exit_kfree:</span><br><span class="line">       kfree(new_client);</span><br><span class="line">exit:</span><br><span class="line">       return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>当注册了i2c_client从设备后,便可以使用i2c_transfer()来实现与设备传输数据了</p>
<p><strong>10.接下来,我们便参考driver/i2c/chips/eeprom.c驱动,来写出24C02驱动以及测试程序</strong></p>
<p><strong>驱动代码步骤如下:</strong></p>
<p><strong>1.</strong>定义file_operations结构体 ,设置字符设备的读写函数(实现对24C02的读写操作)<br>//构造i2c_msg结构体, 使用i2c_transfer()来实现与设备传输数据</p>
<p><strong>2.</strong>定义i2c_client_address_data结构体,里面保存24C02的设备地址<br><strong>3.</strong> 定义一个i2c_driver驱动结构体<br>    <strong>3.1</strong> 设置i2c_driver-&gt; attach_adapter<br>　　　　 // 里面直接调用 i2c_probe(adap, i2c_client_address_data结构体, 回调函数);</p>
<p>　  <strong>3.2</strong> 设置i2c_driver-&gt; detach_client<br>　      //里面卸载i2c_client, 字符设备</p>
<p><strong>4.</strong>写回调函数,里面注册i2c_client,字符设备( 字符设备用来实现读写24C02里的数据)<br>   <strong>4.1</strong> 分配并设置i2c_client</p>
<p>   <strong>4.2</strong> 使用i2c_attach_client()将i2c_client与适配器进行连接</p>
<p>  <strong>4.3</strong> 注册字符设备</p>
<p><strong>5.</strong> 写init入口函数,exit出口函数<br>init: 使用i2c_add_driver()注册i2c_driver<br>exit: 使用i2c_del_driver ()卸载i2c_driver</p>
<p><strong>具体驱动代码如下所示:</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *  I2C-24C02</span><br><span class="line"> *&#x2F;</span><br><span class="line">#include &lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;jiffies.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;mutex.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"></span><br><span class="line">static struct i2c_client *at24c02_client;         &#x2F;&#x2F;从设备结构体</span><br><span class="line">static struct class *at24c02_class;                &#x2F;&#x2F;类结构体</span><br><span class="line">static unsigned int at24c02_major;                 </span><br><span class="line"></span><br><span class="line"> &#x2F;*1.定义file_operations结构体 ,</span><br><span class="line">  *  设置字符设备的读写函数(实现对24C02的读写操作)</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t at24c02_read(struct file *file, char __user *buf, size_t size, loff_t * offset)</span><br><span class="line">&#123;</span><br><span class="line">       struct i2c_msg msg[2];</span><br><span class="line">       u8 addr;</span><br><span class="line">       u8 data;</span><br><span class="line">       int ret;</span><br><span class="line">       </span><br><span class="line">        if(size!&#x3D;1)</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">       copy_from_user(&amp;addr,buf,1);                       &#x2F;&#x2F;获取读地址</span><br><span class="line"></span><br><span class="line">        msg[0].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[0].flags&#x3D;0;                                            &#x2F;&#x2F;写标志</span><br><span class="line">        msg[0].len  &#x3D;1;</span><br><span class="line">        msg[0].buf  &#x3D;&amp;addr;                                     &#x2F;&#x2F;写入要读的地址</span><br><span class="line"></span><br><span class="line">        msg[1].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[1].flags&#x3D;I2C_M_RD;                               &#x2F;&#x2F;读标志</span><br><span class="line">        msg[1].len  &#x3D;1;</span><br><span class="line">        msg[1].buf  &#x3D;&amp;data;                                     &#x2F;&#x2F;读出数据 </span><br><span class="line"></span><br><span class="line">        ret&#x3D;i2c_transfer(at24c02_client-&gt;adapter, msg, 2);     </span><br><span class="line">        if(ret&#x3D;&#x3D;2)      &#x2F;&#x2F;表示2个msg传输成功</span><br><span class="line">        &#123;</span><br><span class="line">             copy_to_user(buf,&amp;data,1);                       &#x2F;&#x2F;上传数据       </span><br><span class="line">             return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t at24c02_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">       struct i2c_msg msg[1];</span><br><span class="line">       u8 val[2];      </span><br><span class="line">       int ret;</span><br><span class="line">       </span><br><span class="line">        if(size!&#x3D;2)         &#x2F;&#x2F;地址   数据</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">        copy_from_user(val,buf,2);                       &#x2F;&#x2F;获取 地址   数据</span><br><span class="line">        msg[0].addr&#x3D;at24c02_client-&gt;addr;</span><br><span class="line">        msg[0].flags&#x3D;0;                                       &#x2F;&#x2F;写标志</span><br><span class="line">        msg[0].len  &#x3D;2;</span><br><span class="line">        msg[0].buf  &#x3D;val;                                     &#x2F;&#x2F;写入要写的地址   数据</span><br><span class="line"></span><br><span class="line">        ret&#x3D;i2c_transfer(at24c02_client-&gt;adapter, msg, 1);     </span><br><span class="line">        if(ret&#x3D;&#x3D;1)      &#x2F;&#x2F;表示1个msg传输成功</span><br><span class="line">        &#123;           </span><br><span class="line">             return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct  file_operations at24c02_fops&#x3D;&#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .read  &#x3D; at24c02_read,</span><br><span class="line">    .write &#x3D; at24c02_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*2.定义i2c_client_address_data结构体,保存24C02的设备地址*&#x2F;</span><br><span class="line">static unsigned short ignore[] &#x3D; &#123; I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short normal_addr[] &#x3D; &#123;0X50,  I2C_CLIENT_END &#125;;</span><br><span class="line">static unsigned short   force_addr[] &#x3D; &#123;ANY_I2C_BUS, 0x60, I2C_CLIENT_END&#125;;</span><br><span class="line">static unsigned short   * forces[] &#x3D;     &#123;force_addr, NULL&#125;;    </span><br><span class="line">static struct i2c_client_address_data   at24c02_addr&#x3D;&#123;</span><br><span class="line">            .normal_i2c&#x3D;normal_addr,</span><br><span class="line">            .probe&#x3D;ignore,</span><br><span class="line">            .ignore&#x3D;ignore,</span><br><span class="line">           &#x2F;&#x2F;  .forces&#x3D;forces,                  &#x2F;&#x2F; 强制地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*3. 定义一个i2c_driver驱动结构体*&#x2F;</span><br><span class="line">static int   at24c02_attach_adapter(struct i2c_adapter *adapter);</span><br><span class="line">static int   at24c02_detach_client(struct i2c_client *client);</span><br><span class="line">static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind);</span><br><span class="line"></span><br><span class="line">&#x2F;* This is the driver that will be inserted *&#x2F;</span><br><span class="line">static struct i2c_driver at24c02_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name    &#x3D; &quot;at24c02&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    .attach_adapter    &#x3D; at24c02_attach_adapter,       &#x2F;&#x2F;绑定回调函数</span><br><span class="line">    .detach_client    &#x3D; at24c02_detach_client,                &#x2F;&#x2F;解绑回调函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*3.1 设置i2c_driver-&gt; attach_adapter*&#x2F;</span><br><span class="line">static int   at24c02_attach_adapter(struct i2c_adapter *adapter)</span><br><span class="line">&#123;</span><br><span class="line">        return i2c_probe(adapter,&amp;at24c02_addr, at24c02_detect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*3.2 设置i2c_driver-&gt; detach_client*&#x2F;</span><br><span class="line">static int   at24c02_detach_client(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;at24c02_detach_client\n&quot;);</span><br><span class="line"></span><br><span class="line">    i2c_detach_client(at24c02_client) ;   </span><br><span class="line">    kfree(at24c02_client);   </span><br><span class="line">    class_device_destroy(at24c02_class,MKDEV(at24c02_major, 0));</span><br><span class="line">    class_destroy(at24c02_class);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*4.写回调函数,里面注册i2c_client,字符设备*&#x2F; </span><br><span class="line">static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind)</span><br><span class="line">&#123;</span><br><span class="line">   printk(&quot;at24c02_detect\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 4.1 分配并设置i2c_client *&#x2F;</span><br><span class="line">    at24c02_client&#x3D; kzalloc(sizeof(struct i2c_client), GFP_KERNEL);</span><br><span class="line">   </span><br><span class="line">    at24c02_client-&gt;addr &#x3D; addr;</span><br><span class="line">    at24c02_client-&gt;adapter &#x3D; adap;</span><br><span class="line">    at24c02_client-&gt;driver &#x3D; &amp;at24c02_driver;</span><br><span class="line">    at24c02_client-&gt;flags &#x3D; 0;</span><br><span class="line">    strlcpy(at24c02_client-&gt;name, &quot;at24c02&quot;, I2C_NAME_SIZE);</span><br><span class="line"></span><br><span class="line">   &#x2F;*4.2 使用i2c_attach_client()将i2c_client与适配器进行连接*&#x2F;</span><br><span class="line">    i2c_attach_client(at24c02_client) ;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*4.3 注册字符设备*&#x2F;</span><br><span class="line">    at24c02_major&#x3D; register_chrdev(0, &quot;at24c02&quot;, &amp;at24c02_fops);  </span><br><span class="line">    at24c02_class&#x3D;class_create(THIS_MODULE, &quot;at24c02&quot;);   </span><br><span class="line">    class_device_create(at24c02_class,0, MKDEV(at24c02_major, 0),0,&quot;at24c02&quot;);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*5. 写init入口函数,exit出口函数*&#x2F;</span><br><span class="line">static int at24c02_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_add_driver(&amp;at24c02_driver);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void at24c02_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;at24c02_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(at24c02_init);</span><br><span class="line">module_exit(at24c02_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>11.测试运行</strong></p>
<p>如下图所示:</p>
<p> <img src="https://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194801809-125890547.png" alt="img"></p>
<hr>
<p><strong>版权声明：本文为博主原创文章，转载请标注文章来源,码字很辛苦,若觉得文章不错,不妨点个赞~</strong></p>
<p><strong>标注出处在于:珍惜他人的码字成果,并且文章有更新或者修改出错的地方,也能方便他人查找到</strong></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>i2c总线驱动</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux内核宏DEVICE_ATTR使用</title>
    <url>/2021/01/25/Linux/Driver/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E5%86%85%E6%A0%B8%E5%AE%8FDEVICE_ATTR%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.cnblogs.com/Cqlismy/p/11454573.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Cqlismy/p/11454573.html】</a></p>
<h1 id="Linux内核宏DEVICE-ATTR使用"><a href="#Linux内核宏DEVICE-ATTR使用" class="headerlink" title="Linux内核宏DEVICE_ATTR使用"></a><a href="https://www.cnblogs.com/Cqlismy/p/11454573.html" target="_blank" rel="noopener">Linux内核宏DEVICE_ATTR使用</a></h1><p>1、前言</p>
<p>在Linux驱动程序编写中，使用DEVICE_ATTR宏，可以定义一个struct device_attribute设备属性，并使用sysfs的API函数，便可以在设备目录下创建出属性文件，当我们在驱动程序中实现了show和store函数后，便可以使用cat和echo命令对创建出来的设备属性文件进行读写，从而达到控制设备的功能。</p>
<p>2、宏DEVICE_ATTR定义</p>
<p>在讲解DEVICE_ATTR宏之前，先了解一些基本的结构体，首先是struct attribute结构体，其定义在include/linux/device.h中，结构体定义如下所示：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct attribute &#123;</span><br><span class="line">    const char        *name;</span><br><span class="line">    umode_t            mode;</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">    bool            ignore_lockdep:1;</span><br><span class="line">    struct lock_class_key    *key;</span><br><span class="line">    struct lock_class_key    skey;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>该结构体有两个重要的成员，分别是name和mode，其中name代表属性的名称，一般表示为文件名，mode代表该属性的读写权限，也就是属性文件的读写权限。</p>
<p>关于文件的权限详解，可以参考下面的链接：</p>
<p><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8658475" target="_blank" rel="noopener">https://blog.csdn.net/DLUTBruceZhang/article/details/8658475</a></p>
<p>接下来要了解的结构体为struct device_attribute，该结构体的定义在include /linux/device.h，其定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* interface for exporting device attributes *&#x2F;</span><br><span class="line">struct device_attribute &#123;</span><br><span class="line">    struct attribute    attr;</span><br><span class="line">    ssize_t (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            char *buf);</span><br><span class="line">    ssize_t (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             const char *buf, size_t count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>该结构体其实是struct attribute结构体的进一步封装，并提供了两个函数指针，show函数用于读取设备的属性文件，而store则是用于写设备的属性文件，当我们在Linux的驱动程序中实现了这两个函数后，便可以使用cat和echo命令对设备属性文件进行读写操作。</p>
<p>了解了一下基本的结构体，接下来，进一步分析宏DEVICE_ATTR的实现，在Linux内核源码中，宏DEVICE_ATTR的定义在include/linux/device.h文件中，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DEVICE_ATTR(_name, _mode, _show, _store) \</span><br><span class="line">    struct device_attribute dev_attr_##_name &#x3D; __ATTR(_name, _mode, _show, _store)</span><br></pre></td></tr></table></figure>

<p>而__ATTR宏的定义在include/linux/sysfs.h文件中，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __ATTR(_name, _mode, _show, _store) &#123;                \</span><br><span class="line">    .attr &#x3D; &#123;.name &#x3D; __stringify(_name),                \</span><br><span class="line">         .mode &#x3D; VERIFY_OCTAL_PERMISSIONS(_mode) &#125;,        \</span><br><span class="line">    .show    &#x3D; _show,                        \</span><br><span class="line">    .store    &#x3D; _store,                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的宏展开可以发现，其实宏DEVICE_ATTR实现的功能就是定义了一个struct device_attribute结构体变量dev_attr_name，并对里面的成员进行初始化，包括struct attribute结构体里面的name和mode成员变量，然后还有实现属性文件读写的show和store函数赋值，非常简单。</p>
<p>3、使用示例</p>
<p>接下来对宏DEVICE_ATTR使用示例进行分析，该示例在内核中将100个字节虚拟成一个设备，在驱动中实现设备属性文件的读写函数，示例如下：</p>
<p>首先是设备属性的定义，以及设备属性文件读写函数的实现：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ssize_t mydevice_show(struct device *dev, struct device_attribute *attr,</span><br><span class="line">        char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    return sprintf(buf, &quot;%s\n&quot;, mybuf);</span><br><span class="line">&#125;</span><br><span class="line">static ssize_t mydevice_store(struct device *dev, struct device_attribute *attr,</span><br><span class="line">         const char *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    sprintf(mybuf, &quot;%s&quot;, buf);</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">static DEVICE_ATTR(mydevice, 0644, mydevice_show, mydevice_store);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在上面的代码中，使用宏DEVICE_ATTR定义了一个mydevice的属性文件，而且这个属性文件的读写权限为：文件所拥有者可读写，组和其他人只能读。代码还实现了该属性文件的读写函数mydevice_show()和mydevice_store()，当在用户空间中使用cat和echo命令时，将会调用到驱动程序中实现的两个函数。</p>
<p>接下来是模块的加载函数，当模块加载时将会被调用，该函数的实现代码如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init mydevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device *mydevice;</span><br><span class="line">    </span><br><span class="line">    major &#x3D; register_chrdev(0, &quot;mydevice&quot;, &amp;myfops);</span><br><span class="line">    if (major &lt; 0) &#123;</span><br><span class="line">        ret &#x3D; major;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myclass &#x3D; class_create(THIS_MODULE, &quot;myclass&quot;);</span><br><span class="line">    if (IS_ERR(myclass)) &#123;</span><br><span class="line">        ret &#x3D; -EBUSY;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mydevice &#x3D; device_create(myclass, NULL, MKDEV(major, 0), NULL, &quot;mydevice&quot;);</span><br><span class="line">    if (IS_ERR(mydevice)) &#123;</span><br><span class="line">        class_destroy(myclass);</span><br><span class="line">        ret &#x3D; -EBUSY;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; sysfs_create_file(&amp;mydevice-&gt;kobj, &amp;dev_attr_mydevice.attr);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    unregister_chrdev(major, &quot;mydevice&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>函数首先调用register_chrdev()完成一个主设备号的动态申请，设备的名称为mydevice，然后调用class_create()和device_create()在sysfs中动态创建出设备所属的类myclass和mydevice设备，需要注意的是，这两个函数调用后，要对返回的结果进行错误检测，最后，使用sysfs的API函数sysfs_create_file()在sysfs中创建出设备的属性文件，完成驱动模块的加载。</p>
<p>接下来是该模块的卸载函数，函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __exit mydevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(myclass, MKDEV(major, 0));</span><br><span class="line">    class_destroy(myclass);</span><br><span class="line">    unregister_chrdev(major, &quot;mydevice&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块的卸载函数与模块的加载函数是相对的操作，需要调用device_destory()和class_destory()对模块加载创建的myclass和mydevice进行销毁，然后调用unregister_chrdev()将动态分配的主设备号进行释放。</p>
<p>驱动程序完整代码如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sysfs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;string.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;device.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line"></span><br><span class="line">static char mybuf[100] &#x3D; &quot;mydevice&quot;;</span><br><span class="line">static int major;</span><br><span class="line">static struct class *myclass;</span><br><span class="line"></span><br><span class="line">static ssize_t mydevice_show(struct device *dev, struct device_attribute *attr,</span><br><span class="line">        char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    return sprintf(buf, &quot;%s\n&quot;, mybuf);</span><br><span class="line">&#125;</span><br><span class="line">static ssize_t mydevice_store(struct device *dev, struct device_attribute *attr,</span><br><span class="line">         const char *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    sprintf(mybuf, &quot;%s&quot;, buf);</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">static DEVICE_ATTR(mydevice, 0644, mydevice_show, mydevice_store);</span><br><span class="line"></span><br><span class="line">static struct file_operations myfops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init mydevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device *mydevice;</span><br><span class="line">    </span><br><span class="line">    major &#x3D; register_chrdev(0, &quot;mydevice&quot;, &amp;myfops);</span><br><span class="line">    if (major &lt; 0) &#123;</span><br><span class="line">        ret &#x3D; major;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myclass &#x3D; class_create(THIS_MODULE, &quot;myclass&quot;);</span><br><span class="line">    if (IS_ERR(myclass)) &#123;</span><br><span class="line">        ret &#x3D; -EBUSY;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mydevice &#x3D; device_create(myclass, NULL, MKDEV(major, 0), NULL, &quot;mydevice&quot;);</span><br><span class="line">    if (IS_ERR(mydevice)) &#123;</span><br><span class="line">        class_destroy(myclass);</span><br><span class="line">        ret &#x3D; -EBUSY;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; sysfs_create_file(&amp;mydevice-&gt;kobj, &amp;dev_attr_mydevice.attr);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    unregister_chrdev(major, &quot;mydevice&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mydevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(myclass, MKDEV(major, 0));</span><br><span class="line">    class_destroy(myclass);</span><br><span class="line">    unregister_chrdev(major, &quot;mydevice&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mydevice_init);</span><br><span class="line">module_exit(mydevice_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(&quot;A simplest driver&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL v2&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;HLY&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>4、测试结果</p>
<p>将驱动程序进行编译后，将驱动模块进行加载，并查看创建出来的属性文件，使用cat和echo命令进行读写测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># make</span><br><span class="line"># insmod simple-device.ko</span><br><span class="line"># cd &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;myclass&#x2F;mydevice&#x2F;</span><br><span class="line"># ls –al .&#x2F;</span><br></pre></td></tr></table></figure>

<p>结果如下所示，可以看到创建出来的属性文件mydevice：</p>
<p><img src="https://img2018.cnblogs.com/blog/1625033/201909/1625033-20190903181940815-665372849.png" alt="img"></p>
<p>使用cat和echo命令进行文件读写测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat mydevice</span><br><span class="line"># echo &quot;I am a simplest driver.&quot; &gt; mydevice</span><br><span class="line"># cat mydevice</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示，可以看到，能使用cat和echo命令正常完成属性文件的读写了：</p>
<p><img src="https://img2018.cnblogs.com/blog/1625033/201909/1625033-20190903181954484-1525330698.png" alt="img"></p>
<p>5、小节</p>
<p>本文简单介绍了Linux内核中DEVICE_ATTR宏的实现，并使用一个简单的驱动程序示例来介绍了如何在Linux驱动程序中使用DEVICE_ATTR宏以及实现属性文件的读写函数。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/hpu11/article/details/83113729" target="_blank" rel="noopener">https://blog.csdn.net/hpu11/article/details/83113729</a></p>
<p><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8658475" target="_blank" rel="noopener">https://blog.csdn.net/DLUTBruceZhang/article/details/8658475</a></p>
<p>《LINUX设备驱动程序（第三版）》</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>设备驱动模型</category>
      </categories>
      <tags>
        <tag>bus</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux驱动模型(bus/driver/device)实训</title>
    <url>/2021/01/18/Linux/Driver/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%AE%AD/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【<a href="https://www.codenong.com/cs106274171/】" target="_blank" rel="noopener">https://www.codenong.com/cs106274171/】</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux内核为驱动开发设计了驱动模型，使总线bus、设备device和驱动driver分别抽象成统一的结构体对象，并且提供了设备与驱动在总线上配对的方法。</p>
<p>在Linux中bus、device、driver的对应结构体对象分别是bus_type、device、device_driver。</p>
<p>通过复写bus_type对象中的match方法，可以定义driver与device之间配对的方法，配对成功后driver中的probe函数就会去做设备device的初始化工作。包括注册设备、挂载设备节点、操作设备资源与方法等。</p>
<h2 id="任务一、创建bus、device、driver模块，体会三者之间的关联逻辑关系"><a href="#任务一、创建bus、device、driver模块，体会三者之间的关联逻辑关系" class="headerlink" title="任务一、创建bus、device、driver模块，体会三者之间的关联逻辑关系"></a>任务一、创建bus、device、driver模块，体会三者之间的关联逻辑关系</h2><p><strong>总线模块：　my_bus.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line">&#x2F;&#x2F;注册挂载到总线上的驱动与设备对象之间的匹配方法</span><br><span class="line">int my_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;In %s \n&quot;, __func__);</span><br><span class="line">    &#x2F;&#x2F;按照名字相同的方式匹配</span><br><span class="line">    return (strcmp(dev_name(dev), drv-&gt;name) &#x3D;&#x3D; 0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化总线对象</span><br><span class="line">static struct bus_type my_bus &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;my_bus&quot;,</span><br><span class="line">    .match &#x3D; my_match,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;将总线对象导出供内核其他模块中的设备对象和驱动对象引用</span><br><span class="line">EXPORT_SYMBOL(my_bus);</span><br><span class="line">static int init_my_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;Hello bus module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;在内核中注册总线</span><br><span class="line">    ret &#x3D; bus_register(&amp;my_bus);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;bus_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;清理并卸载内核模块,注意清理顺序是倒序的，因为各结构体之间有依赖关系</span><br><span class="line">static void cleanup_my_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">    bus_unregister(&amp;my_bus);</span><br><span class="line">    printk(KERN_INFO &quot;Bye module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_my_bus);</span><br><span class="line">module_exit(cleanup_my_bus);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>设备模块：my_device.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设备的清理方法，一般要求要写，即使什么也不做</span><br><span class="line">static void my_release(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;从内核中导入我们需要的总线对象</span><br><span class="line">extern struct bus_type my_bus;</span><br><span class="line">&#x2F;&#x2F;初始化设备对象，声明名字、总线对象与清理方法</span><br><span class="line">static struct device my_dev &#x3D; &#123;</span><br><span class="line">    .init_name &#x3D; &quot;jit_dev&quot;,</span><br><span class="line">    .bus &#x3D; &amp;my_bus,</span><br><span class="line">    .release &#x3D; my_release,</span><br><span class="line">&#125;;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello device module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册设备</span><br><span class="line">    ret &#x3D; device_register(&amp;my_dev);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;dev_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    device_unregister(&amp;my_dev);</span><br><span class="line">    printk(KERN_INFO &quot;Bye device module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>驱动模块: my_driver.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从内核中导入我们需要的总线对象</span><br><span class="line">extern struct bus_type my_bus;</span><br><span class="line">&#x2F;&#x2F;总线匹配成功驱动与设备后，会启动驱动的初始化函数,probe(也称探测函数)</span><br><span class="line">static int my_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int my_remove(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化驱动对象，声明名字、总线对象、探测函数方法与卸载方法</span><br><span class="line">static struct device_driver my_drv &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;jit_dev&quot;,</span><br><span class="line">    .bus &#x3D; &amp;my_bus,</span><br><span class="line">    .probe &#x3D; my_probe,</span><br><span class="line">    .remove &#x3D; my_remove,</span><br><span class="line">&#125;;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello driver module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;在内核中注册驱动</span><br><span class="line">    ret &#x3D; driver_register(&amp;my_drv);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;drv_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    driver_unregister(&amp;my_drv);</span><br><span class="line">    printk(KERN_INFO &quot;Bye driver module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p>测试：我们的模块加载顺序一定要是先加载总线，因为驱动与设备依赖于总线模块。这里写了一个不推荐的偷懒Makefile脚本。</p>
<p><strong>Makefile</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m +&#x3D; my_bus.o</span><br><span class="line">obj-m +&#x3D; my_driver.o</span><br><span class="line">obj-m +&#x3D; my_device.o</span><br><span class="line">all:</span><br><span class="line">    make -C &#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;build M&#x3D;$(PWD) modules</span><br><span class="line">    sudo insmod my_bus.ko</span><br><span class="line">    sudo insmod my_driver.ko</span><br><span class="line">    sudo insmod my_device.ko</span><br><span class="line">clean:</span><br><span class="line">    make -C &#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;build M&#x3D;$(PWD) clean</span><br><span class="line">    sudo rmmod my_device</span><br><span class="line">    sudo rmmod my_driver</span><br><span class="line">    sudo rmmod my_bus</span><br></pre></td></tr></table></figure>

<p><strong>结果截图</strong></p>
<p><img src="http://jiali.clouddn.com/20210118_001.png" alt=""></p>
<p>可以看到加载总线、驱动、设备模块后，总线会使用match方法匹配驱动与设备是否配对，因为我们在编写驱动与设备对象时名字都是相同的，所以总线match匹配成功，驱动调用了它的探测函数probe。说明测试成功。</p>
<p>这个例子，让我们体会到了linux内核框架下bus、driver与device之间的逻辑依赖与操作关系。但是这只是一个空架子，因为我们没有创建任何一个设备文件，也没有提供任何的设备操作方法。设备中也没有提供任何资源。</p>
<h2 id="任务二、在device、device-driver的基础上封装一套自定义的设备与驱动，并且在总线模块中编写它们的注册与卸载方法，并且在match中定义它们的配对方法是通过额外封装的id与数组表查表的配对方式。"><a href="#任务二、在device、device-driver的基础上封装一套自定义的设备与驱动，并且在总线模块中编写它们的注册与卸载方法，并且在match中定义它们的配对方法是通过额外封装的id与数组表查表的配对方式。" class="headerlink" title="任务二、在device、device_driver的基础上封装一套自定义的设备与驱动，并且在总线模块中编写它们的注册与卸载方法，并且在match中定义它们的配对方法是通过额外封装的id与数组表查表的配对方式。"></a>任务二、在device、device_driver的基础上封装一套自定义的设备与驱动，并且在总线模块中编写它们的注册与卸载方法，并且在match中定义它们的配对方法是通过额外封装的id与数组表查表的配对方式。</h2><p><strong>自定义advanced_device、advanced_driver，注册注销方法的头文件:advanced_device.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _ADVANCED_DEVICE_H_</span><br><span class="line">#define _ADVANCED_DEVICE_H_</span><br><span class="line"></span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line"></span><br><span class="line">#define PROBTBSIZE 5</span><br><span class="line">struct advanced_device &#123;</span><br><span class="line">    int id;</span><br><span class="line">    struct device dev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern int advanced_device_register(struct advanced_device *);</span><br><span class="line">extern void advanced_device_unregister(struct advanced_device *);</span><br><span class="line"></span><br><span class="line">struct advanced_driver &#123;</span><br><span class="line">    struct device_driver driver;</span><br><span class="line">    int prob_tb[PROBTBSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern int advanced_driver_register(struct advanced_driver *);</span><br><span class="line">extern void advanced_driver_unregister(struct advanced_driver *);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>总线模块:my_bus.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line"></span><br><span class="line">#include&quot;advanced_device.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册挂载到总线上的驱动与设备对象之间的匹配方法</span><br><span class="line">int my_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">    struct advanced_device *adev;</span><br><span class="line">    struct advanced_driver *adrv;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    printk(&quot;In %s \n&quot;, __func__);</span><br><span class="line">    &#x2F;&#x2F;获得自定义的设备与驱动对象</span><br><span class="line">    adev &#x3D; container_of(dev, struct advanced_device, dev);</span><br><span class="line">    adrv &#x3D; container_of(drv, struct advanced_driver, driver);</span><br><span class="line">    &#x2F;&#x2F;在驱动中查表,id存在则匹配</span><br><span class="line">    for (i &#x3D; 0; i &lt; PROBTBSIZE; i ++) &#123;</span><br><span class="line">        if(adev-&gt;id &#x3D;&#x3D; adrv-&gt;prob_tb[i])</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化总线对象</span><br><span class="line">static struct bus_type my_bus &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;my_bus&quot;,</span><br><span class="line">    .match &#x3D; my_match,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(my_bus);</span><br><span class="line">&#x2F;&#x2F;自定义advanced_device设备的注册方法，注册时指明了总线</span><br><span class="line">int advanced_device_register(struct advanced_device *adev)</span><br><span class="line">&#123;</span><br><span class="line">    adev-&gt;dev.bus &#x3D; &amp;my_bus;</span><br><span class="line">    device_initialize(&amp;adev-&gt;dev);</span><br><span class="line">    return device_add(&amp;adev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(advanced_device_register);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义advanced_device设备的销毁方法</span><br><span class="line">void advanced_device_unregister(struct advanced_device *adev)</span><br><span class="line">&#123;</span><br><span class="line">    device_del(&amp;adev-&gt;dev);</span><br><span class="line">    put_device(&amp;adev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(advanced_device_unregister);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义advanced_driver驱动的注册方法，注册时指明了总线</span><br><span class="line">int advanced_driver_register(struct advanced_driver *adrv)</span><br><span class="line">&#123;</span><br><span class="line">    adrv-&gt;driver.bus &#x3D; &amp;my_bus;</span><br><span class="line">    return driver_register(&amp;adrv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(advanced_driver_register);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义advanced_driver驱动的销毁方法</span><br><span class="line">void advanced_driver_unregister(struct advanced_driver *adrv)</span><br><span class="line">&#123;</span><br><span class="line">    driver_unregister(&amp;adrv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(advanced_driver_unregister);</span><br><span class="line"></span><br><span class="line">static int init_my_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;Hello bus module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;在内核中注册总线</span><br><span class="line">    ret &#x3D; bus_register(&amp;my_bus);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;bus_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_my_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">    bus_unregister(&amp;my_bus);</span><br><span class="line">    printk(KERN_INFO &quot;Bye module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_my_bus);</span><br><span class="line">module_exit(cleanup_my_bus);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p>总线模块中利用container_of宏与传入的device对象可以获得包括这个device对象的自定义封装的advanced_device，从而可以获得advanced_device中的设备号id，获得advanced_driver驱动对象中的设备号表也是同理。这样就可以改写probe来达到我们查表配对的需求。</p>
<p>总线模块中还提供了封装对象与驱动的注册和销毁方法，都通过EXPORT_SYMBOL宏导出供其他模块使用。并且由于是该总线模块提供的方法，所以在注册驱动与设备时的总线都自动指明为当前总线对象。</p>
<p><strong>advanced_driver驱动模块:my_driver.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line">#include &quot;advanced_device.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从内核中导入我们需要的总线对象</span><br><span class="line">extern struct bus_type my_bus;</span><br><span class="line">&#x2F;&#x2F;总线匹配成功驱动与设备后，会启动驱动的初始化函数,probe(也称探测函数)</span><br><span class="line">static int my_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int my_remove(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化自定义的驱动对象，声明支持的设备号表、名字、探测函数方法与卸载方法,会在注册时指定总线</span><br><span class="line">static struct advanced_driver my_drv &#x3D; &#123;</span><br><span class="line">    .prob_tb &#x3D; &#123;1, 2, 3, 4 ,5&#125;,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;jit_dev&quot;,</span><br><span class="line">        .probe &#x3D; my_probe,</span><br><span class="line">        .remove &#x3D; my_remove,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello driver module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;在内核中注册驱动</span><br><span class="line">    ret &#x3D; advanced_driver_register(&amp;my_drv);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;drv_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    advanced_driver_unregister(&amp;my_drv);</span><br><span class="line">    printk(KERN_INFO &quot;Bye driver module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>advanced_device设备模块:my_device.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line">#include&quot;advanced_device.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设备的清理方法，一般要求要写，即使什么也不做</span><br><span class="line">static void my_release(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化设备对象，设备id号、声明名字、清理方法，总线在注册时会自动指明</span><br><span class="line">static struct advanced_device my_dev &#x3D; &#123;</span><br><span class="line">    .id &#x3D; 1,</span><br><span class="line">    .dev &#x3D; &#123;</span><br><span class="line">        .init_name &#x3D; &quot;jit_dev&quot;,</span><br><span class="line">        .release &#x3D; my_release,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello device module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册自定义的设备，会自动指定总线</span><br><span class="line">    ret &#x3D; advanced_device_register(&amp;my_dev);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;dev_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    advanced_device_unregister(&amp;my_dev);</span><br><span class="line">    printk(KERN_INFO &quot;Bye device module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>略</p>
<h2 id="任务三、在任务二的基础上在advanced-device中增加struct-resource资源属性，并且使得驱动可以获得这段资源"><a href="#任务三、在任务二的基础上在advanced-device中增加struct-resource资源属性，并且使得驱动可以获得这段资源" class="headerlink" title="任务三、在任务二的基础上在advanced_device中增加struct resource资源属性，并且使得驱动可以获得这段资源"></a>任务三、在任务二的基础上在advanced_device中增加struct resource资源属性，并且使得驱动可以获得这段资源</h2><p><strong>自定义advanced_device、advanced_driver，注册注销方法的头文件:advanced_device.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct advanced_device &#123;</span><br><span class="line">    int id;</span><br><span class="line">    struct device dev;</span><br><span class="line">    struct resource *resource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在任务二的基础上增加了resource。</p>
<p><strong>总线模块:my_bus.c与任务二相同，总线模块不参与资源操作</strong></p>
<p><strong>advanced_device设备模块:my_device.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int reg &#x3D; 666;</span><br><span class="line">&#x2F;&#x2F;初始化设备资源</span><br><span class="line">static struct resource my_resource[] &#x3D; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name &#x3D; &quot;设备寄存器地址&quot;,</span><br><span class="line">        .start &#x3D; &amp;reg,</span><br><span class="line">        .end &#x3D; &amp;reg + 0x04,</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;初始化设备对象，设备id号、声明名字、清理方法，总线在注册时会自动指明</span><br><span class="line">static struct advanced_device my_dev &#x3D; &#123;</span><br><span class="line">    .id &#x3D; 1,</span><br><span class="line">    .resource &#x3D; my_resource,</span><br><span class="line">    .dev &#x3D; &#123;</span><br><span class="line">        .init_name &#x3D; &quot;jit_dev&quot;,</span><br><span class="line">        .release &#x3D; my_release,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新增了resource的初始化以及添加该成员到my_dev中。</p>
<p>resource的start属性一般都是指向资源的首地址，end是资源尾地址，flags是资源地址映射的方式。（关于资源resource）</p>
<p><strong>advanced_driver驱动模块:my_driver.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;总线匹配成功驱动与设备后，会启动驱动的初始化函数,probe(也称探测函数)</span><br><span class="line">static int my_probe(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct advanced_device *adev;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    adev &#x3D; container_of(dev, struct advanced_device, dev);</span><br><span class="line">    printk(KERN_INFO &quot;Resource name is %s, content is %x\n&quot;, adev-&gt;resource[0].name,</span><br><span class="line">     adev-&gt;resource[0].start);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>驱动模块改写了probe方法，在成功配对后，打印资源信息，表示可以获得资源。</p>
<p>验证：</p>
<p>略</p>
<h2 id="任务四、综合训练，使用platform-device、platform-driver、platform封装好的bus-type，来注册一个字符设备驱动，并且给字符设备驱动提供一些基本操作方法以及尝试给驱动传递resource信息"><a href="#任务四、综合训练，使用platform-device、platform-driver、platform封装好的bus-type，来注册一个字符设备驱动，并且给字符设备驱动提供一些基本操作方法以及尝试给驱动传递resource信息" class="headerlink" title="任务四、综合训练，使用platform_device、platform_driver、platform封装好的bus_type，来注册一个字符设备驱动，并且给字符设备驱动提供一些基本操作方法以及尝试给驱动传递resource信息"></a>任务四、综合训练，使用platform_device、platform_driver、platform封装好的bus_type，来注册一个字符设备驱动，并且给字符设备驱动提供一些基本操作方法以及尝试给驱动传递resource信息</h2><p>综合性训练，对于platform来说，内核已经封装好了platform的bus，这个bus的匹配方法是使用名字匹配。并且内核提供的platform_deivce_register和platform_driver_register也就是驱动与设备的注册方法在实现中已经为我们指定了bus总线，就像我的任务二、三所设计的那样。所以我们不需要编写bus模块，只需要写device和driver模块即可。</p>
<p><strong>设备模块: my_deivce.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化设备资源</span><br><span class="line">static struct resource my_resource[] &#x3D; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name &#x3D; &quot;设备寄存器地址&quot;,</span><br><span class="line">        .start &#x3D; 0x666666,</span><br><span class="line">        .end &#x3D; 0x888888,</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;初始化platform_device</span><br><span class="line">static struct platform_device pdev &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;zjc_dev1&quot;,</span><br><span class="line">        .resource &#x3D; my_resource,</span><br><span class="line">&#125;;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello device module!\n&quot;);</span><br><span class="line">        &#x2F;&#x2F;注册platform_device设备,会默认指明platform_bus_type,并且自动填充release函数</span><br><span class="line">        ret &#x3D; platform_device_register(&amp;pdev);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;pdev);</span><br><span class="line">    printk(KERN_INFO &quot;Bye device module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p>设备模块很简单，只是提供了资源以及注册了platform_device，加载到内核中等候platform bus上的同名platform_driver与之匹配即可。</p>
<p><strong>驱动模块:my_driver.c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;kernel.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;device.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;platform_device.h&gt;</span><br><span class="line">#include&lt;linux&#x2F;cdev.h&gt;</span><br><span class="line"></span><br><span class="line">#define HELLO_MAJOR 252</span><br><span class="line">static dev_t hello_devno;</span><br><span class="line">static struct cdev *hello_cdev;</span><br><span class="line">static struct class *cls;</span><br><span class="line">static struct device *my_dev;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化驱动对象，声明名字、总线对象、探测函数方法与卸载方法</span><br><span class="line">static struct platform_driver my_drv &#x3D; &#123;</span><br><span class="line">    .probe &#x3D; my_probe,</span><br><span class="line">    .remove &#x3D; my_remove,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;zjc_dev1&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int my_open(struct inode *pnode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;字符设备的文件操作集</span><br><span class="line">static struct file_operations hello_ops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open &#x3D; my_open,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;总线匹配成功驱动与设备后，会启动驱动的初始化函数,probe(也称探测函数)</span><br><span class="line">static int my_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    &#x2F;&#x2F;打印资源</span><br><span class="line">    printk(KERN_INFO &quot;Resource name is %s, start is 0x%x, end is 0x%x\n&quot;, dev-&gt;resource[0].name,</span><br><span class="line">            dev-&gt;resource[0].start, dev-&gt;resource[0].end);</span><br><span class="line">    int ret;</span><br><span class="line">    &#x2F;&#x2F;利用宏将主次设备号转化为32位的设备号，供注册函数使用</span><br><span class="line">    hello_devno &#x3D; MKDEV(HELLO_MAJOR, 0);</span><br><span class="line">    &#x2F;&#x2F;注册字符设备号</span><br><span class="line">    ret &#x3D; register_chrdev_region(hello_devno, 1, &quot;zjcchar&quot;);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        &#x2F;&#x2F;注册失败则由系统分配一个设备号</span><br><span class="line">        ret &#x3D; alloc_chrdev_region(&amp;hello_devno, 0, 1, &quot;zjcchar&quot;);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printk(KERN_ERR &quot;allocchr error!\n&quot;);</span><br><span class="line">            goto error0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;动态分配空间给cdev字符设备对象</span><br><span class="line">    hello_cdev &#x3D; cdev_alloc();</span><br><span class="line">    if (hello_cdev &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;alloc error!\n&quot;);</span><br><span class="line">        ret &#x3D; -1;</span><br><span class="line">        goto error1;   </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;初始化cdev字符设备对象并将操作集赋给它</span><br><span class="line">    cdev_init(hello_cdev, &amp;hello_ops);</span><br><span class="line">    &#x2F;&#x2F;将cdev字符设备对象注册到内核中</span><br><span class="line">    ret &#x3D; cdev_add(hello_cdev, hello_devno, 1);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;add error!\n&quot;);</span><br><span class="line">        goto error2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建class供创建设备节点时使用</span><br><span class="line">    cls &#x3D; class_create(THIS_MODULE, &quot;testclass&quot;);</span><br><span class="line">    if (IS_ERR(cls)) &#123;</span><br><span class="line">        ret &#x3D; PTR_ERR(dev);</span><br><span class="line">        printk(KERN_ERR &quot;class_create error!\n&quot;);</span><br><span class="line">        goto error2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建设备节点在&#x2F;dev&#x2F;下,名字为testdev</span><br><span class="line">    my_dev &#x3D; device_create(cls, NULL, hello_cdev-&gt;dev, NULL, &quot;testdev&quot;);</span><br><span class="line">    if (IS_ERR(my_dev)) &#123;</span><br><span class="line">        ret &#x3D; PTR_ERR(my_dev);</span><br><span class="line">        printk(KERN_ERR &quot;device_create error!\n&quot;);</span><br><span class="line">        goto error3;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_ERR &quot;Hello, World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">error3:</span><br><span class="line">    class_destroy(cls);</span><br><span class="line">error2:</span><br><span class="line">    cdev_del(hello_cdev);</span><br><span class="line">error1:</span><br><span class="line">    unregister_chrdev_region(hello_devno, 1);</span><br><span class="line">error0:</span><br><span class="line">    return ret;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除字符设备</span><br><span class="line">static int my_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(cls, hello_devno);</span><br><span class="line">    class_destroy(cls);</span><br><span class="line">    cdev_del(hello_cdev);</span><br><span class="line">    unregister_chrdev_region(hello_devno, 1);</span><br><span class="line">    printk(KERN_INFO &quot;In %s \n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int init_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    printk(KERN_INFO &quot;hello driver module!\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;在内核中注册驱动</span><br><span class="line">    ret &#x3D; platform_driver_register(&amp;my_drv);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;drv_register error!\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static void cleanup_hello(void)</span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_drv);</span><br><span class="line">    printk(KERN_INFO &quot;Bye driver module!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(init_hello);</span><br><span class="line">module_exit(cleanup_hello);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zjc&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A test project&quot;);</span><br></pre></td></tr></table></figure>

<p>重点在于platform_driver驱动初始化时的姓名与前面写的设备名字相同，这样才能在platform bus总线上被匹配。</p>
<p>匹配后会去执行platform_driver中的probe探测函数，可以看到探测函数主要是做了字符设备创建的工作：注册设备号、创建字符设备、创建设备节点等。字符设备提供了一个open操作，主要是打印信息证明来过。</p>
<p>验证：</p>
<p>略</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加载模块设备与驱动模块后，总线匹配成功，查看proc文件系统下设备号的创建、/dev/下设备节点的创建、sys文件系统下总线、设备、驱动的创建。</p>
<p><img src="http://jiali.clouddn.com/20210118_002.png" alt=""></p>
<p>卸载模块后，所有相关信息清空。测试成功</p>
<p><img src="http://jiali.clouddn.com/20210118_003.png" alt=""></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>设备驱动模型</category>
      </categories>
      <tags>
        <tag>bus</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】linux设备驱动程序--bus</title>
    <url>/2021/01/18/Linux/Driver/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F--bus/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文转自：【<a href="https://www.cnblogs.com/downey-blog/p/10507703.html】" target="_blank" rel="noopener">https://www.cnblogs.com/downey-blog/p/10507703.html】</a></p>
<h1 id="linux设备驱动程序–bus"><a href="#linux设备驱动程序–bus" class="headerlink" title="linux设备驱动程序–bus"></a><a href="https://www.cnblogs.com/downey-blog/p/10507703.html" target="_blank" rel="noopener">linux设备驱动程序–bus</a></h1><h2 id="linux-中bus驱动解析"><a href="#linux-中bus驱动解析" class="headerlink" title="linux 中bus驱动解析"></a>linux 中bus驱动解析</h2><p>总线(bus)是linux发展过程中抽象出来的一种设备模型，为了统一管理所有的设备，内核中每个设备都会被挂载在总线上，这个bus可以是对应硬件的bus(i2c bus、spi bus)、可以是虚拟bus(platform bus)。</p>
<h2 id="简述bus的工作流程"><a href="#简述bus的工作流程" class="headerlink" title="简述bus的工作流程"></a>简述bus的工作流程</h2><p>bus将所有挂在上面的具体设备抽象成两部分，driver和device。</p>
<p>driver实现了同类型设备的驱动程序实现，而device则向系统注册具体的设备需要的资源，每当添加一个新的driver(device)到bus中时，都将调用bus的match函数，试图寻找匹配的device(driver)。</p>
<p>总线大概是这样的：</p>
<p><img src="https://raw.githubusercontent.com/linux-downey/bloc_test/master/article/linux_driver/i2c_bus_driver/linux_bus_graph.png" alt="img"></p>
<p>如果匹配成功，就调用probe函数，在probe函数中实现设备的初始化、各种配置以及生成用户空间的文件接口。</p>
<p>举个例子，针对AT24CXX(一种常用的存储设备)这种同系列产品，他们的操作方式都是非常相似的，不同的无非是容量大小。</p>
<p>那么我们就没有必要为AT24C01、AT24C02去分别写一份驱动程序，而是统一为其写一份兼容所有AT24CXX的驱动程序，然后再传入不同的参数以对应具体的型号。</p>
<p>在linux驱动管理模型中的体现就是：驱动程序对应driver、需要的具体型号的硬件资源对应device，将其挂在bus上。</p>
<p>将driver注册到bus上，当用户需要使用AT24C01时，以AT24C01的参数构建一个对应device，注册到bus中，bus的match函数匹配上之后，调用probe函数，即可完成AT24C01的初始化，完成在用户空间的文件接口注册。</p>
<p>以此类推，添加所有的AT24CXX设备都可以以这样的形式实现，只需要构建一份device，而不用为每个设备重写一份驱动，提高了复用性，节省了内存空间。</p>
<h2 id="linux-bus结构体"><a href="#linux-bus结构体" class="headerlink" title="linux bus结构体"></a>linux bus结构体</h2><p>linux将设备挂在总线上，对应设备的注册和匹配流程由总线进行管理，在linux内核中，每一个bus，都由struct bus_type来描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bus_type &#123;</span><br><span class="line">    const char		*name;</span><br><span class="line">    const char		*dev_name;</span><br><span class="line">    struct device		*dev_root;</span><br><span class="line">    ...</span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    int (*probe)(struct device *dev);</span><br><span class="line">    int (*remove)(struct device *dev);</span><br><span class="line">    void (*shutdown)(struct device *dev);</span><br><span class="line">    struct subsys_private *p;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>};<br>为了突出重点，省去了一些暂时不需要深入了解的成员，我们来看看其中最主要的几个成员：</p>
<blockquote>
<p>name : 该bus的名字，这个名字是这个bus在sysfs文件系统中的体现，对应/sys/bus/$name.<br>dev_name : 这个dev_name并不对应bus的名称，而是对应bus所包含的struct device的名字，即对应dev_root。<br>dev_root：bus对应的device结构，每个设备都需要对应一个相应的struct device.<br>match:bus的device链表和driver链表进行匹配的实际执行回调函数，每当有device或者driver添加到bus中时，调用match函数，为device(driver)寻找匹配的driver(device)。<br>uevent:bus时间回调函数，当属于这个bus的设备发生添加、删除、修改等行为时，都将出发uvent事件。<br>probe:当device和driver经由match匹配成功时，将会调用总线的probe函数实现具体driver的初始化。事实上每个driver也会提供相应的probe函数，先调用总线的probe函数，在总线probe函数中调用driver的probe函数。<br>remove:移除挂载在设备上的driver，bus上的driver部分也会提供remove函数，在执行移除时，先调用driver的remove，然后再调用bus的remove以清除资源。<br>struct subsys_private *p：见下文</p>
</blockquote>
<h2 id="struct-subsys-private-p"><a href="#struct-subsys-private-p" class="headerlink" title="struct subsys_private *p"></a>struct subsys_private *p</h2><p>struct subsys_private *p主要实现了对bus中数据的管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct subsys_private &#123;</span><br><span class="line">    struct kset subsys;</span><br><span class="line">    struct kset *devices_kset;</span><br><span class="line"></span><br><span class="line">    struct kset *drivers_kset;</span><br><span class="line">    struct klist klist_devices;</span><br><span class="line">    struct klist klist_drivers;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中struct kset subsys、struct kset *devices_kset、struct kset *drivers_kset都是在sysfs文件系统中创建对应的目录。</p>
<p>struct klist klist_devices、struct klist klist_drivers是两个主要的数据部分，klist_devices是存储所有注册到bus的device的链表，而klist_drivers是存储所有注册到bus的driver的链表。</p>
<h2 id="bus的注册"><a href="#bus的注册" class="headerlink" title="bus的注册"></a>bus的注册</h2><p>了解了bus的结构，那么，bus是怎么注册的呢？</p>
<p>spi bus的注册过程在KERNEL/drivers/spi/spi.c中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init spi_init(void)</span><br><span class="line">&#123; </span><br><span class="line">    ...</span><br><span class="line">    status &#x3D; bus_register(&amp;spi_bus_type);</span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postcore_initcall(spi_init);</span><br></pre></td></tr></table></figure>

<p>i2c bus的注册过程在KERNEL/drivers/i2c/i2c-core-base.c中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init i2c_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    bus_register(&amp;i2c_bus_type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">postcore_initcall(i2c_init);</span><br></pre></td></tr></table></figure>

<p>而platform bus的注册过程在KERNEL/drivers/base/platform.c中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __init platform_bus_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    bus_register(&amp;platform_bus_type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c和spi为物理总线，这两种总线通过postcore_initcall()将各自的init函数注册到系统中，postcore_initcall的详解可以参考另一篇博客：<a href="https://www.cnblogs.com/downey-blog/p/10486653.html" target="_blank" rel="noopener">linux init机制</a>。</p>
<p>而platform作为虚拟总线，platform_bus_init被系统初始化时直接调用，调用流程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_kernel  </span><br><span class="line">-&gt; rest_init();</span><br><span class="line">    -&gt; kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">        -&gt; kernel_init()</span><br><span class="line">            -&gt; kernel_init_freeable();</span><br><span class="line">                -&gt; do_basic_setup();</span><br><span class="line">                    -&gt; driver_init();  </span><br><span class="line">                        -&gt;platform_bus_init();</span><br></pre></td></tr></table></figure>

<p>spi_bus_type、i2c_bus_type、platform_bus_type分别为对应的struct bus_type描述结构体。</p>
<p>对应的spi_bus_type、i2c_bus_type、platform_bus_type实现我将分别在spi、i2c、platform具体框架解析中介绍。</p>
<h2 id="bus-register"><a href="#bus-register" class="headerlink" title="bus_register()"></a>bus_register()</h2><p>可以看到，这三种总线都是由bus_register()接口注册的，那么这个接口到底做了什么呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bus_register(struct bus_type *bus)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line">    struct subsys_private *priv;</span><br><span class="line">    struct lock_class_key *key &#x3D; &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">    priv &#x3D; kzalloc(sizeof(struct subsys_private), GFP_KERNEL);</span><br><span class="line">    if (!priv)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    priv-&gt;bus &#x3D; bus;</span><br><span class="line">    bus-&gt;p &#x3D; priv;</span><br><span class="line"></span><br><span class="line">    BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">    retval &#x3D; kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    priv-&gt;subsys.kobj.kset &#x3D; bus_kset;</span><br><span class="line">    priv-&gt;subsys.kobj.ktype &#x3D; &amp;bus_ktype;</span><br><span class="line">    priv-&gt;drivers_autoprobe &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">    priv-&gt;devices_kset &#x3D; kset_create_and_add(&quot;devices&quot;, NULL,</span><br><span class="line">                        &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    if (!priv-&gt;devices_kset) &#123;</span><br><span class="line">        retval &#x3D; -ENOMEM;</span><br><span class="line">        goto bus_devices_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priv-&gt;drivers_kset &#x3D; kset_create_and_add(&quot;drivers&quot;, NULL,</span><br><span class="line">                        &amp;priv-&gt;subsys.kobj);</span><br><span class="line">    if (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">        retval &#x3D; -ENOMEM;</span><br><span class="line">        goto bus_drivers_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">    __mutex_init(&amp;priv-&gt;mutex, &quot;subsys mutex&quot;, key);</span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">    klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    retval &#x3D; add_probe_files(bus);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bus_groups_fail;</span><br><span class="line"></span><br><span class="line">    pr_debug(&quot;bus: &#39;%s&#39;: registered\n&quot;, bus-&gt;name);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面贴出的代码中，可以看出，bus_register()其实也没做什么特别的事，主要是两个：</p>
<ul>
<li>在sysfs系统中注册各种用户文件接口，将bus的信息和操作接口导出到用户接口。</li>
<li>初始化device和driver链表。</li>
</ul>
<h2 id="向总线中添加driver-device"><a href="#向总线中添加driver-device" class="headerlink" title="向总线中添加driver/device"></a>向总线中添加driver/device</h2><p>既然bus_register只是初始化了相应的资源，在/sys下导出接口文件，那整个bus是如何工作的呢？</p>
<p>以i2c为例，我们来看看这整个过程：</p>
<p>首先使用i2c_new_device接口来添加一个device：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct i2c_client *i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)</span><br><span class="line">&#123;</span><br><span class="line">    struct i2c_client	*client;</span><br><span class="line">    client &#x3D; kzalloc(sizeof *client, GFP_KERNEL);</span><br><span class="line">    client-&gt;adapter &#x3D; adap;</span><br><span class="line"></span><br><span class="line">    client-&gt;dev.platform_data &#x3D; info-&gt;platform_data;</span><br><span class="line">    if (info-&gt;archdata)</span><br><span class="line">        client-&gt;dev.archdata &#x3D; *info-&gt;archdata;</span><br><span class="line">    client-&gt;flags &#x3D; info-&gt;flags;</span><br><span class="line">    client-&gt;addr &#x3D; info-&gt;addr;</span><br><span class="line"></span><br><span class="line">    client-&gt;irq &#x3D; info-&gt;irq;</span><br><span class="line">    client-&gt;dev.parent &#x3D; &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">    client-&gt;dev.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line">    client-&gt;dev.type &#x3D; &amp;i2c_client_type;</span><br><span class="line">    client-&gt;dev.of_node &#x3D; info-&gt;of_node;</span><br><span class="line">    client-&gt;dev.fwnode &#x3D; info-&gt;fwnode;</span><br><span class="line">    ...</span><br><span class="line">    device_register(&amp;client-&gt;dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>申请一个i2c_client并对其赋值，然后以这个为参数调用device_register(&amp;client-&gt;dev)，将dangqiandevice添加到bus中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int device_register(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    return device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int device_add(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">     bus_add_device(dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">int bus_add_device(struct device *dev)&#123;</span><br><span class="line">    ...</span><br><span class="line">    klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">    ...</span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在device_register中，调用了device_add,紧接着调用bus_add_device，根据函数名称可以看出是将这个device添加到对应的bus中。</p>
<p>果然，根据bus_add_device()的源代码，可以看到，将当前device链接到其对应bus的devices链表，然后在下面调用bus_probe_device();这个函数的作用就是轮询对应bus的drivers链接，查看新添加的device是否存在匹配的driver。</p>
<p>对应的，i2c_driver_register()将i2c driver部分添加到bus中，再轮询检查bus的devices链表是否有对应的device能匹配上,有兴趣的可以从i2c_driver_register()开始研究源代码。</p>
<h2 id="device和driver的匹配"><a href="#device和driver的匹配" class="headerlink" title="device和driver的匹配"></a>device和driver的匹配</h2><p>上文中提到当bus中有新的device和driver添加时，会调用bus的match函数进行匹配，那么到底是怎么匹配的呢？</p>
<p>简单来说，在静态定义的device中，一般会有.name属性，与driver的.id_table属性相匹配。</p>
<p>device部分还有可能从设备树转换而来，就有设备树中相应的.compatible属性和driver的of_match_table.compatible属性相匹配。</p>
<p>事实上对于匹配这一部分，可以直接参考每个bus的match函数实现。</p>
<p>这一章节只是对linux中的总线做一个概念性的说明，在之后的博客中会详细介绍到相应bus的框架，同时也会详解对应的match()函数实现。</p>
<p>敬请期待！</p>
<p>好了，关于linux的bus讨论就到此为止啦，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言</p>
<p><strong><em>原创博客，转载请注明出处！</em></strong></p>
<p>祝各位早日实现项目丛中过，bug不沾身.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>设备驱动模型</category>
      </categories>
      <tags>
        <tag>bus</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】输入子系统</title>
    <url>/2021/01/07/Linux/Driver/Input/%E8%BD%AC%E8%BD%BD/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文转自：博客园–<a href="https://home.cnblogs.com/u/Lioker/" target="_blank" rel="noopener">Lioker</a>【<a href="https://www.cnblogs.com/Lioker/p/10871151.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/10871151.html】</a></p>
<p>前面几章我们写的按键驱动程序虽然已经足够完善，但是这个驱动只有知道/dev/key设备节点和write()格式的人才能使用，不具有适应性</p>
<p>故本节引入标准的输入子系统，来编写通用的输入类设备。输入子系统是对所有的标准输入类设备的统一的管理系统，使用这个模型可以跨平台的处理所有的输入类设备</p>
<h1 id="一、输入子系统分层"><a href="#一、输入子系统分层" class="headerlink" title="一、输入子系统分层"></a>一、输入子系统分层</h1><p>输入子系统将一个输入设备的输入过程分成了<strong>设备</strong>驱动（input device driver）和<strong>事件</strong>驱动（input event driver）两层。设备驱动负责从底层硬件采集数据，事件驱动负责给用户程序提供接口。通过分层设计，将不同的设备统一到几种驱动接口上。同一种事件驱动可以用来处理多个同类设备；同一个设备也可以和多种事件驱动相衔接。而事件驱动和设备驱动则由输入核心层进行连接，匹配。分层结构如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515135645745-1155511406.png" alt="img"></p>
<p>输入子系统核心层定义在drivers/input/input.c中</p>
<p>由于输入子系统也是字符设备驱动程序，因此它一定也会有创建类、注册字符设备的过程，而且会有file_operations等结构体，我们可以从此进行分析</p>
<h1 id="二、input-c分析"><a href="#二、input-c分析" class="headerlink" title="二、input.c分析"></a>二、input.c分析</h1><p>在input_init()函数中所做的和按键驱动程序中所做的大致相同，如创建类、注册名为input的字符设备</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    err &#x3D; class_register(&amp;input_class);</span><br><span class="line">    ...</span><br><span class="line">    err &#x3D; register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其file_operations结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct file_operations input_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open &#x3D; input_open_file,</span><br><span class="line">    .llseek &#x3D; noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>当我们应用程序open()时，会调用file_operations input_fops对应的open()函数</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int input_open_file(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">    handler &#x3D; input_table[iminor(inode) &gt;&gt; 5];</span><br><span class="line">    if (handler)</span><br><span class="line">        new_fops &#x3D; fops_get(handler-&gt;fops);</span><br><span class="line">        ...</span><br><span class="line">    old_fops &#x3D; file-&gt;f_op;</span><br><span class="line">    file-&gt;f_op &#x3D; new_fops;</span><br><span class="line"></span><br><span class="line">    err &#x3D; new_fops-&gt;open(inode, file);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>由上述代码可知：</p>
<p>\1. input_table[]根据次设备号存储handler</p>
<p>\2. <strong>open()函数使用新的fops（设备驱动中的fops）代替了旧的fops，这个操作也就解释了为什么file_operations结构体中没有读写函数</strong></p>
<p>\3. open()函数在替换之后，调用了新的fops的open()函数</p>
<p>handler是我们之前没有分析的，它定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct input_handler *input_table[8];</span><br></pre></td></tr></table></figure>

<p>至于数组大小为什么是8，这是因为目前常用的handler只有三种：<strong>evdev</strong>，mousedev，joydev。而且evdev是通用的handler，定义8个应该够用了</p>
<p>handler结构体定义为：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handler - implements one of interfaces for input devices</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handler &#123;</span><br><span class="line">    void *private;</span><br><span class="line"></span><br><span class="line">    void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">    bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);</span><br><span class="line">    bool (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);</span><br><span class="line">    void (*disconnect)(struct input_handle *handle);</span><br><span class="line">    void (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    const struct file_operations *fops;</span><br><span class="line">    int minor;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    const struct input_device_id *id_table;</span><br><span class="line"></span><br><span class="line">    struct list_head    h_list;</span><br><span class="line">    struct list_head    node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>根据注释信息，handler应该就是输入事件驱动程序的结构体</p>
<p>在input_handler结构体中使用了input_handle结构体，其定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct input_handle - links input device with an input handler</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct input_handle &#123;</span><br><span class="line">    void *private;</span><br><span class="line"></span><br><span class="line">    int open;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    struct input_dev *dev;</span><br><span class="line">    struct input_handler *handler;</span><br><span class="line"></span><br><span class="line">    struct list_head    d_node;</span><br><span class="line">    struct list_head    h_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>根据注释信息，<strong>input_handle用于连接input_dev和input_handler</strong>，三者关系在下面分析</p>
<p>分析完了input.c文件，我们来一一分析input_handler、input_handle以及两者的连接过程</p>
<h1 id="三、input-dev"><a href="#三、input-dev" class="headerlink" title="三、input_dev"></a>三、input_dev</h1><p>input_dev使用方法遵循：分配、设置、注册</p>
<p><strong>分配：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void)</span><br></pre></td></tr></table></figure>



<p><strong>设置（首先设置事件类，然后设置具体事件）：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)</span><br><span class="line">&#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">    case EV_KEY:    &#x2F;&#x2F; 按键事件类，可指定按键如KEY_1、KEY_Q、KEY_ENTER等</span><br><span class="line">        __set_bit(code, dev-&gt;keybit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case EV_REL:    &#x2F;&#x2F; 相对位移事件类，可指定相对位移如REL_X、REL_Y等</span><br><span class="line">        __set_bit(code, dev-&gt;relbit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case EV_ABS:    &#x2F;&#x2F; 绝对位移事件类，可指定绝对位移如ABS_X、ABS_Y等</span><br><span class="line">        __set_bit(code, dev-&gt;absbit);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __set_bit(type, dev-&gt;evbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>也可以使用set_bit()函数，两函数代码类似（实际只是去设置某一个bit），在此仅给出__set_bit()函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static inline void __set_bit(int nr, volatile unsigned long *addr) &#123;</span><br><span class="line">2     unsigned long mask &#x3D; BIT_MASK(nr);</span><br><span class="line">3     unsigned long *p &#x3D; ((unsigned long *)addr) + BIT_WORD(nr);</span><br><span class="line">4 </span><br><span class="line">5     *p  |&#x3D; mask;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<p>源代码中使用set_bit()</p>
<p><strong>注册：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 通用的同步事件 *&#x2F;</span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    &#x2F;* 注册的设备名字为input0, 1, 2, ... *&#x2F;</span><br><span class="line">    dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,</span><br><span class="line">             (unsigned long) atomic_inc_return(&amp;input_no) - 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 添加device *&#x2F;</span><br><span class="line">    error &#x3D; device_add(&amp;dev-&gt;dev);</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 把dev结构放到链表里面 *&#x2F;</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 对每一个input_handler都调用input_attach_handler()函数 *&#x2F;</span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        &#x2F;* 匹配dev和handler *&#x2F;</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中的input_attach_handler(dev, handler);对应input_handle，因为之前说过<strong>input_handle用于连接input_dev和input_handler</strong></p>
<p>在注册完成后，若<strong>input_dev获得数据，需要向核心层上报事件</strong>，上报事件使用如下函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上报事件</span><br><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报绝对坐标</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报相对坐标</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报键值</span><br><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上报同步事件</span><br><span class="line">void input_sync(struct input_dev *dev)</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>代码中后四个函数均使用input_event()函数实现，input_event()函数调用过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_event()</span><br><span class="line">  -&gt; input_handle_event()</span><br><span class="line">    -&gt; input_pass_event()</span><br><span class="line">      -&gt; handler-&gt;event(handle, type, code, value);</span><br></pre></td></tr></table></figure>



<p><strong>上报事件最终会调用handler-&gt;event()函数</strong></p>
<p>之前说过evdev是通用的handler，在此我便以/drivers/input/evdev.c进行分析</p>
<p>evdev_read()会进行休眠，<strong>evdev_event()在上报事件被调用后会唤醒休眠进程</strong>，从而完成read()操作</p>
<p><strong>注销：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注销</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br></pre></td></tr></table></figure>





<h1 id="四、input-handler"><a href="#四、input-handler" class="headerlink" title="四、input_handler"></a>四、input_handler</h1><p><strong>注册：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int input_register_handler(struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 设置input_table *&#x2F;</span><br><span class="line">    if (handler-&gt;fops !&#x3D; NULL) &#123;</span><br><span class="line">        if (input_table[handler-&gt;minor &gt;&gt; 5]) &#123;</span><br><span class="line">            retval &#x3D; -EBUSY;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        input_table[handler-&gt;minor &gt;&gt; 5] &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 把handler放入input_handler_list *&#x2F;</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 对每一个dev调用input_attach_handler匹配handler *&#x2F;</span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>注销：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void input_unregister_handler(struct input_handler *handler)</span><br></pre></td></tr></table></figure>





<h1 id="五、input-dev和input-handler的连接过程"><a href="#五、input-dev和input-handler的连接过程" class="headerlink" title="五、input_dev和input_handler的连接过程"></a>五、input_dev和input_handler的连接过程</h1><p>两者匹配使用的是input_attach_handler()函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    id &#x3D; input_match_device(handler, dev);</span><br><span class="line">...</span><br><span class="line">    error &#x3D; handler-&gt;connect(handler, dev, id);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_match_device()函数：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const struct input_device_id *input_match_device(struct input_handler *handler,</span><br><span class="line">                            struct input_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">    for (id &#x3D; handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 默认的匹配过程，使用handler-&gt;id_table和dev-&gt;id进行匹配</span><br><span class="line"></span><br><span class="line">        if (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在代码中，匹配成功退出调用handler的connect()函数，否则调用handler的match()函数</p>
<p>在此还是以evdev为例，其连接函数为evdev_connect()定义如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int evdev_connect(struct input_handler *handler, struct input_dev *dev,</span><br><span class="line">             const struct input_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 分配evdev *&#x2F;</span><br><span class="line">    evdev &#x3D; kzalloc(sizeof(struct evdev), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 设置handle *&#x2F;</span><br><span class="line">    evdev-&gt;handle.dev &#x3D; input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name &#x3D; dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler &#x3D; handler;</span><br><span class="line">    evdev-&gt;handle.private &#x3D; evdev;</span><br><span class="line">...</span><br><span class="line">    &#x2F;* 注册handle *&#x2F;</span><br><span class="line">    error &#x3D; input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line"></span><br><span class="line">    error &#x3D; evdev_install_chrdev(evdev);</span><br><span class="line">    error &#x3D; device_add(&amp;evdev-&gt;dev);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>input_dev、input_handler和input_handle三者关系如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515161307876-106298749.png" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p><strong>1. input_init()初始化输入子系统</strong></p>
<p>1.1 调用register_chrdev(13, “input”, &amp;input_fops);</p>
<p><strong>2. open()输入子系统文件：int input_open_file()</strong></p>
<p>2.1 替换替换file_oprations</p>
<p>2.2 执行new_fops-&gt;open()函数</p>
<p><strong>3. 注册input_handler：input_register_handler()</strong></p>
<p>3.1 添加handler到input_table[]数组</p>
<p>3.2 添加handler到input_handler_list链表</p>
<p>3.3 调用input_attach_handler()</p>
<p><strong>4. 注册input_dev：input_register_device()</strong></p>
<p>4.1 添加dev到input_dev链表</p>
<p>4.2 调用input_attach_handler()</p>
<p><strong>5. 匹配：input_attach_handler()</strong></p>
<p>5.1 匹配dev-&gt;id和handler-&gt;id_table</p>
<p>5.2 成功，调用input_handler-&gt;connect()</p>
<p><strong>6. 连接：input_handler-&gt;connect()</strong></p>
<p>6.1 创建input_handle，三者连接</p>
<p><strong>7. event发生（如按键中断），在中断函数中上报事件：input_event()</strong></p>
<p>7.1 调用input_handler-&gt;event()</p>
<h1 id="七、更改key-c为输入子系统"><a href="#七、更改key-c为输入子系统" class="headerlink" title="七、更改key.c为输入子系统"></a>七、更改key.c为输入子系统</h1><p>主要更改的函数有keys_init()和key_timer_func()：</p>
<p><strong>keys_init()：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int keys_init(void)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     &#x2F;* 1. 分配 *&#x2F;</span><br><span class="line"> 4     inputdev &#x3D; input_allocate_device();</span><br><span class="line"> 5 </span><br><span class="line"> 6     &#x2F;* 2. 设置 *&#x2F;</span><br><span class="line"> 7     &#x2F;* 2.1 设置事件类 *&#x2F;</span><br><span class="line"> 8     set_bit(EV_KEY, inputdev-&gt;evbit);</span><br><span class="line"> 9     set_bit(EV_REP, inputdev-&gt;evbit);    &#x2F;* 重复类事件 *&#x2F;</span><br><span class="line">10 </span><br><span class="line">11     &#x2F;* 2.2 设置按键事件 *&#x2F;</span><br><span class="line">12     set_bit(KEY_L, inputdev-&gt;keybit);</span><br><span class="line">13     set_bit(KEY_S, inputdev-&gt;keybit);</span><br><span class="line">14     set_bit(KEY_ENTER, inputdev-&gt;keybit);</span><br><span class="line">15     set_bit(KEY_LEFTSHIFT, inputdev-&gt;keybit);</span><br><span class="line">16 </span><br><span class="line">17     &#x2F;* 3. 注册 *&#x2F;</span><br><span class="line">18     input_register_device(inputdev);</span><br><span class="line">19 ...</span><br><span class="line">20 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>set_bit(EV_REP, inputdev-&gt;evbit);表示可产生重复类事件</strong>，也就是长按按键，就会产生多次按键效果 </p>
<p><strong>key_timer_func()：</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static void key_timer_func(unsigned long arg)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3 ...</span><br><span class="line"> 4     if (pinval) &#x2F;* 松开 *&#x2F; &#123;</span><br><span class="line"> 5         &#x2F;* 上传数据 *&#x2F;</span><br><span class="line"> 6         input_event(inputdev, EV_KEY, pindesc-&gt;val, 0);</span><br><span class="line"> 7         input_sync(inputdev);</span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9     else &#x2F;* 按下 *&#x2F; &#123;</span><br><span class="line">10         input_event(inputdev, EV_KEY, pindesc-&gt;val, 1);</span><br><span class="line">11         input_sync(inputdev);</span><br><span class="line">12     &#125;</span><br><span class="line">13 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>input_sync(inputdev);表示已完成当前上报工作</strong></p>
<p>key源代码：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 #include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">  2 #include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">  3 #include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">  4 #include &lt;linux&#x2F;cdev.h&gt;</span><br><span class="line">  5 #include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">  6 #include &lt;linux&#x2F;device.h&gt;</span><br><span class="line">  7 #include &lt;linux&#x2F;irq.h&gt;</span><br><span class="line">  8 #include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">  9 #include &lt;linux&#x2F;wait.h&gt;</span><br><span class="line"> 10 #include &lt;linux&#x2F;timer.h&gt;</span><br><span class="line"> 11 #include &lt;linux&#x2F;gpio.h&gt;</span><br><span class="line"> 12 #include &lt;linux&#x2F;sched.h&gt;</span><br><span class="line"> 13 #include &lt;linux&#x2F;input.h&gt;</span><br><span class="line"> 14 </span><br><span class="line"> 15 #include &lt;asm&#x2F;uaccess.h&gt;</span><br><span class="line"> 16 #include &lt;asm&#x2F;irq.h&gt;</span><br><span class="line"> 17 #include &lt;asm&#x2F;io.h&gt;</span><br><span class="line"> 18 </span><br><span class="line"> 19 #include &lt;mach&#x2F;gpio.h&gt;</span><br><span class="line"> 20 </span><br><span class="line"> 21 #define KEY_MAJOR        255</span><br><span class="line"> 22 </span><br><span class="line"> 23 struct pin_desc &#123;</span><br><span class="line"> 24     unsigned int gpio;</span><br><span class="line"> 25     int val;</span><br><span class="line"> 26     char *name;</span><br><span class="line"> 27 &#125;;</span><br><span class="line"> 28 </span><br><span class="line"> 29 static struct timer_list    key_timer;</span><br><span class="line"> 30 static struct pin_desc*        pindesc;</span><br><span class="line"> 31 static struct input_dev*    inputdev;</span><br><span class="line"> 32 </span><br><span class="line"> 33 static struct pin_desc desc[4] &#x3D; &#123;</span><br><span class="line"> 34     &#123; EXYNOS4_GPX3(2), KEY_L, &quot;KEY0&quot; &#125;,</span><br><span class="line"> 35     &#123; EXYNOS4_GPX3(3), KEY_S, &quot;KEY1&quot; &#125;,</span><br><span class="line"> 36     &#123; EXYNOS4_GPX3(4), KEY_ENTER, &quot;KEY2&quot; &#125;,</span><br><span class="line"> 37     &#123; EXYNOS4_GPX3(5), KEY_LEFTSHIFT, &quot;KEY3&quot; &#125;,</span><br><span class="line"> 38 &#125;;</span><br><span class="line"> 39 </span><br><span class="line"> 40 static void key_timer_func(unsigned long arg)</span><br><span class="line"> 41 &#123;</span><br><span class="line"> 42     struct pin_desc *irq_pd &#x3D; pindesc;</span><br><span class="line"> 43 </span><br><span class="line"> 44     if (!irq_pd)</span><br><span class="line"> 45         return ;</span><br><span class="line"> 46     </span><br><span class="line"> 47     unsigned int pinval;</span><br><span class="line"> 48 </span><br><span class="line"> 49     pinval &#x3D; gpio_get_value(pindesc-&gt;gpio);</span><br><span class="line"> 50 </span><br><span class="line"> 51     if (pinval) &#x2F;* 松开 *&#x2F; &#123;</span><br><span class="line"> 52         &#x2F;* 上传数据 *&#x2F;</span><br><span class="line"> 53         input_event(inputdev, EV_KEY, pindesc-&gt;val, 0);</span><br><span class="line"> 54         input_sync(inputdev);</span><br><span class="line"> 55     &#125;</span><br><span class="line"> 56     else &#x2F;* 按下 *&#x2F; &#123;</span><br><span class="line"> 57         input_event(inputdev, EV_KEY, pindesc-&gt;val, 1);</span><br><span class="line"> 58         input_sync(inputdev);</span><br><span class="line"> 59     &#125;</span><br><span class="line"> 60 &#125;</span><br><span class="line"> 61 </span><br><span class="line"> 62 static irqreturn_t key_interrupt(int irq, void *dev_id)</span><br><span class="line"> 63 &#123;</span><br><span class="line"> 64     pindesc &#x3D; (struct pin_desc *)dev_id;</span><br><span class="line"> 65 </span><br><span class="line"> 66     mod_timer(&amp;key_timer, jiffies + HZ &#x2F; 100);</span><br><span class="line"> 67 </span><br><span class="line"> 68     return IRQ_HANDLED;</span><br><span class="line"> 69 &#125;</span><br><span class="line"> 70 </span><br><span class="line"> 71 static int keys_init(void)</span><br><span class="line"> 72 &#123;</span><br><span class="line"> 73     &#x2F;* 1. 分配 *&#x2F;</span><br><span class="line"> 74     inputdev &#x3D; input_allocate_device();</span><br><span class="line"> 75 </span><br><span class="line"> 76     &#x2F;* 2. 设置 *&#x2F;</span><br><span class="line"> 77     &#x2F;* 2.1 设置事件类 *&#x2F;</span><br><span class="line"> 78     set_bit(EV_KEY, inputdev-&gt;evbit);</span><br><span class="line"> 79     set_bit(EV_REP, inputdev-&gt;evbit);    &#x2F;* 重复类事件 *&#x2F;</span><br><span class="line"> 80 </span><br><span class="line"> 81     &#x2F;* 2.2 设置按键事件 *&#x2F;</span><br><span class="line"> 82     set_bit(KEY_L, inputdev-&gt;keybit);</span><br><span class="line"> 83     set_bit(KEY_S, inputdev-&gt;keybit);</span><br><span class="line"> 84     set_bit(KEY_ENTER, inputdev-&gt;keybit);</span><br><span class="line"> 85     set_bit(KEY_LEFTSHIFT, inputdev-&gt;keybit);</span><br><span class="line"> 86 </span><br><span class="line"> 87     &#x2F;* 3. 注册 *&#x2F;</span><br><span class="line"> 88     input_register_device(inputdev);</span><br><span class="line"> 89 </span><br><span class="line"> 90     &#x2F;* 注册中断 *&#x2F;</span><br><span class="line"> 91     int irq, i;</span><br><span class="line"> 92     for (i &#x3D; 0; i &lt; ARRAY_SIZE(desc); i++) &#123;</span><br><span class="line"> 93         irq &#x3D; gpio_to_irq(desc[i].gpio);</span><br><span class="line"> 94         request_irq(irq, key_interrupt, IRQ_TYPE_EDGE_BOTH, desc[i].name, (void *)&amp;desc[i]);</span><br><span class="line"> 95     &#125;</span><br><span class="line"> 96     </span><br><span class="line"> 97     init_timer(&amp;key_timer);</span><br><span class="line"> 98     key_timer.function &#x3D; key_timer_func;</span><br><span class="line"> 99     add_timer(&amp;key_timer);</span><br><span class="line">100 </span><br><span class="line">101     return 0;</span><br><span class="line">102 &#125;</span><br><span class="line">103 </span><br><span class="line">104 static void keys_exit(void)</span><br><span class="line">105 &#123;    </span><br><span class="line">106     &#x2F;&#x2F; 释放中断</span><br><span class="line">107     int irq, i;</span><br><span class="line">108 </span><br><span class="line">109     for (i &#x3D; 0; i &lt; ARRAY_SIZE(desc); i++) &#123;</span><br><span class="line">110         irq &#x3D; gpio_to_irq(desc[i].gpio);</span><br><span class="line">111         free_irq(irq, (void *)&amp;desc[i]);</span><br><span class="line">112     &#125;</span><br><span class="line">113 </span><br><span class="line">114     del_timer(&amp;key_timer);</span><br><span class="line">115 </span><br><span class="line">116     input_unregister_device(inputdev);</span><br><span class="line">117     input_free_device(inputdev);</span><br><span class="line">118 &#125;</span><br><span class="line">119 </span><br><span class="line">120 module_init(keys_init);</span><br><span class="line">121 module_exit(keys_exit);</span><br><span class="line">122 </span><br><span class="line">123 MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Makefile：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 KERN_DIR &#x3D; &#x2F;work&#x2F;tiny4412&#x2F;tools&#x2F;linux-3.5</span><br><span class="line"> 2 </span><br><span class="line"> 3 all:</span><br><span class="line"> 4     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules </span><br><span class="line"> 5 </span><br><span class="line"> 6 clean:</span><br><span class="line"> 7     make -C $(KERN_DIR) M&#x3D;&#96;pwd&#96; modules clean</span><br><span class="line"> 8     rm -rf modules.order</span><br><span class="line"> 9 </span><br><span class="line">10 obj-m    +&#x3D; key.o</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>测试文件：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 #include &lt;stdio.h&gt;</span><br><span class="line"> 2 #include &lt;unistd.h&gt;</span><br><span class="line"> 3 #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"> 4 #include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"> 5 #include &lt;fcntl.h&gt;</span><br><span class="line"> 6 #include &lt;string.h&gt;</span><br><span class="line"> 7 </span><br><span class="line"> 8 int main(int argc, char** argv)</span><br><span class="line"> 9 &#123;</span><br><span class="line">10     if (argc !&#x3D; 2) &#123;</span><br><span class="line">11         printf(&quot;Usage:\n&quot;);</span><br><span class="line">12         printf(&quot;%s &lt;event1|event2&gt;\n&quot;, argv[0]);</span><br><span class="line">13         return 0;</span><br><span class="line">14     &#125;</span><br><span class="line">15     </span><br><span class="line">16     char buf[100] &#x3D; &quot;&#x2F;dev&#x2F;&quot;;</span><br><span class="line">17     strcat(buf, argv[1]);</span><br><span class="line">18     printf(&quot;You Will Open %s\n&quot;, buf);</span><br><span class="line">19     </span><br><span class="line">20     int fd;</span><br><span class="line">21     </span><br><span class="line">22     fd &#x3D; open(buf, O_RDWR);</span><br><span class="line">23     if (fd &lt; 0) &#123;</span><br><span class="line">24         printf(&quot;can&#39;t open %s\n&quot;, buf);</span><br><span class="line">25         return -1;</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28     unsigned char key_val;</span><br><span class="line">29     </span><br><span class="line">30     while (1) &#123;</span><br><span class="line">31         read(fd, &amp;key_val, 1);</span><br><span class="line">32         printf(&quot;key_val &#x3D; 0x%x\n&quot;, key_val);</span><br><span class="line">33     &#125;</span><br><span class="line">34     </span><br><span class="line">35     close(fd);</span><br><span class="line">36 </span><br><span class="line">37     return 0;</span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>测试：</strong></p>
<p>在编译并在开发板上insmod后，会出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;input: Unspecified device as &#x2F;devices&#x2F;virtual&#x2F;input&#x2F;input3</span><br></pre></td></tr></table></figure>



<p>这是由于未设置input_dev的名字所导致的，暂时不需要管</p>
<p>接下来执行：</p>
<p># ps -ef</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200347113-1161513239.png" alt="img"></p>
<p>确定-/bin/sh的pid为108（不同开发板-/bin/sh的pid不同）</p>
<p># ls -l /proc/108/fd</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200548748-631729914.png" alt="img"></p>
<p>确定使用tty1</p>
<p># exec 0&lt;/dev/tty1</p>
<p>接下来按键，效果如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201905/1542940-20190515200914935-24962756.png" alt="img"></p>
<p>下一章  <a href="https://www.cnblogs.com/Lioker/p/10893768.html" target="_blank" rel="noopener">9、总线设备驱动模型</a></p>
<p>作者：<a href="https://www.cnblogs.com/Lioker/" target="_blank" rel="noopener">Lioker</a></p>
<p>邮箱：<a href="mailto:lioker@outlook.com">lioker@outlook.com</a></p>
<p>作者水平有限，欢迎拍砖。转载请注明出处。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>Input子系统</category>
      </categories>
      <tags>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】MMC/SD/SDIO介绍</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91MMC%20SD%20SDIO%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>熟悉Linux kernel的人都知道，kernel使用MMC subsystem统一管理MMC、SD、SDIO等设备，为什么呢？到底什么是MMC？SD和SDIO又是什么？为什么可以用MMC统称呢？</p>
<p>在分析Linux kernel的MMC subsystem之前，有必要先介绍一些概念，以便对MMC/SD/SDIO有一个大致的了解，这就是本文的目的。</p>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>MMC是MultiMediaCard的简称，从本质上看，它是一种用于固态非易失性存储的内存卡（memory card）规范[1]，定义了诸如卡的形态、尺寸、容量、电气信号、和主机之间的通信协议等方方面面的内容。</p>
<p>从1997年MMC规范发布至今，基于不同的考量（物理尺寸、电压范围、管脚数量、最大容量、数据位宽、clock频率、安全特性、是否支持SPI mode、是否支持DDR mode、等等），进化出了MMC、SD、microSD、SDIO、eMMC等不同的规范（如下面图片1所示）。虽然乱花迷人，其本质终究还是一样的，丝毫未变，这就是Linux kernel将它们统称为MMC的原因。</p>
<p><img src="http://jiali.clouddn.com/20201225_001.png" alt=""></p>
<p>​                                                                                             图片1 MMC/SD/SDIO evolution</p>
<p>关于该图片，这里强调几点（其它的，大家可参考[1] [2]，不再详细介绍）：</p>
<blockquote>
<p>MMC、SD、SDIO的技术本质是一样的（使用相同的总线规范，等等），都是从MMC规范演化而来；</p>
<p>MMC强调的是多媒体存储（MM，MultiMedia）；</p>
<p>SD强调的是安全和数据保护（S，Secure）；</p>
<p>SDIO是从SD演化出来的，强调的是接口（IO，Input/Output），不再关注另一端的具体形态（可以是WIFI设备、Bluetooth设备、GPS等等）。</p>
</blockquote>
<h2 id="3-规范简介"><a href="#3-规范简介" class="headerlink" title="3. 规范简介"></a>3. 规范简介</h2><p>MMC分别从卡（Card Concept）、总线（Bus Concept）以及控制器（Host Controller）三个方面，定义MMC system的行为，如下面图片2所示：</p>
<p><img src="http://jiali.clouddn.com/20201225_002.png" alt=""></p>
<p>​                                                                                                   图片2 mmc_sd_sdio_hw_block</p>
<p>不同岗位的工程师，可以根据自己的工作性质，重点理解某一部分的规范，下面从嵌入式软件工程师的视角，简单的介绍一下。</p>
<h3 id="3-1-卡的规范"><a href="#3-1-卡的规范" class="headerlink" title="3.1 卡的规范"></a>3.1 卡的规范</h3><p>卡的规范主要规定卡的形状、物理尺寸、管脚，内部block组成、寄存器等等，以eMMC为例[3]：</p>
<p><img src="http://jiali.clouddn.com/20201225_003.png" alt=""></p>
<p>​                                                                                                      图片3 Card Concept(eMMC)</p>
<p>1）有关形状、尺寸的内容，这里不再介绍，感兴趣的同学可参考[1]。</p>
<p>2）卡的内部由如下几个block组成：</p>
<blockquote>
<p>Memory core，存储介质，一般是NAND flash、NOR flash等；</p>
<p>Memory core interface，管理存储介质的接口，用于访问（读、写、擦出等操作）存储介质；</p>
<p>Card interface（CMD、CLK、DATA），总线接口，外界访问卡内部存储介质的接口，和具体的管脚相连；</p>
<p>Card interface controller，将总线接口上的协议转换为Memory core interface的形式，用于访问内部存储介质；</p>
<p>Power模块，提供reset、上电检测等功能；</p>
<p>寄存器（图片1中位于Card interface controller的左侧，那些小矩形），用于提供卡的信息、参数、访问控制等功能。</p>
</blockquote>
<p>3）卡的管脚有VDD、GND、RST、CLK、CMD和DATA等，VDD和GND提供power，RST用于复位，CLK、CMD和DATA为MMC总线协议（具体可参考3.2小节）的物理通道：</p>
<blockquote>
<p>CLK有一条，提供同步时钟，可以在CLK的上升沿（或者下降沿，或者上升沿和下降沿）采集数据；</p>
<p>CMD有一条，用于传输双向的命令。</p>
<p>DATA用于传说双向的数据，根据MMC的类型，可以有一条（1-bit）、四条（4-bit）或者八条（8-bit）。</p>
</blockquote>
<p>4）以eMMC为例，规范定义了OCR, CID, CSD, EXT_CSD, RCA 以及DSR 6组寄存器，具体含义后面再介绍。</p>
<h3 id="3-2-总线规范"><a href="#3-2-总线规范" class="headerlink" title="3.2 总线规范"></a>3.2 总线规范</h3><p>前面我们提到过，MMC的本质是提供一套可以访问固态非易失性存储介质的通信协议，从产业化的角度看，这些存储介质一般集成在一个独立的外部模块中（卡、WIFI模组等），通过物理总线和CPU连接。对任何有线的通信协议来说，总线规范都是非常重要的。关于MMC总线规范，简单总结如下：</p>
<p>1）物理信号有CLK、CMD和DATA三类。</p>
<p>2）电压范围为1.65V和3.6V（参考上面图片2），根据工作电压的不同，MMC卡可以分为两类：</p>
<blockquote>
<p>High Voltage MultiMediaCard，工作电压为2.7V~3.6V。</p>
<p>Dual Voltage MultiMediaCard，工作电压有两种，1.70V<del>1.95V和2.7V</del>3.6V，CPU可以根据需要切换。</p>
</blockquote>
<p>3）数据传输的位宽（称作data bus width mode）是允许动态配置的，包括1-bit (默认)模式、4-bit模式和8-bit模式。</p>
<blockquote>
<p>注1：不使用的数据线，需要保持上拉状态，这就是图片2中的DATA中标出上拉的原因。另外，由于数据线宽度是动态可配的，这要求CPU可以动态的enable/disable数据线的那些上拉电阻。</p>
</blockquote>
<p>4）MMC规范定义了CLK的频率范围，包括0-20MHz、0-26MHz、0-52MHz等几种，结合数据线宽度，基本决定了MMC的访问速度。</p>
<p>5）总线规范定义了一种简单的、主从式的总线协议，MMC卡位从机（slave），CPU为主机（Host）。</p>
<p>6）协议规定了三种可以在总线上传输的信标（token）：</p>
<blockquote>
<p>Command，Host通过CMD线发送给Slave的，用于启动（或结束）一个操作（后面介绍）；</p>
<p>Response，Slave通过CMD线发送给Host，用于回应Host发送的Command；</p>
<p>Data，Host和Slave之间通过数据线传说的数据。方向可以是Host到Slave，也可以是Slave到Host。数据线的个数可以是1、4或者8。在每一个时钟周期，每根数据线上可以传输1bit或者2bits的数据。</p>
</blockquote>
<p>7）一次数据传输过程，需要涉及所有的3个信标。一次数据传输的过程也称作Bus Operation，根据场景的不同，MMC协议规定了很多类型的Bus Operation（具体可参考相应的规范）。</p>
<h3 id="3-3-控制器规范"><a href="#3-3-控制器规范" class="headerlink" title="3.3 控制器规范"></a>3.3 控制器规范</h3><p>Host控制器是MMC总线规范在Host端的实现，也是Linux驱动工程师比较关注的地方，后面将会结合Linux MMC framework的有关内容，再详细介绍。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文对MMC/SD/SDIO等做了一个简单的介绍，有了这些基本概念之后，在Linux kernel中编写MMC驱动将不再是一个困难的事情（因为MMC是一个协议，所有有关协议的事情，都很简单，因为协议是固定的），我们只需要如下步骤即可完成：</p>
<blockquote>
<p>1）结合MMC的规范，阅读Host MMC controller的spec，理解有关的功能和操作方法。</p>
<p>2）根据Linux MMC framework的框架，将MMC bus有关的操作方法通过MMC controller实现。</p>
</blockquote>
<p>具体可参考后续MMC framework的分析文档。</p>
<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h2><p>[1] <a href="https://en.wikipedia.org/wiki/MultiMediaCard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MultiMediaCard</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Secure_Digital" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Secure_Digital</a></p>
<p>[3] eMM spec（注册后可免费下载），<a href="http://www.jedec.org/standards-documents/results/jesd84-b51" target="_blank" rel="noopener">http://www.jedec.org/standards-documents/results/jesd84-b51</a></p>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net,来自【http://www.wowotech.net/basic_tech/mmc_sd_sdio_intro.html】" target="_blank" rel="noopener">www.wowotech.net,来自【http://www.wowotech.net/basic_tech/mmc_sd_sdio_intro.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Flash Memory 简介</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Flash%20Memory%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>eMMC 是 Flash Memory 的一类，在详细介绍 eMMC 之前，先简单介绍一下 Flash Memory。</p>
<p>Flash Memory 是一种非易失性的存储器。在嵌入式系统中通常用于存放系统、应用和数据等。在 PC 系统中，则主要用在固态硬盘以及主板 BIOS 中。另外，绝大部分的 U 盘、SDCard 等移动存储设备也都是使用 Flash Memory 作为存储介质。</p>
<h2 id="1-Flash-Memory-的主要特性"><a href="#1-Flash-Memory-的主要特性" class="headerlink" title="1. Flash Memory 的主要特性"></a>1. Flash Memory 的主要特性</h2><p>与传统的硬盘存储器相比，Flash Memory 具有质量轻、能耗低、体积小、抗震能力强等的优点，但也有不少局限性，主要如下：</p>
<ol>
<li>需要先擦除再写入<br>Flash Memory 写入数据时有一定的限制。它只能将当前为 1 的比特改写为 0，而无法将已经为 0 的比特改写为 1，只有在擦除的操作中，才能把整块的比特改写为 1。</li>
<li>块擦除次数有限<br>Flash Memory 的每个数据块都有擦除次数的限制（十万到百万次不等），擦写超过一定次数后，该数据块将无法可靠存储数据，成为坏块。<br>为了最大化的延长 Flash Memory 的寿命，在软件上需要做擦写均衡（Wear Leveling），通过分散写入、动态映射等手段均衡使用各个数据块。同时，软件还需要进行坏块管理（Bad Block Management，BBM），标识坏块，不让坏块参与数据存储。（注：除了擦写导致的坏块外，Flash Memory 在生产过程也会产生坏块，即固有坏块。）</li>
<li>读写干扰<br>由于硬件实现上的物理特性，Flash Memory 在进行读写操作时，有可能会导致邻近的其他比特发生位翻转，导致数据异常。这种异常可以通过重新擦除来恢复。Flash Memory 应用中通常会使用 ECC 等算法进行错误检测和数据修正。</li>
<li>电荷泄漏<br>存储在 Flash Memory 存储单元的电荷，如果长期没有使用，会发生电荷泄漏，导致数据错误。不过这个时间比较长，一般十年左右。此种异常是非永久性的，重新擦除可以恢复。</li>
</ol>
<h2 id="2-NOR-Flash-和-NAND-Flash"><a href="#2-NOR-Flash-和-NAND-Flash" class="headerlink" title="2. NOR Flash 和 NAND Flash"></a>2. NOR Flash 和 NAND Flash</h2><p>根据硬件上存储原理的不同，Flash Memory 主要可以分为 NOR Flash 和 NAND Flash 两类。 主要的差异如下所示：</p>
<ul>
<li>NAND Flash 读取速度与 NOR Flash 相近，根据接口的不同有所差异；</li>
<li>NAND Flash 的写入速度比 NOR Flash 快很多；</li>
<li>NAND Flash 的擦除速度比 NOR Flash 快很多；</li>
<li>NAND Flash 最大擦次数比 NOR Flash 多；</li>
<li>NOR Flash 支持片上执行，可以在上面直接运行代码；</li>
<li>NOR Flash 软件驱动比 NAND Flash 简单；</li>
<li>NOR Flash 可以随机按字节读取数据，NAND Flash 需要按块进行读取。</li>
<li>大容量下 NAND Flash 比 NOR Flash 成本要低很多，体积也更小；</li>
</ul>
<p>（注：NOR Flash 和 NAND Flash 的擦除都是按块块进行的，执行一个擦除或者写入操作时，NOR Flash 大约需要 5s，而 NAND Flash 通常不超过 4ms。）</p>
<h3 id="2-1-NOR-Flash"><a href="#2-1-NOR-Flash" class="headerlink" title="2.1 NOR Flash"></a>2.1 NOR Flash</h3><p>NOR Flash 根据与 CPU 端接口的不同，可以分为 Parallel NOR Flash 和 Serial NOR Flash 两类。<br>Parallel NOR Flash 可以接入到 Host 的 SRAM/DRAM Controller 上，所存储的内容可以直接映射到 CPU 地址空间，不需要拷贝到 RAM 中即可被 CPU 访问，因而支持片上执行。Serial NOR Flash 的成本比 Parallel NOR Flash 低，主要通过 SPI 接口与 Host 连接。</p>
<p><img src="http://jiali.clouddn.com/20201225_004.png" alt=""></p>
<p>​                                                                                            图片： Parallel NOR Flash 与 Serial NOR Flash</p>
<p>鉴于 NOR Flash 擦写速度慢，成本高等特性，NOR Flash 主要应用于小容量、内容更新少的场景，例如 PC 主板 BIOS、路由器系统存储等。</p>
<p>更多 NOR Flash 的相关细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/nor_flash/index.html" target="_blank" rel="noopener">NOR Flash</a> 章节。</p>
<h3 id="2-2-NAND-Flash"><a href="#2-2-NAND-Flash" class="headerlink" title="2.2 NAND Flash"></a>2.2 NAND Flash</h3><p>NAND Flash 需要通过专门的 NFI（NAND Flash Interface）与 Host 端进行通信，如下图所示：</p>
<p><img src="http://jiali.clouddn.com/20201225_005.png" alt=""></p>
<p>​                                                                                                                图片：NAND Flash Interface</p>
<p>NAND Flash 根据每个存储单元内存储比特个数的不同，可以分为 SLC（Single-Level Cell）、MLC（Multi-Level Cell） 和 TLC（Triple-Level Cell） 三类。其中，在一个存储单元中，SLC 可以存储 1 个比特，MLC 可以存储 2 个比特，TLC 则可以存储 3 个比特。</p>
<p>NAND Flash 的一个存储单元内部，是通过不同的电压等级，来表示其所存储的信息的。在 SLC 中，存储单元的电压被分为两个等级，分别表示 0 和 1 两个状态，即 1 个比特。在 MLC 中，存储单元的电压则被分为 4 个等级，分别表示 00 01 10 11 四个状态，即 2 个比特位。同理，在 TLC 中，存储单元的电压被分为 8 个等级，存储 3 个比特信息。</p>
<p><img src="http://jiali.clouddn.com/20201225_006.png" alt=""></p>
<p>​                                                                                                              图片： SLC、MLC 与 TLC</p>
<p>NAND Flash 的单个存储单元存储的比特位越多，读写性能会越差，寿命也越短，但是成本会更低。Table 1 中，给出了特定工艺和技术水平下的成本和寿命数据。</p>
<p><strong>Table 1</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>SLC</th>
<th>MLC</th>
<th>TLC</th>
</tr>
</thead>
<tbody><tr>
<td>制造成本</td>
<td>30-35 美元 / 32GB</td>
<td>17 美元 / 32GB</td>
<td>9-12 美元 / 32GB</td>
</tr>
<tr>
<td>擦写次数</td>
<td>10万次或更高</td>
<td>1万次或更高</td>
<td>5000次甚至更高</td>
</tr>
<tr>
<td>存储单元</td>
<td>1 bit / cell</td>
<td>2 bits / cell</td>
<td>3 bits / cell</td>
</tr>
</tbody></table>
<p>（注：以上数据来源于互联网，仅供参考）</p>
<p>相比于 NOR Flash，NAND Flash 写入性能好，大容量下成本低。目前，绝大部分手机和平板等移动设备中所使用的 eMMC 内部的 Flash Memory 都属于 NAND Flash。PC 中的固态硬盘中也是使用 NAND Flash。</p>
<p>更多 NAND Flash 的相关细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/nand_flash/index.html" target="_blank" rel="noopener">NAND Flash</a> 章节。</p>
<h2 id="3-Raw-Flash-和-Managed-Flash"><a href="#3-Raw-Flash-和-Managed-Flash" class="headerlink" title="3. Raw Flash 和 Managed Flash"></a>3. Raw Flash 和 Managed Flash</h2><p>由于 Flash Memory 存在按块擦写、擦写次数的限制、读写干扰、电荷泄露等的局限，为了最大程度的发挥 Flash Memory 的价值，通常需要有一个特殊的软件层次，实现坏块管理、擦写均衡、ECC、垃圾回收等的功能，这一个软件层次称为 FTL（Flash Translation Layer）。</p>
<p>在具体实现中，根据 FTL 所在的位置的不同，可以把 Flash Memory 分为 Raw Flash 和 Managed Flash 两类。</p>
<p><img src="http://jiali.clouddn.com/20201225_007.png" alt=""></p>
<p>​                                                                                                     图片： Raw Flash 和 Managed Flash</p>
<p><strong>Raw Flash</strong><br>在此类应用中，在 Host 端通常有专门的 FTL 或者 Flash 文件系统来实现坏块管理、擦写均衡等的功能。Host 端的软件复杂度较高，但是整体方案的成本较低，常用于价格敏感的嵌入式产品中。<br>通常我们所说的 NOR Flash 和 NAND Flash 都属于这类型。</p>
<p><strong>Managed Flash</strong><br>Managed Flash 在其内部集成了 Flash Controller，用于完成擦写均衡、坏块管理、ECC校验等功能。相比于直接将 Flash 接入到 Host 端，Managed Flash 屏蔽了 Flash 的物理特性，对 Host 提供标准化的接口，可以减少 Host 端软件的复杂度，让 Host 端专注于上层业务，省去对 Flash 进行特殊的处理。<br><a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/index.html" target="_blank" rel="noopener">eMMC</a>、<a href="https://linux.codingbelief.com/zh/storage/flash_memory/sd_card/index.html" target="_blank" rel="noopener">SD Card</a>、<a href="https://linux.codingbelief.com/zh/storage/flash_memory/ufs/index.html" target="_blank" rel="noopener">UFS</a>、U 盘等产品是属于 Managed Flash 这一类。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><a href="https://www.micron.com/~/media/documents/products/product-flyer/flyer_nor_nand_flash_guide.pdf" target="_blank" rel="noopener">NOR NAND Flash Guide: Selecting a Flash Storage Solution</a> [PDF]</li>
<li><a href="https://en.wikipedia.org/wiki/Common_Flash_Memory_Interface" target="_blank" rel="noopener">Wiki: Common Flash Memory Interface</a> [Web]</li>
<li>[Quick Guide to Common Flash Interface](<a href="https://www.spansion.com/Support/Application" target="_blank" rel="noopener">https://www.spansion.com/Support/Application</a> Notes/Quick_Guide_to_CFI_AN.pdf) [PDF]</li>
<li><a href="https://www.micron.com/products/nor-flash" target="_blank" rel="noopener">MICRON NOR Flash Technology</a> [Web]</li>
<li><a href="https://www.micron.com/products/nand-flash" target="_blank" rel="noopener">MICRON NAND Flash Technology</a> [Web]</li>
<li><a href="https://zh.wikipedia.org/wiki/闪存" target="_blank" rel="noopener">Wiki：闪存</a> [Web]</li>
<li><a href="https://en.wikipedia.org/wiki/Flash_file_system" target="_blank" rel="noopener">Wiki：Flash File System</a> [Web]</li>
<li><a href="https://www.micron.com/~/media/documents/products/technical-note/nand-flash/tn2961_wear_leveling_in_nand.pdf" target="_blank" rel="noopener">Wear Leveling in Micron® NAND Flash Memory</a> [PDF]</li>
<li><a href="https://flashdba.com/2014/09/17/understanding-flash-the-flash-translation-layer/" target="_blank" rel="noopener">Understanding Flash: The Flash Translation Layer</a> [Web]</li>
<li><a href="http://blog.sina.com.cn/s/blog_4b4b54da01016rx3.html" target="_blank" rel="noopener">谈NAND Flash的底层结构和解析</a> [Web]</li>
<li><a href="http://www.ssdfans.com/?p=45" target="_blank" rel="noopener">闪存基础</a> [Web]</li>
<li><a href="http://www.onfi.org/" target="_blank" rel="noopener">Open NAND Flash Interface (ONFI)</a> [Web]</li>
</ol>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net，来自【http://www.wowotech.net/basic_tech/flash_memory_intro.html】" target="_blank" rel="noopener">www.wowotech.net，来自【http://www.wowotech.net/basic_tech/flash_memory_intro.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
      </categories>
      <tags>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>MMC tools introduction</title>
    <url>/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/MMC%20tools%20introduction/</url>
    <content><![CDATA[<h2 id="MMC-tools-introduction"><a href="#MMC-tools-introduction" class="headerlink" title="MMC tools introduction"></a>MMC tools introduction</h2><p>There is one MMC test tools called mmc-utils, which is maintained by Chris Ball, you can find it at the below public git repository:</p>
<p><a href="http://git.kernel.org/cgit/linux/kernel/git/cjb/mmc-utils.git/" target="_blank" rel="noopener">http://git.kernel.org/cgit/linux/kernel/git/cjb/mmc-utils.git/</a></p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>The mmc-utils tools can do the following:</p>
<ul>
<li>Print and parse extcsd data.</li>
<li>Determine the eMMC writeprotect status.</li>
<li>Set the eMMC writeprotect status.</li>
<li>Set the eMMC data sector size to 4KB by disabling emulation.</li>
<li>Create general purpose partition.</li>
<li>Enable the enhanced user area.</li>
<li>Enable write reliability per partition.</li>
<li>Print the response to STATUS_SEND (CMD13).</li>
<li>Enable the boot partition.</li>
<li>Set Boot Bus Conditions.</li>
<li>Enable the eMMC BKOPS feature.</li>
<li>Permanently enable the eMMC H/W Reset feature.</li>
<li>Permanently disable the eMMC H/W Reset feature.</li>
<li>Send Sanitize command.</li>
<li>Program authentication key for the device.</li>
<li>Counter value for the rpmb device will be read to stdout.</li>
<li>Read from rpmb device to output.</li>
<li>Write to rpmb device from data file.</li>
<li>Enable the eMMC cache feature.</li>
<li>Disable the eMMC cache feature.</li>
<li>Print and parse CID data.</li>
<li>Print and parse CSD data.</li>
<li>Print and parse SCR data.</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC 简介</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>eMMC 是 embedded MultiMediaCard 的简称。MultiMediaCard，即 MMC， 是一种闪存卡（Flash Memory Card）标准，它定义了 MMC 的架构以及访问　Flash Memory 的接口和协议。而 eMMC 则是对 MMC 的一个拓展，以满足更高标准的性能、成本、体积、稳定、易用等的需求。</p>
<p>eMMC 的整体架构如下图片所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_architecture.png" alt="img"></p>
<p>​                                                                                                                 图片： eMMC 整体架构</p>
<p>eMMC 内部主要可以分为 Flash Memory、Flash Controller 以及 Host Interface 三大部分。</p>
<h2 id="1-Flash-Memory"><a href="#1-Flash-Memory" class="headerlink" title="1. Flash Memory"></a>1. Flash Memory</h2><p>Flash Memory 是一种非易失性的存储器，通常在嵌入式系统中用于存放系统、应用和数据等，类似与 PC 系统中的硬盘。</p>
<p>目前，绝大部分手机和平板等移动设备中所使用的 eMMC 内部的 Flash Memory 都属于 NAND Flash，关于 NAND Flash 的更多细节可以参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/index.html" target="_blank" rel="noopener">Flash Memory</a> 章节。</p>
<p>eMMC 在内部对 Flash Memory 划分了几个主要区域，如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_partitions.png" alt="img"></p>
<p>​                                                                                    图片：eMMC 内部分区</p>
<ol>
<li>BOOT Area Partition 1 &amp; 2<br>此分区主要是为了支持从 eMMC 启动系统而设计的。<br>该分区的数据，在 eMMC 上电后，可以通过很简单的协议就可以读取出来。同时，大部分的 SOC 都可以通过 GPIO 或者 FUSE 的配置，让 ROM 代码在上电后，将 eMMC BOOT 分区的内容加载到 SOC 内部的 SRAM 中执行。</li>
<li>RPMB Partition<br>RPMB 是 Replay Protected Memory Block 的简称，它通过 HMAC SHA-256 和 Write Counter 来保证保存在 RPMB 内部的数据不被非法篡改。<br>在实际应用中，RPMB 分区通常用来保存安全相关的数据，例如指纹数据、安全支付相关的密钥等。</li>
<li>General Purpose Partition 1～4<br>此区域则主要用于存储系统或者用户数据。 General Purpose Partition 在芯片出厂时，通常是不存在的，需要主动进行配置后，才会存在。</li>
<li>User Data Area<br>此区域则主要用于存储系统和用户数据。<br>User Data Area 通常会进行再分区，例如 Android 系统中，通常在此区域分出 boot、system、userdata 等分区。</li>
</ol>
<p>更多 eMMC 分区相关的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_partitions.html" target="_blank" rel="noopener">eMMC 分区管理</a> 章节。</p>
<h2 id="2-Flash-Controller"><a href="#2-Flash-Controller" class="headerlink" title="2. Flash Controller"></a>2. Flash Controller</h2><p>NAND Flash 直接接入 Host 时，Host 端通常需要有 NAND Flash Translation Layer，即 NFTL 或者 NAND Flash 文件系统来做坏块管理、ECC等的功能。</p>
<p>eMMC 则在其内部集成了 Flash Controller，用于完成擦写均衡、坏块管理、ECC校验等功能。相比于直接将 NAND Flash 接入到 Host 端，eMMC 屏蔽了 NAND Flash 的物理特性，可以减少 Host 端软件的复杂度，让 Host 端专注于上层业务，省去对 NAND Flash 进行特殊的处理。同时，eMMC 通过使用 Cache、Memory Array 等技术，在读写性能上也比 NAND Flash 要好很多。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_vs_nand_flash.png" alt="img"></p>
<p>​                                                                                                       图片：NAND Flash 与 eMMC</p>
<h2 id="3-Host-Interface"><a href="#3-Host-Interface" class="headerlink" title="3. Host Interface"></a>3. Host Interface</h2><p>eMMC 与 Host 之间的连接如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_host_interfaces.png" alt="img"></p>
<p>​                                                                                                            图片：eMMC Interface</p>
<p>各个信号的用途如下所示：</p>
<p><strong>CLK</strong><br>用于同步的时钟信号</p>
<p><strong>Data Strobe</strong><br>此信号是从 Device 端输出的时钟信号，频率和 CLK 信号相同，用于同步从 Device 端输出的数据。该信号在 eMMC 5.0 中引入。</p>
<p><strong>CMD</strong><br>此信号用于发送 Host 的 command 和 Device 的 response。</p>
<p><strong>DAT0-7</strong><br>用于传输数据的 8 bit 总线。</p>
<p>Host 与 eMMC 之间的通信都是 Host 以一个 Command 开始发起的。针对不同的 Command，Device 会做出不同的响应。详细的通信协议相关内容，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_bus_protocol.html" target="_blank" rel="noopener">eMMC 总线协议</a> 章节。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><a href="http://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf" target="_blank" rel="noopener">Embedded Multi-Media Card (e•MMC) Electrical Standard (5.1)</a> [PDF]</li>
</ol>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_intro.html】" target="_blank" rel="noopener">www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_intro.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC分区管理</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Partitions-Overview"><a href="#1-Partitions-Overview" class="headerlink" title="1. Partitions Overview"></a>1. Partitions Overview</h2><p>eMMC 标准中，将内部的 Flash Memory 划分为 4 类区域，最多可以支持 8 个硬件分区，如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_partitions.png" alt="img"></p>
<h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>一般情况下，Boot Area Partitions 和 RPMB Partition 的容量大小通常都为 4MB，部分芯片厂家也会提供配置的机会。General Purpose Partitions (GPP) 则在出厂时默认不被支持，即不存在这些分区，需要用户主动使能，并配置其所要使用的 GPP 的容量大小，GPP 的数量可以为 1 - 4 个，各个 GPP 的容量大小可以不一样。User Data Area (UDA) 的容量大小则为总容量大小减去其他分区所占用的容量。更多各个分区的细节将在后续小节中描述。</p>
<h3 id="1-2-分区编址"><a href="#1-2-分区编址" class="headerlink" title="1.2 分区编址"></a>1.2 分区编址</h3><p>eMMC 的每一个硬件分区的存储空间都是独立编址的，即访问地址为 0 - partition size。具体的数据读写操作实际访问哪一个硬件分区，是由 eMMC 的 Extended CSD register 的 PARTITION_CONFIG Field 中 的 Bit[2:0]: PARTITION_ACCESS 决定的，用户可以通过配置 PARTITION_ACCESS 来切换硬件分区的访问。也就是说，用户在访问特定的分区前，需要先发送命令，配置 PARTITION_ACCESS，然后再发送相关的数据访问请求。更多数据读写相关的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_bus_protocol.html" target="_blank" rel="noopener">eMMC 总线协议</a> 章节。</p>
<p>eMMC 的各个硬件分区有其自身的功能特性，多分区的设计，为不同的应用场景提供了便利。</p>
<h2 id="2-Boot-Area-Partitions"><a href="#2-Boot-Area-Partitions" class="headerlink" title="2. Boot Area Partitions"></a>2. Boot Area Partitions</h2><p>Boot Area 包含两个 Boot Area Partitions，主要用于存储 Bootloader，支持 SOC 从 eMMC 启动系统。</p>
<h3 id="2-1-容量大小"><a href="#2-1-容量大小" class="headerlink" title="2.1 容量大小"></a>2.1 容量大小</h3><p>两个 Boot Area Partitions 的大小是完全一致的，由 Extended CSD register 的 BOOT_SIZE_MULT Field 决定，大小的计算公式如下：</p>
<p><strong>Size = 128Kbytes x BOOT_SIZE_MULT</strong></p>
<p>一般情况下，Boot Area Partition 的大小都为 4 MB，即 BOOT_SIZE_MULT 为 32，部分芯片厂家会提供改写 BOOT_SIZE_MULT 的功能来改变 Boot Area Partition 的容量大小。BOOT_SIZE_MULT 最大可以为 255，即 Boot Area Partition 的最大容量大小可以为 255 x 128 KB = 32640 KB = 31.875 MB。</p>
<h3 id="2-2-从-Boot-Area-启动"><a href="#2-2-从-Boot-Area-启动" class="headerlink" title="2.2 从 Boot Area 启动"></a>2.2 从 Boot Area 启动</h3><p>eMMC 中定义了 Boot State，在 Power-up、HW reset 或者 SW reset 后，如果满足一定的条件，eMMC 就会进入该 State。进入 Boot State 的条件如下：</p>
<p><strong>Original Boot Operation</strong><br>CMD 信号保持低电平不少于 74 个时钟周期，会触发 Original Boot Operation，进入 Boot State。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/original_boot.png" alt="img"></p>
<p><strong>Alternative Boot Operation</strong><br>在 74 个时钟周期后，在 CMD 信号首次拉低或者 Host 发送 CMD1 之前，Host 发送参数为 0xFFFFFFFA 的 COM0时，会触发 Alternative Boot Operation，进入 Boot State。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/alternative_boot.png" alt="img"></p>
<p>在 Boot State 下，如果有配置 BOOT_ACK，eMMC 会先发送 “010” 的 ACK 包，接着 eMMC 会将最大为 128Kbytes x BOOT_SIZE_MULT 的 Boot Data 发送给 Host。传输过程中，Host 可以通过拉高 CMD 信号 (Original Boot 中)，或者发送 Reset 命令 (Alternative Boot 中) 来中断 eMMC 的数据发送，完成 Boot Data 传输。</p>
<p>Boot Data 根据 Extended CSD register 的 PARTITION_CONFIG Field 的 Bit[5:3]:BOOT_PARTITION_ENABLE 的设定，可以从 Boot Area Partition 1、Boot Area Partition 2 或者 User Data Area 读出。</p>
<blockquote>
<p>Boot Data 存储在 Boot Area 比在 User Data Area 中要更加的安全，可以减少意外修改导致系统无法启动，同时无法更新系统的情况出现。</p>
</blockquote>
<p>（更多 Boot State 的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html" target="_blank" rel="noopener">eMMC 工作模式</a> 的 Boot Mode 章节）</p>
<h3 id="2-3-写保护"><a href="#2-3-写保护" class="headerlink" title="2.3 写保护"></a>2.3 写保护</h3><p>通过设定 Extended CSD register 的 BOOT_WP Field，可以为两个 Boot Area Partition 独立配置写保护功能,以防止数据被意外改写或者擦出。</p>
<p>eMMC 中定义了两种 Boot Area 的写保护模式：</p>
<ol>
<li>Power-on write protection，使能后，如果 eMMC 掉电，写保护功能失效，需要每次 Power on 后进行配置</li>
<li>Permanent write protection，使能后，即使掉电也不会失效，主动进行关闭才会失效</li>
</ol>
<h2 id="3-RPMB-Partition"><a href="#3-RPMB-Partition" class="headerlink" title="3. RPMB Partition"></a>3. RPMB Partition</h2><p>RPMB（Replay Protected Memory Block）Partition 是 eMMC 中的一个具有安全特性的分区。<br>eMMC 在写入数据到 RPMB 时，会校验数据的合法性，只有指定的 Host 才能够写入，同时在读数据时，也提供了签名机制，保证 Host 读取到的数据是 RPMB 内部数据，而不是攻击者伪造的数据。</p>
<p>RPMB 在实际应用中，通常用于存储一些有防止非法篡改需求的数据，例如手机上指纹支付相关的公钥、序列号等。RPMB 可以对写入操作进行鉴权，但是读取并不需要鉴权，任何人都可以进行读取的操作，因此存储到 RPMB 的数据通常会进行加密后再存储。</p>
<h3 id="3-1-容量大小"><a href="#3-1-容量大小" class="headerlink" title="3.1 容量大小"></a>3.1 容量大小</h3><p>两个 RPMB Partition 的大小是由 Extended CSD register 的 BOOT_SIZE_MULT Field 决定，大小的计算公式如下：</p>
<p><strong>Size = 128Kbytes x BOOT_SIZE_MULT</strong></p>
<p>一般情况下，Boot Area Partition 的大小为 4 MB，即 RPMB_SIZE_MULT 为 32，部分芯片厂家会提供改写 RPMB_SIZE_MULT 的功能来改变 RPMB Partition 的容量大小。RPMB_SIZE_MULT 最大可以为 128，即 Boot Area Partition 的最大容量大小可以为 128 x 128 KB = 16384 KB = 16 MB。</p>
<h3 id="3-2-Replay-Protect-原理"><a href="#3-2-Replay-Protect-原理" class="headerlink" title="3.2 Replay Protect 原理"></a>3.2 Replay Protect 原理</h3><p>使用 eMMC 的产品，在产线生产时，会为每一个产品生产一个唯一的 256 bits 的 Secure Key，烧写到 eMMC 的 OTP 区域（只能烧写一次的区域），同时 Host 在安全区域中（例如：TEE）也会保留该 Secure Key。</p>
<p>在 eMMC 内部，还有一个RPMB Write Counter。RPMB 每进行一次合法的写入操作时，Write Counter 就会自动加一 。</p>
<p>通过 Secure Key 和 Write Counter 的应用，RMPB 可以实现数据读取和写入的 Replay Protect。</p>
<h4 id="RPMB-数据读取"><a href="#RPMB-数据读取" class="headerlink" title="RPMB 数据读取"></a>RPMB 数据读取</h4><p>RPMB 数据读取的流程如下：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/rpmb_r.png" alt="img"></p>
<ol>
<li>Host 向 eMMC 发起读 RPMB 的请求，同时生成一个 16 bytes 的随机数，发送给 eMMC。</li>
<li>eMMC 将请求的数据从 RPMB 中读出，并使用 Secure Key 通过 HMAC SHA-256 算法，计算读取到的数据和接收到的随机数拼接到一起后的签名。然后，eMMC 将读取到的数据、接收到的随机数、计算得到的签名一并发送给 Host。</li>
<li>Host 接收到 RPMB 的数据、随机数以及签名后，首先比较随机数是否与自己发送的一致，如果一致，再用同样的 Secure Key 通过 HMAC SHA-256 算法对数据和随机数组合到一起进行签名，如果签名与 eMMC 发送的签名是一致的，那么就可以确定该数据是从 RPMB 中读取到的正确数据，而不是攻击者伪造的数据。</li>
</ol>
<p>通过上述的读取流程，可以保证 Host 正确的读取到 RPMB 的数据。</p>
<h4 id="RPMB-数据写入"><a href="#RPMB-数据写入" class="headerlink" title="RPMB 数据写入"></a>RPMB 数据写入</h4><p>RPMB 数据写入的流程如下：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/rpmb_w.png" alt="img"></p>
<ol>
<li>Host 按照上面的读数据流程，读取 RPMB 的 Write Counter。</li>
<li>Host 将需要写入的数据和 Write Counter 拼接到一起并计算签名，然后将数据、Write Counter 以及签名一并发给 eMMC。</li>
<li>eMMC 接收到数据后，先对比 Write Counter 是否与当前的值相同，如果相同那么再对数据和 Write Counter 的组合进行签名，然后和 Host 发送过来的签名进行比较，如果签名相同则鉴权通过，将数据写入到 RPMB 中。</li>
</ol>
<p>通过上述的写入流程，可以保证 RPMB 不会被非法篡改。</p>
<p>更多 RPMB 相关的细节，可以参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_rpmb.html" target="_blank" rel="noopener">eMMC RPMB</a> 章节。</p>
<h2 id="4-General-Purpose-Partitions"><a href="#4-General-Purpose-Partitions" class="headerlink" title="4. General Purpose Partitions"></a>4. General Purpose Partitions</h2><p>eMMC 提供了 General Purpose Partitions (GPP)，主要用于存储系统和应用数据。在很多使用 eMMC 的产品中，GPP 都没有被启用，因为它在功能上与 UDA 类似，产品上直接使用 UDA 就可以满足需求。</p>
<h3 id="4-1-容量大小"><a href="#4-1-容量大小" class="headerlink" title="4.1 容量大小"></a>4.1 容量大小</h3><p>eMMC 最多可以支持 4 个 GPPs，每一个 GPP 的大小可以单独配置。用户可以通过设定 Extended CSD register 的以下三个 Field 来设 GPPx (x=1~4) 的容量大小：</p>
<ul>
<li>GP_SIZE_MULT_x_2</li>
<li>GP_SIZE_MULT_x_1</li>
<li>GP_SIZE_MULT_x_0</li>
</ul>
<p>GPPx 的容量计算公式如下：</p>
<p>Size = (GP_SIZE_MULT_x_2 * 2^16 + GP_SIZE_MULT_x_1 * 2^8 + GP_SIZE_MULT_x_0 * 2^0) * (Write protect group size)</p>
<p>Write protect group size = 512KB * HC_ERASE_GRP_SIZE * HC_WP_GRP_SIZE</p>
<blockquote>
<ul>
<li>eMMC 中，擦除和写保护都是按块进行的，上述表达式中的 HC_WP_GRP_SIZE 为写保护的操作块大小，HC_ERASE_GRP_SIZE 则为擦除操作的快的大小。</li>
<li>eMMC 芯片的 GPP 的配置通常是只能进行一次 (OTP)，一般会在产品量产阶段，在产线上进行。</li>
</ul>
</blockquote>
<h3 id="4-2-分区属性"><a href="#4-2-分区属性" class="headerlink" title="4.2 分区属性"></a>4.2 分区属性</h3><p>eMMC 标准中，为 GPP 定义了两类属性，Enhanced attribute 和 Extended attribute。每个 GPP 可以设定两类属性中的一种属性，不可以同时设定多个属性。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/gpp_attributes.png" alt="img"></p>
<p><strong>Enhanced attribute</strong></p>
<ul>
<li>Default, 未设定 Enhanced attribute。</li>
<li>Enhanced storage media， 设定 GPP 为 Enhanced storage media。</li>
</ul>
<p>在 eMMC 标准中，实际上并未定义设定 Enhanced attribute 后对 eMMC 的影响。Enhanced attribute 的具体作用，由芯片制造商定义。<br>在实际的产品中，设定 Enhanced storage media 后，一般是把该分区的存储介质从 MLC 改变为 SLC，提高该分区的读写性能、寿命以及稳定性。由于 1 个存储单元下，MLC 的容量是 SLC 的两倍，所以在总的存储单元数量一定的情况下，如果把原本为 MLC 的分区改变为 SLC，会减少 eMMC 的容量，就是说，此时 eMMC 的实际总容量比标称的总容量会小一点。（MLC 和 SLC 的细节可以参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/index.html" target="_blank" rel="noopener">Flash Memory</a> 章节内容）</p>
<p><strong>Extended attribute</strong></p>
<ul>
<li>Default, 未设定 Extended attribute。</li>
<li>System code， 设定 GPP 为 System code 属性，该属性主要用在存放操作系统类的、很少进行擦写更新的分区。</li>
<li>Non-Persistent，设定 GPP 为 Non-Persistent 属性，该属性主要用于存储临时数据的分区，例如 tmp 目录所在分区、 swap 分区等。</li>
</ul>
<p>在 eMMC 标准中，同样也没有定义设定 Extended attribute 后对 eMMC 的影响。Extended attribute 的具体作用，由芯片制造商定义。Extended attribute 主要是跟分区的应用场景有关，厂商可以为不用应用场景的分区做不同的优化处理。</p>
<h2 id="5-User-Data-Area"><a href="#5-User-Data-Area" class="headerlink" title="5. User Data Area"></a>5. User Data Area</h2><p>User Data Area (UDA) 通常是 eMMC 中最大的一个分区，是实际产品中，最主要的存储区域。</p>
<h3 id="5-1-容量大小"><a href="#5-1-容量大小" class="headerlink" title="5.1 容量大小"></a>5.1 容量大小</h3><p>UDA 的容量大小不需要设置，在配置完其他分区大小后，再扣除设置 Enhanced attribute 所损耗的容量，剩下的容量就是 UDA 的容量。</p>
<h3 id="5-2-软件分区"><a href="#5-2-软件分区" class="headerlink" title="5.2 软件分区"></a>5.2 软件分区</h3><p>为了更合理的管理数据，满足不同的应用需求，UDA 在实际产品中，会进行软件再分区。目前主流的软件分区技术有 MBR（Master Boot Record）和 GPT（GUID Partition Table）两种。这两种分区技术的基本原理类似，如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/uda_partitions.png" alt="img"></p>
<p>软件分区技术一般是将存储介质划分为多个区域，既 SW Partitions，然后通过一个 Partition Table 来维护这些 SW Partitions。在 Partition Table 中，每一个条目都保存着一个 SW Partition 的起始地址、大小等的属性信息。软件系统在启动后，会去扫描 Partition Table，获取存储介质上的各个 SW Partitions 信息，然后根据这些信息，将各个 Partitions 加载到系统中，进行数据存取。</p>
<blockquote>
<p>MBR 和 GPT 此处不展开详细介绍，更多的细节可以参考 wikipedia 上 <a href="https://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="noopener">MBR</a> 和 <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" target="_blank" rel="noopener">GPT</a> 相关介绍。</p>
</blockquote>
<h3 id="5-3-区域属性"><a href="#5-3-区域属性" class="headerlink" title="5.3 区域属性"></a>5.3 区域属性</h3><p>eMMC 标准中，支持为 UDA 中一个特定大小的区域设定 Enhanced attribute。与 GPP 中的 Enhanced attribute 相同，eMMC 标准也没有定义该区域设定 Enhanced attribute 后对 eMMC 的影响。Enhanced attribute 的具体作用，由芯片制造商定义。</p>
<p><strong>Enhanced attribute</strong></p>
<ul>
<li>Default, 未设定 Enhanced attribute。</li>
<li>Enhanced storage media， 设定该区域为 Enhanced storage media。</li>
</ul>
<p>在实际的产品中，UDA 区域设定为 Enhanced storage media 后，一般是把该区域的存储介质从 MLC 改变为 SLC。通常，产品中可以将某一个 SW Partition 设定为 Enhanced storage media，以获得更好的性能和健壮性。</p>
<h2 id="6-eMMC-分区应用实例"><a href="#6-eMMC-分区应用实例" class="headerlink" title="6. eMMC 分区应用实例"></a>6. eMMC 分区应用实例</h2><p>在一个 Android 手机系统中，各个分区的呈现形式如下：</p>
<ul>
<li>mmcblk0 为 eMMC 的块设备;</li>
<li>mmcblk0boot0 和 mmcblk0boot1 对应两个 Boot Area Partitions;</li>
<li>mmcblk0rpmb 则为 RPMB Partition，</li>
<li>mmcblk0px 为 UDA 划分出来的 SW Partitions;</li>
<li>如果存在 GPP，名称则为 mmcblk0gp1、mmcblk0gp2、mmcblk0gp3、mmcblk0gp4;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:&#x2F; # ls &#x2F;dev&#x2F;block&#x2F;mmcblk0*</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0boot0</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0boot1</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0rpmb</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p1</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p2</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p3</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p4</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p5</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p6</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p7</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p8</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p9</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p10</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p11</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p12</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p13</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p14</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p15</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p16</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p17</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p18</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p19</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p20</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p21</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p22</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p23</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p24</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p25</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p26</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p27</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p28</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p29</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p30</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p31</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;mmcblk0p32</span><br></pre></td></tr></table></figure>

<p>每一个分区会根据实际的功能来设定名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:&#x2F; # ls -l &#x2F;dev&#x2F;block&#x2F;platform&#x2F;mtk-msdc.0&#x2F;11230000.msdc0&#x2F;by-name&#x2F;</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 boot -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p22</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 cache -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p30</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 custom -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p3</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 devinfo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p28</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 expdb -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p4</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 flashinfo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p32</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 frp -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p5</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 keystore -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p27</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 lk -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p20</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 lk2 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p21</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 logo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p23</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 md1arm7 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p17</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 md1dsp -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p16</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 md1img -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p15</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 md3img -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p18</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 metadata -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p8</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 nvdata -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p7</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 nvram -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p19</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 oemkeystore -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p12</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 para -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p2</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 ppl -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p6</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 proinfo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p13</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 protect1 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p9</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 protect2 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p10</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 recovery -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p1</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 rstinfo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p14</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 seccfg -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p11</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 secro -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p26</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 system -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p29</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 tee1 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p24</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 tee2 -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p25</span><br><span class="line">lrwxrwxrwx root root 2015-01-03 04:03 userdata -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p31</span><br></pre></td></tr></table></figure>

<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ol>
<li><a href="http://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf" target="_blank" rel="noopener">Embedded Multi-Media Card (e•MMC) Electrical Standard (5.1)</a> [PDF]</li>
<li><a href="https://en.wikipedia.org/wiki/Disk_partitioning" target="_blank" rel="noopener">Disk partitioning</a> [Web]</li>
<li><a href="https://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="noopener">Master Boot Record</a> [Web]</li>
<li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" target="_blank" rel="noopener">GUID Partition Table</a> [Web]</li>
</ol>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_partitions.html】" target="_blank" rel="noopener">www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_partitions.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC总线协议</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-eMMC-总线接口"><a href="#1-eMMC-总线接口" class="headerlink" title="1. eMMC 总线接口"></a>1. eMMC 总线接口</h2><p>eMMC 总线接口定义如下图所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_host_interfaces.png" alt="img"></p>
<p>各个信号的描述如下：</p>
<p><strong>CLK</strong></p>
<p>CLK 信号用于从 Host 端输出时钟信号，进行数据传输的同步和设备运作的驱动。<br>在一个时钟周期内，CMD 和 DAT0-7 信号上都可以支持传输 1 个比特，即 SDR (Single Data Rate) 模式。此外，DAT0-7 信号还支持配置为 DDR (Double Data Rate) 模式，在一个时钟周期内，可以传输 2 个比特。<br>Host 可以在通讯过程中动态调整时钟信号的频率（注，频率范围需要满足 Spec 的定义）。通过调整时钟频率，可以实现省电或者数据流控（避免 Over-run 或者 Under-run）功能。 在一些场景中，Host 端还可以关闭时钟，例如 eMMC 处于 Busy 状态时，或者接收完数据，进入 Programming State 时。</p>
<p><strong>CMD</strong></p>
<p>CMD 信号主要用于 Host 向 eMMC 发送 Command 和 eMMC 向 Host 发送对于的 Response。Command 和 Response 的细节会在后续章节中介绍。</p>
<p><strong>DAT0-7</strong></p>
<p>DAT0-7 信号主要用于 Host 和 eMMC 之间的数据传输。在 eMMC 上电或者软复位后，只有 DAT0 可以进行数据传输，完成初始化后，可配置 DAT0-3 或者 DAT0-7 进行数据传输，即数据总线可以配置为 4 bits 或者 8 bits 模式。</p>
<p><strong>Data Strobe</strong></p>
<p>Data Strobe 时钟信号由 eMMC 发送给 Host，频率与 CLK 信号相同，用于 Host 端进行数据接收的同步。Data Strobe 信号只能在 HS400 模式下配置启用，启用后可以提高数据传输的稳定性，省去总线 tuning 过程。</p>
<blockquote>
<p><strong>NOTE:</strong><br>Extended CSD byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h2 id="2-eMMC-总线模型"><a href="#2-eMMC-总线模型" class="headerlink" title="2. eMMC 总线模型"></a>2. eMMC 总线模型</h2><p>eMMC 总线中，可以有一个 Host，多个 eMMC Devices。总线上的所有通讯都由 Host 端以一个 Command 开发发起，Host 一次只能与一个 eMMC Device 通讯。</p>
<p>系统在上电启动后，Host 会为所有 eMMC Device 逐个分配地址（RCA，Relative device Address）。当 Host 需要和某一个 eMMC Device 通讯时，会先根据 RCA 选中该 eMMC Device，只有被选中的 eMMC Device 才会响应 Host 的 Command。</p>
<blockquote>
<p>NOTE:<br>更详细的工作原理请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html" target="_blank" rel="noopener">eMMC 工作模式</a> 章节。</p>
</blockquote>
<h3 id="2-1-速率模式"><a href="#2-1-速率模式" class="headerlink" title="2.1 速率模式"></a>2.1 速率模式</h3><p>随着 eMMC 协议的版本迭代，eMMC 总线的速率越来越高。为了兼容旧版本的 eMMC Device，所有 Devices 在上电启动或者 Reset 后，都会先进入兼容速率模式（Backward Compatible Mode）。在完成 eMMC Devices 的初始化后，Host 可以通过特定的流程，让 Device 进入其他高速率模式，目前支持以下的几种速率模式。</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Data Rate</th>
<th>Bus Width</th>
<th>Frequency</th>
<th>Max Data Transfer (x8)</th>
</tr>
</thead>
<tbody><tr>
<td>Backward Compatible</td>
<td>Single</td>
<td>x1, x4, x8</td>
<td>0-26 MHz</td>
<td>26 MB/s</td>
</tr>
<tr>
<td>High Speed SDR</td>
<td>Single</td>
<td>x1, x4, x8</td>
<td>0-52 MHz</td>
<td>52 MB/s</td>
</tr>
<tr>
<td>High Speed DDR</td>
<td>Dual</td>
<td>x4, x8</td>
<td>0-52 MHz</td>
<td>104 MB/s</td>
</tr>
<tr>
<td>HS200</td>
<td>Single</td>
<td>x4, x8</td>
<td>0-200 MHz</td>
<td>200 MB/s</td>
</tr>
<tr>
<td>HS400</td>
<td>Dual</td>
<td>x8</td>
<td>0-200 MHz</td>
<td>400 MB/s</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>NOTE:</strong><br>Extended CSD byte[185] HS_TIMING 寄存器可以配置总线速率模式<br>Extended CSD byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h3 id="2-2-通信模型"><a href="#2-2-通信模型" class="headerlink" title="2.2 通信模型"></a>2.2 通信模型</h3><p>Host 与 eMMC Device 之间的通信都是由 Host 以一个 Command 开始发起的，eMMC Device 在完成 Command 所指定的任务后，则返回一个 Response。</p>
<h4 id="2-2-1-Read-Data"><a href="#2-2-1-Read-Data" class="headerlink" title="2.2.1 Read Data"></a>2.2.1 Read Data</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/multi_block_read.png" alt="img"></p>
<p>Host 从 eMMC Device 读取数据的流程如上图所示。</p>
<p>如果 Host 发送的是 Single Block Read 的 Command，那么 eMMC Device 只会发送一个 Block 的数据（一个 Block 的数据的字节数由 Host 设定或者为 eMMC Device 的默认值，更多细节请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html" target="_blank" rel="noopener">eMMC 工作模式</a> 章节）。<br>如果 Host 发送的是 Multiple Block Read 的 Command，那么 eMMC Device 会持续发送数据，直到 Host 主动发送 Stop Command。</p>
<blockquote>
<p><strong>NOTE:</strong><br>从 eMMC Device 读数据都是按 Block 读取的。</p>
</blockquote>
<h4 id="2-2-2-Write-Data"><a href="#2-2-2-Write-Data" class="headerlink" title="2.2.2 Write Data"></a>2.2.2 Write Data</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/multi_block_write.png" alt="img"></p>
<p>Host 向 eMMC Device 写入数据的流程如上图所示。</p>
<p>如果 Host 发送的是 Single Block Write Command，那么 eMMC Device 只会将后续第一个 Block 的数据写入的存储器中。<br>如果 Host 发送的是 Multiple Block Write Command，那么 eMMC Device 会持续地将接收到的数据写入到存储器中，直到 Host 主动发送 Stop Command。</p>
<p>eMMC Device 在接收到一个 Block 的数据后，会进行 CRC 校验，然后将校验结果通过 CRC Token 发送给 Host。<br>发送完 CRC Token 后，如果 CRC 校验成功，eMMC Device 会将数据写入到内部存储器时，此时 DAT0 信号会拉低，作为 Busy 信号。Host 会持续检测 DAT0 信号，直到为高电平时，才会接着发送下一个 Block 的数据。如果 CRC 校验失败，那么 eMMC Device 不会进行数据写入，此次传输后续的数据都会被忽略。</p>
<blockquote>
<p><strong>NOTE:</strong><br>向 eMMC Device 写数据都是按 Block 写入的。</p>
</blockquote>
<h4 id="2-2-3-No-Data"><a href="#2-2-3-No-Data" class="headerlink" title="2.2.3 No Data"></a>2.2.3 No Data</h4><p>在 Host 与 eMMC Device 的通信中，有部分交互是不需要进行数据传输的，还有部分交互甚至不需要 eMMC Device 的回复 Response。</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/no_resp_or_data.png" alt="img"></p>
<h4 id="2-2-4-Command"><a href="#2-2-4-Command" class="headerlink" title="2.2.4 Command"></a>2.2.4 Command</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/command_token_format.png" alt="img"></p>
<p>如上图所示，eMMC Command 由 48 Bits 组成，各个 Bits 的解析如下所示：</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>Start Bit</th>
<th>Transmission Bit</th>
<th>Command Index</th>
<th>Argument</th>
<th>CRC7</th>
<th>End Bit</th>
</tr>
</thead>
<tbody><tr>
<td>Bit position</td>
<td>47</td>
<td>46</td>
<td>[45:40]</td>
<td>[39:8]</td>
<td>[7:1]</td>
<td>0</td>
</tr>
<tr>
<td>Width (bits)</td>
<td>1</td>
<td>1</td>
<td>6</td>
<td>32</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>Value</td>
<td>“0”</td>
<td>“1”</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>“1”</td>
</tr>
</tbody></table>
<p>Start Bit 固定为 “0”，在没有数据传输的情况下，CMD 信号保持高电平，当 Host 将 Start Bit 发送到总线上时，eMMC Device 可以很方便检测到该信号，并开始接收 Command。</p>
<p>Transmission Bit 固定为 “1”，指示了该数据包的传输方向为 Host 发送到 eMMC Device。</p>
<p>Command Index 和 Argument 为 Command 的具体内容，不同的 Command 有不同的 Index，不同的 Command 也有各自的 Argument。 更多的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_commands.html" target="_blank" rel="noopener">eMMC Commands</a> 章节。</p>
<p>CRC7 是包含 Start Bit、Transmission Bit、 Command Index 和 Argument 内容的 CRC 校验值。</p>
<p>End Bit 为结束标志位，固定为”1”。</p>
<blockquote>
<p><strong>NOTE:</strong><br>CRC 校验简单来说，是发送方将需要传输的数据“除于”（模2除）一个约定的数，并将得到的余数附在数据上一并发送出去。接收方收到数据后，再做同样的“除法”，然后校验得到余数是否与接收的余数相同。如果不相同，那么意味着数据在传输过程中发生了改变。更多的细节不在本文展开描述，感兴趣的读者可以参考 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC wiki</a> 中的介绍。</p>
</blockquote>
<h4 id="2-2-5-Response"><a href="#2-2-5-Response" class="headerlink" title="2.2.5 Response"></a>2.2.5 Response</h4><p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/respone_token_format.png" alt="img"></p>
<p>eMMC Response 有两种长度的数据包，分别为 48 Bits 和 136 Bits。</p>
<p>Start Bit 与 Command 一样，固定为 “0”，在没有数据传输的情况下，CMD 信号保持高电平，当 eMMC Device 将 Start Bit 发送到总线上时，Host 可以很方便检测到该信号，并开始接收 Response。</p>
<p>Transmission Bit 固定为 “0”，指示了该数据包的传输方向为 eMMC Device 发送到 Host。</p>
<p>Content 为 Response 的具体内容，不同的 Command 会有不同的 Content。 更多的细节，请参考 <a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_responses.html" target="_blank" rel="noopener">eMMC Responses</a> 章节。</p>
<p>CRC7 是包含 Start Bit、Transmission Bit 和 Content 内容的 CRC 校验值。</p>
<p>End Bit 为结束标志位，固定为”1”。</p>
<h4 id="2-2-6-Data-Block"><a href="#2-2-6-Data-Block" class="headerlink" title="2.2.6 Data Block"></a>2.2.6 Data Block</h4><p>Data Block 由 Start Bit、Data、CRC16 和 End Bit 组成。以下是不同总线宽度和 Data Rate 下，Data Block 详细格式。</p>
<p><strong>1 Bit Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/1_bit_bus_sdr.png" alt="img"></p>
<p>CRC 为 Data 的 16 bit CRC 校验值，不包含 Start Bit。</p>
<p><strong>4 Bits Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/4_bits_bus_sdr.png" alt="img"></p>
<p>各个 Data Line 上的 CRC 为对应 Data Line 的 Data 的 16 bit CRC 校验值。</p>
<p><strong>8 Bits Bus SDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/8_bits_bus_sdr.png" alt="img"></p>
<p>各个 Data Line 上的 CRC 为对应 Data Line 的 Data 的16 bit CRC 校验值。</p>
<p><strong>4 Bits Bus DDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/4_bits_bus_ddr.png" alt="img"></p>
<p><strong>8 Bits Bus DDR</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/8_bits_bus_ddr.png" alt="img"></p>
<p>在 DDR 模式下，Data Line 在时钟的上升沿和下降沿都会传输数据，其中上升沿传输数据的奇数字节 （Byte 1,3,5 …），下降沿则传输数据的偶数字节（Byte 2,4,6 …）。<br>此外，在 DDR 模式下，1 个 Data Line 上有两个相互交织的 CRC16，上升沿的 CRC 比特组成 odd CRC16，下降沿的 CRC 比特组成 even CRC16。odd CRC16 用于校验该 Data Line 上所有上升沿比特组成的数据，even CRC16 则用于校验该 Data Line 上所有下降沿比特组成的数据。</p>
<blockquote>
<p><strong>NOTE:</strong><br>DDR 模式下使用两个 CRC16 作为校验，可能是为了更可靠的校验，选用 CRC16 而非 CRC32 则可能是出于兼容性设计的考虑。</p>
</blockquote>
<h4 id="2-2-7-CRC-Status-Token"><a href="#2-2-7-CRC-Status-Token" class="headerlink" title="2.2.7 CRC Status Token"></a>2.2.7 CRC Status Token</h4><p>在写数据传输中，eMMC Device 接收到 Host 发送的一个 Data Block 后，会进行 CRC 校验，如果校验成功，eMMC 会在对应的 Data Line 上向 Host 发回一个 Positive CRC status token (010)，如果校验失败，则会在对应的 Data Line 上发送一个 Negative CRC status token (101)。</p>
<blockquote>
<p><strong>NOTE:</strong><br>读数据时，Host 接收到 eMMC Device 发送的 Data Block 后，也会进行 CRC 校验，但是不管校验成功或者失败，都不会向 eMMC Device 发送 CRC Status Token。</p>
</blockquote>
<p>详细格式如下图所示：</p>
<p><strong>Positive CRC status token</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/positive_crc_status_token.png" alt="img"></p>
<p><strong>Negative CRC status token</strong></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/negative_crc_status_token.png" alt="img"></p>
<h2 id="3-eMMC-总线测试过程"><a href="#3-eMMC-总线测试过程" class="headerlink" title="3. eMMC 总线测试过程"></a>3. eMMC 总线测试过程</h2><p>当 eMMC Device 处于 SDR 模式时，Host 可以发送 CMD19 命令，触发总线测试过程（Bus testing procedure），测试总线硬件上的连通性。如果 eMMC Device 支持总线测试，那么 eMMC Device 在接收到 CMD19 后，会发回对应的 Response，接着 eMMC Device 会发送一组固定的测试数据给 Host。Host 接收到数据后，检查数据正确与否，即可得知总线是否正确连通。</p>
<blockquote>
<p><strong>NOTE:</strong> 如果 eMMC Device 不支持总线测试，那么接收到 CMD19 时，不会发回 Response。<br>总线测试不支持在 DDR 模式下进行。</p>
</blockquote>
<p>测试数据如下所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/bus_testing_data.png" alt="img"></p>
<blockquote>
<p><strong>NOTE:</strong> 总线宽度为 1 时，只发送 DAT0 上的数据，总线宽度为 4 时，则只发送 DAT0-3 上的数据</p>
</blockquote>
<h2 id="4-eMMC-总线-Sampling-Tuning"><a href="#4-eMMC-总线-Sampling-Tuning" class="headerlink" title="4. eMMC 总线 Sampling Tuning"></a>4. eMMC 总线 Sampling Tuning</h2><p>由于芯片制造工艺、PCB 走线、电压、温度等因素的影响，数据信号从 eMMC Device 到达 Host 端的时间是存在差异的，Host 接收数据时采样的时间点也需要相应的进行调整。而 Host 端最佳采样时间点，则是通过 Sampling Tuning 流程得到。</p>
<blockquote>
<p><strong>NOTE:</strong><br>不同 eMMC Device 最佳的采样点可能不同，同一 eMMC Device 在不同的环境下运作时的最佳采样点也可能不同。<br>在 eMMC 标准中，定义了在 HS200 模式下可以进行 Sampling Tuning。</p>
</blockquote>
<h3 id="4-1-Sampling-Tuning-流程"><a href="#4-1-Sampling-Tuning-流程" class="headerlink" title="4.1 Sampling Tuning 流程"></a>4.1 Sampling Tuning 流程</h3><p>Sampling Tuning 是用于计算 Host 最佳采样时间点的流程，大致的流程如下：</p>
<ol>
<li>Host 将采样时间点重置为默认值</li>
<li>Host 向 eMMC Device 发送 Send Tuning Block 命令</li>
<li>eMMC Device 向 Host 发送固定的 Tuning Block 数据</li>
<li>Host 接收到 Tuning Block 并进行校验</li>
<li>Host 修改采样时点，重新从第 2 步开始执行，直到 Host 获取到一个有效采样时间点区间</li>
<li>Host 取有效采样时间点区间的中间值作为采样时间点，并推出 Tuning 流程</li>
</ol>
<blockquote>
<p><strong>NOTE:</strong><br>上述流程仅仅是一个示例。Tuning 流程执行的时机、频率和具体的步骤是由 Host 端的 eMMC Controller 具体实现而定的。</p>
</blockquote>
<h3 id="4-2-Tuning-Block-数据"><a href="#4-2-Tuning-Block-数据" class="headerlink" title="4.2 Tuning Block 数据"></a>4.2 Tuning Block 数据</h3><p>Tuning Block 是专门为了 Tuning 而设计的一组特殊数据。相对于普通的数据，这组特殊数据在传输过程中，会更高概率的出现 high SSO noise、deterministic jitter、ISI、timing errors 等问题。这组数据的具体内容如下所示：</p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/tuning_block_pattern.png" alt="img"></p>
<p><img src="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/tuning_block_on_data_lines.png" alt="img"></p>
<blockquote>
<p><strong>NOTE:</strong> 总线宽度为 1 时，只发送 DAT0 上的数据，总线宽度为 4 时，则只发送 DAT0-3 上的数据</p>
</blockquote>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ol>
<li><a href="http://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf" target="_blank" rel="noopener">Embedded Multi-Media Card (e•MMC) Electrical Standard (5.1)</a> [PDF]</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.296.5338&rep=rep1&type=pdf" target="_blank" rel="noopener">SD/MMC Controller, Hard Processor System (HPS) Technical Reference Manual (TRM)</a> [PDF]</li>
<li><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">CRC wiki</a> [WEB]</li>
</ol>
<p><strong>注</strong>：本文转自蜗窝科技<a href="http://www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_bus_protocol.html】" target="_blank" rel="noopener">www.wowotech.net，来自【http://www.wowotech.net/basic_tech/emmc_bus_protocol.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux EMMC子系统分析-初始化流程</title>
    <url>/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Linux%20EMMC%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://blog.csdn.net/kickxxx/article/details/51130888】" target="_blank" rel="noopener">https://blog.csdn.net/kickxxx/article/details/51130888】</a></p>
<p>最近在解EMMC的一个bug，发现Linux EMMC有点小复杂，先整理个文档出来吧</p>
<p>用的是TI 平台，仅分析MMC，不分析SD和SDIO</p>
<h1 id="mmc-init"><a href="#mmc-init" class="headerlink" title="mmc_init"></a>mmc_init</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2769 static int __init mmc_init(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2770 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2774 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2775     workqueue = alloc_ordered_workqueue("kmmcd", 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2776     if (!workqueue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2777         return -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2778 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2779     ret = mmc_register_bus();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2780     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2781         goto destroy_workqueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2782 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2783     ret = mmc_register_host_class();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2784     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2785         goto unregister_bus;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2793 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2802 &#125;</span><br></pre></td></tr></table></figure>



<p>2775分配一个workqueue，这个workqueue是专门用来处理card detect的，EMMC因为是unremovable的，所以不需要关注它</p>
<p>2779 注册mmc_bus_type，实现如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">int mmc_register_bus(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return bus_register(&amp;mmc_bus_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把mmc_bus_type注册到bus系统，后面调用device_add函数时，则会辗转调用到mmc_bus_type中的probe函数，不必太纠结在这个代码</p>
<p>mmc_init调用时间比较早，会在host驱动初始化之前执行完。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">subsys_initcall(mmc_init);</span><br></pre></td></tr></table></figure>



<h1 id="host驱动初始化"><a href="#host驱动初始化" class="headerlink" title="host驱动初始化"></a>host驱动初始化</h1><p>kernel/drivers/mmc/host/omap_hsmmc.c</p>
<p>host驱动位置是kernel/drivers/mmc/host/，一般来说都是platform_driver，以omap hsmmc host驱动为例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>.probe      = omap_hsmmc_probe,<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .remove     = omap_hsmmc_remove,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .driver     = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .name = DRIVER_NAME,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .pm = &amp;omap_hsmmc_dev_pm_ops,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .of_match_table = of_match_ptr(omap_mmc_of_match),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_platform_driver(omap_hsmmc_driver);</span><br></pre></td></tr></table></figure>



<p>只需要关注omap_hsmmc_probe即可，当系统匹配到platform_device时，会调用omap_hsmmc_probe，好长的一个函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2627     base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2628     if (IS_ERR(base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2629         return PTR_ERR(base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2630 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2631     ret = omap_hsmmc_gpio_init(pdata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2632     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2633         goto err;</span><br></pre></td></tr></table></figure>

<p>devm_ioremap_resource，实质就是ioremap，设备特定io资源到内核地址的映射，自行脑补一下ioremap。</p>
<p>omap_hsmmc_gpio_init是card detect和write protect gpio的初始化，Ignore it!!!</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2635     mmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2636     if (!mmc) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2637         ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2638         goto err_alloc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2639     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...............</span><br></pre></td></tr></table></figure>

<p>mmc_alloc_host，分配一个omap_hsmmc_host结构(包含struct mmc_host)，以供后面玩耍</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2661     mmc-&gt;ops    = &amp;omap_hsmmc_ops;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2410 static const struct mmc_host_ops omap_hsmmc_ops = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2411     .enable = omap_hsmmc_enable_fclk,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2412     .disable = omap_hsmmc_disable_fclk,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2413     .post_req = omap_hsmmc_post_req,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2414     .pre_req = omap_hsmmc_pre_req,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2415     .request = omap_hsmmc_request,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2416     .set_ios = omap_hsmmc_set_ios,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2417     .get_cd = omap_hsmmc_get_cd,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2418     .get_ro = omap_hsmmc_get_ro,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2419     .init_card = omap_hsmmc_init_card,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2420     .start_signal_voltage_switch = omap_start_signal_voltage_switch,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2421     .card_busy = omap_hsmmc_card_busy,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2422     .execute_tuning = omap_execute_tuning,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2423     /* NYET -- enable_sdio_irq */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2424 &#125;;</span><br></pre></td></tr></table></figure>

<p> omap hsmmc host驱动和mmc子系统的所有接口都在这里了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2663     mmc-&gt;f_min = OMAP_MMC_MIN_CLOCK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2675     if (pdata-&gt;max_freq &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2676         mmc-&gt;f_max = pdata-&gt;max_freq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2677         ret = clk_set_rate(host-&gt;fclk, pdata-&gt;max_freq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2678         if (ret) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2679             dev_err(dev, "failed to set clock to %d\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2680                 pdata-&gt;max_freq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2681             goto err1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2682         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2683     &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2684         mmc-&gt;f_max = OMAP_MMC_MAX_CLOCK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2685     &#125;</span><br></pre></td></tr></table></figure>

<p>定义了最小时钟400K，在系统初始化阶段为了兼容的原因会使用这个时钟。最大时钟为52MHZ，后面还有机会再修改这个时钟频率。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2724     mmc-&gt;max_segs = 1024;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2725 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2726     mmc-&gt;max_blk_size = 512;       /* Block Length at max can be 1024 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2727     mmc-&gt;max_blk_count = 0xFFFF;    /* No. of Blocks is 16 bits */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2728     mmc-&gt;max_req_size = mmc-&gt;max_blk_size * mmc-&gt;max_blk_count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2729     mmc-&gt;max_seg_size = mmc-&gt;max_req_size;</span><br></pre></td></tr></table></figure>



<p>mmc作为快设备，最主要的操作就是数据sectors读写，max_segs定义了block设备的request所支持的最大segment</p>
<p>max_blk_count 一个request中所包含的最大block数</p>
<p>其实多少都不重要，反正就是和request相关的一些上限。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2731     mmc-&gt;caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2732              MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2733 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2734     mmc-&gt;caps |= mmc_slot(host).caps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2735     if (mmc-&gt;caps &amp; MMC_CAP_8_BIT_DATA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2736         mmc-&gt;caps |= MMC_CAP_4_BIT_DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2737     if (mmc_slot(host).nonremovable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2738         mmc-&gt;caps |= MMC_CAP_NONREMOVABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2741 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2742     if (of_property_read_bool(np, "sd-uhs-sdr12"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2743         mmc-&gt;caps |= MMC_CAP_UHS_SDR12;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2744     if (of_property_read_bool(np, "sd-uhs-sdr25"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2745         mmc-&gt;caps |= MMC_CAP_UHS_SDR25;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2746     if (of_property_read_bool(np, "sd-uhs-sdr50"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2747         mmc-&gt;caps |= MMC_CAP_UHS_SDR50;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2748     if (of_property_read_bool(np, "sd-uhs-sdr104"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2749         mmc-&gt;caps |= MMC_CAP_UHS_SDR104;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2750     if (of_property_read_bool(np, "sd-uhs-ddr50"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2751         mmc-&gt;caps |= MMC_CAP_UHS_DDR50;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2752     if (of_property_read_bool(np, "mmc-ddr-1_8v"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2753         mmc-&gt;caps |= MMC_CAP_1_8V_DDR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2754     if (of_property_read_bool(np, "mmc-hs200-1_8v"))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2755         mmc-&gt;caps2 |= MMC_CAP2_HS200_1_8V_SDR;</span><br></pre></td></tr></table></figure>

<p>mmc-&gt;caps 表示host能力的标志，mmc-&gt;caps2 表示host更多的能力，也许有一天会添加mmc-&gt;caps3这个字段</p>
<p>MMCCAP_MMC_HIGHSPEED, MMC_CAP_SD_HIGHSPEED MMC_CAP_WAIT_WHILE_BUSY MMC_CAP_ERASE是最基本的能力</p>
<p>MMC_CAP_8_BIT_DATA表示数据总线是多少，EMMC 数据线支持8线，4线和1线。</p>
<p>2742 ~ 2755 通过of系统定义的一些特定能力，当前MMC_CAP_1_8V_DDR，MMC_CAP2_HS200_1_8V_SDR都很常见了。DDR是Double Date Rate的缩写，SDR是Single Data Rate的缩写</p>
<p>自行脑补百度资料DDR SDRAM， EMMC的DDR SDR与之类似。</p>
<p>DDR=Double Data Rate双倍速率同步动态随机存储器。严格的说DDR应该叫DDR SDRAM，人们习惯称为DDR，其中，SDRAM 是Synchronous Dynamic Random Access Memory的缩写，<br>即同步动态随机存取存储器。而DDR SDRAM是Double Data Rate SDRAM的缩写，是双倍速率同步动态随机存储器的意思。DDR内存是在SDRAM内存基础上发展而来的，仍然沿用SDRAM生产体系，<br>一个时钟周期内进行两次读/写操作，即在时钟的上升沿和下降沿分别执行一次读/写操作。</p>
<p>因此对于内存厂商而言，只需对制造普通SDRAM的设备稍加改进，即可实现DDR内存的生产，可有效的降低成本。Double Data Rate：与传统的单数据速率相比，DDR技术实现了一个时钟周期内进行两次读/写操作，即在时钟的上升沿和下降沿分别执行一次读/写操作。</p>
<p>注意对于EMMC CMD线来说，是没有DDR SDR说法的，CMD和response只在clock的上升沿传输，参见EMMC spec5.0 section 6.15.1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2773     omap_hsmmc_conf_bus_power(host);</span><br></pre></td></tr></table></figure>

<p>设置EMMC总线电压，EMMC芯片支持3.3V, 1.8V和1.2V总线信号电压，host需要和EMMC芯片的电压匹配（就是相同了）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2775     if (!pdev-&gt;dev.of_node) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2776         res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2777         if (!res) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2778             dev_err(mmc_dev(host-&gt;mmc), "cannot get DMA TX channel\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2779             ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2780             goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2781         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2782         tx_req = res-&gt;start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2783 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2784         res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2785         if (!res) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2786             dev_err(mmc_dev(host-&gt;mmc), "cannot get DMA RX channel\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2787             ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2788             goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2789         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2790         rx_req = res-&gt;start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2791     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2792 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2793     dma_cap_zero(mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2794     dma_cap_set(DMA_SLAVE, mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2795 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2796     host-&gt;rx_chan =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2797         dma_request_slave_channel_compat(mask, omap_dma_filter_fn,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2798                          &amp;rx_req, &amp;pdev-&gt;dev, "rx");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2799 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2800     if (!host-&gt;rx_chan) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2801         dev_err(mmc_dev(host-&gt;mmc), "unable to obtain RX DMA engine channel %u\n", rx_req);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2802         ret = -ENXIO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2803         goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2804     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2805 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2806     host-&gt;tx_chan =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2807         dma_request_slave_channel_compat(mask, omap_dma_filter_fn,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2808                          &amp;tx_req, &amp;pdev-&gt;dev, "tx");</span><br></pre></td></tr></table></figure>


<p>DMA相关的代码，内核中EMMC驱动必然要使用DMA方式读写数据，</p>
<p>dma_request_slave_channel_compat分配一个DMA channel</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2816     /* Request IRQ for MMC operations */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2817     ret = devm_request_irq(&amp;pdev-&gt;dev, host-&gt;irq, omap_hsmmc_irq, 0,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2818             mmc_hostname(mmc), host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2819     if (ret) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2820         dev_err(mmc_dev(host-&gt;mmc), "Unable to grab HSMMC IRQ\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2821         goto err_irq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2822     &#125;</span><br></pre></td></tr></table></figure>

<p>设置中断处理函数，omap_hsmmc_irq负责处理EMMC 命令和EMMC DMA数据传输。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2864     mmc_add_host(mmc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drivers/mmc/core/host.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">538 int mmc_add_host(struct mmc_host *host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">539 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">557     mmc_start_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">562 &#125;</span><br></pre></td></tr></table></figure>

<p>初始换mmc host硬件，mmc_start_host会负责扫描mmc设备</p>
<p>mmc_start_host-&gt;_mmc_detect_change -&gt; mmc_rescan -&gt;mmc_rescan_try_freq，对于REMOVALBE设备，rescan可以进行多次，而对于mmc这样的NON-REMOVABLE设备，只需扫描一次即可。</p>
<p>host会使用不同的频率发送命令到device，因此这个函数也是尝试设置f_init的过程</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2362 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2363 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2364     host-&gt;f_init = freq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2365 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2371     mmc_power_up(host, host-&gt;ocr_avail);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2372 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2389     /* Order's important: probe SDIO, then SD, then MMC */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2390     if (!mmc_attach_sdio(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2391         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2392     if (!mmc_attach_sd(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2393         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2394     if (!mmc_attach_mmc(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2395         printk(KERN_ERR "%s: end, host-&gt;index=%d\n", __func__, host-&gt;index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2396         return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2397     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2401 &#125;</span><br></pre></td></tr></table></figure>

<p>分别用400K 300K 200K 100K 频率尝试和device通信，不过400K就会成功</p>
<p>mmc_power_up Power_up流程，可参见MMC spec5.0 A6.1，首先设置总线操作电压，然后设置clock</p>
<p>mmc_attach_mmc: mmc 卡初始化函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1785 int mmc_attach_mmc(struct mmc_host *host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1786 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1792    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1794     /* Set correct bus mode for MMC before attempting attach */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1795     if (!mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1796         mmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1797 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1798     err = mmc_send_op_cond(host, 0, &amp;ocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1799     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1800         return err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1804 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1805     mmc_attach_bus_ops(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1806     if (host-&gt;ocr_avail_mmc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1807         host-&gt;ocr_avail = host-&gt;ocr_avail_mmc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1808 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1817 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1818     rocr = mmc_select_voltage(host, ocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1819 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1827 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1828     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1829      * Detect and init the card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1830      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1831     err = mmc_init_card(host, rocr, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1832     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1833         goto err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1834 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1835     mmc_release_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1836     err = mmc_add_card(host-&gt;card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1837     mmc_claim_host(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1838     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1839         goto remove_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1840 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1842     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1856 &#125;</span><br></pre></td></tr></table></figure>

<p>mmc_send_op_cond等待device完成power up过程</p>
<p>mmc_select_voltage检查前面获得的ocr，判断ocr中标称的电压，返回的ocr为处理过的ocr</p>
<p>mmc_init_card 会读取cid csd ext_csd，并根据这些寄存器的值做一些初始化操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">133 int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">134 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">135     struct mmc_command cmd = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">136     int i, err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">139 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">140     cmd.opcode = MMC_SEND_OP_COND;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">141     cmd.arg = mmc_host_is_spi(host) ? 0 : ocr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">142     cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">143 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">144     for (i = 100; i; i--) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">145         err = mmc_wait_for_cmd(host, &amp;cmd, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">146         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">147             break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">148 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">149         /* if we're just probing, do a single pass */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">150         if (ocr == 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">151             break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">152 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">153         /* otherwise wait until reset completes */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">154         if (mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">155             if (!(cmd.resp[0] &amp; R1_SPI_IDLE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">156                 break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">157         &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">158             if (cmd.resp[0] &amp; MMC_CARD_BUSY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">159                 break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">160         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">161 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">162         err = -ETIMEDOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">163 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">164         mmc_delay(10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">165     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">166 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">167     if (rocr &amp;&amp; !mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">168         *rocr = cmd.resp[0];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">169 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">170     return err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">171 &#125;</span><br></pre></td></tr></table></figure>

<p>145 发送CMD1并等待R3</p>
<p>158 如果发现ocr的最高位为1，表示mmc device已经完成power up，否则循环发送CMD1，直到mmc device 完成power up</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> 969 static int mmc_init_card(struct mmc_host *host, u32 ocr,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 970     struct mmc_card *oldcard)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 971 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 995 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 996     /* The extra bit indicates that we support high capacity */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 997     err = mmc_send_op_cond(host, ocr | (1 &lt;&lt; 30), &amp;rocr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 998     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 999         goto err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1000 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1010     /* </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1011      * Fetch CID from card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1012      */        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1013     if (mmc_host_is_spi(host))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1014         err = mmc_send_cid(host, cid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1015     else</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1016         err = mmc_all_send_cid(host, cid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1017     if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1018         goto err;</span><br></pre></td></tr></table></figure>

<p>997 ocr | (1 &lt;&lt; 30) 表示驱动支持的是sector模式，Linux EMMC 子系统强制使用sector模式。</p>
<p>1016 mmc_all_send_cid 发送CMD10，并等待device 返回R2。CMD10请求设备发送CID给host</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1047     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1048      * For native busses:  set card RCA and quit open drain mode.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1049      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1050     if (!mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1051         err = mmc_set_relative_addr(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1052         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1053             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1054 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1055         mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1056     &#125;</span><br></pre></td></tr></table></figure>

<p>对于本地总线，也就是相对于spi emmc总线，需要设置emmc chip地址，并且设置总线模式为PUSHPULL</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1058     if (!oldcard) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1059         /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1060          * Fetch CSD from card.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1061          */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1062         err = mmc_send_csd(card, card-&gt;raw_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1063         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1064             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1065 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1066         err = mmc_decode_csd(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1067         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1068             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1069         err = mmc_decode_cid(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1070         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1071             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1072     &#125;</span><br></pre></td></tr></table></figure>

<p>1062 发送MMC_SEND_CSD CMD9获取设备csd寄存器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1077     if (!mmc_host_is_spi(host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1078         err = mmc_select_card(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1079         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1080             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1081     &#125;</span><br></pre></td></tr></table></figure>

<p> 1078 发送MMC_SELECT_CARD CMD7选择设备，device的状态会从standby状态转化为transfer状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1083     if (!oldcard) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1084         /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1085          * Fetch and process extended CSD.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1086          */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1087 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1088         err = mmc_get_ext_csd(card, &amp;ext_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1089         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1090             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1091         err = mmc_read_ext_csd(card, ext_csd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1092         if (err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1093             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1094 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1095         /* If doing byte addressing, check if required to do sector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1096          * addressing.  Handle the case of <span class="tag">&lt;<span class="name">2GB</span> <span class="attr">cards</span> <span class="attr">needing</span> <span class="attr">sector</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1097</span>          * <span class="attr">addressing.</span>  <span class="attr">See</span> <span class="attr">section</span> <span class="attr">8.1</span> <span class="attr">JEDEC</span> <span class="attr">Standard</span> <span class="attr">JED84-A441</span>;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1098</span>          * <span class="attr">ocr</span> <span class="attr">register</span> <span class="attr">has</span> <span class="attr">bit</span> <span class="attr">30</span> <span class="attr">set</span> <span class="attr">for</span> <span class="attr">sector</span> <span class="attr">addressing.</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">1099</span>          */</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">1100         if (!(mmc_card_blockaddr(card)) &amp;&amp; (rocr &amp; (1&lt;&lt;30)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1101             mmc_card_set_blockaddr(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1102 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1103         /* Erase size depends on CSD and Extended CSD */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1104         mmc_set_erase_size(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1105     &#125;</span><br></pre></td></tr></table></figure>


<p>1088 获取ext_csd，ext_csd的获取，需要发送MMC_SEND_EXT_CSD，并从data线上获取device发送回ext_csd</p>
<p>1091 解析获取的ext_csd</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1174     if (card-&gt;ext_csd.hs_max_dtr != 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1175         err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1176         if (card-&gt;ext_csd.hs_max_dtr &gt; 52000000 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1177             host-&gt;caps2 &amp; MMC_CAP2_HS200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1178             err = mmc_select_hs200(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1179         else if (host-&gt;caps &amp; MMC_CAP_MMC_HIGHSPEED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1180             err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1181                      EXT_CSD_HS_TIMING, 1,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1182                      card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1183 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1184         if (err &amp;&amp; err != -EBADMSG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1185             goto free_card;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1186 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1187         if (err) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1188             pr_warning("%s: switch to highspeed failed\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1189                    mmc_hostname(card-&gt;host));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1190             err = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1191         &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1192             if (card-&gt;ext_csd.hs_max_dtr &gt; 52000000 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1193                 host-&gt;caps2 &amp; MMC_CAP2_HS200) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1194                 mmc_card_set_hs200(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1195                 mmc_set_timing(card-&gt;host,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1196                            MMC_TIMING_MMC_HS200);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1198             &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1199                 mmc_card_set_highspeed(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1200                 mmc_set_timing(card-&gt;host, MMC_TIMING_MMC_HS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1202             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1203         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1204     &#125;</span><br></pre></td></tr></table></figure>

<p>ext_csd.hs_max_dtr已经在mmc_select_card_type中设置为可支持的最大速度，这个值是由ext_csd[CARD_TYPE]以及host-caps2来决定的。比如host支持HS200，device 也支持HS200</p>
<p>那么理论上总线应该能跑到HS200，此时就设置ext_csd.hs_max_dtr为MMC_HS200_MAX_DTR</p>
<p>mmc_select_hs200设置device的timing为HS200</p>
<p>mmc_set_timing则设置host的timing 为HS200</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1211     if (mmc_card_highspeed(card) || mmc_card_hs200(card)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1212         if (max_dtr &gt; card-&gt;ext_csd.hs_max_dtr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1213             max_dtr = card-&gt;ext_csd.hs_max_dtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1214         if (mmc_card_highspeed(card) &amp;&amp; (max_dtr &gt; 52000000))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1215             max_dtr = 52000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1216     &#125; else if (max_dtr &gt; card-&gt;csd.max_dtr) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1217         max_dtr = card-&gt;csd.max_dtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1218     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1219 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1220     printk(KERN_ERR "%s: mmc_set_clock() max_dtr=%d\n", __func__, max_dtr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1221     mmc_set_clock(host, max_dtr);</span><br></pre></td></tr></table></figure>


<p>设置host的最大clock</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1267         ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1268                 EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1269         err = mmc_select_powerclass(card, ext_csd_bits);</span><br></pre></td></tr></table></figure>

<p>1269 设置device 的power class。关于power class, EMMC spec为了让host端控制EMMC芯片的耗电范围，允许host设置ext_csd的POWER_CLASS[187]来控制device的耗电行为。</p>
<p>但是低耗电带来的副作用就是性能的损失，所以linux emmc core 驱动都是性能优先。</p>
<p>mmc_add_card</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">309 int mmc_add_card(struct mmc_card *card)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">310 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">351 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">352     if (mmc_card_uhs(card) &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">353         (card-&gt;sd_bus_speed <span class="tag">&lt; <span class="attr">ARRAY_SIZE</span>(<span class="attr">uhs_speeds</span>)))</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">354</span>         <span class="attr">uhs_bus_speed_mode</span> = <span class="string">uhs_speeds[card-</span>&gt;</span>sd_bus_speed];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">355 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">356     if (mmc_host_is_spi(card-&gt;host)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">357         pr_info("%s: new %s%s%s card on SPI\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">358             mmc_hostname(card-&gt;host),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">359             mmc_card_highspeed(card) ? "high speed " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">360             mmc_card_ddr_mode(card) ? "DDR " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">361             type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">362     &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">363         pr_info("%s: new %s%s%s%s%s card at address %04x\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">364             mmc_hostname(card-&gt;host),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">365             mmc_card_uhs(card) ? "ultra high speed " :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">366             (mmc_card_highspeed(card) ? "high speed " : ""),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">367             (mmc_card_hs200(card) ? "HS200 " : ""),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">368             mmc_card_ddr_mode(card) ? "DDR " : "",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">369             uhs_bus_speed_mode, type, card-&gt;rca);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">370     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">379     ret = device_add(&amp;card-&gt;dev);</span><br></pre></td></tr></table></figure>


<p>352~370会输出mmc card的一些信息，比如high speed, HS200；DDR等</p>
<p>379会调用设备模型，增加设备，因为card属于mmc_bus，会调用mmc_bus_probe</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">110 static int mmc_bus_probe(struct device *dev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">111 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">112     int ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">113     struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">114     struct mmc_card *card = mmc_dev_to_card(dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">115 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">117     ret = drv-&gt;probe(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">118 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">120     return ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">121 &#125;</span><br></pre></td></tr></table></figure>

<p>drv-&gt;probe对应的是mmc/card/block.c中的mmc_driver-.probe</p>
<p>这样理解，每个mmc设备也是一个block设备，因此这个mmc设备，也要对应一个mmc block驱动。mmc block驱动需要调用驱动本身的probe函数，探测这个block设备</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2429 static int mmc_blk_probe(struct mmc_card *card)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2430 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2431     struct mmc_blk_data *md, *part_md;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2432     char cap_str[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2439 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2440     md = mmc_blk_alloc(card);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2441     if (IS_ERR(md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2442         return PTR_ERR(md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2443 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2444     string_get_size((u64)get_capacity(md-&gt;disk) &lt;&lt; 9, STRING_UNITS_2,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2445             cap_str, sizeof(cap_str));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2446     pr_info("%s: %s %s %s %s\n",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2447         md-&gt;disk-&gt;disk_name, mmc_card_id(card), mmc_card_name(card),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2448         cap_str, md-&gt;read_only ? "(ro)" : "");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2449 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2450     if (mmc_blk_alloc_parts(card, md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2451         goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2452 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2453     mmc_set_drvdata(card, md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2454     mmc_fixup_device(card, blk_fixups);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2455 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2456     if (mmc_add_disk(md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2457         goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2458 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2459     list_for_each_entry(part_md, &amp;md-&gt;part, part) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2460         if (mmc_add_disk(part_md))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2461             goto out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2462     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2467     /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2468      * Don't enable runtime PM for SD-combo cards here. Leave that</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2469      * decision to be taken during the SDIO init sequence instead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2470      */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2471     if (card-&gt;type != MMC_TYPE_SD_COMBO) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2472         pm_runtime_set_active(&amp;card-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2473         pm_runtime_enable(&amp;card-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2474     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2475 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2476     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2477 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2478  out:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2479     mmc_blk_remove_parts(card, md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2480     mmc_blk_remove_req(md);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2481     return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2482 &#125;</span><br></pre></td></tr></table></figure>

<p>2440 每一个mmc_card都对应一个mmc_blk_data，mmc_blk_data管理快设备相关的数据。</p>
<p>2450 mmc设备内部可能预先分配了boot partitions，以及最多四个general purpose partitions，需要为这些内置分区分配part。注意这些分区在系统中是以通用磁盘的形式存在的，并不是传统意义上的分区。</p>
<p>2456 mmc_add_disk增加mmc 设备到系统中，mmc_add_disk会调用add_disk向系统内增加通用硬盘，这个函数比较复杂，会单独开一个帖子分析add_disk的流程。</p>
<p>mmc_add_disk结束后，mmc设备的分区信息也已经添加到系统中。</p>
<p>mmc_blk_data主要实现函数是mmc_blk_alloc_req</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2074 static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2075                           struct device *parent,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2076                           sector_t size,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2077                           bool default_ro,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2078                           const char *subname,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2079                           int area_type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2080 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2116     md-&gt;disk = alloc_disk(perdev_minors);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2117     if (md-&gt;disk == NULL) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2118         ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2119         goto err_kfree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2120     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2126     ret = mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock, subname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2127     if (ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2128         goto err_putdisk;</span><br></pre></td></tr></table></figure>


<p>2116 alloc_disk分配一个gendisk结构，在linux内核中gendisk用来表示一个磁盘或者分区</p>
<p>2126 初始化该块设备的queue，从这里我们可以看出不管mmc_blk_data对应是磁盘还是分区，都会为它分配queue。这是合理的，比如我们可以通过/dev/mmcblk0访问设备，也可以通过/dev/mmcblk0p1访问设备。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>三星eMMC芯片KLM4G1FEPD-B031使用说明</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E4%B8%89%E6%98%9FeMMC%E8%8A%AF%E7%89%87KLM4G1FEPD-B031%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>三星eMMC是一种以BGA封装形式设计的嵌入式MMC解决方案。eMMC操作与MMC设备相同，因此非常简单使用MMC协议v5.0（行业标准）读取和写入内存。</p>
<p>eMMC标准规格书可以在jedec官网获取，emmc v5.1【<a href="https://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf】。" target="_blank" rel="noopener">https://www.jedec.org/sites/default/files/docs/JESD84-B51.pdf】。</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>embedded MultiMediaCard Ver. 5.0 compatible. Detail description is referenced by JEDEC Standard</li>
<li>SAMSUNG eMMC supports features of eMMC5.0 which are defined in JEDEC Standard</li>
</ul>
<p>​      – Supported Features : Packed command, Cache, Discard, Sanitize, Power Off Notification, Data Tag,<br>​      –  Partition types, Context ID, Real Time Clock, Dynamic Device Capacity, HS200, HS400,Field Firmware Update.</p>
<ul>
<li>Non-supported Features : Large Sector Size (4KB)</li>
<li>Full backward compatibility with previous MultiMediaCard system specification (1bit data bus, multi-eMMC systems)</li>
<li>Data bus width : 1bit (Default), 4bit and 8bit</li>
<li>MMC I/F Clock Frequency : 0 ~ 200MHz<br>MMC I/F Boot Frequency : 0 ~ 52MHz</li>
<li>Temperature : Operation (-25C ~ 85C), Storage without operation (-40摄氏度 ~ 85摄氏度)</li>
<li>Power : Interface power → VDD(VCCQ) (1.70V ~ 1.95V or 2.7V ~ 3.6V) , Memory power → VDDF(VCC) (2.7V ~ 3.6V)</li>
</ul>
<h2 id="芯片结构图"><a href="#芯片结构图" class="headerlink" title="芯片结构图"></a>芯片结构图</h2><p><img src="http://jiali.clouddn.com/20201225_008.png" alt=""></p>
<p>​                                                                                                  图 eMMC 内部结构</p>
<p><strong>eMMC接口信号</strong></p>
<p><img src="http://jiali.clouddn.com/20201225_009.png" alt=""></p>
<p>​                                                                                                             表 eMMC引脚信号</p>
<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>The device initially consists of two Boot Partitions and RPMB Partition and User Data Area.</p>
<p>The User Data Area can be divided into four General Purpose Area Partitions and User Data Area partition. Each of the General Purpose Area partitions<br>and a section of User Data Area partition can be configured as enhanced partition.</p>
<p><strong>设备出厂默认四个分区，分别是两个Boot分区、RPMB分区和User Data分区。设备支持从User Data分区中再划分出四个General Purpose分区。四个General Purpose分区和User Data分区中的一段区域，它们的属性可以配置为enhanced partition。分区属性，有些芯片只能配置一次，终生有效，再次配置就会失败。比如Micron 的MTFC8GAKAJCN-1M，但是三星的KLM4G1FEPD-B031，支持多次配置</strong>。</p>
<p><strong>Enhanced Partition (Area)</strong></p>
<p>SAMSUNG eMMC adopts Enhanced User Data Area as SLC Mode. Therefore when master adopts some portion as enhanced user data area in User<br>Data Area, that area occupies triple size of original set up size. ( ex&gt; if master set 1MB for enhanced mode, total 3MB user data area is needed to generate 1MB enhanced area)</p>
<p><strong>（注意：把分区属性改为 Enhanced，就是把MLC模式改为SLC模式，这样做导致容量比原来少三倍。比如，配置1MBenhanced user data area，需要3MB user data area。）</strong></p>
<p>Max Enhanced User Data Area size is defined as (MAX_ENH_SIZE_MULT x HC_WP_GRP_SIZE x HC_ERASE_GRP_SIZE x 512kBytes)</p>
<p>如下图所示，设置支持最大八个分区，其中，4个General Purpose分区，默认不配置。如果主机需要General Purpose分区，可以通过配置General Purpose Partition Size寄存器。Enhanced Partition可以理解为从User Data区域，划分出一段区域并配置为Enhanced属性。</p>
<p><img src="http://jiali.clouddn.com/20201225_010.png" alt=""></p>
<p>​                                                                                                            图 eMMC分区管理</p>
<p>想查看设备分区支持哪些属性，可以查询PARTITIONING_SUPPORT寄存器。寄存器定义如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_011.png" alt=""></p>
<p>​                                                                                          图 PARTITIONING_SUPPORT寄存器</p>
<p><strong>General Purpose分区大小设置</strong></p>
<p>General Purpose Partition Size为12 byte,每个分区大小配置占3byte。大小配置如下图</p>
<p><img src="http://jiali.clouddn.com/20201225_012.png" alt=""></p>
<p>​                                                                                                      图 GP_SIZE_MULT_GP0 - GP_SIZE_MULT_GP3大小配置</p>
<p>HC_WP_GRP_SIZE和HC_ERASE_GRP_SIZE大小如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_014.png" alt=""></p>
<p>​                                                                                                                图HC_WP_GRP_SIZE和HC_ERASE_GRP_SIZE</p>
<p><strong>Enhanced User Data Area大小设置</strong> </p>
<p>配置寄存器如下：</p>
<p><img src="http://jiali.clouddn.com/20201225_015.png" alt=""></p>
<p>​                                                                                             图ENH_SIZE_MULT和ENH_START_ADDR寄存器</p>
<p>Linux内核配置Enhanced User Data Area代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">				 EXT_CSD_ENH_START_ADDR+i,</span><br><span class="line">				 0,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">		err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">				 EXT_CSD_ENH_SIZE_MULT+i,</span><br><span class="line">				 ext_csd[EXT_CSD_MAX_ENH_SIZE_MULT+i],card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line">	&#125;</span><br><span class="line">	err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">			 EXT_CSD_PARTITION_ATTRIBUTE, ext_csd[EXT_CSD_PARTITION_ATTRIBUTE] | 0x01,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	err &#x3D; mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">			 EXT_CSD_PARTITION_SETTING,</span><br><span class="line">			 0x01,card-&gt;ext_csd.generic_cmd6_time);</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br></pre></td></tr></table></figure>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>每个eMMC设备都有一组寄存器，如下</p>
<p><img src="http://jiali.clouddn.com/20201225_016.png" alt=""></p>
<p>​                                                                                                             图 eMMC寄存器</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>测试1：首次配置分区属性</p>
<p><img src="http://jiali.clouddn.com/20201225_017.png" alt=""></p>
<p>可以看出，成功识别EMMC.</p>
<p>测试2，非首次配置分区属性</p>
<p><img src="http://jiali.clouddn.com/20201225_018.png" alt=""></p>
<p>可以，看出，err返回-74，配置分区属性失败。</p>
<p><strong>总结：</strong></p>
<p>eMMC标准协议规定分区属性，只能配置一次，终生有效。但是有些芯片不遵守这个规定，比如三星的KLM4G1FEPD-B031。因此，编写Linux驱动时候，注意兼容性。</p>
<p>参考：</p>
<p>Storage【<a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/】" target="_blank" rel="noopener">https://linux.codingbelief.com/zh/storage/flash_memory/emmc/】</a></p>
<p>eMMC协议【<a href="https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html】" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee1e82ce25c52cc58ad6be0f.html】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC分区管理（①介绍②命令限制③配置分区）</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%EF%BC%88%E2%91%A0%E4%BB%8B%E7%BB%8D%E2%91%A1%E5%91%BD%E4%BB%A4%E9%99%90%E5%88%B6%E2%91%A2%E9%85%8D%E7%BD%AE%E5%88%86%E5%8C%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>1、存储设备的默认区域包括一个用于存储数据的<strong>用户数据区域</strong>，两个可能的用于boot的<strong>boot区域</strong>分区和一个用于保护已验证身份的数据的重放保护的内存块<strong>RPMB区域分区</strong>，还有一个要我们自己分配的GPP区域</p>
<p><img src="https://img-blog.csdnimg.cn/20200326185611446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>2、嵌入式设备还为主机提供了配置其他本地内存分区的可能性<br>具有独立的地址空间，从逻辑地址0x00000000开始，用于不同的使用模型。<br>因此，存储块区域可以分类如下：<br>（1）两个引导区分区，其大小为128 KB的倍数，可以在其中执行从e•MMC的引导<br>（2）通过受信任机制访问的一个RPMB分区，其大小定义为以下各项的倍数：<br>128 KB。<br>（3）四个通用区域分区，用于存储敏感数据或用于其他主机使用模型，<br>大小是写保护组的倍数。<br>每个通用区域分区都可以通过增强或扩展的技术功能（例如更好的可靠性）来实现，这些功能可以将它们与默认存储介质区分开。 如果设备支持增强存储媒体功能，则默认情况下，引导和RPMB区域分区应实现为增强存储媒体。</p>
<p>3、引导区和RPMB区域分区的大小和属性由内存制造商定义（只读），而通用区域分区的大小和属性只能由主机在设备生命周期中进行一次编程（一次可编程）。<br>此外，主机可以自由配置用户数据区域中的一个网段，以实现为增强型存储介质，并根据写保护组来指定其起始位置和大小。 在设备生命周期内，该增强型用户数据区的属性只能编程一次（可以一次编程）。<br>可能的最终配置如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200326190259812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>主机对通用分区和增强型用户数据区域的配置可能会影响先前存储的数据（它们将被销毁）和设备初始化时间。 特别是，由于内部控制器可以执行操作来设置主机指定的配置，因此配置之后的第一个电源循环之后的初始化时间可能会超过规范定义的最大初始化时间。</p>
<p>4、各分区的命令限制：<br>定义了可以发布到每个分区的命令的一些限制：<br>（1）引导分区<br>不允许使用命令class6（写保护）和class7（锁定设备）。<br>（2）RPMB分区<br>仅允许使用Class0，Class2和Class4类的命令。 仍然使用除CMD0，CMD6，CMD8，CMD12，CMD13，CMD15以外的任何其他命令或在6.6.22中定义的命令为非法命令。<br>（3）通用分区<br>允许使用命令class0、2、4、5、6。<br>可以为每个分区中的每个写保护组分别设置写保护。 因此，主机可以在每个写保护组中设置不同的写保护类型。<br>在增强型用户数据区中，可以发出用户数据区中允许的class的所有命令。</p>
<p>5、扩展分区属性<br>每个通用分区可以具有不同的扩展分区属性。 属性类型列表包括：<br>（1）默认-未设置任何扩展属性<br>（2）系统代码–很少更新的分区，包含重要的系统文件（例如，包含<br>主机操作系统的可执行文件）<br>（3）非持久性-用于临时信息的分区（例如，交换文件以扩展主机虚拟内存空间）</p>
<p><strong>单个分区不能同时为其设置增强和扩展属性。</strong></p>
<p>6、配置分区<br>（1）扩展CSD寄存器中“属性”段的PARTITIONING_SUPPORT字段【160】中的 位0（PARTITIONING_EN）指示存储设备是否支持分区属性。 同一字段中的位1（ENH_ATTRIBUTE_EN）指示存储设备是否支持增强功能。位2（EXT_ATTRIBUTE_EN）指示存储设备是否支持“通用分区”中的扩展分区属性</p>
<p><img src="https://img-blog.csdnimg.cn/20200327112445193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）通用分区-最多4个分区的大小和属性。 要设置的EXT_CSD寄存器的Modes段中的字段是：<br>① <strong>GP_SIZE_MULT_GP0-GP_SIZE_MULT_GP3</strong>【154:143】设置大小：（此寄存器<strong>定义通用分区长度</strong>。通用分区长度应以<strong>大容量写保护分组为单位</strong>来表示）<br>②<strong>PARTITIONS_ATTRIBUTE</strong>设置<strong>增强属性</strong>【156】：（此寄存器用来设置哪个分区的增强属性。）<br>③ <strong>EXT_PARTITIONS_ATTRIBUTE</strong>设置<strong>扩展属性</strong>【53:52】：（此寄存器位设置通用分区的扩展属性）<br>（3）增强型用户数据区-区域的起始地址和属性。 要设置的EXT_CSD寄存器的Modes段中的字段是：<br>① ENH_START_ADDR【139:136】设置起始地址（此寄存器定义增强用户数据区的起始地址。<br>增强用户数据区段的起始地址在用户数据区内（对于大容量设备，以字节或扇区表示））<br>② ENH_SIZE_MULT【142:140】设置大小（此寄存器定义增强用户数据区长度。增强用户数据区长度应以大容量写保护分组为单位来表示。）<br>③ PARTITIONS_ATTRIBUTE【156】设置增强属性：（此寄存器用来设置哪个分区的增强属性。）</p>
<p>增强用户数据区的起始地址要求与写保护分组对齐。它是分组地址，对于最大 2GB 容<br>量，以字节为单位，对于大于 2GB 的容量，以扇区为单位。设备将忽略小于分组大小的低<br>位，将增强用户数据区起始地址与所属写保护分组地址（按字节或扇区）对齐。</p>
<p>增强用户数据区域的地址空间与剩下的用户数据区域的地址连续（增强用户数据区域与其余用户数据区域之间没有地址间隙。</p>
<p>通用分区和增强型用户数据区的粒度以大容量写保护组大小为单位。<br>配置分区参数后，应将ERASE_GROUP_DEF【175】位置1。以表示将使用大容量擦除组大小和大容量写保护组大小。如果在设置ERASE_GROUP_DEF位之前将分区参数通过CMD6发送到设备，则从站将显示SWITCH_ERROR。</p>
<p>如果先通过CMD6把分区参数发送给device，再设置ERASE_GROUP_DEF【175】位为1，device将显示将显示SWITCH_ERROR。</p>
<p>一旦设备被分区且配置固定，所有的命令类 5 和 6 命令将被看作是对于大容量擦除分组和大容量写保护分组的。</p>
<p>除了配置分区参数外，我们还得设置PARTITION_SETTING_COMPLETED【155】的bit0为1。（该位被置位则是告知设备，参数定义已经完成，设备可以启动其内部配置活动。若此位尚未置位时发生了突然掉电，则分区配置无效，给主机一个可以重新正确完成的机会）</p>
<p><img src="https://img-blog.csdnimg.cn/20200327134738274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3MzAwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>主机应发出CMD13，以确保正确设置所有参数。 如果任何一个分区参数不正确，设备将引发SWITCH_ERROR。</p>
<p>由于在设置PARTITION_SETTING_COMPLETED位之前，设备不会知道配置分区和用户区域的总大小，因此，如果配置分区和用户数据区域的总大小不适合设备的可用空间，则当主机设置PARTITION_SETTING_COMPLETED位时，设备可能会显示SWITCH_ERROR。在这种情况下，所有设置将在下一次电源循环后清除。所以主机需要再次在每个分区配置寄存器字节中设置正确的值</p>
<p>The device will actually configure itself, according to the partition parameters in the Extended CSD, only<br>after a power cycle. Any valid commands issued after PARTITION_SETTING_COMPLETED bit is set<br>but before a power cycle takes place will be normally executed. Any previous incomplete partitioning<br>configuration sequence before this bit is set will be cancelled upon a power cycle.</p>
<p>在一个电源周期下会配置分区，2 GB的设备的C_SIZE值和超过2GB的设备的SEC_COUNT值将被更改，以表示在配置后的用户数据区的大小，这个大小应该为配置分区之前的的用户数据区大小（对应2GB设备），而对于配置分区之前的2 GB以上的设备，即使分区大小减小到2 GB以下，SEC_COUNT也应始终表示配置分区之后的用户数据区的大小。）</p>
<p>用户数据区域的大小包括用户区域中增强用户数据区域的大小。 因此，主机可能需要在电源关闭后读取这些值，以计算用户数据区域的大小。 配置分区后，访问模式应保持不变。</p>
<p>如果主机上电后按照配置过程尝试使用CMD6更改通用分区和增强型用户数据区功能。设备将在没有执行任何内部动作的情况下将CMD 6响应的状态寄存器中的SWITCH_ERROR 断言（assert）。</p>
<p>分区配置参数存储在扩展CSD寄存器的一次性可编程字段中。 即使尚未设置PARTITION_SETTING_COMPLETED，主机也可以通过CMD8读取它们，但是只有在随后的加电之后，分区的执行才会发生。由于它们是一次性可编程字段，因此建议在读取后避免更改这些参数。</p>
<p>主机应遵循上图16中的流程图来配置通用区域分区和增强型用户数据区域的参数。 否则可能导致未定义的行为。</p>
<p>注：本文转自【<a href="https://blog.csdn.net/weixin_44773006/article/details/105125490】" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44773006/article/details/105125490】</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC驱动框架分析</title>
    <url>/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.cnblogs.com/Lioker/p/11258958.html】" target="_blank" rel="noopener">https://www.cnblogs.com/Lioker/p/11258958.html】</a></p>
<h1 id="一、MMC简介"><a href="#一、MMC简介" class="headerlink" title="一、MMC简介"></a>一、MMC简介</h1><p>eMMC使用BGA封装了Nand Flash和Flash控制器，向外提供MMC标准接口，其结构图如下图所示（图来自<a href="https://files.cnblogs.com/files/Lioker/eMMC.zip" target="_blank" rel="noopener">《eMMC5.1官方标准协议》</a>）。eMMC的出现使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。</p>
<p>对于我们来说，eMMC就是在Nand Flash上添加负责ECC、管理坏块等功能的控制器。</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1542940/202002/1542940-20200223143344599-1883319230.png" alt="img"></p>
<p>在内核中，使用MMC子系统统一管理MMC、SD、SDIO等设备。从MMC规范发布至今，基于不同的考量（物理尺寸、数据位宽和clock频率等），进化出了MMC、SD、microSD、SDIO、eMMC等不同的规范。其本质是一样的，这也是内核将它们统称为MMC的原因。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728091349445-637184680.png" alt="img"></p>
<p>和MTD相同，MMC驱动也有一个单独的文件夹，位于drivers/mmc目录下，目录下的三个目录card、core、host对应MMC驱动的三个层次。</p>
<p>\1. card：区块层，用于实现卡的块设备驱动。</p>
<p>\2. core：核心层，抽象了卡的设备驱动的函数。</p>
<p>\3. host：主机控制器层，依赖于不同平台的控制器操作函数。</p>
<h1 id="二、MMC框架分析"><a href="#二、MMC框架分析" class="headerlink" title="二、MMC框架分析"></a>二、MMC框架分析</h1><p>为了方便分析框架，我们需要分析host目录，读者可在此目录下任意选择一个单板驱动文件进行分析，我选择的是s3cmci.c文件。</p>
<p>文件链接：</p>
<p><a href="https://files.cnblogs.com/files/Lioker/19_emmc.zip" target="_blank" rel="noopener">https://files.cnblogs.com/files/Lioker/19_emmc.zip</a></p>
<p>首先来看它的入口函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static int __init s3cmci_init(void)</span><br><span class="line">2 &#123;</span><br><span class="line">3     return platform_driver_register(&amp;s3cmci_driver);</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>我们进入platform_driver的probe函数中，看看它如何初始化。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 static int __devinit s3cmci_probe(struct platform_device *pdev)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     struct s3cmci_host *host;</span><br><span class="line"> 4     struct mmc_host    *mmc;</span><br><span class="line"> 5 ...</span><br><span class="line"> 6     &#x2F;* 分配mmc_host *&#x2F;</span><br><span class="line"> 7     mmc &#x3D; mmc_alloc_host(sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</span><br><span class="line"> 8 ...    &#x2F;* 省略阶段做的是设置s3cmci_host成员和gpio管脚 *&#x2F;</span><br><span class="line"> 9     request_irq(host-&gt;irq_cd, s3cmci_irq_cd, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, DRIVER_NAME, host));    </span><br><span class="line">10 ...</span><br><span class="line">11     &#x2F;* 设置mmc_host *&#x2F;</span><br><span class="line">12     mmc-&gt;ops     &#x3D; &amp;s3cmci_ops;</span><br><span class="line">13     mmc-&gt;ocr_avail    &#x3D; MMC_VDD_32_33 | MMC_VDD_33_34;</span><br><span class="line">14 #ifdef CONFIG_MMC_S3C_HW_SDIO_IRQ</span><br><span class="line">15     mmc-&gt;caps    &#x3D; MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;</span><br><span class="line">16 #else</span><br><span class="line">17     mmc-&gt;caps    &#x3D; MMC_CAP_4_BIT_DATA;</span><br><span class="line">18 #endif</span><br><span class="line">19     mmc-&gt;f_min     &#x3D; host-&gt;clk_rate &#x2F; (host-&gt;clk_div * 256);</span><br><span class="line">20     mmc-&gt;f_max     &#x3D; host-&gt;clk_rate &#x2F; host-&gt;clk_div;</span><br><span class="line">21 </span><br><span class="line">22     if (host-&gt;pdata-&gt;ocr_avail)</span><br><span class="line">23         mmc-&gt;ocr_avail &#x3D; host-&gt;pdata-&gt;ocr_avail;</span><br><span class="line">24 </span><br><span class="line">25     mmc-&gt;max_blk_count    &#x3D; 4095;</span><br><span class="line">26     mmc-&gt;max_blk_size    &#x3D; 4095;</span><br><span class="line">27     mmc-&gt;max_req_size    &#x3D; 4095 * 512;</span><br><span class="line">28     mmc-&gt;max_seg_size    &#x3D; mmc-&gt;max_req_size;</span><br><span class="line">29 </span><br><span class="line">30     mmc-&gt;max_segs        &#x3D; 128;</span><br><span class="line">31 ...</span><br><span class="line">32     &#x2F;* 添加mmc_host *&#x2F;</span><br><span class="line">33     ret &#x3D; mmc_add_host(mmc);</span><br><span class="line">34 ...</span><br><span class="line">35     platform_set_drvdata(pdev, mmc);</span><br><span class="line">36 ...</span><br><span class="line">37     return ret;</span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中，</p>
<p>\1. mmc_alloc_host()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc &#x3D; mmc_alloc_host(sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</span><br><span class="line">  -&gt; host &#x3D; kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</span><br><span class="line">  &#x2F;* 初始化工作队列 *&#x2F;</span><br><span class="line">  -&gt; INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</span><br></pre></td></tr></table></figure>

<p>\2. mmc_add_host()函数调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc_add_host(mmc);</span><br><span class="line">  -&gt; device_add(&amp;host-&gt;class_dev);</span><br><span class="line">  -&gt; mmc_start_host(host);</span><br><span class="line">    -&gt; mmc_power_off(host);            &#x2F;* 掉电刷新 *&#x2F;</span><br><span class="line">    -&gt; mmc_detect_change(host, 0);</span><br><span class="line">      -&gt; mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</span><br><span class="line">        &#x2F;* 在工作队列中添加一个延迟的工作任务host-&gt;detect *&#x2F;</span><br><span class="line">        -&gt; return queue_delayed_work(workqueue, work, delay);</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>mmc_add_host()函数最终会调用mmc_alloc_host()初始化工作队列的mmc_rescan()函数。此函数用于检测是否有卡插入了卡控制器。</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 void mmc_rescan(struct work_struct *work)</span><br><span class="line"> 2 &#123;</span><br><span class="line"> 3     static const unsigned freqs[] &#x3D; &#123; 400000, 300000, 200000, 100000 &#125;;</span><br><span class="line"> 4     struct mmc_host *host &#x3D; container_of(work, struct mmc_host, detect.work);</span><br><span class="line"> 5     int i;</span><br><span class="line"> 6 ...</span><br><span class="line"> 7     mmc_bus_get(host);</span><br><span class="line"> 8 </span><br><span class="line"> 9     &#x2F;* 检测卡是否仍旧存在 *&#x2F;</span><br><span class="line">10     if (host-&gt;bus_ops &amp;&amp; host-&gt;bus_ops-&gt;detect &amp;&amp; !host-&gt;bus_dead</span><br><span class="line">11         &amp;&amp; !(host-&gt;caps &amp; MMC_CAP_NONREMOVABLE))</span><br><span class="line">12         host-&gt;bus_ops-&gt;detect(host);</span><br><span class="line">13 </span><br><span class="line">14     &#x2F;* If the card was removed the bus will be marked</span><br><span class="line">15      * as dead - extend the wakelock so userspace</span><br><span class="line">16      * can respond *&#x2F;</span><br><span class="line">17     if (host-&gt;bus_dead)</span><br><span class="line">18         extend_wakelock &#x3D; 1;</span><br><span class="line">19 </span><br><span class="line">20     &#x2F;*</span><br><span class="line">21      * Let mmc_bus_put() free the bus&#x2F;bus_ops if we&#39;ve found that</span><br><span class="line">22      * the card is no longer present.</span><br><span class="line">23      *&#x2F;</span><br><span class="line">24     mmc_bus_put(host);</span><br><span class="line">25     mmc_bus_get(host);</span><br><span class="line">26 </span><br><span class="line">27     &#x2F;* 如果卡仍存在, stop here *&#x2F;</span><br><span class="line">28     if (host-&gt;bus_ops !&#x3D; NULL) &#123;</span><br><span class="line">29         mmc_bus_put(host);</span><br><span class="line">30         mmc_set_drv_state(e_inserted,host);&#x2F;&#x2F;ly</span><br><span class="line">31         goto out;</span><br><span class="line">32     &#125;</span><br><span class="line">33 </span><br><span class="line">34     &#x2F;*</span><br><span class="line">35      * Only we can add a new handler, so it&#39;s safe to</span><br><span class="line">36      * release the lock here.</span><br><span class="line">37      *&#x2F;</span><br><span class="line">38     mmc_bus_put(host);</span><br><span class="line">39 </span><br><span class="line">40     &#x2F;* 卡不存在，释放 *&#x2F;</span><br><span class="line">41     if (host-&gt;ops-&gt;get_cd &amp;&amp; host-&gt;ops-&gt;get_cd(host) &#x3D;&#x3D; 0)&#123;</span><br><span class="line">42         mmc_set_drv_state(e_removed,host);</span><br><span class="line">43         goto out;</span><br><span class="line">44     &#125;</span><br><span class="line">45     mmc_claim_host(host);</span><br><span class="line">46     for (i &#x3D; 0; i &lt; ARRAY_SIZE(freqs); i++) &#123;</span><br><span class="line">47         if (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))) &#123;</span><br><span class="line">48             extend_wakelock &#x3D; true;</span><br><span class="line">49             break;</span><br><span class="line">50         &#125;</span><br><span class="line">51         if (freqs[i] &lt;&#x3D; host-&gt;f_min)</span><br><span class="line">52             break;</span><br><span class="line">53     &#125;</span><br><span class="line">54     mmc_release_host(host);</span><br><span class="line">55 </span><br><span class="line">56  out:</span><br><span class="line">57     if (extend_wakelock)</span><br><span class="line">58         wake_lock_timeout(&amp;host-&gt;detect_wake_lock, HZ &#x2F; 2);</span><br><span class="line">59     else</span><br><span class="line">60         wake_unlock(&amp;host-&gt;detect_wake_lock);</span><br><span class="line">61     if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL) &#123;</span><br><span class="line">62         wake_lock(&amp;host-&gt;detect_wake_lock);</span><br><span class="line">63         mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</span><br><span class="line">64     &#125;</span><br><span class="line">65 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>probe()函数所做的有以下几点：</strong></p>
<p>\1. 分配、设置并添加mmc_host</p>
<p>\2. 检测卡是否插入了卡控制器</p>
<p>如果在probe()函数执行时，卡并没有插入呢？也就是除了probe()函数，一定会有其他函数最终调用了mmc_rescan()函数。现在我们需要重新看一遍probe()函数，它注册了一个中断函数s3cmci_irq_cd()。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static irqreturn_t s3cmci_irq_cd(int irq, void *dev_id)</span><br><span class="line">2 &#123;</span><br><span class="line">3     struct s3cmci_host *host &#x3D; (struct s3cmci_host *)dev_id;</span><br><span class="line">4     dbg(host, dbg_irq, &quot;card detect\n&quot;);</span><br><span class="line">5 </span><br><span class="line">6     mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));</span><br><span class="line">7 </span><br><span class="line">8     return IRQ_HANDLED;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>之前分析过，mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));函数最终会调用mmc_rescan()函数。</p>
<p>此时如果有卡插入了，会调用到mmc_rescan()函数，此函数调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc_rescan(struct work_struct *work)</span><br><span class="line">  -&gt; mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))</span><br><span class="line">    -&gt; mmc_attach_sdio(host)    &#x2F;* 检测卡的类型 *&#x2F;</span><br><span class="line">    -&gt; mmc_attach_sd(host)</span><br><span class="line">    -&gt; mmc_attach_mmc(host)</span><br><span class="line">      -&gt; mmc_send_op_cond(host, 0, &amp;ocr);         &#x2F;* 发送卡的ID *&#x2F;</span><br><span class="line">      -&gt; mmc_init_card(host, host-&gt;ocr, NULL);    &#x2F;* 初始化mmc_card *&#x2F;</span><br><span class="line">        -&gt; card &#x3D; mmc_alloc_card(host, &amp;mmc_type);</span><br><span class="line">          -&gt; device_initialize(&amp;card-&gt;dev);</span><br><span class="line">          -&gt; card-&gt;dev.bus &#x3D; &amp;mmc_bus_type;   &#x2F;* 设置总线为mmc_bus_type *&#x2F;</span><br><span class="line">        -&gt; card-&gt;type &#x3D; MMC_TYPE_MMC;         &#x2F;* 设置card结构体 *&#x2F;</span><br><span class="line">      -&gt; mmc_release_host(host);</span><br><span class="line">      -&gt; mmc_add_card(host-&gt;card);            &#x2F;* 添加卡mmc_card *&#x2F;</span><br><span class="line">        -&gt; device_add(&amp;card-&gt;dev);</span><br><span class="line">      -&gt; mmc_claim_host(host);                &#x2F;* 使能host *&#x2F;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在添加mmc_card调用device_add()函数时，mmc_bus_type总线会调用match()函数匹配设备驱动，如果匹配成功会调用总线的probe()函数或设备驱动的probe()函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static int mmc_bus_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">2 &#123;</span><br><span class="line">3     return 1;    &#x2F;* 匹配永远成功 *&#x2F;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>probe()函数最终会调用mmc_driver的probe()函数。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 static int mmc_bus_probe(struct device *dev)</span><br><span class="line">2 &#123;</span><br><span class="line">3     struct mmc_driver *drv &#x3D; to_mmc_driver(dev-&gt;driver);</span><br><span class="line">4     struct mmc_card *card &#x3D; mmc_dev_to_card(dev);</span><br><span class="line">5 </span><br><span class="line">6     return drv-&gt;probe(card);</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>在SI4的Project中搜索struct mmc_driver，发现只有block.c文件有对此结构体的定义。</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728133653404-2134305167.png" alt="img"></p>
<p>现在我们来查看mmc_driver的probe()函数。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int mmc_blk_probe(struct mmc_card *card)</span><br><span class="line">&#123;</span><br><span class="line">    struct mmc_blk_data *md, *part_md;</span><br><span class="line">    int err;</span><br><span class="line">    char cap_str[10];</span><br><span class="line">...</span><br><span class="line">    md &#x3D; mmc_blk_alloc(card);</span><br><span class="line"></span><br><span class="line">    err &#x3D; mmc_blk_set_blksize(md, card);</span><br><span class="line">...</span><br><span class="line">    mmc_set_drvdata(card, md);</span><br><span class="line">    mmc_fixup_device(card, blk_fixups);</span><br><span class="line">...</span><br><span class="line">    if (mmc_add_disk(md))</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(part_md, &amp;md-&gt;part, part) &#123;</span><br><span class="line">        if (mmc_add_disk(part_md))</span><br><span class="line">            goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mmc_blk_remove_parts(card, md);</span><br><span class="line">    mmc_blk_remove_req(md);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>其中，</p>
<p>\1. mmc_blk_alloc()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md &#x3D; mmc_blk_alloc(card);</span><br><span class="line">  -&gt; md &#x3D; mmc_blk_alloc_req(card, &amp;card-&gt;dev, size, false, NULL);</span><br><span class="line">    -&gt; md-&gt;disk &#x3D; alloc_disk(perdev_minors);</span><br><span class="line">    -&gt; ret &#x3D; mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock, subname);</span><br><span class="line">      -&gt; mq-&gt;queue &#x3D; blk_init_queue(mmc_request, lock);</span><br><span class="line">    -&gt; set_capacity(md-&gt;disk, size);</span><br></pre></td></tr></table></figure>

<p>\2. mmc_add_disk()函数调用关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc_add_disk(md)</span><br><span class="line">  -&gt; add_disk(md-&gt;disk);</span><br><span class="line">  -&gt; device_create_file(disk_to_dev(md-&gt;disk), &amp;md-&gt;force_ro);</span><br></pre></td></tr></table></figure>



<p>这个mmc_driver底层做的与块设备驱动相同：</p>
<p>\1. 分配、初始化请求队列，绑定请求队列和请求函数</p>
<p>\2. 分配、设置并添加gendisk</p>
<p>\3. 注册块设备驱动</p>
<p>队列函数为mmc_blk_issue_rq()，其调用关系如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc_blk_issue_rq</span><br><span class="line">  -&gt; mmc_blk_issue_secdiscard_rq(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_discard_rq(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_flush(mq, req);</span><br><span class="line">  -&gt; mmc_blk_issue_rw_rq(mq, req);    &#x2F;* 上面四个函数选一个执行 *&#x2F;</span><br><span class="line">    -&gt; mmc_wait_for_req(card-&gt;host, &amp;brq.mrq);</span><br><span class="line">      -&gt; mmc_start_request(host, mrq);</span><br><span class="line">        -&gt; host-&gt;ops-&gt;request(host, mrq);    &#x2F;* s3cmci.c中host-&gt;requset &#x3D; s3cmci_request *&#x2F;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h1 id="三、MMC驱动框架总结"><a href="#三、MMC驱动框架总结" class="headerlink" title="三、MMC驱动框架总结"></a>三、MMC驱动框架总结</h1><p>\1. 各个结构体作用：</p>
<p>struct mmc_card用于描述卡，struct mmc_driver用于描述卡驱动，sutrct mmc_host用于描述卡控制器，struct mmc_host_ops用于描述卡控制器操作函数。</p>
<p>\2. 整体框架：</p>
<p><img src="https://img2018.cnblogs.com/blog/1542940/201907/1542940-20190728144349852-2146413256.png" alt="img"></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】EMMC 驱动</title>
    <url>/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91EMMC%20%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://blog.csdn.net/luopingfeng/article/details/42844611】" target="_blank" rel="noopener">https://blog.csdn.net/luopingfeng/article/details/42844611】</a></p>
<p>块设备是Linux最复杂的设备之一，但是作为执着于知其然的Geek，我们总会把代码翻个遍，把道理弄个透。当然了，快速地学习一种新的东西，方法是最重要的，个人觉得： 内核当中 MMC/SD 卡驱动程序构架是学习EMMC 驱动程序的重点，只有理解了它才能真正理解该块设备驱动程序，同时才能真正理解 LINUX 块设备驱动程序。</p>
<p> ben</p>
<p>一．需要的基础知识：</p>
<p>\1.    LINUX 设备驱动的基本结构。</p>
<p>\2.    块设备驱动程序的基本构架（相信研究过 LDD3 当中的 sbull 的人应该都不成问题，如果只是走马观花的话，那可得好好再补补了）</p>
<p>\3.    LINUX 设备驱动模型。</p>
<p>\4.    EMMC的原理，是Nand Flash的基础上加上一个负责：ECC、负载均衡和坏块管理功能的controler。</p>
<p>二．驱动程序分析</p>
<p>​    首先，说明一下EMMC驱动涉及到的文件。另外，我们重点是分析驱动程序的基本构架，所以不同内核版本的差异并不是很大。 MMC/SD 卡驱动程序位于 drivers/mmc 目录下</p>
<p>Card/</p>
<p>​    block.c</p>
<p>​    queue.c/queue.h</p>
<p>core/</p>
<p>​    bus.c/bus.h</p>
<p>​    core.c/core.h</p>
<p>​    host.c/host.h</p>
<p>​    mmc.c</p>
<p>​    mmc_ops.c/mmc_ops.h 拿 MMC 卡来分析， SD 卡驱动程序流程类似。</p>
<p>host/</p>
<p>​    s3cmci.c/s3cmci.h 以 S3C24XX 的 MMC/SD 卡控制器为例，其它类型的控制器类似。</p>
<p>LINUX 当中对目录的划分是很有讲究的，这些文件被分布在 3 个目录下，正好对应 MMC/SD 驱动程序的 3 个层次（关于层的划分这里浏览一下，有个概念即可，当我们分析完了后再回头来看，你会觉得很形象）：</p>
<p>（1）    区块层</p>
<p>主要是按照 LINUX 块设备驱动程序的框架实现一个卡的块设备驱动，这 block.c 当中我们可以看到写一个块设备驱动程序时需要的 block_device_operations 结构体变量的定义，其中有 open/release/request 函数的实现，而 queue.c 则是对内核提供的请求队列的封装，我们暂时不用深入理解它，只需要知道一个块设备需要一个请求队列就可以了。</p>
<p>（2）    核心层</p>
<p>核心层封装了 MMC/SD 卡的命令，例如存储卡的识别，设置，读写。例如不管什么卡都应该有一些识别，设置，和读写的命令，这些流程都是必须要有的，只是具体对于不同的卡会有一些各自特有的操作。 Core.c 文件是由 sd.c 、 mmc.c 两个文件支撑的， core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd.c 和 sd_ops.c 、 mmc.c 和 mmc_ops.c 来完成。</p>
<p>（3）    主机控制器层</p>
<p>主机控制器则是依赖于不同的平台的，例如 s3c2410 的卡控制器和 atmel 的卡控制器必定是不一样的，所以要针对不同的控制器来实现。以 s3cmci.c 为例，它首先要进行一些设置，例如中断函数注册，全能控制器等等。然后它会向 core 层注册一个主机（ host ），用结构 mmc_host_ops 描述，这样核心层就可以拿着这个 host 来操作 s3c24xx 的卡控制器了，而具体是 s3c24xx 的卡控制器还是 atmel 的卡控制器， core 层是不用知道的。 </p>
<p>   对这几个目录有一个大概认识以后，我们来看几个重要的数据结构：</p>
<p>struct mmc_host 用来描述卡控制器</p>
<p>struct mmc_card 用来描述卡</p>
<p>struct mmc_driver 用来描述 mmc 卡驱动</p>
<p>struct mmc_host_ops 用来描述卡控制器操作集，用于从主机控制器层向 core 层注册操作函数，从而将 core 层与具体的主机控制器隔离。也就是说 core 要操作主机控制器，就用这个 ops 当中给的函数指针操作，不能直接调用具体主控制器的函数。</p>
<p>第一阶段：</p>
<p>​    从 s3cmci_init 开始往下看</p>
<p>static int __init s3cmci_init(void)</p>
<p>{</p>
<p>platform_driver_register(&amp;s3cmci_driver_2410);</p>
<p>}</p>
<p>有 platform_driver_register 函数，根据设备模型的知识，我们知道那一定会有对应的 platform_device_register 函数的，可是在哪里呢？没有看到，那是不是这个 s3cmci_driver_2410 当中给的 probe 函数就不执行了？？？当然不是， mci 接口一般都是硬件做好的（我认为是这样），所以在系统启动时一定会有调用 platform_device­_register 对板上的资源进行注册，如果没有这个硬件资源，那我们这个驱动也就没有用了。好，我们就假定是有 mci 接口的，而且也有与 s3cmci_driver_2410 对应的硬件资源注册了，那自己就会去跑 probe 函数。来看一下 s3cmci_driver_2410:</p>
<p>static struct platform_driver s3cmci_driver_2410 = {</p>
<p>​    .driver.name  = “s3c2410-sdi”,</p>
<p>​    .probe      = s3cmci_probe_2410,</p>
<p>​    .remove     = s3cmci_remove,</p>
<p>​    .suspend = s3cmci_suspend,</p>
<p>​    .resume     = s3cmci_resume,</p>
<p>};</p>
<p>我们到 s3cmci_probe_2410 函数中看，还是干脆直接看 s3cmci_probe 算了：</p>
<p>static int s3cmci_probe(struct platform_device *pdev, int is2440) // 来自 /host/s3cmci.c</p>
<p>{</p>
<p>​    struct mmc_host  *mmc;</p>
<p>​    struct s3cmci_host    *host;</p>
<p>​    int ret;</p>
<p>……</p>
<p>​    mmc = mmc_alloc_host (sizeof(struct s3cmci_host), &amp;pdev-&gt;dev);</p>
<p>​    if (!mmc) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto probe_out;</p>
<p>​    }</p>
<p>……</p>
<p>​    mmc-&gt;ops   = &s3cmci_ops;</p>
<p>……</p>
<p>​    ret = mmc_add_host (mmc);</p>
<p>​    if (ret) {</p>
<p>​       dev_err(&amp;pdev-&gt;dev, “failed to add mmc host./n”);</p>
<p>​       goto free_dmabuf;</p>
<p>​    }</p>
<p>……</p>
<p>​    platform_set_drvdata(pdev, mmc);</p>
<p>​    return 0;</p>
<p>……</p>
<p>}</p>
<p>这个函数很长，做的事件也很多，但我们关心的整个驱动的构架 / 流程，所以过滤掉一些细节的东西，只看 2 个最重要的函数： mmc_alloc_host 、 mmc_add_host 。函数命名已经很形象了，前者是申请一个 mmc_host ，而后者是添加一个 mmc_host 。中间还有一个操作，就是给 mmc 的 ops 成员赋上了 s3cmci_ops 这个值。申请 mmc_host 当然很简单，就是申请一个结构体（我们暂且这样认为，因为他里面还做的其它事情，后面会看到），而添加又是添加到哪里去呢？看 mmc_add_host 函数：</p>
<p>int mmc_add_host(struct mmc_host *host) // 来自 core/host.c</p>
<p>{</p>
<p>​    int err;</p>
<p>……</p>
<p>​    err = device_add(&amp;host-&gt;class_dev);</p>
<p>​    if (err)</p>
<p>​       return err;</p>
<p>​    mmc_start_host(host);</p>
<p>​    return 0;</p>
<p>}</p>
<p>很简单，就是增加了一个 device ，然后就调用 mmc_start_host 了，那就先跳过 device_add 这个动作，来看 mmc_start_host:</p>
<p>void mmc_start_host(struct mmc_host *host) // 来自 /host/core.c</p>
<p>{</p>
<p>​    mmc_power_off(host);        // 掉电一下</p>
<p>​    mmc_detect_change(host, 0);       // ？？？</p>
<p>}</p>
<p>看上去只有两行代码，不过浓缩才是精华， mmc_power_off(host) 光看名子都知道是在干什么，先跳过，来看 mmc_detect_change ，那么它到底干了些什么呢？看一下就知道了：</p>
<p>void mmc_detect_change(struct mmc_host *host, unsigned long delay)  // core/core.c</p>
<p>{</p>
<p>​    mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</p>
<p>}</p>
<p>static int mmc_schedule_delayed_work(struct delayed_work *work, unsigned long delay)</p>
<p>{</p>
<p>​    return queue_delayed_work(workqueue, work, delay);</p>
<p>}</p>
<p>mmc_detect_change 又跳了一下，最后调用了 queue_delayed_work ，不知道这个函数功能的去查一下〈〈 LDD3 〉〉和〈〈深入理解 LINUX 内核〉〉，这几个代码告诉我们在 workqueue 这个工作队列当中添加一个延迟的工作任务，而这个工作任务就是由 host-&gt;detect 来描述的，在随后的 delay 个 jiffies 后会有一个记录在 host-&gt;detect 里面的函数被执行，那么到这里 s3cmci_probe 这个函数算是结束了，但事情还没有完， workqueue 这个工作队列还在忙，不一会儿它就会调用 host-&gt;detect 里面那个函数，这个函数到底是哪个函数，到底是用来干什么的呢？好像没有看到， detect 包含在 host 里面，那估计是在刚才那个申请的地方设置的那个函数，回过头来看一下 mmc_alloc_host:</p>
<p>struct mmc_host *mmc_alloc_host(int extra, struct device *dev) // 来自 core/host.c</p>
<p>{</p>
<p>​    struct mmc_host *host;</p>
<p>​    host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</p>
<p>​    if (!host)</p>
<p>​       return NULL;</p>
<p>​    INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</p>
<p>​    return host;</p>
<p>}</p>
<p>如果你看了 queue_delayed_work 这个函数功能介绍，相信对 INIT_DELAYED_WORK 也不会陌生了吧。不废话了，来看 mmc_rescan ：</p>
<p>// 来自 core/host.c</p>
<p>void mmc_rescan(struct work_struct *work)  // // 来自 core/host.c</p>
<p>{</p>
<p>​    struct mmc_host *host =   container_of(work, struct mmc_host, detect.work);</p>
<p>​    u32 ocr;</p>
<p>​    int err;</p>
<p>……</p>
<p>​    /* detect a newly inserted card */</p>
<p>……</p>
<p>​    /*</p>
<p>​     * First we search for SDIO…</p>
<p>​     */</p>
<p>​    err = mmc_send_io_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_sdio(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * …then normal SD…</p>
<p>​     */</p>
<p>​    err = mmc_send_app_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_sd(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * …and finally MMC.</p>
<p>​     */</p>
<p>​    err = mmc_send_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_mmc(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    mmc_release_host(host);</p>
<p>​    mmc_power_off(host);</p>
<p>out:</p>
<p>​    if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</p>
<p>​       mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</p>
<p>}</p>
<p>浏览一个这个函数，看看函数名，再看看注释，知道什么了吗？它是在检测是不是有卡插入了卡控制器，如果有卡挺入就要采取相应的行动了。这里要明白一点，我们平时用的 SD/MMC 卡就是一个卡，如果要操作它得用 SD/MMC 卡控制器才行，所以可以看到有 struct mmc_card,struct mmc_host 的区分。</p>
<p>​    到这里了，来回忆一下 s3cmci_probe 这个函数做的事情，大概就是准备一个 mmc_host 结构，然后添加一个主控制器设备到内核，最后又调用了一下 mmc_rescan 来检测是不是有卡插入了。</p>
<p>​    如果有卡插入了还好，可以去操作卡了，那如果没有卡插入呢？ mmc_rescan 不是白调用了一次吗？是啊，的确是白调用了一次。可是卡插入时为什么 PC 还是能检测到呢？看来卡检测的动作不光是在 probe 的最后一步做了一次，其它地方也有做。卡插入一般都是人为地随时去插入的，像这种情况一般都是会用中断机制去提供系统有外来侵入，然后再去采取行动。 SD/MMC 卡也的确是这样做的，找来找去，发现在 s3cmci_probe 里面注册了一个中断函数 s3cmci_irq_cd( 函数名的意思应该是 irq card detect) ，就是这个了，看看这个函数先：</p>
<p>static irqreturn_t s3cmci_irq_cd(int irq, void *dev_id)  // host/s3cmci.c</p>
<p>{</p>
<p>​    struct s3cmci_host *host = (struct s3cmci_host *)dev_id;</p>
<p>​    mmc_detect_change(host-&gt;mmc, msecs_to_jiffies(500));</p>
<p>​    return IRQ_HANDLED;</p>
<p>}</p>
<p>看到这个函数想都不用想，直接跳到 mmc_rescan 里面去看就行了。前面已经知道了 mmc_rescan 里面就是在检测卡是不是插入了，既然卡随时插入我们都能检测到了，那就来看卡插入后都做了些什么动作吧。</p>
<p>第二阶段：</p>
<p>​    mmc_rescan 里面既要检测 sd 卡，又要检测 mmc 卡的，我们就照着一个往下走，假定有个人插入了 MMC 卡，那就应该走下面这几行：</p>
<p>​    err = mmc_send_op_cond(host, 0, &amp;ocr);</p>
<p>​    if (!err) {</p>
<p>​       if (mmc_attach_mmc(host, ocr))</p>
<p>​           mmc_power_off(host);</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>mmc_send_op_cond 这个函数据说是读了一下卡的什么值，这个值是什么意义我也不清楚，这就像检测 FLASH 时读 FLASH 的 ID 一样，网卡也是这样的，不用管这个值的意义了，只要知道它能标识是一个 MMC 卡插入就行了。如果取这个值没有错误的话就得进 mmc_attach_mmc 了：</p>
<p>/*</p>
<p> * Starting point for MMC card init.</p>
<p> */</p>
<p>int mmc_attach_mmc(struct mmc_host *host, u32 ocr) // core/mmc.c</p>
<p>{</p>
<p>​    int err;</p>
<p>……</p>
<p>​    mmc_attach_bus_ops(host);     // 这个与总线的电源管理有关，暂时跳过</p>
<p>……</p>
<p>​    /*</p>
<p>​     * Detect and init the card.</p>
<p>​     */</p>
<p>​    err = mmc_init_card(host, host-&gt;ocr, NULL);</p>
<p>​    if (err)</p>
<p>​       goto err;</p>
<p>……</p>
<p>​    mmc_release_host(host);</p>
<p>​    err = mmc_add_card(host-&gt;card);</p>
<p>​    if (err)</p>
<p>​       goto remove_card;</p>
<p>​    return 0;</p>
<p>remove_card:</p>
<p>……</p>
<p>err:</p>
<p>……</p>
<p>​    return err;</p>
<p>}</p>
<p>还是找几个关键函数来看 mmc_init_card 从函数名来看就是初始化一个 card ，这个 card 就用 struct mmc_card 结构来描述，然后又调用 mmc_add_card 将卡设备添加到了内核，先来看 mmc_init_card 都做了些什么事情：</p>
<p>static int mmc_init_card(struct mmc_host *host, u32 ocr,</p>
<p>​    struct mmc_card *oldcard)</p>
<p>{</p>
<p>​    struct mmc_card *card;</p>
<p>​    int err;</p>
<p>​    u32 cid[4];</p>
<p>​    unsigned int max_dtr;</p>
<p>……</p>
<p>​       /*</p>
<p>​        * Allocate card structure.</p>
<p>​        */</p>
<p>​       card = mmc_alloc_card(host, &amp;mmc_type);</p>
<p>​       if (IS_ERR(card)) {</p>
<p>​           err = PTR_ERR(card);</p>
<p>​           goto err;</p>
<p>​       }</p>
<p>​       card-&gt;type = MMC_TYPE_MMC;</p>
<p>​       card-&gt;rca = 1;</p>
<p>​       memcpy(card-&gt;raw_cid, cid, sizeof(card-&gt;raw_cid));</p>
<p>……</p>
<p>​       host-&gt;card = card;</p>
<p>​    return 0;</p>
<p>free_card:</p>
<p>……</p>
<p>err:</p>
<p>……</p>
<p>​    return err;</p>
<p>}</p>
<p>将与硬件操作相关的全部删掉，最后对我们有用的也就这几行了 mmc_alloc_card 申请了一个 struct mmc_card 结构，然后给 card-&gt;type 赋上 MMC_TYPE_MMC ，最后将 card 又赋给了 host-&gt;card ，这和具体硬件还是挺像的，因为一个主控制器一般就插一个卡，有卡时 host-&gt;card 有值，没有卡时 host-&gt;card 自己就是 NULL 了。</p>
<p>​    钻进 mmc_alloc_card 里面来看看：</p>
<p>/*</p>
<p> * Allocate and initialise a new MMC card structure.</p>
<p> */</p>
<p>struct mmc_card *mmc_alloc_card(struct mmc_host *host, struct device_type *type)</p>
<p>{</p>
<p>​    struct mmc_card *card;</p>
<p>​    card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);</p>
<p>​    if (!card)</p>
<p>​       return ERR_PTR(-ENOMEM);</p>
<p>​    card-&gt;host = host;</p>
<p>​    device_initialize(&amp;card-&gt;dev);</p>
<p>​    card-&gt;dev.parent = mmc_classdev(host);</p>
<p>​    card-&gt;dev.bus = &mmc_bus_type;</p>
<p>​    card-&gt;dev.release = mmc_release_card;</p>
<p>​    card-&gt;dev.type = type;</p>
<p>​    return card;</p>
<p>}</p>
<p>Struct mmc_card 结构里面包含了一个 struct device 结构， mmc_alloc_card 不但申请了内存，而且还填充了 struct device 中的几个成员，尤其 card-&gt;dev.bus = &mmc_bus_type; 这一句要重点对待。</p>
<p>​    申请一个 mmc_card 结构，并简单初始化后， mmc_init_card 的使命就完成了，然后再调用 mmc_add_card 将这个 card 设备添加到内核。 mmc_add_card 其实很简单，就是调用 device_add 将 card-&gt;dev 添加到内核当中去。</p>
<p>​    知道总线模型这个东西的人都明白，理到 device_add 里面总线就应该有动作了，具体是哪个总线呢？那就得看你调用 device_add 时送的那个 dev 里面指定的是哪个总线了，我们送的 card-&gt;dev ，那么 card-&gt;dev.bus 具体指向什么呢？很明现是那个 mmc_bus_type ：</p>
<p>static struct bus_type mmc_bus_type = {</p>
<p>​    .name       = “mmc”,</p>
<p>​    .dev_attrs    = mmc_dev_attrs,</p>
<p>​    .match      = mmc_bus_match,</p>
<p>​    .uevent      = mmc_bus_uevent,</p>
<p>​    .probe      = mmc_bus_probe,</p>
<p>​    .remove     = mmc_bus_remove,</p>
<p>​    .suspend = mmc_bus_suspend,</p>
<p>​    .resume     = mmc_bus_resume,</p>
<p>};</p>
<p>在 device_add 里面，设备对应的总线会拿着你这个设备和挂在这个总线上的所有驱动程序去匹配（ match ），此时会调用 match 函数，如果匹配到了就会调用总线的 probe 函数或驱动的 probe 函数，那我们看一下这里的 mmc_bus_match 是如何进行匹配的：</p>
<p>static int mmc_bus_match(struct device *dev, struct device_driver *drv)</p>
<p>{</p>
<p>​    return 1;</p>
<p>}</p>
<p>看来 match 永远都能成功，那就去执行 probe 吧：</p>
<p>static int mmc_bus_probe(struct device *dev)</p>
<p>{</p>
<p>​    struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</p>
<p>​    struct mmc_card *card = dev_to_mmc_card(dev);</p>
<p>​    return drv-&gt;probe(card);</p>
<p>}</p>
<p>这里就有点麻烦了，在这个函数里面又调用了一下 drv-&gt;probe() ，那这个 drv 是什么呢？上面有： struct mmc_driver *drv = to_mmc_driver(dev-&gt;driver);</p>
<p>match 函数总是返回 1 ，那看来只要是挂在这条总线上的 driver 都有可能跑到这里来了，事实的确也是这样的，不过好在挂在这条总线上的 driver 只有一个，它是这样定义的：</p>
<p>static struct mmc_driver mmc_driver = {</p>
<p>​    .drv    = {</p>
<p>​       .name   = “mmcblk”,</p>
<p>​    },</p>
<p>​    .probe      = mmc_blk_probe,</p>
<p>​    .remove     = mmc_blk_remove,</p>
<p>​    .suspend   = mmc_blk_suspend,</p>
<p>​    .resume     = mmc_blk_resume,</p>
<p>};</p>
<p>看到这里时， card/core/host 几个已经全部被扯进来了，边看 mmc_driver 中的几个函数，他们几个如何联系起来也就慢慢明白了。那我们继续吧。</p>
<p>第三阶段：</p>
<p>前面已经看到了，在总线的 probe 里面调用了 drv-&gt;probe, 而这个函数就对应的是 mmc_blk_probe ，具体这个 mmc_driver 是怎么挂到 mmc_bus 上的，自己去看 mmc_blk_init() ，就几行代码，应该不难。</p>
<p>static int mmc_blk_probe(struct mmc_card *card) // 来自 card/block.c</p>
<p>{</p>
<p>​    struct mmc_blk_data *md;</p>
<p>​    int err;</p>
<p>……</p>
<p>​    md = mmc_blk_alloc(card);</p>
<p>​    if (IS_ERR(md))</p>
<p>​       return PTR_ERR(md);</p>
<p>……</p>
<p>​    add_disk(md-&gt;disk);</p>
<p>​    return 0;</p>
<p> out:</p>
<p>​    mmc_blk_put(md);</p>
<p>​    return err;</p>
<p>}</p>
<p>还是捡重要的函数看，一看到这个函数最后调用了 add_disk ，你应该可以想到些什么吧？如果你不知道我在说些什么，那我估计你没有看过 LDD3 ，或者看了也是走马观花了。我来告诉你：如果看到 add_disk ，那说明前面一定会有 alloc_disk 和初始化队列的动作，在 mmc_blk_probe 时面没有体现出来，那就看 mmc_blk_alloc(card) 那一行：</p>
<p>static struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)</p>
<p>{</p>
<p>​    struct mmc_blk_data *md;</p>
<p>​    int devidx, ret;</p>
<p>​    devidx = find_first_zero_bit(dev_use, MMC_NUM_MINORS);</p>
<p>​    if (devidx &gt;= MMC_NUM_MINORS)</p>
<p>​       return ERR_PTR(-ENOSPC);</p>
<p>​    __set_bit(devidx, dev_use);</p>
<p>​    md = kzalloc(sizeof(struct mmc_blk_data), GFP_KERNEL);</p>
<p>​    if (!md) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto out;</p>
<p>​    }</p>
<p>​    /*</p>
<p>​     * Set the read-only status based on the supported commands</p>
<p>​     * and the write protect switch.</p>
<p>​     */</p>
<p>​    md-&gt;read_only = mmc_blk_readonly(card);</p>
<p>​    md-&gt;disk = alloc_disk(1 &lt;&lt; MMC_SHIFT);</p>
<p>​    if (md-&gt;disk == NULL) {</p>
<p>​       ret = -ENOMEM;</p>
<p>​       goto err_kfree;</p>
<p>​    }</p>
<p>​    spin_lock_init(&amp;md-&gt;lock);</p>
<p>​    md-&gt;usage = 1;</p>
<p>​    ret = mmc_init_queue(&amp;md-&gt;queue, card, &amp;md-&gt;lock);</p>
<p>​    if (ret)</p>
<p>​       goto err_putdisk;</p>
<p>​    md-&gt;queue.issue_fn = mmc_blk_issue_rq;</p>
<p>​    md-&gt;queue.data = md;</p>
<p>​    md-&gt;disk-&gt;major  = MMC_BLOCK_MAJOR;</p>
<p>​    md-&gt;disk-&gt;first_minor = devidx &lt;&lt; MMC_SHIFT;</p>
<p>​    md-&gt;disk-&gt;fops = &mmc_bdops;</p>
<p>​    md-&gt;disk-&gt;private_data = md;</p>
<p>​    md-&gt;disk-&gt;queue = md-&gt;queue.queue;</p>
<p>​    md-&gt;disk-&gt;driverfs_dev = &amp;card-&gt;dev;</p>
<p>​    /*</p>
<p>​     * As discussed on lkml, GENHD_FL_REMOVABLE should:</p>
<p>​     *</p>
<p>​     * - be set for removable media with permanent block devices</p>
<p>​     * - be unset for removable block devices with permanent media</p>
<p>​     *</p>
<p>​     * Since MMC block devices clearly fall under the second</p>
<p>​     * case, we do not set GENHD_FL_REMOVABLE. Userspace</p>
<p>​     * should use the block device creation/destruction hotplug</p>
<p>​     * messages to tell when the card is present.</p>
<p>​     */</p>
<p>​    sprintf(md-&gt;disk-&gt;disk_name, “mmcblk%d”, devidx);</p>
<p>​    blk_queue_logical_block_size(md-&gt;queue.queue, 512);</p>
<p>​    if (!mmc_card_sd(card) &amp;&amp; mmc_card_blockaddr(card)) {</p>
<p>​       /*</p>
<p>​        * The EXT_CSD sector count is in number or 512 byte</p>
<p>​        * sectors.</p>
<p>​        */</p>
<p>​       set_capacity(md-&gt;disk, card-&gt;ext_csd.sectors);</p>
<p>​    } else {</p>
<p>​       /*</p>
<p>​        * The CSD capacity field is in units of read_blkbits.</p>
<p>​        * set_capacity takes units of 512 bytes.</p>
<p>​        */</p>
<p>​       set_capacity(md-&gt;disk,</p>
<p>​           card-&gt;csd.capacity &lt;&lt; (card-&gt;csd.read_blkbits - 9));</p>
<p>​    }</p>
<p>​    return md;</p>
<p> err_putdisk:</p>
<p>​    put_disk(md-&gt;disk);</p>
<p> err_kfree:</p>
<p>​    kfree(md);</p>
<p> out:</p>
<p>​    return ERR_PTR(ret);</p>
<p>}</p>
<p>看到这个函数的代码，我们自然就回忆起了块设备驱动的整个套路了：</p>
<p>\1.    分配、初始化请求队列，并绑定请求队列和请求函数。</p>
<p>\2.    分配，初始化 gendisk ，给 gendisk 的 major ， fops ， queue 等成员赋值，最后添加 gendisk 。</p>
<p>\3.    注册块设备驱动。</p>
<p>我们看看 MMC 卡驱动程序有没有按这个套路走，</p>
<p>1 、 mmc_init_queue 初始了队列，并将 mmc_blk_issue_rq; 函数绑定成请求函数；</p>
<p>2 、 alloc_disk 分配了 gendisk 结构，并初始化了 major ， fops ，和 queue ；</p>
<p>3 、最后调用 add_disk 将块设备加到 KERNEL 中去。</p>
<p>到这里虽然 mmc_blk_probe 已经结束了，但我们别停下来。记得 LDD3 上在讲 sbull 实例时说过， add_disk 的调用标志着一个块设备驱动将被激活，所以在这之前必须把其它所有准备工作全部做好，作者为什么会这样说是有理由的，因为在 add_disk 里面 kernel 会去调用你绑定到队列中的请求函数，目的是去你的块设备上读分区表。而且是在 add_disk 内部就要做的，而不是 add_disk 返回后再做，具体为什么会这样，去看 add_disk 的代码实现就知道了。</p>
<p>既然要调用请求函数去读，那我们就来看看请求函数： mmc_blk_issue_rq</p>
<p>static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)</p>
<p>{</p>
<p>​    struct mmc_blk_data *md = mq-&gt;data;</p>
<p>​    struct mmc_card *card = md-&gt;queue.card;</p>
<p>​    struct mmc_blk_request brq;</p>
<p>​    int ret = 1, disable_multi = 0;</p>
<p>​    do {</p>
<p>​       mmc_wait_for_req(card-&gt;host, &amp;brq.mrq);</p>
<p>​       /*</p>
<p>​        * A block was successfully transferred.</p>
<p>​        */</p>
<p>​       spin_lock_irq(&amp;md-&gt;lock);</p>
<p>​       ret = __blk_end_request(req, 0, brq.data.bytes_xfered);</p>
<p>​       spin_unlock_irq(&amp;md-&gt;lock);</p>
<p>​    } while (ret);</p>
<p>​    return 1;</p>
<p>}</p>
<p>这个函数实在太长了，好在我们不用全部看，大部分读数据的准备代码和出错处理的代码已经被我删掉了，只要知道读数据都是在这里完成的就够了。看不懂这个函数的，拿上 LDD3 找个人少的地方，将 sbull 研究透了也就明白这个函数了。不过这个函数里涉及的东西还挺不少，“散列表”，“回弹”都在这里出现了，有时间慢慢去研究吧。</p>
<p>​    在块设备驱动当中你只需要抓住请求队列和请求函数就可以了，具体那些 block_device_operations 里面赋值的函数可不像字符设备驱动里面那么受关注了。</p>
<p>​    分析到这里， MMC/SD 卡的驱动整个构架基本也就很明析了，说简单了就是做了两件事：</p>
<p>\1.    卡的检测；</p>
<p>\2.    卡数据的读取。</p>
<p>最后再将这两个过程大概串一下：</p>
<p>\1.    卡的检测：</p>
<p>S3cmci_probe(host/s3cmci.c)</p>
<p>​    Mmc_alloc_host(core/core.c)</p>
<p>​       Mmc_rescan(core/core.c)</p>
<p>​           Mmc_attach_mmc(core/mmc.c)</p>
<p>​              Mmc_init_card(core/mmc.c)</p>
<p>​              mmc_add_card(core/bus.c)</p>
<p>​                  device_add</p>
<p>​                     mmc_bus_match(core/bus.c)</p>
<p>​                     mmc_bus_probe(core/bus.c)</p>
<p>​                         mmc_blk_probe(card/block.c)</p>
<p>​                            alloc_disk/add_disk</p>
<p>\2.    读写数据：</p>
<p>mmc_blk_issue_rq （ card/block.c ）</p>
<p>​    mmc_wait_for_req(core/core.c)</p>
<p>​       mmc_start_request(core/core.c)</p>
<p>​           host-&gt;ops-&gt;request(host, mrq)  // s3cmci 中 s3cmci_request</p>
<p>MMC/SD 卡的驱动分析完了，是不是有些复杂，不过这样设计的目的是为了分层，让具体平台的驱动编写更加省事。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>基于OMAP335x eMMC驱动</title>
    <url>/2020/12/25/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E5%9F%BA%E4%BA%8EOMAP335x%20eMMC%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="驱动程序分析"><a href="#驱动程序分析" class="headerlink" title="驱动程序分析"></a>驱动程序分析</h2><h3 id="软件层次划分"><a href="#软件层次划分" class="headerlink" title="软件层次划分"></a>软件层次划分</h3><p>MMC framework的软件架构，如下图</p>
<p><img src="http://jiali.clouddn.com/20201225_020.png" alt=""></p>
<p>​                                                                                                                                图 mmc 软件架构</p>
<p>eMMC使用MMC驱动模块，mmc驱动位于driver/mmc目录下，该文件夹包含card、core和host目录，每个目录跟mmc相关的文件如下：</p>
<blockquote>
<p>Card/</p>
<pre><code>block.c

queue.c/queue.h</code></pre><p>core/</p>
<pre><code>bus.c/bus.h

core.c/core.h

host.c/host.h

mmc.c

mmc_ops.c/mmc_ops.h</code></pre><p>host/</p>
<pre><code>omap_hsmmc.c 表示 omap335x 的 MMC/SD 卡控制器，代表emmc控制器的硬件操作</code></pre></blockquote>
<p>三个目录对应mmc驱动三个层次：</p>
<p>（1）       块设备层（card）</p>
<p>主要是按照 LINUX 块设备驱动程序的框架实现一个卡的块设备驱动，这 block.c 当中我们可以看到写一个块设备驱动程序时需要的 block_device_operations 结构体变量的定义，其中有 open/release/request 函数的实现，而 queue.c 则是对内核提供的请求队列的封装。</p>
<p>（2）       核心层(core)</p>
<p>核心层封装了 MMC/SD 卡的命令，例如存储卡的识别，设置，读写。例如不管什么卡都应该有一些识别，设置，和读写的命令，这些流程都是必须要有的，只是具体对于不同的卡会有一些各自特有的操作。 Core.c 文件是由 sd.c 、 mmc.c 两个文件支撑的， core.c 把 MMC 卡、 SD 卡的共性抽象出来，它们的差别由 sd.c 和 sd_ops.c 、 mmc.c 和 mmc_ops.c 来完成。</p>
<p>（3）       硬件控制层(host)</p>
<p>主机控制器则是依赖于不同的平台的，例如 omap335x 的卡控制器和 atmel 的卡控制器必定是不一样的，所以要针对不同的控制器来实现。以 omap_hsmmc.c 为例，它首先要进行一些设置，例如中断函数注册，全能控制器等等。然后它会向 core 层注册一个主机（ host ），用结构 mmc_host_ops 描述，这样核心层就可以拿着这个 host 来操作omap335x 的卡控制器了，而具体是 omap335x 的卡控制器还是 atmel 的卡控制器， core 层是不用知道的。 </p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="关于mmc的几个重要数据结构"><a href="#关于mmc的几个重要数据结构" class="headerlink" title="关于mmc的几个重要数据结构"></a>关于mmc的几个重要数据结构</h4><blockquote>
<p>struct mmc_host 用来描述卡控制器</p>
<p>struct mmc_card 用来描述卡</p>
<p>struct mmc_driver 用来描述 mmc 卡驱动</p>
<p>struct mmc_host_ops 用来描述卡控制器操作集，用于从主机控制器层向 core 层注册操作函数，从而将 core 层与具体的主机控制器隔离。也就是说 core 要操作主机控制器，就用这个 ops 当中给的函数指针操作，不能直接调用具体主控制器的函数。</p>
</blockquote>
<h4 id="mmc模式初始化"><a href="#mmc模式初始化" class="headerlink" title="mmc模式初始化"></a>mmc模式初始化</h4><p>在Linux 启动过程中，依次初始化下面的模块：</p>
<blockquote>
<p>1、subsys_initcall(mmc_init) //注册了mmc_bus_type总线</p>
<p>2、module_init(mmc_blk_init) //注册一个mmc块设备，并向mmc_bus_type总线添加mmc驱动</p>
<p>3、module_init(omap_hsmmc_init) //注册一个MMC/SD卡控制器为platform总线设备，mmc的一系列初始化，从这个入口开始。</p>
</blockquote>
<h4 id="注册mmc总线"><a href="#注册mmc总线" class="headerlink" title="注册mmc总线"></a>注册mmc总线</h4><p>drivers/mmc/core/core.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init mmc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	workqueue &#x3D; alloc_ordered_workqueue(&quot;kmmcd&quot;, 0);</span><br><span class="line">	if (!workqueue)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; mmc_register_bus();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto destroy_workqueue;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; mmc_register_host_class();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto unregister_bus;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; sdio_register_bus();</span><br><span class="line">	if (ret)</span><br><span class="line">		goto unregister_host_class;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">unregister_host_class:</span><br><span class="line">	mmc_unregister_host_class();</span><br><span class="line">unregister_bus:</span><br><span class="line">	mmc_unregister_bus();</span><br><span class="line">destroy_workqueue:</span><br><span class="line">	destroy_workqueue(workqueue);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mmc_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	sdio_unregister_bus();</span><br><span class="line">	mmc_unregister_host_class();</span><br><span class="line">	mmc_unregister_bus();</span><br><span class="line">	destroy_workqueue(workqueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(mmc_init);</span><br><span class="line">module_exit(mmc_exit);</span><br></pre></td></tr></table></figure>

<p>drivers/mmc/core/bus.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct bus_type mmc_bus_type &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;mmc&quot;,</span><br><span class="line">	.dev_attrs	&#x3D; mmc_dev_attrs,</span><br><span class="line">	.match		&#x3D; mmc_bus_match,</span><br><span class="line">	.uevent		&#x3D; mmc_bus_uevent,</span><br><span class="line">	.probe		&#x3D; mmc_bus_probe,</span><br><span class="line">	.remove		&#x3D; mmc_bus_remove,</span><br><span class="line">	.pm		&#x3D; &amp;mmc_bus_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int mmc_register_bus(void)</span><br><span class="line">&#123;</span><br><span class="line">	return bus_register(&amp;mmc_bus_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册-mmc-bus-driver"><a href="#注册-mmc-bus-driver" class="headerlink" title="注册 mmc bus driver"></a>注册 mmc bus driver</h4><p>drivers/mmc/card/block.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct mmc_driver mmc_driver &#x3D; &#123;</span><br><span class="line">	.drv		&#x3D; &#123;</span><br><span class="line">		.name	&#x3D; &quot;mmcblk&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe		&#x3D; mmc_blk_probe,</span><br><span class="line">	.remove		&#x3D; mmc_blk_remove,</span><br><span class="line">	.suspend	&#x3D; mmc_blk_suspend,</span><br><span class="line">	.resume		&#x3D; mmc_blk_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init mmc_blk_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	if (perdev_minors !&#x3D; CONFIG_MMC_BLOCK_MINORS)</span><br><span class="line">		pr_info(&quot;mmcblk: using %d minors per device\n&quot;, perdev_minors);</span><br><span class="line"></span><br><span class="line">	max_devices &#x3D; 256 &#x2F; perdev_minors;</span><br><span class="line"></span><br><span class="line">	res &#x3D; register_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	res &#x3D; mmc_register_driver(&amp;mmc_driver);</span><br><span class="line">	if (res)</span><br><span class="line">		goto out2;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"> out2:</span><br><span class="line">	unregister_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line"> out:</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mmc_blk_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	mmc_unregister_driver(&amp;mmc_driver);</span><br><span class="line">	unregister_blkdev(MMC_BLOCK_MAJOR, &quot;mmc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mmc_blk_init);</span><br><span class="line">module_exit(mmc_blk_exit);</span><br></pre></td></tr></table></figure>

<h4 id="注册主机MMC-SD卡控制器为platform总线设备"><a href="#注册主机MMC-SD卡控制器为platform总线设备" class="headerlink" title="注册主机MMC/SD卡控制器为platform总线设备"></a>注册主机MMC/SD卡控制器为platform总线设备</h4><p>drivers/mmc/host/omap_hsmmc.c</p>
<p>入口函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct platform_driver omap_hsmmc_driver &#x3D; &#123;</span><br><span class="line">	.remove		&#x3D; omap_hsmmc_remove,</span><br><span class="line">	.driver		&#x3D; &#123;</span><br><span class="line">		.name &#x3D; DRIVER_NAME,</span><br><span class="line">		.owner &#x3D; THIS_MODULE,</span><br><span class="line">		.pm &#x3D; &amp;omap_hsmmc_dev_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init omap_hsmmc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Register the MMC driver *&#x2F;</span><br><span class="line">	return platform_driver_probe(&amp;omap_hsmmc_driver, omap_hsmmc_probe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit omap_hsmmc_cleanup(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Unregister MMC driver *&#x2F;</span><br><span class="line">	platform_driver_unregister(&amp;omap_hsmmc_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(omap_hsmmc_init);</span><br><span class="line">module_exit(omap_hsmmc_cleanup);</span><br></pre></td></tr></table></figure>

<p>这里注册一个名为DRIVER_NANE(omap_hsmmc)的platform_driver,因此，在系统启动时一定会有调用 platform_device­_register 对板上的资源进行注册。这里注册成功就会调用omap_hsmmc_probe()函数来初始化mmc设备，最后把mmc设备加入mmc bus ,完成mmc 块设备的创建。</p>
<p><strong>第一阶段：初始化mmc控制器，并检测卡</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int __init omap_hsmmc_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_mmc_platform_data *pdata &#x3D; pdev-&gt;dev.platform_data;</span><br><span class="line">	struct mmc_host *mmc;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D; NULL;</span><br><span class="line">	struct resource *res, *dma_tx, *dma_rx;</span><br><span class="line">	int ret, irq;</span><br><span class="line"></span><br><span class="line">	if (pdata &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, &quot;Platform Data is missing\n&quot;);</span><br><span class="line">		return -ENXIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;nr_slots &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, &quot;No Slots\n&quot;);</span><br><span class="line">		return -ENXIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">	irq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">	if (res &#x3D;&#x3D; NULL || irq &lt; 0)</span><br><span class="line">		return -ENXIO;</span><br><span class="line"></span><br><span class="line">	res-&gt;start +&#x3D; pdata-&gt;reg_offset;</span><br><span class="line">	res-&gt;end +&#x3D; pdata-&gt;reg_offset;</span><br><span class="line">	res &#x3D; request_mem_region(res-&gt;start, resource_size(res), pdev-&gt;name);</span><br><span class="line">	if (res &#x3D;&#x3D; NULL)</span><br><span class="line">		return -EBUSY;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; omap_hsmmc_gpio_init(pdata);</span><br><span class="line">	if (ret)</span><br><span class="line">		goto err;</span><br><span class="line"></span><br><span class="line">	mmc &#x3D; mmc_alloc_host(sizeof(struct omap_hsmmc_host), &amp;pdev-&gt;dev);&#x2F;&#x2F;分配mmc_host</span><br><span class="line">	if (!mmc) &#123;</span><br><span class="line">		ret &#x3D; -ENOMEM;</span><br><span class="line">		goto err_alloc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host		&#x3D; mmc_priv(mmc);</span><br><span class="line">	host-&gt;mmc	&#x3D; mmc;</span><br><span class="line">	host-&gt;pdata	&#x3D; pdata;</span><br><span class="line">	host-&gt;dev	&#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">	host-&gt;use_dma	&#x3D; 1;</span><br><span class="line">	host-&gt;dev-&gt;dma_mask &#x3D; &amp;pdata-&gt;dma_mask;</span><br><span class="line">	host-&gt;dma_ch	&#x3D; -1;</span><br><span class="line">	host-&gt;irq	&#x3D; irq;</span><br><span class="line">	host-&gt;id	&#x3D; pdev-&gt;id;</span><br><span class="line">	host-&gt;slot_id	&#x3D; 0;</span><br><span class="line">	host-&gt;mapbase	&#x3D; res-&gt;start;</span><br><span class="line">	host-&gt;base	&#x3D; ioremap(host-&gt;mapbase, SZ_4K);</span><br><span class="line">	host-&gt;power_mode &#x3D; MMC_POWER_OFF;</span><br><span class="line">	host-&gt;next_data.cookie &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, host);</span><br><span class="line">	INIT_WORK(&amp;host-&gt;mmc_carddetect_work, omap_hsmmc_detect);</span><br><span class="line">    &#x2F;&#x2F;初始化mmc_host配置</span><br><span class="line">	mmc-&gt;ops	&#x3D; &amp;omap_hsmmc_ops;&#x2F;&#x2F;跟主机的硬件操作相关</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If regulator_disable can only put vcc_aux to sleep then there is</span><br><span class="line">	 * no off state.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (mmc_slot(host).vcc_aux_disable_is_sleep)</span><br><span class="line">		mmc_slot(host).no_off &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;f_min	&#x3D; OMAP_MMC_MIN_CLOCK;</span><br><span class="line"></span><br><span class="line">	if(mmc-&gt;index &#x3D;&#x3D; 0)</span><br><span class="line">		mmc-&gt;f_max	&#x3D; OMAP_MMC_MAX_CLOCK_SD;</span><br><span class="line">	if(mmc-&gt;index &#x3D;&#x3D; 1)</span><br><span class="line">		mmc-&gt;f_max	&#x3D; OMAP_MMC_MAX_CLOCK_EMMC;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;host-&gt;irq_lock);</span><br><span class="line"></span><br><span class="line">	host-&gt;fclk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;fck&quot;);</span><br><span class="line">	if (IS_ERR(host-&gt;fclk)) &#123;</span><br><span class="line">		ret &#x3D; PTR_ERR(host-&gt;fclk);</span><br><span class="line">		host-&gt;fclk &#x3D; NULL;</span><br><span class="line">		goto err1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_context_save(host);</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; MMC_CAP_DISABLE;</span><br><span class="line">	if (host-&gt;pdata-&gt;controller_flags &amp; OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) &#123;</span><br><span class="line">		dev_info(&amp;pdev-&gt;dev, &quot;multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\n&quot;);</span><br><span class="line">		mmc-&gt;caps2 |&#x3D; MMC_CAP2_NO_MULTI_READ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm_runtime_enable(host-&gt;dev);</span><br><span class="line">	pm_runtime_get_sync(host-&gt;dev);</span><br><span class="line">	pm_runtime_set_autosuspend_delay(host-&gt;dev, MMC_AUTOSUSPEND_DELAY);</span><br><span class="line">	pm_runtime_use_autosuspend(host-&gt;dev);</span><br><span class="line"></span><br><span class="line">	if (cpu_is_omap2430()) &#123;</span><br><span class="line">		host-&gt;dbclk &#x3D; clk_get(&amp;pdev-&gt;dev, &quot;mmchsdb_fck&quot;);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * MMC can still work without debounce clock.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (IS_ERR(host-&gt;dbclk))</span><br><span class="line">			dev_warn(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Failed to get debounce clock\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			host-&gt;got_dbclk &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		if (host-&gt;got_dbclk)</span><br><span class="line">			if (clk_enable(host-&gt;dbclk) !&#x3D; 0)</span><br><span class="line">				dev_dbg(mmc_dev(host-&gt;mmc), &quot;Enabling debounce&quot;</span><br><span class="line">							&quot; clk failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Since we do only SG emulation, we can have as many segs</span><br><span class="line">	 * as we want. *&#x2F;</span><br><span class="line">	if (pdata-&gt;version &#x3D;&#x3D; MMC_CTRL_VERSION_2)</span><br><span class="line">		mmc-&gt;max_segs &#x3D; 1;</span><br><span class="line">	else</span><br><span class="line">		mmc-&gt;max_segs &#x3D; 1024;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;max_blk_size &#x3D; 512;       &#x2F;* Block Length at max can be 1024 *&#x2F;</span><br><span class="line">	mmc-&gt;max_blk_count &#x3D; 0xFFFF;    &#x2F;* No. of Blocks is 16 bits *&#x2F;</span><br><span class="line">	mmc-&gt;max_req_size &#x3D; mmc-&gt;max_blk_size * mmc-&gt;max_blk_count;</span><br><span class="line">	mmc-&gt;max_seg_size &#x3D; mmc-&gt;max_req_size;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |</span><br><span class="line">		     MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;caps |&#x3D; mmc_slot(host).caps;</span><br><span class="line">	if (mmc-&gt;caps &amp; MMC_CAP_8_BIT_DATA)</span><br><span class="line">		mmc-&gt;caps |&#x3D; MMC_CAP_4_BIT_DATA;</span><br><span class="line"></span><br><span class="line">	if (mmc_slot(host).nonremovable)</span><br><span class="line">		mmc-&gt;caps |&#x3D; MMC_CAP_NONREMOVABLE;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;pm_caps &#x3D; mmc_slot(host).pm_caps;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_conf_bus_power(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Select DMA lines *&#x2F;</span><br><span class="line">	if (pdata-&gt;version &#x3D;&#x3D; MMC_CTRL_VERSION_2) &#123;</span><br><span class="line">		dma_rx &#x3D; platform_get_resource_byname(pdev,</span><br><span class="line">							IORESOURCE_DMA, &quot;rx&quot;);</span><br><span class="line">		if (!dma_rx) &#123;</span><br><span class="line">			ret &#x3D; -EINVAL;</span><br><span class="line">			goto err1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dma_tx &#x3D; platform_get_resource_byname(pdev,</span><br><span class="line">							IORESOURCE_DMA, &quot;tx&quot;);</span><br><span class="line">		if (!dma_tx) &#123;</span><br><span class="line">			ret &#x3D; -EINVAL;</span><br><span class="line">			goto err1;</span><br><span class="line">		&#125;</span><br><span class="line">		host-&gt;dma_line_tx &#x3D; dma_tx-&gt;start;</span><br><span class="line">		host-&gt;dma_line_rx &#x3D; dma_rx-&gt;start;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		switch (host-&gt;id) &#123;</span><br><span class="line">		case OMAP_MMC1_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP24XX_DMA_MMC1_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP24XX_DMA_MMC1_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC2_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP24XX_DMA_MMC2_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP24XX_DMA_MMC2_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC3_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP34XX_DMA_MMC3_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP34XX_DMA_MMC3_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC4_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP44XX_DMA_MMC4_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP44XX_DMA_MMC4_RX;</span><br><span class="line">			break;</span><br><span class="line">		case OMAP_MMC5_DEVID:</span><br><span class="line">			host-&gt;dma_line_tx &#x3D; OMAP44XX_DMA_MMC5_TX;</span><br><span class="line">			host-&gt;dma_line_rx &#x3D; OMAP44XX_DMA_MMC5_RX;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			dev_err(mmc_dev(host-&gt;mmc), &quot;Invalid MMC id\n&quot;);</span><br><span class="line">			goto err_irq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Request IRQ for MMC operations *&#x2F;</span><br><span class="line">	ret &#x3D; request_irq(host-&gt;irq, omap_hsmmc_irq, 0,</span><br><span class="line">			mmc_hostname(mmc), host);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_dbg(mmc_dev(host-&gt;mmc), &quot;Unable to grab HSMMC IRQ\n&quot;);</span><br><span class="line">		goto err_irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (pdata-&gt;init !&#x3D; NULL) &#123;</span><br><span class="line">		if (pdata-&gt;init(&amp;pdev-&gt;dev) !&#x3D; 0) &#123;</span><br><span class="line">			dev_dbg(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Unable to configure MMC IRQs\n&quot;);</span><br><span class="line">			goto err_irq_cd_init;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (omap_hsmmc_have_reg() &amp;&amp; !mmc_slot(host).set_power) &#123;</span><br><span class="line">		ret &#x3D; omap_hsmmc_reg_get(host);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err_reg;</span><br><span class="line">		host-&gt;use_reg &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mmc-&gt;ocr_avail &#x3D; mmc_slot(host).ocr_mask;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Request IRQ for card detect *&#x2F;</span><br><span class="line">	if ((mmc_slot(host).card_detect_irq)) &#123;</span><br><span class="line">		ret &#x3D; request_irq(mmc_slot(host).card_detect_irq,</span><br><span class="line">				  omap_hsmmc_cd_handler,</span><br><span class="line">				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">				  mmc_hostname(mmc), host);</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			dev_dbg(mmc_dev(host-&gt;mmc),</span><br><span class="line">				&quot;Unable to grab MMC CD IRQ\n&quot;);</span><br><span class="line">			goto err_irq_cd;</span><br><span class="line">		&#125;</span><br><span class="line">		pdata-&gt;suspend &#x3D; omap_hsmmc_suspend_cdirq;</span><br><span class="line">		pdata-&gt;resume &#x3D; omap_hsmmc_resume_cdirq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_disable_irq(host);</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_protect_card(host);</span><br><span class="line"></span><br><span class="line">	mmc_add_host(mmc);&#x2F;&#x2F;添加mmc_host</span><br><span class="line"></span><br><span class="line">	if (mmc_slot(host).name !&#x3D; NULL) &#123;</span><br><span class="line">		ret &#x3D; device_create_file(&amp;mmc-&gt;class_dev, &amp;dev_attr_slot_name);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err_slot_name;</span><br><span class="line">	&#125;</span><br><span class="line">	if (mmc_slot(host).card_detect_irq &amp;&amp; mmc_slot(host).get_cover_state) &#123;</span><br><span class="line">		ret &#x3D; device_create_file(&amp;mmc-&gt;class_dev,</span><br><span class="line">					&amp;dev_attr_cover_switch);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err_slot_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	omap_hsmmc_debugfs(mmc);</span><br><span class="line">	pm_runtime_mark_last_busy(host-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(host-&gt;dev);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_slot_name:</span><br><span class="line">	mmc_remove_host(mmc);</span><br><span class="line">	free_irq(mmc_slot(host).card_detect_irq, host);</span><br><span class="line">err_irq_cd:</span><br><span class="line">	if (host-&gt;use_reg)</span><br><span class="line">		omap_hsmmc_reg_put(host);</span><br><span class="line">err_reg:</span><br><span class="line">	if (host-&gt;pdata-&gt;cleanup)</span><br><span class="line">		host-&gt;pdata-&gt;cleanup(&amp;pdev-&gt;dev);</span><br><span class="line">err_irq_cd_init:</span><br><span class="line">	free_irq(host-&gt;irq, host);</span><br><span class="line">err_irq:</span><br><span class="line">	pm_runtime_mark_last_busy(host-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(host-&gt;dev);</span><br><span class="line">	clk_put(host-&gt;fclk);</span><br><span class="line">	if (host-&gt;got_dbclk) &#123;</span><br><span class="line">		clk_disable(host-&gt;dbclk);</span><br><span class="line">		clk_put(host-&gt;dbclk);</span><br><span class="line">	&#125;</span><br><span class="line">err1:</span><br><span class="line">	iounmap(host-&gt;base);</span><br><span class="line">	platform_set_drvdata(pdev, NULL);</span><br><span class="line">	mmc_free_host(mmc);</span><br><span class="line">err_alloc:</span><br><span class="line">	omap_hsmmc_gpio_free(pdata);</span><br><span class="line">err:</span><br><span class="line">	release_mem_region(res-&gt;start, resource_size(res));</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>probe()函数所做的有以下几点：</strong></p>
<ol>
<li><p>分配、设置并添加mmc_host</p>
</li>
<li><p>检测卡是否插入了卡控制器</p>
</li>
</ol>
</blockquote>
<p>看 mmc_alloc_host 函数:</p>
<p>来自drivers/mmc/core/host.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_alloc_host - initialise the per-host structure.</span><br><span class="line"> *	@extra: sizeof private data structure</span><br><span class="line"> *	@dev: pointer to host device model structure</span><br><span class="line"> *</span><br><span class="line"> *	Initialise the per-host structure.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct mmc_host *mmc_alloc_host(int extra, struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line">	struct mmc_host *host;</span><br><span class="line"></span><br><span class="line">	if (!idr_pre_get(&amp;mmc_host_idr, GFP_KERNEL))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	host &#x3D; kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);</span><br><span class="line">	if (!host)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;mmc_host_lock);</span><br><span class="line">	err &#x3D; idr_get_new(&amp;mmc_host_idr, host, &amp;host-&gt;index);</span><br><span class="line">	spin_unlock(&amp;mmc_host_lock);</span><br><span class="line">	if (err)</span><br><span class="line">		goto free;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;host-&gt;class_dev, &quot;mmc%d&quot;, host-&gt;index);</span><br><span class="line"></span><br><span class="line">	host-&gt;parent &#x3D; dev;</span><br><span class="line">	host-&gt;class_dev.parent &#x3D; dev;</span><br><span class="line">	host-&gt;class_dev.class &#x3D; &amp;mmc_host_class;</span><br><span class="line">	device_initialize(&amp;host-&gt;class_dev);</span><br><span class="line"></span><br><span class="line">	mmc_host_clk_init(host);</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;host-&gt;lock);</span><br><span class="line">	init_waitqueue_head(&amp;host-&gt;wq);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);&#x2F;&#x2F;初始化工作队列，向host-&gt;detect注册一个mmc_rescan函数</span><br><span class="line">	INIT_DELAYED_WORK_DEFERRABLE(&amp;host-&gt;disable, mmc_host_deeper_disable);</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	host-&gt;pm_notify.notifier_call &#x3D; mmc_pm_notify;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * By default, hosts do not support SGIO or large requests.</span><br><span class="line">	 * They have to set these according to their abilities.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	host-&gt;max_segs &#x3D; 1;</span><br><span class="line">	host-&gt;max_seg_size &#x3D; PAGE_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">	host-&gt;max_req_size &#x3D; PAGE_CACHE_SIZE;</span><br><span class="line">	host-&gt;max_blk_size &#x3D; 512;</span><br><span class="line">	host-&gt;max_blk_count &#x3D; PAGE_CACHE_SIZE &#x2F; 512;</span><br><span class="line"></span><br><span class="line">	return host;</span><br><span class="line"></span><br><span class="line">free:</span><br><span class="line">	kfree(host);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mmc_add_host函数做了什么？</p>
<p>drivers/mmc/core/host.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_add_host - initialise host hardware</span><br><span class="line"> *	@host: mmc host</span><br><span class="line"> *</span><br><span class="line"> *	Register the host with the driver model. The host must be</span><br><span class="line"> *	prepared to start servicing requests before this function</span><br><span class="line"> *	completes.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int mmc_add_host(struct mmc_host *host)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	WARN_ON((host-&gt;caps &amp; MMC_CAP_SDIO_IRQ) &amp;&amp;</span><br><span class="line">		!host-&gt;ops-&gt;enable_sdio_irq);</span><br><span class="line"></span><br><span class="line">	err &#x3D; device_add(&amp;host-&gt;class_dev); </span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	led_trigger_register_simple(dev_name(&amp;host-&gt;class_dev), &amp;host-&gt;led);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_FS</span><br><span class="line">	mmc_add_host_debugfs(host);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mmc_start_host(host);</span><br><span class="line">	register_pm_notifier(&amp;host-&gt;pm_notify);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看mmc_start_host()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mmc_start_host(struct mmc_host *host)</span><br><span class="line">&#123;</span><br><span class="line">	mmc_power_off(host); &#x2F;&#x2F;掉电重启</span><br><span class="line">	mmc_detect_change(host, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看mmc_detect_change（）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *	mmc_detect_change - process change of state on a MMC socket</span><br><span class="line"> *	@host: host which changed state.</span><br><span class="line"> *	@delay: optional delay to wait before detection (jiffies)</span><br><span class="line"> *</span><br><span class="line"> *	MMC drivers should call this when they detect a card has been</span><br><span class="line"> *	inserted or removed. The MMC layer will confirm that any</span><br><span class="line"> *	present card is still functional, and initialize any newly</span><br><span class="line"> *	inserted.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void mmc_detect_change(struct mmc_host *host, unsigned long delay)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MMC_DEBUG</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	spin_lock_irqsave(&amp;host-&gt;lock, flags);</span><br><span class="line">	WARN_ON(host-&gt;removed);</span><br><span class="line">	spin_unlock_irqrestore(&amp;host-&gt;lock, flags);</span><br><span class="line">#endif</span><br><span class="line">	host-&gt;detect_change &#x3D; 1;</span><br><span class="line">	mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);&#x2F;&#x2F;等待一会，在调度host-&gt;detect，执行mmc_rescan()函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看 mmc_rescan函数做了什么?</p>
<p>来自drivers/mmc/core/core.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mmc_rescan(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	static const unsigned freqs[] &#x3D; &#123; 400000, 300000, 200000, 100000 &#125;;</span><br><span class="line">	struct mmc_host *host &#x3D;</span><br><span class="line">		container_of(work, struct mmc_host, detect.work);</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;rescan_disable)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	mmc_bus_get(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * if there is a _removable_ card registered, check whether it is</span><br><span class="line">	 * still present</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (host-&gt;bus_ops &amp;&amp; host-&gt;bus_ops-&gt;detect &amp;&amp; !host-&gt;bus_dead</span><br><span class="line">	    &amp;&amp; !(host-&gt;caps &amp; MMC_CAP_NONREMOVABLE))</span><br><span class="line">		host-&gt;bus_ops-&gt;detect(host);</span><br><span class="line"></span><br><span class="line">	host-&gt;detect_change &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Let mmc_bus_put() free the bus&#x2F;bus_ops if we&#39;ve found that</span><br><span class="line">	 * the card is no longer present.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	mmc_bus_put(host);</span><br><span class="line">	mmc_bus_get(host);</span><br><span class="line"></span><br><span class="line">	&#x2F;* if there still is a card present, stop here *&#x2F;</span><br><span class="line">	if (host-&gt;bus_ops !&#x3D; NULL) &#123;</span><br><span class="line">		mmc_bus_put(host);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Only we can add a new handler, so it&#39;s safe to</span><br><span class="line">	 * release the lock here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	mmc_bus_put(host);</span><br><span class="line"></span><br><span class="line">	if (host-&gt;ops-&gt;get_cd &amp;&amp; host-&gt;ops-&gt;get_cd(host) &#x3D;&#x3D; 0)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	mmc_claim_host(host);</span><br><span class="line">	for (i &#x3D; 0; i &lt; ARRAY_SIZE(freqs); i++) &#123;</span><br><span class="line">		if (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min)))</span><br><span class="line">			break;</span><br><span class="line">		if (freqs[i] &lt;&#x3D; host-&gt;f_min)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	mmc_release_host(host);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	if (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</span><br><span class="line">		mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是在检测是不是有卡插入了卡控制器，如果有卡挺入就要采取相应的行动了。这里要明白一点，我们平时用的 SD/MMC 卡就是一个卡，如果要操作它得用 SD/MMC 卡控制器才行，所以可以看到有 struct mmc_card,struct mmc_host 的区分。</p>
<p>如果在probe()函数执行时，卡并没有插入呢？也就是除了probe()函数，一定会有其他函数最终调用了mmc_rescan()函数。现在我们需要重新看一遍omap_hsmmc_probe()函数，它注册了一个中断函数omap_hsmmc_cd_handler。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * ISR for handling card insertion and removal</span><br><span class="line"> *&#x2F;</span><br><span class="line">static irqreturn_t omap_hsmmc_cd_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D; (struct omap_hsmmc_host *)dev_id;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;suspended)</span><br><span class="line">		return IRQ_HANDLED;</span><br><span class="line">	schedule_work(&amp;host-&gt;mmc_carddetect_work); &#x2F;&#x2F;调度队列，最后执行mmc_rescan()</span><br><span class="line"></span><br><span class="line">	return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在omap_hsmmc_probe函数，注册host-&gt;mmc_carddetect_work队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;host-&gt;mmc_carddetect_work, omap_hsmmc_detect);</span><br></pre></td></tr></table></figure>

<p>来看看omap_hsmmc_detect()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Work Item to notify the core about card insertion&#x2F;removal</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void omap_hsmmc_detect(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	struct omap_hsmmc_host *host &#x3D;</span><br><span class="line">		container_of(work, struct omap_hsmmc_host, mmc_carddetect_work);</span><br><span class="line">	struct omap_mmc_slot_data *slot &#x3D; &amp;mmc_slot(host);</span><br><span class="line">	int carddetect;</span><br><span class="line"></span><br><span class="line">	if (host-&gt;suspended)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	sysfs_notify(&amp;host-&gt;mmc-&gt;class_dev.kobj, NULL, &quot;cover_switch&quot;);</span><br><span class="line"></span><br><span class="line">	if (slot-&gt;card_detect)</span><br><span class="line">		carddetect &#x3D; slot-&gt;card_detect(host-&gt;dev, host-&gt;slot_id);</span><br><span class="line">	else &#123;</span><br><span class="line">		omap_hsmmc_protect_card(host);</span><br><span class="line">		carddetect &#x3D; -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;*检测到卡，执行mmc_detect_change()*&#x2F;</span><br><span class="line">	if (carddetect)</span><br><span class="line">		mmc_detect_change(host-&gt;mmc, (HZ * 200) &#x2F; 1000);</span><br><span class="line">	else</span><br><span class="line">		mmc_detect_change(host-&gt;mmc, (HZ * 50) &#x2F; 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段分析完毕，当检测到卡，执行mmc_rescan（）函数，进入第二阶段。</p>
<p><strong>第二阶段，初始化卡，注册mmc块设备</strong></p>
<p>mmc_rescan()函数，调用关系如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmc_rescan(struct work_struct *work)</span><br><span class="line">  -&gt; mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))</span><br><span class="line">    -&gt; mmc_attach_sdio(host)    &#x2F;* 检测卡的类型 *&#x2F;</span><br><span class="line">    -&gt; mmc_attach_sd(host)</span><br><span class="line">    -&gt; mmc_attach_mmc(host)</span><br><span class="line">      -&gt; mmc_send_op_cond(host, 0, &amp;ocr);         &#x2F;* 发送卡的ID *&#x2F;</span><br><span class="line">      -&gt; mmc_init_card(host, host-&gt;ocr, NULL);    &#x2F;* 初始化mmc_card *&#x2F;</span><br><span class="line">        -&gt; card &#x3D; mmc_alloc_card(host, &amp;mmc_type);</span><br><span class="line">          -&gt; device_initialize(&amp;card-&gt;dev);</span><br><span class="line">          -&gt; card-&gt;dev.bus &#x3D; &amp;mmc_bus_type;   &#x2F;* 设置总线为mmc_bus_type *&#x2F;</span><br><span class="line">        -&gt; card-&gt;type &#x3D; MMC_TYPE_MMC;         &#x2F;* 设置card结构体 *&#x2F;</span><br><span class="line">      -&gt; mmc_release_host(host);</span><br><span class="line">      -&gt; mmc_add_card(host-&gt;card);            &#x2F;* 添加卡mmc_card *&#x2F;</span><br><span class="line">        -&gt; device_add(&amp;card-&gt;dev);            &#x2F;*把卡设备加入mmc bus *&#x2F;</span><br><span class="line">      -&gt; mmc_claim_host(host);                &#x2F;* 使能host *&#x2F;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在mmc_add_card函数中调用device_add()函数时，mmc_bus_type总线会调用match()函数匹配设备驱动，如果匹配成功会调用总线的probe()函数或设备驱动的probe()函数完成块设备创建。</p>
<p>这个mmc_driver底层做的与块设备驱动相同：</p>
<ol>
<li><p>分配、初始化请求队列，绑定请求队列和请求函数</p>
</li>
<li><p>分配、设置并添加gendisk</p>
</li>
<li><p>注册块设备驱动</p>
</li>
</ol>
<h2 id="mmc驱动总结"><a href="#mmc驱动总结" class="headerlink" title="mmc驱动总结"></a>mmc驱动总结</h2><ol>
<li>各个结构体作用：</li>
</ol>
<p>struct mmc_card用于描述卡，struct mmc_driver用于描述卡驱动，sutrct mmc_host用于描述卡控制器，struct mmc_host_ops用于描述卡控制器操作函数。</p>
<ol start="2">
<li><p>整体框架：</p>
<p><img src="http://jiali.clouddn.com/20201225_019.png" alt=""></p>
</li>
</ol>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/Lioker/p/11258958.html" target="_blank" rel="noopener">eMMC驱动框架分析</a></p>
<p><a href="https://blog.csdn.net/luopingfeng/article/details/42844611" target="_blank" rel="noopener">EMMC 驱动</a></p>
<p><a href="https://blog.csdn.net/kickxxx/article/details/51130888" target="_blank" rel="noopener">Linux EMMC子系统分析-初始化流程</a></p>
<p><a href="https://www.daimajiaoliu.com/daima/4794cd5a29003fc" target="_blank" rel="noopener">eMMC驱动分析</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】eMMC驱动分析</title>
    <url>/2020/12/28/Linux/Driver/storage/Flash%20Memory/mmc/%E9%A9%B1%E5%8A%A8/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91eMMC%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文转自：【<a href="https://www.daimajiaoliu.com/daima/4794cd5a29003fc】" target="_blank" rel="noopener">https://www.daimajiaoliu.com/daima/4794cd5a29003fc】</a></p>
<h1 id="基于ATMEL-sama5d3芯片与Linux-3-6-9内核"><a href="#基于ATMEL-sama5d3芯片与Linux-3-6-9内核" class="headerlink" title="基于ATMEL-sama5d3芯片与Linux-3.6.9内核"></a>基于ATMEL-sama5d3芯片与Linux-3.6.9内核</h1><h2 id="SD卡系列简介"><a href="#SD卡系列简介" class="headerlink" title="SD卡系列简介"></a>SD卡系列简介</h2><p>这些都是网上找出来的，权当作为开场白了。</p>
<p>MMC卡全称Multi Media Card，由西门子公司和SanDisk公司1997年推出的多媒体记忆卡标准。MMC卡尺寸为32mm x24mm x 1.4mm，它将存贮单元和控制器一同做到了卡上，智能的控制器使得MMC保证兼容性和灵活性。MMC卡具有MMC和SPI两种工作模式，MMC模式是默认工作模式，具有MMC的全部特性。而SPI模式则是MMC协议的一个子集，主要用于低速系统。</p>
<p>SD卡全称Secure Digital Memory Card，由松下、东芝和SanDisk公司于1999年8月共同开发的新一代记忆卡标准，已完全兼容MMC标准。SD卡比MMC卡多了一个进行数据著作权保护的暗号认证功能，读写速度比MMC卡快4倍。尺寸为32mm x 24mm x2.1mm，长宽和MMC卡一样，只是比MMC卡厚了0.7mm，以容纳更大容量的存贮单元。SD卡与MMC卡保持向上兼容，也就是说，MMC卡可以被新的设有SD卡插槽的设备存取，但是SD卡却不可以被设有MMC插槽的设备存取。</p>
<p>SDIO全称Secure Digital Input and Output Card，SDIO是在SD标准上定义了一种外设接口，它使用SD的I/O接口来连接外围设备，并通过SD上的I/O数据接口与这些外围设备传输数据。现在已经有很多手持设备支持SDIO功能，而且许多SDIO外设也被开发出来，目前常见的SDIO外设有：WIFI Card、GPS Card、 Bluetooth Card等等。</p>
<p>eMMC全称Embedded Multi MediaCard，是MMC协会所制定的内嵌式存储器标准规格，主要应用于智能手机和移动嵌入式产品等。eMMC是一种嵌入式非易失性存储系统，由闪存和闪存控制器两部分组成，它的一个明显优势是在封装中集成了一个闪存控制器，它采用JEDEC标准BGA封装，并采用统一闪存接口管理闪存。eMMC结构由一个嵌入式存储解决方案组成，带有MMC接口、快闪存储设备及主控制器，所有这些由一个小型BGA封装。由于采用标准封装，eMMC也很容易升级，并不用改变硬件结构。</p>
<h2 id="MMC-SD通信协议"><a href="#MMC-SD通信协议" class="headerlink" title="MMC/SD通信协议"></a>MMC/SD通信协议</h2><p>卡的状态与模式：</p>
<p>工作条件检测：</p>
<p>发送CMD0(reset)；</p>
<p>发送CMD8，用于取得SD卡支持的工作电压。</p>
<p>在版本2.0中，发送ACMD41，必须先发送CMD8，有应答则是高容量SD卡。</p>
<p>ACMD41是给卡的控制器一个识别卡是否能在给定电压下工作的机制。</p>
<p>卡根据CMD8的参数检测控制器的电压，如果电压不可以，卡处于Idle状态；如果电压可以，发送回执(check voltage, check pattern)，控制器分析回传的CMD8参数校验是否可以在给定的电压下工作。</p>
<p>在ACMD41之后，控制器与卡之间的工作电压将确定。</p>
<p>初始化：</p>
<p>开始于收到ACMD41。</p>
<p>响应CMD8的卡为SDHC卡，ACMD41的HCS部分为1；不响应CMD8的则是普通SD卡；</p>
<p>作为ACMD41的回应，SDHC卡会带有CCS=1。</p>
<p>控制器发送CMD2，处于Ready状态的卡，发送自己的CID作为响应，然后卡进入Identification状态。</p>
<p>控制器发送CMD3，SD卡会发送一个相对地址（RCA）作为响应。卡进入等待状态。</p>
<p>数据传输模式：</p>
<p>CMD7：选择某个卡进入Transfer状态。</p>
<p>CMD9：获取卡的CSD(card specific data)，包括块长度、卡的容量等。</p>
<p>CMD12：停止命令。</p>
<p>CMD17：块读命令。</p>
<p>CMD18：多块读命令。</p>
<p>ACMD51：发送scr(SD Configuration Register)</p>
<p>CMD24：块写命令。</p>
<p>CMD25：多块写命令。</p>
<p>CMD32：擦除的起始地址。</p>
<p>CMD33：擦除的截止地址。</p>
<p>CMD38：擦除命令。</p>
<p>仅仅看SPEC上的通信协议可能略有枯燥，结合代码就比较好理解了。关于SD卡的初始化过程参见：<a href="http://www.cnblogs.com/fengeryi/p/3469782.html" target="_blank" rel="noopener">http://www.cnblogs.com/fengeryi/p/3469782.html</a></p>
<p>这个博客详细描述了SD卡的初始化（mmc_sd_init_card()）。MMC卡的初始化是mmc_init_card()，大致过程相似，比SD卡的函数长不少，但实际的代码干的事情貌似比SD的那些简单一些。这里我们用到的是MMC卡，它的初始化后面会涉及到的。</p>
<p>关于eMMC的原理图部分：</p>
<p>现在的内核使用设备树文件，来描述ARM平台上的相关硬件设备资源。对于设备树（Device Tree）这个东西资料还不是很多，网上有宋宝华写的有关设备树的文章，挺值得参考的。</p>
<p>按我自己的理解，设备树文件就是用一种类似于C语言的东西来描述具体平台相关的硬件资源。这些文件使用特定的编译器编译为.dtb文件，在uboot加载内核的时候，将dtb文件提供给内核，内核便获知了具体的硬件设置；而不再是以前那样，各种各样的硬件信息统统编译进内核。</p>
<p>所使用的硬件资源，来自于设备树文件sama5d3.dtsi（arch/arm/boot/dts/sama5d3.dtsi）与MMC设置有关的寄存器地址：0xf0000000；长度0x600。中断号21，触发模式：4（上升沿触发）。中断优先级为0 。拥有的DMA资源是dma0，寄存器的配置为0x10002200 。</p>
<p>关于设备树文件含义的一些说明，在源码目录中的Document/devicetree/bindings/下有TXT类型的描述文档。</p>
<h2 id="MMC驱动的层次结构"><a href="#MMC驱动的层次结构" class="headerlink" title="MMC驱动的层次结构"></a>MMC驱动的层次结构</h2><p>CARD层  具体的块设备驱动</p>
<p>CORE层  为card层提供操作接口，为host层注册提供机制</p>
<p>HOST层  MMC/SD/SDIO的控制器驱动层</p>
<p>我觉得之所以将整个的驱动分为三层，是为了驱动能够更好的移植到其他的硬件平台上去。CARD层是通用的MMC块设备驱动，这些代码只要是Linux都可以用的；而HOST层里的代码则是与具体平台有关的，进去看文件与函数的名字就可以猜到——我们这里HOST层中的函数常常是”atmci”开头，意思是ATMEL的媒体控制接口，这是因为我们的平台是ATMEL的ARM芯片；而CORE层，则是提供了MMC/SD的核心机制，并且为CARD层屏蔽了HOST层中具体硬件的差异。基于这些有但不完全的原因，MMC/SD的驱动自然而然的分出了三层，也就是drivers/mmc下的三个文件夹。</p>
<h2 id="Linux内核中的面向对象的思想与实现"><a href="#Linux内核中的面向对象的思想与实现" class="headerlink" title="Linux内核中的面向对象的思想与实现"></a>Linux内核中的面向对象的思想与实现</h2><p>在个人学习Linux驱动的过程中，感觉如果只是按照一个一个函数的调用，不断的来回跳，即便是能看懂单个函数的意思，对于整个体系依然是云里雾里，不知内核写了神马东西。若是按照面向对象的思想去理解这些代码，我发现内核的东西就比较容易懂了。</p>
<p>内核虽然是用面向过程的C语言写出来的，但处处体现着面向对象的思想，甚至可以称为一种编程哲学（PS.那些把内核写出来的牛人们，实在太牛了）。Linux不仅仅把设备全部抽象为文件，这种宏观的抽象对象的方法在内核代码里也是比比皆是。个人感觉看代码是在自己脑子里把程序要处理的东西，都抽象为一件件具体的物品，对理解内核代码的来龙去脉，很有帮助。</p>
<p>Linux内核中用面向过程的C语言实现了面向对象的程序架构。一种面向对象的语言，拥有三方面的特性：封装、继承、多态。Linux内核用C语言的基本特性实现了这三种面向对象的特性：使用结构体实现了封装；而某一结构体成员中含有其他结构体的实例，这样实现了一个结构体对另一个结构体的继承；多态的实现则是使用了成员是函数指针的结构体，通过对该结构体中同一个函数指针赋不同的值，调用同一个成员，实际上就会调用不同的函数。当然这些只是我个人的理解了，不一定完全正确。</p>
<p>这种编程思想在驱动中的实现，则主要体现在驱动中对”总线””驱动””设备”这三种结构体处理上：</p>
<p>可以看出来，在驱动的整体框架代码中都是在描述这三个结构体的关系，而功能的实现常常被封装起来。</p>
<p>各种的驱动（device_driver）继承于device_driver结构体；</p>
<p>各种的设备（device）继承于device结构体；</p>
<p>各种的总线（bus）都是bus_type的实例化。</p>
<p>而上述这些都是直接或间接继承于基类kobject。Linux内核通过对kobject的操作，实现了对各部分（包括设备、驱动等）的管理。</p>
<p>驱动与设备在内核中的管理通过总线来实现，对于内核来说，驱动和设备是平级的，因为他们在内核看来都是一个个的继承于kobject的结构体。这一点与我们平常感觉驱动是依附在设备上的直观感觉不同。因为这些都是在代码里体现的，都是虚拟的0与1，驱动和设备以及总线，在内核看来自然差不多了，都是kobject。</p>
<p>在驱动或设备进行probe时，都是沿着总线上的设备和驱动进行匹配的。Linux使用总线的概念来管理设备与驱动的功用。总线就是挂着一串有着相似功用的东西的一根线，同种类的设备与驱动是挂在同一根总线上的，就像拴在一根线上的蚂蚱。在内核看来：这一根上拴的都是绿蚂蚱，那一根上拴的都是黄蚂蚱……想找哪一种蚂蚱，就把哪根线扯出来，再具体看自己是想要上面具体的哪一只蚂蚱。</p>
<p>初始化过程中，添加一个设备主要的工作是初始化继承于device的设备结构体，并把它添加到对应的总线上去。在总线上将去匹配挂在该总线上的驱动。</p>
<p>添加一个驱动的过程与此类似。</p>
<h2 id="MMC-SD驱动的流程"><a href="#MMC-SD驱动的流程" class="headerlink" title="MMC/SD驱动的流程"></a>MMC/SD驱动的流程</h2><p>在Linux启动过程中，加载的有关MMC的模块有3个，分别来自：</p>
<p>/drivers/mmc/core/core.c中的subsys_initcall（优先级4）</p>
<p>/drivers/mmc/card/block.c中的module_init（宏定义来自device_initcall）（优先级6）</p>
<p>/drivers/mmc/host/atmel-mci.c中的late_initcall（优先级7）</p>
<p>优先级的数字越小越是优先。描述各种加载优先级的宏，定义在include/linux/init.h中。</p>
<p>在core.c的init中注册了mmc_bus_type总线。</p>
<p>在block.c的init中调用了mmc_blk_init() → mmc_bus_register_driver()，向mmc_bus_type总线注册了mmc的块设备驱动，并有去尝试probe的动作；但是驱动并没有匹配到设备，因为此时对应的设备还没有注册到总线上，Linux此时并不知道设备的存在，因为到此late_initcall还没有执行到，所以并没有进行probe。</p>
<p>在atmel-mci.c的init调用了platform_driver_register()，完成主机的驱动与设备的注册，之后的一系列操作调用到了mmc_attach_mmc() → mmc_add_card()向总线注册了卡设备，并匹配到了之前的卡驱动。后面会继续详细说的。</p>
<p>在代码里可以看到，整个MMC的驱动涉及了两个总线：platform_bus_type总线和mmc_bus_type总线。因为内核将MMC/SD卡控制器抽象为一个platform总线设备，将MMC/SD卡（块设备）抽象为mmc总线设备。</p>
<p>插曲：{</p>
<p>嗯，上面说到了好多次”总线”，这里再补充说明一下：这”总线”并不是实实在在存在的物理上的电路线；当然对于I2C、SPI等类型的设备，它们有自己的i2c_bus_type和spi_bus_type，它们也的确有看得见摸得着的、用于连接控制器与物理设备的电线存在；但是内核是不理会任何电气特性的，内核认得的东西都是虚拟抽象出来的概念对象。I2C、SPI使用不同方式进行通信，内核对这些不同的方式（通信协议）有不同的处理与管理的方法，因此归纳为不同的”总线”，这个”总线”的概念与物理的”电线”没有逻辑依赖关系。</p>
<p>我看宋宝华的《Linux设备驱动开发详解》有关于platform的讲解，但是我一些内容理解有偏差：”在S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device”。我当时看了，以为platform总线是比i2c总线更为广泛的概念：i2c总线来自于platform总线。但是当我接触的sama5d3的Linux代码时，发现我之前理解的那样是有问题的，platform总线与i2c总线都是struct bus_type类型的实例，是平级的。Linux引入platform总线是为了描述那些不属于常见总线（常见的，比如i2c、spi等等）的设备的一种虚拟总线。</p>
<p>不过，对于”平级”的说法，是我这个初学者的个人看法哈<del>我发现在Linux启动的时候对platform总线是有”特别照顾”的，Linux启动时，系统会加载属于platform总线的设备。是不是i2c这样平台上自带的设备也会搭载这个顺风车？我就不是很清楚了，因为我还没有研究过Linux的I2C驱动。个人感觉应该会，毕竟都是平台（platform）上自带的嘛</del>那么《Linux设备驱动开发详解》我理解的没错只是因为知识不够，所以理解不透啦<del>！哈哈</del>我是新手啊~求别喷呀。</p>
<p>}</p>
<p>整个代码运行的大致流程如下：</p>
<p>从控制器的INIT到块设备的probe。橙色方框描述的是要依赖的一些功能。</p>
<p>下面开始一段一段的说了……</p>
<h3 id="函数atmci-init"><a href="#函数atmci-init" class="headerlink" title="函数atmci_init()"></a>函数atmci_init()</h3><p>（drivers/mmc/host/atmel-mci.c）</p>
<p>在这里的初始化直接对platform_driver的控制器驱动进行了probe。</p>
<p>下面将调用到platfrom_driver_register()。向platform总线注册驱动。凡是在总线注册了的驱动或设备，才是内核所能操作的。这其实是依赖有关于kobject的k_list。</p>
<p>platform_driver_probe() 与 platform_driver_register()</p>
<p>一般来说设备是不能被热插拔的，所以可以将probe()函数放在init中，来节省driver运行时候的内存开销。</p>
<p>一个驱动注册用platform_driver_probe()，在功能和使用上与platform_driver_register()是一样的。唯一的区别是它不能被以后其他的设备probe。也就是说，这个驱动只能和一个设备绑定。而这些的实现就是上图529——534行的代码，可以看看上面的那段注释。</p>
<h3 id="函数platform-driver-register"><a href="#函数platform-driver-register" class="headerlink" title="函数platform_driver_register()"></a>函数platform_driver_register()</h3><p>（drivers/base/platform.c）</p>
<p>将struct platform_driver类型的drv中的driver（struct device_driver类型）的probe成员、remove成员、shutdown成员，填入platform驱动的函数；然后调用driver_register()函数，将驱动注册到总线。</p>
<p>就是将drv变成platform driver。（重载了platform的操作函数，之后的调用者只管使用，并不关心是哪种总线的驱动。）</p>
<h3 id="函数driver-register"><a href="#函数driver-register" class="headerlink" title="函数driver_register()"></a>函数driver_register()</h3><p>将驱动添加到总线。</p>
<p>在driver_register()中主要的就是调用：</p>
<p>  bus_add_driver(drv);</p>
<p>完成驱动向总线的添加。这方面的实现主要是：</p>
<p>  driver_attach(drv);</p>
<p>在总线的设备列表（klist_devices）中遍历，尝试匹配这个驱动。</p>
<p>如果driver_probe_device()返回0，并且dev→driver被设置，就是找到了这个驱动匹配的设备。（这是我翻译的上图中的一句注释）</p>
<h3 id="函数bus-for-each-dev"><a href="#函数bus-for-each-dev" class="headerlink" title="函数bus_for_each_dev()"></a>函数bus_for_each_dev()</h3><p>可以看出该函数里面最终是调用了__driver_attach(dev,data)</p>
<p>dev来自于klist_devices的设备；</p>
<p>data就是drv。</p>
<p>那这里之前都是注册driver的，运行到这里要在总线上为driver匹配device了。这里是找到设备的，因为我当时打印的Log发现能够继续向下运行，没见有找不到设备的样子。那么这个dev是什么时候加到总线上的？我当时找了很久，没找到。也的确不是前面涉及的那些代码添加的设备，是在Linux系统加载的时候把platform设备加到对应的总线上的。</p>
<p>在init/main.c中</p>
<p>kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()初始化platform总线。在这里目前只找到这些可以确定的信息了。</p>
<p>在这个函数中，将由__driver_attach(dev, drv)来具体地实现设备与驱动的匹配。</p>
<h3 id="函数-driver-attach"><a href="#函数-driver-attach" class="headerlink" title="函数__driver_attach()"></a>函数__driver_attach()</h3><p>（drivers/base/dd.c）</p>
<p>driver_match_device(drv, dev)中调用了drv→bus→match(dev, drv)。</p>
<p>这个match是platform_match()进行设备名字与驱动名字的比较，相同或者drv→bus→match为空将返回1。</p>
<p>如果dev→driver之前没有被设置，将执行driver_probe_device()。</p>
<p>__driver_attach()</p>
<p>→ driver_probe_device()</p>
<p>→ really_probe()</p>
<p>{</p>
<p>…</p>
<p>if(dev→bus →probe){</p>
<p>ret = dev→bus→probe(dev);</p>
<p>…</p>
<p>} else if {</p>
<p>ret = drv→probe(dev);</p>
<p>…</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>在这里将会执行drv→probe(dev)（这个probe在platform_driver_register()中被赋值）即platform_drv_probe()，这个函数中调用的其实是drv→probe(dev)。在这里的probe就是atmci_probe()了。</p>
<p>以上调用过程的总结：</p>
<p>在最开始传入的是struct platform_driver *atmci_driver（代表了MMC/SD控制器驱动）。然后使用由Linux kernel提供的platform机制对改驱动进行注册。</p>
<p>完成系统内的注册后，将交给atmci_probe()来处理具体平台相关的工作。</p>
<p>这里对probe函数的处理，就类似于面向对象的”重载”。因为不管是什么样的platform驱动都会调用platform_drv_probe()，此处则是重载到了atmci_probe()。</p>
<h3 id="函数atmci-probe"><a href="#函数atmci-probe" class="headerlink" title="函数atmci_probe()"></a>函数atmci_probe()</h3><p>这个函数的操作主要是围绕struct atmel_mci *host展开的。这个结构体的含义应该是对控制器状态的描述。</p>
<p>可以分为两段：</p>
<p>第一段是获取资源。第二段是初始化slot。</p>
<p>获取内存资源；</p>
<p>从设备树的节点里读取信息到platform_data；</p>
<p>设置引脚模式；</p>
<p>获取中断资源；</p>
<p>初始化struct atmel_mci host中的锁和队列；</p>
<p>设置中断处理函数、数据传输方式，等。</p>
<p>atmci_init_slot()函数：设置硬件的相关信息，最后用这些信息初始化struct mmc_host *mmc硬件（表示mmc的控制器）。</p>
<p>主要包含mmc_alloc_host()为控制器结构体分配空间，并初始化控制器结构体；</p>
<p>和mmc_add_host()初始化host硬件。</p>
<h3 id="函数mmc-add-host"><a href="#函数mmc-add-host" class="headerlink" title="函数mmc_add_host()"></a>函数mmc_add_host()</h3><p>在atmci_probe()中调用的atmci_init_slot()，其前半段是获取资源设置相关信息，即函数mmc_alloc_host()。后半段则是使用这些信息去初始化MMC控制器的硬件，使之能够工作，即mmc_add_host()函数。</p>
<p>在mmc_add_host()中主要起作用的是mmc_start_host()</p>
<h3 id="函数mmc-detect-change"><a href="#函数mmc-detect-change" class="headerlink" title="函数mmc_detect_change()"></a>函数mmc_detect_change()</h3><p>（drivers/mmc/core/core.c）</p>
<p>当有卡插入或移除时，应调用这个函数，MMC层将确定现有的卡正常工作，并且初始化新插入的卡。</p>
<p>最主要的是mmc_schedule_delayed_work(&amp;host→detect, delay)</p>
<p>→ queue_delayed_work(workqueue, work, delay)</p>
<p>→ queue_work(wq, &amp;dwork→work)</p>
<p>mmc_schedule_delayed_work(&amp;host→detect, delay)的意思是，把&amp;host→detect作为一个work传给了queue_delayed_work()。</p>
<p>这个函数将一个工作（work）添加到workqueue这个工作队列中。</p>
<p>在工作队列中，不久将会调用host→detect描述的函数。</p>
<p>那这个detect指向的是哪一个函数？在mmc_alloc_host()中有：</p>
<p>INIT_DELAYED_WORK(&amp;host→detect, mmc_rescan);</p>
<p>含义为：初始化一个工作mmc_rescan，由detect指向它。</p>
<p>所以在工作队列workqueue中mmc_rescan()函数将被执行。在这个函数中将调用mmc_rescan_try_freq()，接下来将会是卡的检测与初始化。</p>
<p>以上阶段的总结：</p>
<p>struct atmci_mci 代表了MMC控制器的接口状态。并非内核中MMC控制器本身，而是其parent device。</p>
<p>在内核看来每一个卡槽（slot）由一个MMC控制器（struct mmc_host）来代表。嗯嗯，我是这样理解的。</p>
<h3 id="函数mmc-rescan"><a href="#函数mmc-rescan" class="headerlink" title="函数mmc_rescan()"></a>函数mmc_rescan()</h3><p>调用函数mmc_rescan_try_freq() （drivers/mmc/core/core.c）</p>
<p>首先发送CMD0，即mmc_go_idle()；</p>
<p>然后发送CMD8，即mmc_send_if_cond()；（其实后面还会在发送这些命令的。）</p>
<p>接下来依次探测SDIO、SD、MMC。</p>
<p>我们这里是eMMC，所以进入mmc_attach_mmc()：</p>
<h3 id="函数mmc-attach-mmc"><a href="#函数mmc-attach-mmc" class="headerlink" title="函数mmc_attach_mmc()"></a>函数mmc_attach_mmc()</h3><p>（drivers/mmc/core/mmc.c）</p>
<p>mmc_init_card()对一个卡（struct mmc_card card）进行初始化。</p>
<p>mmc_add_card()将卡设备添加到内核。</p>
<h3 id="函数mmc-init-card"><a href="#函数mmc-init-card" class="headerlink" title="函数mmc_init_card()"></a>函数mmc_init_card()</h3><p>下面的两个图是极简版的代码（原版的代码好像有460多行，挺长的），有好多重要的东西省掉了，仅仅是为了结合代码标注一下CMD。</p>
<p>CMD0：让卡进入idle状态。</p>
<p>CMD1：让卡发送OCR。</p>
<p>CMD2：向卡询问CID。</p>
<p>CMD3：设置卡的相对地址。</p>
<p>CMD9：获取卡的CSD。</p>
<p>CMD7：选择一个卡。</p>
<p>CMD8：获取扩展的CSD。</p>
<p>主机与卡之间的协调设置。（如：分区、掉电通知、高速等等）</p>
<p>CMD6：为选定的卡修改模式或更改EXT_CSD。（这个命令在mmc_switch()中的，上面的图中被省略了。）</p>
<p>总之，mmc_init_card()完成了对卡的应有的全部初始化工作，包括传输速度、总线宽度等等，但是要更改这些设置是不在这个函数中改的，这里全都是MMC/SD卡协议的落实。真正要改的话是在HOST层中改一些数据，而不是在这里的CORE层中改。在后面会说到如何更改传输速度和总线宽度的。</p>
<h3 id="函数mmc-add-card"><a href="#函数mmc-add-card" class="headerlink" title="函数mmc_add_card()"></a>函数mmc_add_card()</h3><p>（drivers/mmc/core/bus.c）</p>
<p>mmc_init_card()之后，调用mmc_add_card()，作用是将这个card设备添加到内核，内部调用了device_add将card→dev添加到内核中。</p>
<p>device_add(&amp;card→dev)</p>
<p>→ bus_probe_device(dev)</p>
<p>→ device_attach(dev)</p>
<p>→ bus_for_each_drv(dev→bus, NULL, dev, __device_attach)</p>
<p><strong>device_attach()与之前的</strong>driver_attach()基本一样。</p>
<p>我们传入的dev是&amp;card→dev，这个在mmc_alloc_card()中被赋值为mmc_bus_type。（mmc.c-866; bus.c-250）</p>
<p>如前面所说的那样，在上图中的driver_match_device()将调用dev的match函数（mmc_bus_match()）而这个函数始终返回1（里面什么都没写，除了一句”return 1;”）。</p>
<p>所以执行driver_probe_device()。这里将调用really_probe()执行mmc_bus_type结构体中的probe成员（mmc_bus_probe()）。</p>
<h3 id="函数mmc-bus-probe"><a href="#函数mmc-bus-probe" class="headerlink" title="函数mmc_bus_probe()"></a>函数mmc_bus_probe()</h3><p>（drivers/mmc/core/bus.c）</p>
<p>在to_mmc_driver()，将返回含有dev→driver的mmc_driver的指针。这个结构体中的probe()则是mmc_blk_probe()函数。</p>
<p>在mmc_dev_to_card()，将返回含有dev的mmc_card的指针。</p>
<p>在这个始终返回1的match，可以看出：挂在这条总线上的driver都会如此运行，也就是说都会来执行mmc_blk_probe()函数。（之所以要始终返回1，是为了，全部的设备都去匹配MMC的块设备驱动。）</p>
<p>现在，则是由CORE层转入了CARD层了。 struct mmc_driver， mmc_blk_probe()都是在 drivers/mmc/card/block.c中定义的。</p>
<h3 id="函数mmc-blk-probe"><a href="#函数mmc-blk-probe" class="headerlink" title="函数mmc_blk_probe()"></a>函数mmc_blk_probe()</h3><p>（drivers/mmc/card/block.c）</p>
<p>mmc_blk_alloc()为块设备分配空间，并初始化请求队列。</p>
<p>mmc_add_disk()中调用了add_disk()l函数，说明之前一定有alloc_disk和初始化队列的动作。</p>
<p>其中因为调用了add_disk()，磁盘设备将被”激活”，并随时会调用它提供的方法。</p>
<p>请求队列就是在mmc_blk_alloc()函数完成的。而其中的主要成分就是mmc_blk_alloc_req()。</p>
<h3 id="函数mmc-blk-alloc-req"><a href="#函数mmc-blk-alloc-req" class="headerlink" title="函数mmc_blk_alloc_req()"></a>函数mmc_blk_alloc_req()</h3><p>（drivers/mmc/card/block.c）</p>
<p>下图红线标注的依次是：</p>
<p>allco_disk()分配gendisk结构体；</p>
<p>初始化请求队列；</p>
<p>绑定请求函数。</p>
<p>下面是初始化major、fops、queue等。</p>
<p>MMC卡驱动走的块设备驱动的套路：</p>
<p>1.alloc_disk()分配了gendisk结构体。并初始化了major，fops，queue。</p>
<p>2.mmc_init_queue()初始化了队列，并将mmc_blk_issue_rq()绑定为请求函数。</p>
<p>3.调用add_disk()将块设备加到内核。</p>
<h3 id="函数add-disk"><a href="#函数add-disk" class="headerlink" title="函数add_disk()"></a>函数add_disk()</h3><p>由mmc_add_disk()调用的内核函数。</p>
<p>其完成的任务：</p>
<p>1.验证设备号。   blk_alloc_devt(&amp;disk→part0, &amp;devt);</p>
<p>2.注册bolck_device   register_disk(disk);</p>
<p>3.注册请求队列   blk_register_queue(disk);</p>
<p>mmc_blk_probe()</p>
<p>→ mmc_blk_alloc()</p>
<p>→ mmc_blk_alloc_req()</p>
<p>→ alloc_disk()</p>
<p>&amp; mmc_init_queue()</p>
<p>&amp; mmc_add_disk()</p>
<p>→ add_disk()</p>
<p>add_disk()的调用标志着一个块设备驱动将被激活。</p>
<p>MMC驱动的加载过程也到此结束。</p>
<p>以上阶段的总结：</p>
<h2 id="对卡插入的支持"><a href="#对卡插入的支持" class="headerlink" title="对卡插入的支持"></a>对卡插入的支持</h2><p>函数atmci_init_slot() （drivers/mmc/host/atmel-mci.c）</p>
<p>在中断处理函数atmci_detect_interrupt()中，调用了mod_timer()，这个函数会重新注册定时器到内核，而不管定时器函数是否被运行过。在注册定时器到内核的函数setup_timer()中的回调函数（atmci_detect_change()）中，最终调用了mmc_detect_change()。如前所述，此函数会引起<strong>函数mmc_rescan()</strong>的调用，这个函数就是检测卡是否插入的。</p>
<p>也就是说，detect引脚有中断，就会重新注册定时器到内核，经过一段时间，将运行定时器的回调函数，最终进行了插卡的检测。</p>
<p>不过我们这里是eMMC，是直接焊在板子上的，不会有什么插卡的动作；在这里只是提一下。</p>
<h2 id="MMC-SD卡读写"><a href="#MMC-SD卡读写" class="headerlink" title="MMC/SD卡读写"></a>MMC/SD卡读写</h2><h3 id="读写在内核中的处理层次"><a href="#读写在内核中的处理层次" class="headerlink" title="读写在内核中的处理层次"></a>读写在内核中的处理层次</h3><p>过程概述：</p>
<p>Linux系统调用（SCI）的实现机制，实际上是多路汇聚以及分解。汇聚点是0x80中断入口，所有的系统调用从用户空间汇聚到0x80中断，中断处理程序运行时，将根据不同的系统调用号分别处理。</p>
<p>例如，当调用read时，库函数在保存read的SCI号及参数后，陷入0x80中断。这时库函数的工作结束，从用户空间进入到内核空间。</p>
<p>0x80中断处理程序，根据系统调用号查询系统调用表。</p>
<p>以read为例，read对应的是sys_read，传递参数并运行sys_read。</p>
<p>最终将一个请求（request）传递给块设备驱动处理。</p>
<p>对应的块设备处理函数为mmc_blk_issue_rq()（drivers/mmc/card/block.c 在上文提到过，被绑定的请求函数）</p>
<p>请求的调用层次，见下图（图中第一项多写了一个”e”）：</p>
<h3 id="驱动层上的读写"><a href="#驱动层上的读写" class="headerlink" title="驱动层上的读写"></a>驱动层上的读写</h3><p>（将会对上图进行一些说明）</p>
<p>在函数mmc_blk_alloc_req中，调用的mmc_init_queue拉起了一个内核线程，这个线程主要的作用是把上层IO的request一个个地向具体的driver发送。</p>
<p>这个线程叫做”mmcdq”，函数mmc_queue_thread是实际做事情的。</p>
<p>线程mmcqd的工作非常简单，在blk_fetch_request(q)获取一个request后，最终通过调用mq→issue_fn(mq, req)向底层发送request。</p>
<p>这个函数便是mmc_blk_issue_rq。大部分request通过</p>
<p>ret = mmc_blk_issue_rw_rq(mq, req);</p>
<p>来发送。</p>
<p>之后会调用到mmc的core部分。</p>
<p>mmc_blk_issue_rw_rq()</p>
<p>→ mmc_start_req()</p>
<p>→ __mmc_start_req()</p>
<p>→ mmc_start_request()</p>
<p>→ host→ops→request(host, mrq)</p>
<p>== atmci_request()</p>
<p>→ atmci_queue_request(host, slot, mrq)</p>
<p>→ atmci_start_request(host, slot)</p>
<p>函数atmci_request() （drivers/mmc/host/atmel-mci.c）</p>
<p>atmci_request()</p>
<p>→ atmci_queue_request()</p>
<p>→ atmci_start_request()</p>
<p>如上图所示在atmel-mci.c, atmci_probe()中就对DMA操作函数进行准备了。</p>
<p>对atmci_start_request()的过程画了一个流程图：</p>
<p>以上过程的总结：</p>
<h2 id="修改MMC的传输速度"><a href="#修改MMC的传输速度" class="headerlink" title="修改MMC的传输速度"></a>修改MMC的传输速度</h2><p>函数atmci_init_slot() （drivers/mmc/host/atmel-mci.c）</p>
<h3 id="关于时钟-55MHz与44MHz"><a href="#关于时钟-55MHz与44MHz" class="headerlink" title="关于时钟 55MHz与44MHz"></a>关于时钟 55MHz与44MHz</h3><p>（因为发现软件上设置的是55MHz，实际测出来是44MHz）</p>
<p>mmc_set_clock()→atmci_set_ios()。52MHz最终由atmci_set_ios()处理。</p>
<p>这是cpu的spec上的相关说明，其中：</p>
<p>{CLKDIV, CLKODD} + 2 == (CLKDIV * 2 + CLKODD) + 2</p>
<p>drivers/mmc/host/atmel-mci.c</p>
<p>atmci_set_ios()</p>
<p>上图红线标出的三个宏定义为：</p>
<p>#define DIV_ROUND_UP(n, d)  (((n) + (d) - 1) / (d))</p>
<p>#define ATMCI_MR_CLKDIV(x)  ((x) &lt;&lt; 0)</p>
<p>#define ATMCI_MR_CLKODD(x)  ((x) &lt;&lt; 16)</p>
<p>那么，接下来我们按照代码中的描述，自己计算一下：</p>
<p>(132M + 52M - 1) / 52M = 3</p>
<p>clkdiv = 3 - 2 = 1</p>
<p>1 &gt;&gt; 1 = 0</p>
<p>1 &amp; 1 = 1</p>
<p>mode_reg = (0 &lt;&lt; 0) | (1 &lt;&lt; 16)</p>
<p>所以写入HSMCI_MR寄存器的是：CLKODD置1；CLKDIV是00000000。</p>
<p>根据cpu的spec，得：</p>
<p>CLKDIV * 2 + CLKODD + 2 </p>
<p>= 0 * 2 + 1 + 2</p>
<p>= 3 （3分频）</p>
<p>132MHz / 3 = 44MHz</p>
<p>所以传入的52MHz，实际获得的是44MHz。之前低速的26MHz，实际获得的是22MHz。</p>
<p>在atmci_set_ios()中的这些处理，是因为bus_hz具体是多少，写程序的人是不知道的，这个是由具体的硬件来决定的（在这里就是132MHz）。所以，不能保证设置52MHz，硬件就能真的分频出52MHz，于是设计了上面的运算：根据实际的总线时钟大小（132MHz），和软件中设定的时钟（52/26MHz）；计算出一个接近设定的时钟，而且能由总线时钟分频出来的一个值（44/22MHz）。</p>
<h2 id="我在更改过程中遇到的一些错误"><a href="#我在更改过程中遇到的一些错误" class="headerlink" title="我在更改过程中遇到的一些错误"></a>我在更改过程中遇到的一些错误</h2><h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><p>drivers/mmc/core/mmc.c</p>
<p>mmc_init_card()</p>
<p>导致不能启动。</p>
<p>我刚开始改的时候，直接去找时钟在哪里设定的，然后去改那个值。就做出了上图的更改，这样是片面的；因为52MHz同时需要对高速的支持，控制器与卡之间也要保持协调。</p>
<h3 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3><p>高速8bit模式下，数据传输可能出错（windows循环冗余检查出错）</p>
<p>出现条件：线路与示波器测试头接触时，很可能出现。这个错误只会出现在硬件测量的时候，如果安静地让它去复制，就不会出错，一切正常。</p>
<p>在4bit模式下的数据传输过程中没有出现这个情况。</p>
<p>解决方法：CPU的HSMCI_CFG寄存器HSMODE置位。</p>
<p>嗯嗯，这个驱动就这样粗略地整理完了……</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Android-emmc性能测试</title>
    <url>/2020/12/29/Linux/Driver/storage/Flash%20Memory/mmc/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android-emmc%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>本文转自：【<a href="http://qiushao.net/2020/02/12/Android/emmc-performance-test/】" target="_blank" rel="noopener">http://qiushao.net/2020/02/12/Android/emmc-performance-test/】</a></p>
<h2 id="Android-emmc性能测试"><a href="#Android-emmc性能测试" class="headerlink" title="Android-emmc性能测试"></a>Android-emmc性能测试</h2><p>在 Android 可以用来测试 emmc io 性能的工具有很多，　比如 fio, iozone, dd 等。　看了大半天的　fio, iozone，　感觉用起来比较复杂，相对来说还是使用 dd 简单方便。接下来我们就以 dd 为主介绍一下如何测试 emmc 的 io　性能。</p>
<h2 id="1-页面缓存"><a href="#1-页面缓存" class="headerlink" title="1. 页面缓存"></a>1. 页面缓存</h2><p>在开始之前，我们先了解一下页面缓存的概念。简单的说就是系统会把读取过的部分文件缓存到内存中，以此加快热点文件的读取速度，提高磁盘的 IO 速度。<br>具体的原理见 <a href="http://www.ilinuxkernel.com/files/Linux.Kernel.Cache.pdf" target="_blank" rel="noopener">Linux内核文件Cache机制</a>。<br>为了测试 emmc 的真实读写性能，我们需要先把页面缓存给清理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br></pre></td></tr></table></figure>

<p>我们先看看页面缓存的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 5.023993 seconds, 203.8MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #                                                               </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 0.564027 seconds, 1.8GB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; # </span><br><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 5.103213 seconds, 200.7MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>连续执行两次同样参数的 dd 命令，　从 /dev/block/mmcblk0 (也就是我们的 emmc) 块设备中读取内容，　写到 /dev/null 。/dev/null 是一个虚拟设备，写入这个路径并不会保存，我们可以认为这个设备的写入速度无限大，　也就是写入速度不会成为这个命令的瓶颈，　我们这个命令主要是为了测试 emmc 的读取速度。可以看到第一次执行的结果是 203.8MB/s，　第二次执行的结果是 1.8GB/s。从这个数据来看，页面缓存极大的提高了热点文件的读取速度。然后我们用 <code>echo 1 &gt; /proc/sys/vm/drop_caches</code>　命令清除一下页面缓存，再执行同样的 dd　命令，发现速度跟第一次差不多了。</p>
<h2 id="2-写入性能测试"><a href="#2-写入性能测试" class="headerlink" title="2. 写入性能测试"></a>2. 写入性能测试</h2><p>我们分为两种情况来测试</p>
<h3 id="2-1-写入块设备"><a href="#2-1-写入块设备" class="headerlink" title="2.1 写入块设备"></a>2.1 写入块设备</h3><p>cache 分区一般是用来存放 OTA 升级包的，正常状态下挂载失败也不影响系统的正常运行，所以我们拿 cache 分区来作写入测试，先找到 cache 对应的块设备文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; #ls -l &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache                         &lt;</span><br><span class="line">lrwxrwxrwx 1 root root 21 1970-01-01 08:00 &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p18</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>cache 分区的块设备文件为 /dev/block/mmcblk0p18。<br>写入测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync     </span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 24.122624 seconds, 42.4MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>输入文件为 /dev/zero，是一个虚拟设备，我们可以认为这个设备的读取速度无限大，也就是读取速度不会影响到写入的速度。<br>bs=1M : 一次写入 1M<br>count=1024 : 写入 1024 次，也就是写入的数据总量为 1G<br><strong>conv=fsync : dd 结束前，把数据同步到 emmc，如果没加这个参数的话，数据可能还在缓存之中。为了确保数据准确，一定要加这个参数。</strong></p>
<p>重复测试几次，速度基本在 42M/s　左右。</p>
<h3 id="2-2-写入文件"><a href="#2-2-写入文件" class="headerlink" title="2.2 写入文件"></a>2.2 写入文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;data&#x2F;ddtest.bin bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync                         &lt;</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 30.607905 seconds, 33.5MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>重复测试几次，速度基本在 33M/s　左右。相对直接写块设备文件慢了 10M/s 左右。这可能是文件系统带来的影响。</p>
<h2 id="3-读取测试"><a href="#3-读取测试" class="headerlink" title="3. 读取测试"></a>3. 读取测试</h2><h3 id="3-1-读取块设备"><a href="#3-1-读取块设备" class="headerlink" title="3.1 读取块设备"></a>3.1 读取块设备</h3><p>直接用我们上面介绍清除缓存的例子就行，这里就不再重复了。<br>从上面的例子得到的数据为 203M/s 左右。</p>
<h3 id="3-1-读取文件"><a href="#3-1-读取文件" class="headerlink" title="3.1 读取文件"></a>3.1 读取文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;data&#x2F;ddtest.bin of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024</span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.0GB) copied, 4.915286 seconds, 208.3MB&#x2F;s</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>直接拿测试写入速度时生成的文件，重复测试几次，速度基本上在 208MB/s 左右。</p>
<h2 id="4-对比iozone"><a href="#4-对比iozone" class="headerlink" title="4. 对比iozone"></a>4. 对比iozone</h2><p>Android 系统源码中并没有 iozone，我们得自己人官网上下载编译，我下载时最新版本为　iozone3_489，　这个版本已经有 Android.mk 在代码里面了，　将源码放到 Android 系统源码里面 mm 即可。<br>随机读写测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">KKHi3751V810:&#x2F; # iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin                             </span><br><span class="line">        Iozone: Performance Test of File I&#x2F;O</span><br><span class="line">                Version $Revision: 3.489 $</span><br><span class="line">                Compiled for 64 bit mode.</span><br><span class="line">                Build: linux-arm </span><br><span class="line"></span><br><span class="line">        Contributors:William Norcott, Don Capps, Isom Crawford, Kirby Collins</span><br><span class="line">                     Al Slater, Scott Rhine, Mike Wisner, Ken Goss</span><br><span class="line">                     Steve Landherr, Brad Smith, Mark Kelly, Dr. Alain CYR,</span><br><span class="line">                     Randy Dunlap, Mark Montague, Dan Million, Gavin Brebner,</span><br><span class="line">                     Jean-Marc Zucconi, Jeff Blomberg, Benny Halevy, Dave Boone,</span><br><span class="line">                     Erik Habbinga, Kris Strecker, Walter Wong, Joshua Root,</span><br><span class="line">                     Fabrice Bacchella, Zhenghua Xue, Qin Li, Darren Sawyer,</span><br><span class="line">                     Vangel Bojaxhi, Ben England, Vikentsi Lapa,</span><br><span class="line">                     Alexey Skidanov, Sudhir Kumar.</span><br><span class="line"></span><br><span class="line">        Run began: Wed Feb 12 20:47:58 2020</span><br><span class="line"></span><br><span class="line">        Auto Mode</span><br><span class="line">        Cross over of record size disabled.</span><br><span class="line">        Include fsync in write timing</span><br><span class="line">        Include close in write timing</span><br><span class="line">        O_DIRECT feature enabled</span><br><span class="line">        No retest option selected</span><br><span class="line">        Record Size 1024 kB</span><br><span class="line">        File size set to 1048576 kB</span><br><span class="line">        Setting no_unlink</span><br><span class="line">        Command line used: iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin</span><br><span class="line">        Output is in kBytes&#x2F;sec</span><br><span class="line">        Time Resolution &#x3D; 0.000001 seconds.</span><br><span class="line">        Processor cache size set to 32 kBytes.</span><br><span class="line">        Processor cache line size set to 64 bytes.</span><br><span class="line">        File stride size set to 17 * record size.</span><br><span class="line">                                                              random    random     bkwd    record    stride                                    </span><br><span class="line">              kB  reclen    write  rewrite    read    reread    read     write     read   rewrite      read   fwrite frewrite    fread  freread</span><br><span class="line">         1048576    1024    74782        0                     199299    71520                                                                </span><br><span class="line"></span><br><span class="line">iozone test complete.</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>从结果来看，随机读速度为 199299 kB/s , 大概为 200M/s。　随机写速度为 71520 kB/s，　大概为 70M/s。<br>重复测试几次结果差不多，读的速度基本跟 dd 的一致。写入的比 dd 的快了将近一倍。</p>
<h2 id="5-对比fio"><a href="#5-对比fio" class="headerlink" title="5. 对比fio"></a>5. 对比fio</h2><h3 id="5-1-写入文件速度"><a href="#5-1-写入文件速度" class="headerlink" title="5.1 写入文件速度"></a>5.1 写入文件速度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randwrite -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_write_1m</span><br><span class="line">rand_write_1m: (g&#x3D;0): rw&#x3D;randwrite, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1</span><br><span class="line">...</span><br><span class="line">fio-2.2.6</span><br><span class="line">Starting 4 threads</span><br><span class="line">Jobs: 3 (f&#x3D;3): [w(3),_(1)] [98.1% done] [0KB&#x2F;80734KB&#x2F;0KB &#x2F;s] [0&#x2F;78&#x2F;0 iops] [eta 00m:01s]</span><br><span class="line">rand_write_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;8316: Wed Feb 12 21:03:34 2020</span><br><span class="line">  write: io&#x3D;4096.0MB, bw&#x3D;83067KB&#x2F;s, iops&#x3D;81, runt&#x3D; 50493msec</span><br><span class="line">    clat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.60, stdev&#x3D;44.45</span><br><span class="line">     lat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.86, stdev&#x3D;44.44</span><br><span class="line">    clat percentiles (msec):</span><br><span class="line">     |  1.00th&#x3D;[   18],  5.00th&#x3D;[   22], 10.00th&#x3D;[   23], 20.00th&#x3D;[   26],</span><br><span class="line">     | 30.00th&#x3D;[   34], 40.00th&#x3D;[   37], 50.00th&#x3D;[   46], 60.00th&#x3D;[   48],</span><br><span class="line">     | 70.00th&#x3D;[   58], 80.00th&#x3D;[   65], 90.00th&#x3D;[   76], 95.00th&#x3D;[   87],</span><br><span class="line">     | 99.00th&#x3D;[  104], 99.50th&#x3D;[  114], 99.90th&#x3D;[  758], 99.95th&#x3D;[ 1123],</span><br><span class="line">     | 99.99th&#x3D;[ 1369]</span><br><span class="line">    bw (KB  &#x2F;s): min&#x3D; 1343, max&#x3D;41353, per&#x3D;25.49%, avg&#x3D;21171.93, stdev&#x3D;4637.55</span><br><span class="line">    lat (msec) : 20&#x3D;1.51%, 50&#x3D;60.52%, 100&#x3D;36.40%, 250&#x3D;1.37%, 500&#x3D;0.02%</span><br><span class="line">    lat (msec) : 750&#x3D;0.05%, 1000&#x3D;0.05%, 2000&#x3D;0.07%</span><br><span class="line">  cpu          : usr&#x3D;0.43%, sys&#x3D;1.13%, ctx&#x3D;10620, majf&#x3D;0, minf&#x3D;6</span><br><span class="line">  IO depths    : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     submit    : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     complete  : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     issued    : total&#x3D;r&#x3D;0&#x2F;w&#x3D;4096&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0</span><br><span class="line">     latency   : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  WRITE: io&#x3D;4096.0MB, aggrb&#x3D;83067KB&#x2F;s, minb&#x3D;83067KB&#x2F;s, maxb&#x3D;83067KB&#x2F;s, mint&#x3D;50493msec, maxt&#x3D;50493msec</span><br><span class="line"></span><br><span class="line">Disk stats (read&#x2F;write):</span><br><span class="line">  mmcblk0: ios&#x3D;54&#x2F;8332, merge&#x3D;5&#x2F;888, ticks&#x3D;60872&#x2F;378355, in_queue&#x3D;439181, util&#x3D;100.00%</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>4个线程的平均写入速度为 bw=83067KB/s，大概是 80M/s，　比 dd 也快了一倍多。</p>
<h3 id="5-2-读取文件速度"><a href="#5-2-读取文件速度" class="headerlink" title="5.2 读取文件速度"></a>5.2 读取文件速度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches                             </span><br><span class="line">KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randread -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_read_1m</span><br><span class="line">rand_read_1m: (g&#x3D;0): rw&#x3D;randread, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1</span><br><span class="line">...</span><br><span class="line">fio-2.2.6</span><br><span class="line">Starting 4 threads</span><br><span class="line">Jobs: 1 (f&#x3D;1): [_(3),r(1)] [96.2% done] [148.5MB&#x2F;0KB&#x2F;0KB &#x2F;s] [148&#x2F;0&#x2F;0 iops] [eta 00m:01s]     </span><br><span class="line">rand_read_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;7889: Wed Feb 12 20:56:21 2020</span><br><span class="line">  read : io&#x3D;4096.0MB, bw&#x3D;171813KB&#x2F;s, iops&#x3D;167, runt&#x3D; 24412msec</span><br><span class="line">    clat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06</span><br><span class="line">     lat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06</span><br><span class="line">    clat percentiles (msec):</span><br><span class="line">     |  1.00th&#x3D;[    7],  5.00th&#x3D;[    8], 10.00th&#x3D;[    8], 20.00th&#x3D;[   11],</span><br><span class="line">     | 30.00th&#x3D;[   11], 40.00th&#x3D;[   11], 50.00th&#x3D;[   11], 60.00th&#x3D;[   14],</span><br><span class="line">     | 70.00th&#x3D;[   14], 80.00th&#x3D;[   14], 90.00th&#x3D;[   14], 95.00th&#x3D;[   14],</span><br><span class="line">     | 99.00th&#x3D;[   16], 99.50th&#x3D;[   30], 99.90th&#x3D;[ 2638], 99.95th&#x3D;[ 4113],</span><br><span class="line">     | 99.99th&#x3D;[ 9372]</span><br><span class="line">    bw (KB  &#x2F;s): min&#x3D;  964, max&#x3D;145420, per&#x3D;46.41%, avg&#x3D;79740.53, stdev&#x3D;25495.41</span><br><span class="line">    lat (msec) : 10&#x3D;13.77%, 20&#x3D;85.55%, 50&#x3D;0.29%, 100&#x3D;0.12%, 500&#x3D;0.05%</span><br><span class="line">    lat (msec) : 750&#x3D;0.05%, 2000&#x3D;0.05%, &gt;&#x3D;2000&#x3D;0.12%</span><br><span class="line">  cpu          : usr&#x3D;0.22%, sys&#x3D;3.16%, ctx&#x3D;9195, majf&#x3D;0, minf&#x3D;1030</span><br><span class="line">  IO depths    : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     submit    : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     complete  : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0%</span><br><span class="line">     issued    : total&#x3D;r&#x3D;4096&#x2F;w&#x3D;0&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0</span><br><span class="line">     latency   : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: io&#x3D;4096.0MB, aggrb&#x3D;171813KB&#x2F;s, minb&#x3D;171813KB&#x2F;s, maxb&#x3D;171813KB&#x2F;s, mint&#x3D;24412msec, maxt&#x3D;24412msec</span><br><span class="line"></span><br><span class="line">Disk stats (read&#x2F;write):</span><br><span class="line">  mmcblk0: ios&#x3D;8365&#x2F;46, merge&#x3D;15&#x2F;47, ticks&#x3D;633927&#x2F;61332, in_queue&#x3D;695214, util&#x3D;99.20%</span><br><span class="line">KKHi3751V810:&#x2F; #</span><br></pre></td></tr></table></figure>

<p>４个线程的平均读速度为 bw=171813KB/s，　大概为 170M/s。</p>
<p>综合对比 dd, iozone, fio　这几个工具发现，读的速度基本上差不多，但写速度差距比较大，可能跟设置的参数有关。<br>为了简单起见，我们只采用 dd 的结果作为参考数据即可。</p>
<p>参考文章:</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>storage</category>
        <category>Flash Memory</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>PCI-Express 处理器DMA实现方案</title>
    <url>/2020/07/29/Linux/Driver/PCIe/PCI-Express%20%E5%A4%84%E7%90%86%E5%99%A8DMA%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工程项目中，使用PCIe主要是利用DMA机制，实现高速数据传输。曾经接触过一个项目，采用x86+FPGA方案实现高速数据采集。该方案，使用FPGA自带的PCIe核与x86进行DMA数据传输。本文讲解在x86下Linux 实现DMA的方案，不讲FPGA内部PCIe实现逻辑。</p>
<h2 id="DMA基础知识"><a href="#DMA基础知识" class="headerlink" title="DMA基础知识"></a>DMA基础知识</h2><p>在PCIE中有两种数据传输方式：</p>
<p><strong>DMA(Direct Memory Access)直接内存访问:</strong>在该模式下，数据传送不是由CPU负责处理，而是由一个特殊的处理器DMA控制器来完成，因此占用极少的CPU资源。</p>
<p><strong>PIO(Programmed Input-Output)，可编程输入输出:</strong>在该模式下，数据传送由CPU执行I/O端口指令来按照字节或更大的数据单位来处理，占用大量的CPU资源，数据传输速度也大大低于DMA模式。举例老说，在DMA方式下，如果copy文件的同时在播放mp3音乐，则不受丝毫影响；如果在PIO模式下，则会发现音乐声时断时续，这是因为大部分CPU资源被文件传输占用。</p>
<p>总的来说，DMA模式与PIO相比有很大优势，PIO数据传输直接由CPU执行，通常每次只能传输一个DW数据，在大量数据传输中会占用较多CPU资源，导致传输速度不足；然而对于大数据传输，DMA实现会带来更高的数据吞吐量，因为DMA硬件引擎不限于一个或两个DW传输。此外，DMA引擎通过直接传输数据来卸载CPU，从而通过较低的CPU利用率提高整个系统的性能。</p>
<p>DMA核的逻辑设计图如下</p>
<p><img src="http://jiali.clouddn.com/20200729_002.png" alt=""></p>
<p>硬件实现了DMA机制，Linux要做的事情：</p>
<ul>
<li>分配一块物理地址连续的内存区域，用于DMA传输</li>
<li>设置FPGA的BAR0空间的DMA起始地址寄存器</li>
<li>使能DMA传输</li>
</ul>
<h2 id="DMA写（FPGA往CPU的内存写数据）"><a href="#DMA写（FPGA往CPU的内存写数据）" class="headerlink" title="DMA写（FPGA往CPU的内存写数据）"></a>DMA写（FPGA往CPU的内存写数据）</h2><p>DMA参考设计图</p>
<p><img src="http://jiali.clouddn.com/20200729_003.png" alt=""></p>
<h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><p>FPGA PCIe总线的BAR0空间内的寄存器列表</p>
<p><img src="http://jiali.clouddn.com/20200729_004.png" alt=""></p>
<p>DMA控制寄存器列表如下：</p>
<p><img src="http://jiali.clouddn.com/20200729_005.png" alt=""></p>
<p>中断控制寄存器列表如下：</p>
<p><img src="http://jiali.clouddn.com/20200729_006.png" alt=""></p>
<p>DMA写内存实现过程如下：</p>
<p>(1)分配一块物理地址连续的内存区域，用于存储DMA传输过来的数据。</p>
<p>(2)配置好msi中断。</p>
<p>(3)配置突发长度寄存器。</p>
<p>(4)配置DMA的目的地址寄存器。</p>
<p>(5)使能DMA控制寄存器，启动DMA传输。</p>
<p>(6)FPGA向主机发起写TLP请求，并将数据放入TLP包中—连续发出多个写请求</p>
<p>(7)FPGA发送完数据后通过中断等形式通知主机DMA完成</p>
<p>(8)等待MSI中断，主机从内存中获取数据。在MSI中断处理服务函数，操作地址偏移和重新配置DMA的目的地址寄存器，然后再次使能DMA。</p>
<p>配置好之后，重复6-8顺序的动作。FPGA只管发数据，Linux驱动等待中断，中断来就读取DMA内存区域的数据，中间的过程都是硬件完成。</p>
<p><strong>注意：</strong></p>
<p>DMA写DDR请求，发送的是TLP包，所以需要两端设备约定好Max_Payload_Size.</p>
<p>往CPU的DDR地址0xfdaff040写入0x12345678，DDR地址0xfdaff040对应的PCIe总线域地址为0x3f6bfc10，一个简单的TLP写请求包的例子如下：</p>
<p><img src="http://jiali.clouddn.com/20200729_007.png" alt=""></p>
<p>软件实现方案</p>
<p><img src="http://jiali.clouddn.com/20200729_013.png" alt=""></p>
<h2 id="FPGA-读CPU的DDR数据过程"><a href="#FPGA-读CPU的DDR数据过程" class="headerlink" title="FPGA 读CPU的DDR数据过程"></a>FPGA 读CPU的DDR数据过程</h2><p><strong>DMA读内存的过程：</strong></p>
<p>(1)分配一块物理地址连续的内存区域。</p>
<p>(2)配置好msi中断。</p>
<p>(3)配置突发长度寄存器。</p>
<p>(4)配置DMA读取内存的地址寄存器。</p>
<p>(5)主机向该内存区域写入数据。</p>
<p>(6)使能DMA读内存控制寄存器，启动DMA传输。</p>
<p>(7)FPGA向主机发起读TLP请求—连续发出多个读请求。</p>
<p>(8)主机向FPGA返回CPLD包—连续返回多个CPLD。</p>
<p>(9)FPGA取出CPLD包中的有效数据。</p>
<p>(10)FPGA发送完数据后通过中断等形式通知主机DMA完成。</p>
<p>(11)主机收到MSI中断，操作地址偏移和重新配置DMA的目的地址寄存器，然后再次使能DMA，启动读操作；直到数据读取结束，不在使能DMA读控制寄存器。</p>
<h3 id="实践：实现FPGA升级功能"><a href="#实践：实现FPGA升级功能" class="headerlink" title="实践：实现FPGA升级功能"></a>实践：实现FPGA升级功能</h3><p>设计框架如下：</p>
<p><img src="http://jiali.clouddn.com/20200729_008.png" alt=""></p>
<p>FPGA升级功能相关寄存器列表</p>
<p><img src="http://jiali.clouddn.com/20200729_009.png" alt=""></p>
<p>操作过程如下图:</p>
<p><img src="http://jiali.clouddn.com/20200729_010.png" alt=""></p>
<p>软件实现流程</p>
<p><img src="http://jiali.clouddn.com/20200729_012.png" alt=""></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>How does DMA work with PCI Express devices?</p>
<p>A PCI based bus has no “DMA Controller” in form of a chip or a sub circuit in the chipset. Every device on the bus can become a bus master. The main memory is always a slave.</p>
<p>Let’s assume you have build your own PCIe device card, which can act as an PCI master and your program (running on CPU) wants to send data from that card to main memory (4 MiB).</p>
<p>The device driver knows the memory mapping for that particular memory region from operating system (some keywords: memory mapped I/O, PCI bus enumeration, PCI BARs, ).</p>
<p>The driver transfers the command (write), source-address, destination-address and length to the device. This can be done by sending bytes to a special address inside an pre-defined BAR or by writing into the PCI config space. The DMA master on the cards checks these special regions for new tasks (scatter-gather lists). If so, theses tasks get enqueued.</p>
<p>Now the DMA master knows where to send, how many data. He will read the data from local memory and wrap it into 512 byte TLPs of max payload size (the max payload size on path device &lt;—&gt; main memory is known from enumeration) and send it to the destination address. The PCI address-based routing mechanisms direct these TLPs to the main memory.</p>
<p>参考：</p>
<p><a href="http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1" target="_blank" rel="noopener">Down to the TLP: How PCI express devices talk (Part I)</a></p>
<p><a href="http://www.hitechglobal.com/IPCores/DMA_Back_End.htm" target="_blank" rel="noopener">PCI Express Block DMA/SGDMA IP Solution</a></p>
<p><a href="https://www.cnblogs.com/chengqi521/p/8512510.html" target="_blank" rel="noopener">PCIE的DMA和PIO介绍</a></p>
<p><a href="https://blog.csdn.net/abcamus/article/details/76167747" target="_blank" rel="noopener">PCIe实践之路：DMA机制</a></p>
<p><a href="http://xilinx.eetrend.com/d6-xilinx/blog/2018-08/13333.html" target="_blank" rel="noopener">PCIe学习（二）——PCIe DMA关键模块分析之一</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Driver</category>
        <category>PCIe</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>Events - SoftDevice to application</title>
    <url>/2020/10/09/IoT/%E8%93%9D%E7%89%99/nordic%20Soc%E5%BC%80%E5%8F%91/Events%20-%20SoftDevice%20to%20application/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用过SDK52832就会发现，应用程序注册ble回调函数来处理ble事件。那么，回调函数的机制是什么？nordic 芯片SoftDevice如何与应用程序交互事件？本节针对ble事件处理流程做简单的介绍。</p>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>nordic厂家把ble协议栈编译为二进制文件，也就是.hex文件。因此，编写应用程序时候，不需要重新编译ble协议栈，做到应用程序和协议栈完全隔离。它们在内存和flash中分布如下图。</p>
<p><img src="http://jiali.clouddn.com/20201009_001.png" alt=""></p>
<p>​                                                                                          内存映射图</p>
<h2 id="应用程序与SoftDevice交互"><a href="#应用程序与SoftDevice交互" class="headerlink" title="应用程序与SoftDevice交互"></a>应用程序与SoftDevice交互</h2><p>从内存区域划分中可以看出，应用程序和SoftDevice是分开的。那么应用程序如何调用协议栈接口以及协议栈产生的事件如何通知应用程序呢？</p>
<p><strong>1、应用程序如何调用SoftDevice的接口</strong></p>
<p>看一下协议栈提供的添加服务接口函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle)</span><br></pre></td></tr></table></figure>

<p>这个函数在ble_gatts.h中声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**@brief Add a service declaration to the Attribute Table.</span><br><span class="line"> *</span><br><span class="line"> * @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to</span><br><span class="line"> *       add a secondary service declaration that is not referenced by another service later in the Attribute Table.</span><br><span class="line"> *</span><br><span class="line"> * @mscs</span><br><span class="line"> * @mmsc&#123;@ref BLE_GATTS_ATT_TABLE_POP_MSC&#125;</span><br><span class="line"> * @endmscs</span><br><span class="line"> *</span><br><span class="line"> * @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.</span><br><span class="line"> * @param[in] p_uuid    Pointer to service UUID.</span><br><span class="line"> * @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.</span><br><span class="line"> *</span><br><span class="line"> * @retval ::NRF_SUCCESS Successfully added a service declaration.</span><br><span class="line"> * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.</span><br><span class="line"> * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.</span><br><span class="line"> * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.</span><br><span class="line"> * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));</span><br></pre></td></tr></table></figure>

<p>SVCALL宏声明一个接口函数，供应用程序调用。该宏作用就是引发一个svc异常，产生中断，然后在SVC中断中调用Ble协议栈提供的接口函数。因此通过SVCALL宏，就可以调用SoftDevice提供的接口函数。</p>
<p><strong>2、SoftDevice产生的事件如何通知应用层</strong></p>
<p>应用程序注册的回调函数被执行，其机制就是SoftDevice触发软中断（s132_nrf52_7.0.1_softdevice 使用Software interrupt 2），在软中断处理函数中遍历SoftDevice事件，如果存在事件就执行事件的回调函数。</p>
<p><strong>软中断寄存器列表</strong></p>
<p><img src="http://jiali.clouddn.com/20201009_002.png" alt=""></p>
<p><strong>代码分析</strong></p>
<p>在nrf_soc.h中重命名软中断处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SD_EVT_IRQHandler                 (SWI2_IRQHandler)</span><br></pre></td></tr></table></figure>

<p>在nfr_sdh.c中定义SoftDevice事件处理函数和软中断处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void nrf_sdh_evts_poll(void)</span><br><span class="line">&#123;</span><br><span class="line">    nrf_section_iter_t iter;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Notify observers about pending SoftDevice event.</span><br><span class="line">    for (nrf_section_iter_init(&amp;iter, &amp;sdh_stack_observers);</span><br><span class="line">         nrf_section_iter_get(&amp;iter) !&#x3D; NULL;</span><br><span class="line">         nrf_section_iter_next(&amp;iter))</span><br><span class="line">    &#123;</span><br><span class="line">        nrf_sdh_stack_observer_t    * p_observer;</span><br><span class="line">        nrf_sdh_stack_evt_handler_t   handler;</span><br><span class="line"></span><br><span class="line">        p_observer &#x3D; (nrf_sdh_stack_observer_t *) nrf_section_iter_get(&amp;iter);</span><br><span class="line">        handler    &#x3D; p_observer-&gt;handler;</span><br><span class="line"></span><br><span class="line">        handler(p_observer-&gt;p_context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if (NRF_SDH_DISPATCH_MODEL &#x3D;&#x3D; NRF_SDH_DISPATCH_MODEL_INTERRUPT)</span><br><span class="line"></span><br><span class="line">void SD_EVT_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">    nrf_sdh_evts_poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif (NRF_SDH_DISPATCH_MODEL &#x3D;&#x3D; NRF_SDH_DISPATCH_MODEL_APPSH)</span><br><span class="line"></span><br><span class="line">&#x2F;**@brief   Function for polling SoftDevice events.</span><br><span class="line"> *</span><br><span class="line"> * @note    This function is compatible with @ref app_sched_event_handler_t.</span><br><span class="line"> *</span><br><span class="line"> * @param[in]   p_event_data Pointer to the event data.</span><br><span class="line"> * @param[in]   event_size   Size of the event data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void appsh_events_poll(void * p_event_data, uint16_t event_size)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_PARAMETER(p_event_data);</span><br><span class="line">    UNUSED_PARAMETER(event_size);</span><br><span class="line"></span><br><span class="line">    nrf_sdh_evts_poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SD_EVT_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t ret_code &#x3D; app_sched_event_put(NULL, 0, appsh_events_poll);</span><br><span class="line">    APP_ERROR_CHECK(ret_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif (NRF_SDH_DISPATCH_MODEL &#x3D;&#x3D; NRF_SDH_DISPATCH_MODEL_POLLING)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#error &quot;Unknown SoftDevice handler dispatch model.&quot;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; NRF_SDH_DISPATCH_MODEL</span><br></pre></td></tr></table></figure>

<p>nrf_sdh_evts_poll函数作用就是遍历NRF_SDH_STACK_OBSERVER宏注册的回调函数，并执行。</p>
<p>NRF_SDH_STACK_OBSERVER宏分别在nrf_sdh_ble.c和nrf_sdh_soc.c中使用。</p>
<p>nrf_sdh_ble.c中调用NRF_SDH_STACK_OBSERVER宏来注册Ble相关的回调函数，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**@brief       Function for polling BLE events.</span><br><span class="line"> *</span><br><span class="line"> * @param[in]   p_context   Context of the observer.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void nrf_sdh_ble_evts_poll(void * p_context)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_VARIABLE(p_context);</span><br><span class="line"></span><br><span class="line">    ret_code_t ret_code;</span><br><span class="line"></span><br><span class="line">    if (!m_stack_is_enabled)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;*lint -save -e(587) *&#x2F;</span><br><span class="line">        __ALIGN(4) uint8_t evt_buffer[NRF_SDH_BLE_EVT_BUF_SIZE];</span><br><span class="line">        &#x2F;*lint -restore *&#x2F;</span><br><span class="line"></span><br><span class="line">        ble_evt_t * p_ble_evt;</span><br><span class="line">        uint16_t    evt_len &#x3D; (uint16_t)sizeof(evt_buffer);</span><br><span class="line"></span><br><span class="line">        ret_code &#x3D; sd_ble_evt_get(evt_buffer, &amp;evt_len);</span><br><span class="line">        if (ret_code !&#x3D; NRF_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p_ble_evt &#x3D; (ble_evt_t *)evt_buffer;</span><br><span class="line"></span><br><span class="line">        NRF_LOG_DEBUG(&quot;BLE event: 0x%x.&quot;, p_ble_evt-&gt;header.evt_id);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Forward the event to BLE observers.</span><br><span class="line">        nrf_section_iter_t  iter;</span><br><span class="line">        for (nrf_section_iter_init(&amp;iter, &amp;sdh_ble_observers);</span><br><span class="line">             nrf_section_iter_get(&amp;iter) !&#x3D; NULL;</span><br><span class="line">             nrf_section_iter_next(&amp;iter))</span><br><span class="line">        &#123;</span><br><span class="line">            nrf_sdh_ble_evt_observer_t * p_observer;</span><br><span class="line">            nrf_sdh_ble_evt_handler_t    handler;</span><br><span class="line"></span><br><span class="line">            p_observer &#x3D; (nrf_sdh_ble_evt_observer_t *)nrf_section_iter_get(&amp;iter);</span><br><span class="line">            handler    &#x3D; p_observer-&gt;handler;</span><br><span class="line"></span><br><span class="line">            handler(p_ble_evt, p_observer-&gt;p_context); &#x2F;&#x2F;执行应用程序注册的Ble事件回调函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ret_code !&#x3D; NRF_ERROR_NOT_FOUND)</span><br><span class="line">    &#123;</span><br><span class="line">        APP_ERROR_HANDLER(ret_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NRF_SDH_STACK_OBSERVER(m_nrf_sdh_ble_evts_poll, NRF_SDH_BLE_STACK_OBSERVER_PRIO) &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    .handler   &#x3D; nrf_sdh_ble_evts_poll,</span><br><span class="line">    .p_context &#x3D; NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nrf_sdh_soc.c中调用NRF_SDH_STACK_OBSERVER宏来注册soc相关的回调函数，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**@brief   Function for polling SoC events.</span><br><span class="line"> *</span><br><span class="line"> * @param[in]   p_context   Context of the observer.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void nrf_sdh_soc_evts_poll(void * p_context)</span><br><span class="line">&#123;</span><br><span class="line">    ret_code_t ret_code;</span><br><span class="line"></span><br><span class="line">    UNUSED_VARIABLE(p_context);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t evt_id;</span><br><span class="line"></span><br><span class="line">        ret_code &#x3D; sd_evt_get(&amp;evt_id);</span><br><span class="line">        if (ret_code !&#x3D; NRF_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NRF_LOG_DEBUG(&quot;SoC event: 0x%x.&quot;, evt_id);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Forward the event to SoC observers.</span><br><span class="line">        nrf_section_iter_t  iter;</span><br><span class="line">        for (nrf_section_iter_init(&amp;iter, &amp;sdh_soc_observers);</span><br><span class="line">             nrf_section_iter_get(&amp;iter) !&#x3D; NULL;</span><br><span class="line">             nrf_section_iter_next(&amp;iter))</span><br><span class="line">        &#123;</span><br><span class="line">            nrf_sdh_soc_evt_observer_t * p_observer;</span><br><span class="line">            nrf_sdh_soc_evt_handler_t    handler;</span><br><span class="line"></span><br><span class="line">            p_observer &#x3D; (nrf_sdh_soc_evt_observer_t *) nrf_section_iter_get(&amp;iter);</span><br><span class="line">            handler    &#x3D; p_observer-&gt;handler;</span><br><span class="line"></span><br><span class="line">            handler(evt_id, p_observer-&gt;p_context);&#x2F;&#x2F;执行注册的soc事件回调函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ret_code !&#x3D; NRF_ERROR_NOT_FOUND)</span><br><span class="line">    &#123;</span><br><span class="line">        APP_ERROR_HANDLER(ret_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NRF_SDH_STACK_OBSERVER(m_nrf_sdh_soc_evts_poll, NRF_SDH_SOC_STACK_OBSERVER_PRIO) &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    .handler   &#x3D; nrf_sdh_soc_evts_poll,</span><br><span class="line">    .p_context &#x3D; NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="应用程序注册Ble事件回调函数"><a href="#应用程序注册Ble事件回调函数" class="headerlink" title="应用程序注册Ble事件回调函数"></a>应用程序注册Ble事件回调函数</h2><p>略。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，看出应用层注册的回调函数是在软中断中执行。因此，回调函数中如果处理比较耗时的任务，需要注意。</p>
<p>参考：</p>
<p>《SoftDevice Specification v7.1》中第四章Application programming interface</p>
<p>《nRF5 SDK v17.0.2》中 <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v17.0.2/modules.html" target="_blank" rel="noopener">API Reference</a> &gt; [SDK common libraries]&gt;oftDevice Handler</p>
<p><a href="https://blog.csdn.net/weixin_44485518/article/details/86671311" target="_blank" rel="noopener">nordic nFR52832 结构框架</a></p>
<p><a href="https://blog.csdn.net/wulazula/article/details/88738921" target="_blank" rel="noopener">Nordic系列芯片讲解九 （BLE事件回调机制解析）</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>蓝牙</category>
        <category>Nordic Soc开发</category>
      </categories>
  </entry>
</search>
